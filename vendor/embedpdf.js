(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a3, b2) => (typeof require !== "undefined" ? require : a3)[b2]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // node_modules/@embedpdf/snippet/dist/browser-awZxztMA-K_rXQQYD.js
  function p(e3) {
    return async (t2, r2 = "image/webp", n3) => {
      try {
        const i3 = t2(), o3 = new Uint8ClampedArray(i3.data);
        return await e3.encode({ data: o3, width: i3.width, height: i3.height }, r2, n3);
      } catch (e4) {
        return console.warn("Worker encoding failed, falling back to main-thread Canvas:", e4), l(t2, r2, n3);
      }
    };
  }
  var o, s, u, a, c, d, h, g, l;
  var init_browser_awZxztMA_K_rXQQYD = __esm({
    "node_modules/@embedpdf/snippet/dist/browser-awZxztMA-K_rXQQYD.js"() {
      init_embedpdf_Ob4AJbqq();
      o = "TaskQueue";
      s = "Queue";
      u = ((e3) => (e3[e3.CRITICAL = 3] = "CRITICAL", e3[e3.HIGH = 2] = "HIGH", e3[e3.MEDIUM = 1] = "MEDIUM", e3[e3.LOW = 0] = "LOW", e3))(u || {});
      a = class {
        constructor(t2 = {}) {
          this.queue = [], this.running = 0, this.resultTasks = /* @__PURE__ */ new Map(), this.idleListeners = /* @__PURE__ */ new Set();
          const { concurrency: r2 = 1, comparator: n3, ranker: i3, onIdle: o3, maxQueueSize: s4, autoStart: u4 = true, logger: a3 } = t2;
          this.logger = a3 ?? new at(), this.opts = { concurrency: Math.max(1, r2), comparator: n3, ranker: i3, onIdle: o3 ?? (() => {
          }), maxQueueSize: s4 ?? Number.POSITIVE_INFINITY, autoStart: u4 };
        }
        setComparator(e3) {
          this.opts.comparator = e3;
        }
        setRanker(e3) {
          this.opts.ranker = e3;
        }
        size() {
          return this.queue.length;
        }
        inFlight() {
          return this.running;
        }
        isIdle() {
          return 0 === this.queue.length && 0 === this.running;
        }
        async drain() {
          this.isIdle() || await new Promise((e3) => {
            const t2 = () => {
              this.isIdle() && (this.offIdle(t2), e3());
            };
            this.onIdle(t2);
          });
        }
        notifyIdle() {
          this.isIdle() && ([...this.idleListeners].forEach((e3) => e3()), this.idleListeners.clear(), this.opts.onIdle());
        }
        onIdle(e3) {
          this.idleListeners.add(e3);
        }
        offIdle(e3) {
          this.idleListeners.delete(e3);
        }
        enqueue(e3, r2 = {}) {
          const n3 = this.generateId(), i3 = r2.priority ?? 1, u4 = new gt();
          if (this.queue.length >= this.opts.maxQueueSize) {
            const e4 = new Error("Queue is full (maxQueueSize reached).");
            return u4.reject(e4), u4;
          }
          this.resultTasks.set(n3, u4);
          const a3 = { id: n3, priority: i3, meta: r2.meta ?? e3.meta, executeFactory: e3.execute };
          this.queue.push(a3), this.logger.debug(o, s, `Task enqueued: ${n3} | Priority: ${i3} | Running: ${this.running} | Queued: ${this.queue.length}`);
          const c4 = u4.abort.bind(u4);
          return u4.abort = (e4) => {
            this.logger.debug(o, s, `Task aborted: ${n3}`), this.cancel(n3), c4(e4);
          }, this.opts.autoStart && this.process(true === r2.fifo), u4;
        }
        cancel(e3) {
          const t2 = this.queue.length;
          this.queue = this.queue.filter((t3) => t3.id !== e3 || (t3.cancelled = true, false)), this.resultTasks.delete(e3), t2 !== this.queue.length && (this.logger.debug(o, s, `Task cancelled and removed: ${e3}`), this.kick());
        }
        kick() {
          queueMicrotask(() => this.process());
        }
        async process(e3 = false) {
          for (this.logger.debug(o, s, `process() called | Running: ${this.running} | Concurrency: ${this.opts.concurrency} | Queued: ${this.queue.length}`); this.running < this.opts.concurrency && this.queue.length > 0; ) {
            this.logger.debug(o, s, `Starting new task | Running: ${this.running} | Queued: ${this.queue.length}`), e3 || this.sortQueue();
            const t2 = this.queue.shift();
            if (t2.cancelled) {
              this.logger.debug(o, s, `Skipping cancelled task: ${t2.id}`);
              continue;
            }
            const r2 = this.resultTasks.get(t2.id);
            r2 && (this.running++, (async () => {
              let e4 = null;
              try {
                if (e4 = t2.executeFactory(), !e4) throw new Error("Task factory returned null/undefined");
                e4.wait((e5) => {
                  0 === r2.state.stage && r2.resolve(e5);
                }, (e5) => {
                  0 === r2.state.stage && ("abort" === e5.type ? r2.abort(e5.reason) : r2.reject(e5.reason));
                }), e4.onProgress((e5) => {
                  r2.progress(e5);
                }), await e4.toPromise();
              } catch (e5) {
                0 === r2.state.stage && r2.reject(e5);
              } finally {
                this.resultTasks.delete(t2.id), this.running--, this.logger.debug(o, s, `Task completed: ${t2.id} | Running: ${this.running} | Queued: ${this.queue.length}`), this.isIdle() ? this.notifyIdle() : this.queue.length > 0 && this.kick();
              }
            })().catch((e4) => {
              this.logger.error(o, s, "Unhandled error in task execution wrapper:", e4), this.running = Math.max(0, this.running - 1), this.isIdle() ? this.notifyIdle() : this.queue.length > 0 && this.kick();
            }));
          }
        }
        sortQueue() {
          const { comparator: e3, ranker: t2 } = this.opts;
          if (e3) return void this.queue.sort(e3);
          const r2 = /* @__PURE__ */ new Map(), n3 = (e4) => t2 ? (r2.has(e4.id) || r2.set(e4.id, t2(e4)), r2.get(e4.id)) : this.defaultRank(e4);
          this.queue.sort((e4, t3) => {
            if (e4.priority !== t3.priority) return t3.priority - e4.priority;
            const r3 = n3(e4), i3 = n3(t3);
            return r3 !== i3 ? i3 - r3 : this.extractTime(e4.id) - this.extractTime(t3.id);
          });
        }
        defaultRank(e3) {
          return 0;
        }
        generateId() {
          return "undefined" != typeof crypto && "randomUUID" in crypto ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(36).slice(2)}`;
        }
        extractTime(e3) {
          const t2 = Number(e3.split("-")[0]);
          return Number.isFinite(t2) ? t2 : 0;
        }
      };
      c = "PdfEngine";
      d = "Orchestrator";
      h = class {
        constructor(t2, r2) {
          this.executor = t2, this.logger = r2.logger ?? new at(), this.options = { imageConverter: r2.imageConverter, fetcher: r2.fetcher ?? ("undefined" != typeof fetch ? (e3, t3) => fetch(e3, t3) : void 0), logger: this.logger }, this.workerQueue = new a({ concurrency: 1, autoStart: true, logger: this.logger }), this.logger.debug(c, d, "PdfEngine orchestrator created");
        }
        chunkArray(e3, t2) {
          const r2 = [];
          for (let n3 = 0; n3 < e3.length; n3 += t2) r2.push(e3.slice(n3, n3 + t2));
          return r2;
        }
        isSupport(e3) {
          const n3 = new gt();
          return n3.resolve([$t.Create, $t.Read, $t.Update, $t.Delete]), n3;
        }
        destroy() {
          const e3 = new gt();
          try {
            this.executor.destroy(), e3.resolve(true);
          } catch (t2) {
            e3.reject({ code: Ht.Unknown, message: String(t2) });
          }
          return e3;
        }
        openDocumentUrl(e3, r2) {
          const i3 = new gt();
          return (async () => {
            try {
              if (!this.options.fetcher) throw new Error("Fetcher is not set");
              const t2 = await this.options.fetcher(e3.url, null == r2 ? void 0 : r2.requestOptions), n3 = await t2.arrayBuffer(), o3 = { id: e3.id, content: n3 };
              this.openDocumentBuffer(o3, { password: null == r2 ? void 0 : r2.password }).wait((e4) => i3.resolve(e4), (e4) => i3.fail(e4));
            } catch (e4) {
              i3.reject({ code: Ht.Unknown, message: String(e4) });
            }
          })(), i3;
        }
        openDocumentBuffer(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.openDocumentBuffer(e3, t2), meta: { docId: e3.id, operation: "openDocumentBuffer" } }, { priority: u.CRITICAL });
        }
        getMetadata(e3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.getMetadata(e3), meta: { docId: e3.id, operation: "getMetadata" } }, { priority: u.MEDIUM });
        }
        setMetadata(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.setMetadata(e3, t2), meta: { docId: e3.id, operation: "setMetadata" } }, { priority: u.MEDIUM });
        }
        getDocPermissions(e3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.getDocPermissions(e3), meta: { docId: e3.id, operation: "getDocPermissions" } }, { priority: u.MEDIUM });
        }
        getDocUserPermissions(e3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.getDocUserPermissions(e3), meta: { docId: e3.id, operation: "getDocUserPermissions" } }, { priority: u.MEDIUM });
        }
        getSignatures(e3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.getSignatures(e3), meta: { docId: e3.id, operation: "getSignatures" } }, { priority: u.MEDIUM });
        }
        getBookmarks(e3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.getBookmarks(e3), meta: { docId: e3.id, operation: "getBookmarks" } }, { priority: u.MEDIUM });
        }
        setBookmarks(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.setBookmarks(e3, t2), meta: { docId: e3.id, operation: "setBookmarks" } }, { priority: u.MEDIUM });
        }
        deleteBookmarks(e3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.deleteBookmarks(e3), meta: { docId: e3.id, operation: "deleteBookmarks" } }, { priority: u.MEDIUM });
        }
        renderPage(e3, t2, r2) {
          return this.renderWithEncoding(() => this.executor.renderPageRaw(e3, t2, r2), r2, e3.id, t2.index, u.CRITICAL);
        }
        renderPageRect(e3, t2, r2, n3) {
          return this.renderWithEncoding(() => this.executor.renderPageRect(e3, t2, r2, n3), n3, e3.id, t2.index, u.HIGH);
        }
        renderThumbnail(e3, t2, r2) {
          return this.renderWithEncoding(() => this.executor.renderThumbnailRaw(e3, t2, r2), r2, e3.id, t2.index, u.MEDIUM);
        }
        renderPageAnnotation(e3, t2, r2, n3) {
          return this.renderWithEncoding(() => this.executor.renderPageAnnotationRaw(e3, t2, r2, n3), n3, e3.id, t2.index, u.MEDIUM);
        }
        renderWithEncoding(e3, r2, n3, i3, o3 = u.CRITICAL) {
          const s4 = new gt(), a3 = this.workerQueue.enqueue({ execute: () => e3(), meta: { docId: n3, pageIndex: i3, operation: "render" } }, { priority: o3 }), c4 = s4.abort.bind(s4);
          return s4.abort = (e4) => {
            a3.abort(e4), c4(e4);
          }, a3.wait((e4) => {
            0 === s4.state.stage && this.encodeImage(e4, r2, s4);
          }, (e4) => {
            0 === s4.state.stage && s4.fail(e4);
          }), s4;
        }
        encodeImage(e3, t2, r2) {
          const i3 = (null == t2 ? void 0 : t2.imageType) ?? "image/webp", o3 = null == t2 ? void 0 : t2.quality, s4 = { data: new Uint8ClampedArray(e3.data), width: e3.width, height: e3.height };
          this.options.imageConverter(() => s4, i3, o3).then((e4) => r2.resolve(e4)).catch((e4) => r2.reject({ code: Ht.Unknown, message: String(e4) }));
        }
        getPageAnnotations(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.getPageAnnotations(e3, t2), meta: { docId: e3.id, pageIndex: t2.index, operation: "getPageAnnotations" } }, { priority: u.MEDIUM });
        }
        createPageAnnotation(e3, t2, r2, n3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.createPageAnnotation(e3, t2, r2, n3), meta: { docId: e3.id, pageIndex: t2.index, operation: "createPageAnnotation" } }, { priority: u.MEDIUM });
        }
        updatePageAnnotation(e3, t2, r2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.updatePageAnnotation(e3, t2, r2), meta: { docId: e3.id, pageIndex: t2.index, operation: "updatePageAnnotation" } }, { priority: u.MEDIUM });
        }
        removePageAnnotation(e3, t2, r2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.removePageAnnotation(e3, t2, r2), meta: { docId: e3.id, pageIndex: t2.index, operation: "removePageAnnotation" } }, { priority: u.MEDIUM });
        }
        getAllAnnotations(e3) {
          const t2 = this.chunkArray(e3.pages, 500);
          this.logger.debug(c, d, `getAllAnnotations: ${e3.pages.length} pages in ${t2.length} chunks`);
          const r2 = new bn({ aggregate: (e4) => Object.assign({}, ...e4) });
          return t2.forEach((t3, n3) => {
            const i3 = this.workerQueue.enqueue({ execute: () => this.executor.getAnnotationsBatch(e3, t3), meta: { docId: e3.id, operation: "getAnnotationsBatch", chunkSize: t3.length } }, { priority: u.LOW });
            i3.onProgress((e4) => {
              r2.progress({ page: e4.pageIndex, result: e4.result });
            }), r2.addChild(i3, n3);
          }), r2.finalize(), r2;
        }
        getPageTextRects(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.getPageTextRects(e3, t2), meta: { docId: e3.id, pageIndex: t2.index, operation: "getPageTextRects" } }, { priority: u.MEDIUM });
        }
        searchAllPages(e3, t2, r2) {
          const n3 = Array.isArray(null == r2 ? void 0 : r2.flags) ? r2.flags.reduce((e4, t3) => e4 | t3, 0) : (null == r2 ? void 0 : r2.flags) ?? 0, o3 = this.chunkArray(e3.pages, 25);
          this.logger.debug(c, d, `searchAllPages: ${e3.pages.length} pages in ${o3.length} chunks`);
          const s4 = new bn({ aggregate: (e4) => {
            const t3 = e4.flatMap((e5) => Object.values(e5).flat());
            return { results: t3, total: t3.length };
          } });
          return o3.forEach((r3, i3) => {
            const o4 = this.workerQueue.enqueue({ execute: () => this.executor.searchBatch(e3, r3, t2, n3), meta: { docId: e3.id, operation: "searchBatch", chunkSize: r3.length } }, { priority: u.LOW });
            o4.onProgress((e4) => {
              s4.progress({ page: e4.pageIndex, results: e4.result });
            }), s4.addChild(o4, i3);
          }), s4.finalize(), s4;
        }
        getAttachments(e3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.getAttachments(e3), meta: { docId: e3.id, operation: "getAttachments" } }, { priority: u.MEDIUM });
        }
        addAttachment(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.addAttachment(e3, t2), meta: { docId: e3.id, operation: "addAttachment" } }, { priority: u.MEDIUM });
        }
        removeAttachment(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.removeAttachment(e3, t2), meta: { docId: e3.id, operation: "removeAttachment" } }, { priority: u.MEDIUM });
        }
        readAttachmentContent(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.readAttachmentContent(e3, t2), meta: { docId: e3.id, operation: "readAttachmentContent" } }, { priority: u.MEDIUM });
        }
        setFormFieldValue(e3, t2, r2, n3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.setFormFieldValue(e3, t2, r2, n3), meta: { docId: e3.id, pageIndex: t2.index, operation: "setFormFieldValue" } }, { priority: u.MEDIUM });
        }
        flattenPage(e3, t2, r2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.flattenPage(e3, t2, r2), meta: { docId: e3.id, pageIndex: t2.index, operation: "flattenPage" } }, { priority: u.MEDIUM });
        }
        extractPages(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.extractPages(e3, t2), meta: { docId: e3.id, pageIndexes: t2, operation: "extractPages" } }, { priority: u.MEDIUM });
        }
        extractText(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.extractText(e3, t2), meta: { docId: e3.id, pageIndexes: t2, operation: "extractText" } }, { priority: u.MEDIUM });
        }
        redactTextInRects(e3, t2, r2, n3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.redactTextInRects(e3, t2, r2, n3), meta: { docId: e3.id, pageIndex: t2.index, operation: "redactTextInRects" } }, { priority: u.MEDIUM });
        }
        getTextSlices(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.getTextSlices(e3, t2), meta: { docId: e3.id, slices: t2, operation: "getTextSlices" } }, { priority: u.MEDIUM });
        }
        getPageGlyphs(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.getPageGlyphs(e3, t2), meta: { docId: e3.id, pageIndex: t2.index, operation: "getPageGlyphs" } }, { priority: u.MEDIUM });
        }
        getPageGeometry(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.getPageGeometry(e3, t2), meta: { docId: e3.id, pageIndex: t2.index, operation: "getPageGeometry" } }, { priority: u.MEDIUM });
        }
        merge(e3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.merge(e3), meta: { docId: e3.map((e4) => e4.id).join(","), operation: "merge" } }, { priority: u.MEDIUM });
        }
        mergePages(e3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.mergePages(e3), meta: { docId: e3.map((e4) => e4.docId).join(","), operation: "mergePages" } }, { priority: u.MEDIUM });
        }
        preparePrintDocument(e3, t2) {
          return this.workerQueue.enqueue({ execute: () => this.executor.preparePrintDocument(e3, t2), meta: { docId: e3.id, operation: "preparePrintDocument" } }, { priority: u.MEDIUM });
        }
        saveAsCopy(e3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.saveAsCopy(e3), meta: { docId: e3.id, operation: "saveAsCopy" } }, { priority: u.MEDIUM });
        }
        closeDocument(e3) {
          return this.workerQueue.enqueue({ execute: () => this.executor.closeDocument(e3), meta: { docId: e3.id, operation: "closeDocument" } }, { priority: u.MEDIUM });
        }
        closeAllDocuments() {
          return this.workerQueue.enqueue({ execute: () => this.executor.closeAllDocuments(), meta: { operation: "closeAllDocuments" } }, { priority: u.MEDIUM });
        }
      };
      g = class extends Error {
        constructor(e3) {
          super(e3), this.name = "ImageConverterError";
        }
      };
      l = (e3, t2 = "image/webp", r2) => {
        if ("undefined" == typeof document) return Promise.reject(new g("document is not available. This converter requires a browser environment."));
        const n3 = e3(), i3 = new ImageData(n3.data, n3.width, n3.height);
        return new Promise((e4, n4) => {
          const o3 = document.createElement("canvas");
          o3.width = i3.width, o3.height = i3.height, o3.getContext("2d").putImageData(i3, 0, 0), o3.toBlob((t3) => {
            t3 ? e4(t3) : n4(new g("Canvas toBlob returned null"));
          }, t2, r2);
        });
      };
    }
  });

  // node_modules/@embedpdf/snippet/dist/worker-engine-BwJuk6Jt.js
  var worker_engine_BwJuk6Jt_exports = {};
  __export(worker_engine_BwJuk6Jt_exports, {
    createPdfiumEngine: () => m
  });
  function m(t2, r2) {
    const o3 = r2 instanceof Object && "debug" in r2 ? { logger: r2 } : r2 || {}, { logger: a3, encoderPoolSize: i3, fontFallback: s4 } = o3, d4 = new Worker(URL.createObjectURL(new Blob(['var Rotation = /* @__PURE__ */ ((Rotation2) => {\n  Rotation2[Rotation2["Degree0"] = 0] = "Degree0";\n  Rotation2[Rotation2["Degree90"] = 1] = "Degree90";\n  Rotation2[Rotation2["Degree180"] = 2] = "Degree180";\n  Rotation2[Rotation2["Degree270"] = 3] = "Degree270";\n  return Rotation2;\n})(Rotation || {});\nfunction toIntPos(p) {\n  return { x: Math.floor(p.x), y: Math.floor(p.y) };\n}\nfunction toIntSize(s) {\n  return { width: Math.ceil(s.width), height: Math.ceil(s.height) };\n}\nfunction toIntRect(r) {\n  return {\n    origin: toIntPos(r.origin),\n    size: toIntSize(r.size)\n  };\n}\nfunction swap(size) {\n  const { width, height } = size;\n  return {\n    width: height,\n    height: width\n  };\n}\nfunction quadToRect(q) {\n  const xs = [q.p1.x, q.p2.x, q.p3.x, q.p4.x];\n  const ys = [q.p1.y, q.p2.y, q.p3.y, q.p4.y];\n  return {\n    origin: { x: Math.min(...xs), y: Math.min(...ys) },\n    size: {\n      width: Math.max(...xs) - Math.min(...xs),\n      height: Math.max(...ys) - Math.min(...ys)\n    }\n  };\n}\nfunction rectToQuad(r) {\n  return {\n    p1: { x: r.origin.x, y: r.origin.y },\n    p2: { x: r.origin.x + r.size.width, y: r.origin.y },\n    p3: { x: r.origin.x + r.size.width, y: r.origin.y + r.size.height },\n    p4: { x: r.origin.x, y: r.origin.y + r.size.height }\n  };\n}\nfunction rotateRect(containerSize, rect, rotation) {\n  let x = rect.origin.x;\n  let y = rect.origin.y;\n  let size = rect.size;\n  switch (rotation) {\n    case 0:\n      break;\n    case 1:\n      x = containerSize.height - rect.origin.y - rect.size.height;\n      y = rect.origin.x;\n      size = swap(rect.size);\n      break;\n    case 2:\n      x = containerSize.width - rect.origin.x - rect.size.width;\n      y = containerSize.height - rect.origin.y - rect.size.height;\n      break;\n    case 3:\n      x = rect.origin.y;\n      y = containerSize.width - rect.origin.x - rect.size.width;\n      size = swap(rect.size);\n      break;\n  }\n  return {\n    origin: {\n      x,\n      y\n    },\n    size: {\n      width: size.width,\n      height: size.height\n    }\n  };\n}\nfunction scaleRect(rect, scaleFactor) {\n  return {\n    origin: {\n      x: rect.origin.x * scaleFactor,\n      y: rect.origin.y * scaleFactor\n    },\n    size: {\n      width: rect.size.width * scaleFactor,\n      height: rect.size.height * scaleFactor\n    }\n  };\n}\nfunction transformRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, rotation), scaleFactor);\n}\nfunction buildUserToDeviceMatrix(rect, rotation, outW, outH) {\n  const L = rect.origin.x;\n  const B = rect.origin.y;\n  const W = rect.size.width;\n  const H = rect.size.height;\n  const sx0 = outW / W;\n  const sy0 = outH / H;\n  const sx90 = outW / H;\n  const sy90 = outH / W;\n  switch (rotation) {\n    case 0:\n      return { a: sx0, b: 0, c: 0, d: sy0, e: -sx0 * L, f: -sy0 * B };\n    case 3:\n      return { a: 0, b: -sy90, c: sx90, d: 0, e: -sx90 * B, f: sy90 * (L + W) };\n    case 2:\n      return { a: -sx0, b: 0, c: 0, d: -sy0, e: sx0 * (L + W), f: sy0 * (B + H) };\n    case 1:\n      return { a: 0, b: sy90, c: -sx90, d: 0, e: sx90 * (B + H), f: -sy90 * L };\n  }\n}\nclass NoopLogger {\n  /** {@inheritDoc Logger.isEnabled} */\n  isEnabled() {\n    return false;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug() {\n  }\n  /** {@inheritDoc Logger.info} */\n  info() {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn() {\n  }\n  /** {@inheritDoc Logger.error} */\n  error() {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf() {\n  }\n}\nclass ConsoleLogger {\n  /** {@inheritDoc Logger.isEnabled} */\n  isEnabled() {\n    return true;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    console.debug(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    console.info(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    console.warn(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    console.error(`${source}.${category}`, ...args);\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    console.info(`${source}.${category}.${event}.${phase}`, ...args);\n  }\n}\nclass LevelLogger {\n  /**\n   * create new LevelLogger\n   * @param logger - the original logger\n   * @param level - log level that used for filtering, all logs lower than this level will be filtered out\n   */\n  constructor(logger, level) {\n    this.logger = logger;\n    this.level = level;\n  }\n  /** {@inheritDoc Logger.isEnabled} */\n  isEnabled(level) {\n    const levelMap = {\n      debug: 0,\n      info: 1,\n      warn: 2,\n      error: 3\n      /* Error */\n    };\n    return this.level <= levelMap[level];\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    if (this.level <= 0) {\n      this.logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    if (this.level <= 1) {\n      this.logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    if (this.level <= 2) {\n      this.logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    if (this.level <= 3) {\n      this.logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    this.logger.perf(source, category, event, phase, ...args);\n  }\n}\nclass PerfLogger {\n  /**\n   * create new PerfLogger\n   */\n  constructor() {\n    this.marks = /* @__PURE__ */ new Map();\n  }\n  /** {@inheritDoc Logger.isEnabled} */\n  isEnabled() {\n    return false;\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, identifier, ...args) {\n    const markName = `${source}.${category}.${event}.${phase}.${identifier}`;\n    switch (phase) {\n      case "Begin":\n        globalThis.performance.mark(markName, { detail: args });\n        this.marks.set(`${source}.${category}.${event}.${identifier}`, Date.now());\n        break;\n      case "End":\n        globalThis.performance.mark(markName, { detail: args });\n        const measureName = `${source}.${category}.${event}.Measure.${identifier}`;\n        const beginMark = `${source}.${category}.${event}.Begin.${identifier}`;\n        globalThis.performance.measure(measureName, beginMark, markName);\n        const startTime = this.marks.get(`${source}.${category}.${event}.${identifier}`);\n        if (startTime) {\n          const duration = Date.now() - startTime;\n          console.info(`\u23F1\uFE0F ${source}.${category}.${event}.${identifier}: ${duration}ms`);\n          this.marks.delete(`${source}.${category}.${event}.${identifier}`);\n        }\n        break;\n    }\n  }\n}\nclass AllLogger {\n  /**\n   * create new PerfLogger\n   */\n  constructor(loggers) {\n    this.loggers = loggers;\n  }\n  /** {@inheritDoc Logger.isEnabled} */\n  isEnabled(level) {\n    return this.loggers.some((logger) => logger.isEnabled(level));\n  }\n  /** {@inheritDoc Logger.debug} */\n  debug(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.debug(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.info} */\n  info(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.info(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.warn(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.error} */\n  error(source, category, ...args) {\n    for (const logger of this.loggers) {\n      logger.error(source, category, ...args);\n    }\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf(source, category, event, phase, ...args) {\n    for (const logger of this.loggers) {\n      logger.perf(source, category, event, phase, ...args);\n    }\n  }\n}\nclass TaskAbortedError extends Error {\n  constructor(reason) {\n    super(`Task aborted: ${JSON.stringify(reason)}`);\n    this.name = "TaskAbortedError";\n    this.reason = reason;\n  }\n}\nclass TaskRejectedError extends Error {\n  constructor(reason) {\n    super(`Task rejected: ${JSON.stringify(reason)}`);\n    this.name = "TaskRejectedError";\n    this.reason = reason;\n  }\n}\nclass Task {\n  constructor() {\n    this.state = {\n      stage: 0\n      /* Pending */\n    };\n    this.resolvedCallbacks = [];\n    this.rejectedCallbacks = [];\n    this._promise = null;\n    this.progressCbs = [];\n  }\n  /**\n   * Convert task to promise\n   * @returns promise that will be resolved when task is settled\n   */\n  toPromise() {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.wait(\n          (result) => resolve(result),\n          (error) => {\n            if (error.type === "abort") {\n              reject(new TaskAbortedError(error.reason));\n            } else {\n              reject(new TaskRejectedError(error.reason));\n            }\n          }\n        );\n      });\n    }\n    return this._promise;\n  }\n  /**\n   * wait for task to be settled\n   * @param resolvedCallback - callback for resolved value\n   * @param rejectedCallback - callback for rejected value\n   */\n  wait(resolvedCallback, rejectedCallback) {\n    switch (this.state.stage) {\n      case 0:\n        this.resolvedCallbacks.push(resolvedCallback);\n        this.rejectedCallbacks.push(rejectedCallback);\n        break;\n      case 1:\n        resolvedCallback(this.state.result);\n        break;\n      case 2:\n        rejectedCallback({\n          type: "reject",\n          reason: this.state.reason\n        });\n        break;\n      case 3:\n        rejectedCallback({\n          type: "abort",\n          reason: this.state.reason\n        });\n        break;\n    }\n  }\n  /**\n   * resolve task with specific result\n   * @param result - result value\n   */\n  resolve(result) {\n    if (this.state.stage === 0) {\n      this.state = {\n        stage: 1,\n        result\n      };\n      for (const resolvedCallback of this.resolvedCallbacks) {\n        try {\n          resolvedCallback(result);\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * reject task with specific reason\n   * @param reason - abort reason\n   *\n   */\n  reject(reason) {\n    if (this.state.stage === 0) {\n      this.state = {\n        stage: 2,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: "reject",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * abort task with specific reason\n   * @param reason - abort reason\n   */\n  abort(reason) {\n    if (this.state.stage === 0) {\n      this.state = {\n        stage: 3,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: "abort",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * fail task with a TaskError from another task\n   * This is a convenience method for error propagation between tasks\n   * @param error - TaskError from another task\n   */\n  fail(error) {\n    if (error.type === "abort") {\n      this.abort(error.reason);\n    } else {\n      this.reject(error.reason);\n    }\n  }\n  /**\n   * add a progress callback\n   * @param cb - progress callback\n   */\n  onProgress(cb) {\n    this.progressCbs.push(cb);\n  }\n  /**\n   * call progress callback\n   * @param p - progress value\n   */\n  progress(p) {\n    for (const cb of this.progressCbs) cb(p);\n  }\n  /**\n   * Static method to wait for all tasks to resolve\n   * Returns a new task that resolves with an array of all results\n   * Rejects immediately if any task fails\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static all(tasks) {\n    const combinedTask = new Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let resolvedCount = 0;\n    let isSettled = false;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          results[index] = result;\n          resolvedCount++;\n          if (resolvedCount === tasks.length) {\n            isSettled = true;\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === "abort") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method to wait for all tasks to settle (resolve, reject, or abort)\n   * Always resolves with an array of settlement results\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks settle\n   * @public\n   */\n  static allSettled(tasks) {\n    const combinedTask = new Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let settledCount = 0;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          results[index] = { status: "resolved", value: result };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          results[index] = {\n            status: error.type === "abort" ? "aborted" : "rejected",\n            reason: error.reason\n          };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method that resolves/rejects with the first task that settles\n   *\n   * @param tasks - array of tasks to race\n   * @returns new task that settles with the first input task that settles\n   * @public\n   */\n  static race(tasks) {\n    const combinedTask = new Task();\n    if (tasks.length === 0) {\n      combinedTask.reject("No tasks provided");\n      return combinedTask;\n    }\n    let isSettled = false;\n    tasks.forEach((task) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          isSettled = true;\n          combinedTask.resolve(result);\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === "abort") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Utility to track progress of multiple tasks\n   *\n   * @param tasks - array of tasks to track\n   * @param onProgress - callback called when any task completes\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static withProgress(tasks, onProgress) {\n    const combinedTask = Task.all(tasks);\n    if (onProgress) {\n      let completedCount = 0;\n      tasks.forEach((task) => {\n        task.wait(\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          }\n        );\n      });\n    }\n    return combinedTask;\n  }\n}\nconst PdfSoftHyphenMarker = "\xAD";\nconst PdfZeroWidthSpace = "\u200B";\nconst PdfWordJoiner = "\u2060";\nconst PdfBomOrZwnbsp = "\\uFEFF";\nconst PdfNonCharacterFFFE = "\uFFFE";\nconst PdfNonCharacterFFFF = "\uFFFF";\nconst PdfUnwantedTextMarkers = Object.freeze([\n  PdfSoftHyphenMarker,\n  PdfZeroWidthSpace,\n  PdfWordJoiner,\n  PdfBomOrZwnbsp,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF\n]);\nconst PdfUnwantedTextRegex = new RegExp(`[${PdfUnwantedTextMarkers.join("")}]`, "g");\nfunction stripPdfUnwantedMarkers(text) {\n  return text.replace(PdfUnwantedTextRegex, "");\n}\nvar PdfZoomMode = /* @__PURE__ */ ((PdfZoomMode2) => {\n  PdfZoomMode2[PdfZoomMode2["Unknown"] = 0] = "Unknown";\n  PdfZoomMode2[PdfZoomMode2["XYZ"] = 1] = "XYZ";\n  PdfZoomMode2[PdfZoomMode2["FitPage"] = 2] = "FitPage";\n  PdfZoomMode2[PdfZoomMode2["FitHorizontal"] = 3] = "FitHorizontal";\n  PdfZoomMode2[PdfZoomMode2["FitVertical"] = 4] = "FitVertical";\n  PdfZoomMode2[PdfZoomMode2["FitRectangle"] = 5] = "FitRectangle";\n  PdfZoomMode2[PdfZoomMode2["FitBoundingBox"] = 6] = "FitBoundingBox";\n  PdfZoomMode2[PdfZoomMode2["FitBoundingBoxHorizontal"] = 7] = "FitBoundingBoxHorizontal";\n  PdfZoomMode2[PdfZoomMode2["FitBoundingBoxVertical"] = 8] = "FitBoundingBoxVertical";\n  return PdfZoomMode2;\n})(PdfZoomMode || {});\nvar PdfTrappedStatus = /* @__PURE__ */ ((PdfTrappedStatus2) => {\n  PdfTrappedStatus2[PdfTrappedStatus2["NotSet"] = 0] = "NotSet";\n  PdfTrappedStatus2[PdfTrappedStatus2["True"] = 1] = "True";\n  PdfTrappedStatus2[PdfTrappedStatus2["False"] = 2] = "False";\n  PdfTrappedStatus2[PdfTrappedStatus2["Unknown"] = 3] = "Unknown";\n  return PdfTrappedStatus2;\n})(PdfTrappedStatus || {});\nvar PdfStandardFont = /* @__PURE__ */ ((PdfStandardFont2) => {\n  PdfStandardFont2[PdfStandardFont2["Unknown"] = -1] = "Unknown";\n  PdfStandardFont2[PdfStandardFont2["Courier"] = 0] = "Courier";\n  PdfStandardFont2[PdfStandardFont2["Courier_Bold"] = 1] = "Courier_Bold";\n  PdfStandardFont2[PdfStandardFont2["Courier_BoldOblique"] = 2] = "Courier_BoldOblique";\n  PdfStandardFont2[PdfStandardFont2["Courier_Oblique"] = 3] = "Courier_Oblique";\n  PdfStandardFont2[PdfStandardFont2["Helvetica"] = 4] = "Helvetica";\n  PdfStandardFont2[PdfStandardFont2["Helvetica_Bold"] = 5] = "Helvetica_Bold";\n  PdfStandardFont2[PdfStandardFont2["Helvetica_BoldOblique"] = 6] = "Helvetica_BoldOblique";\n  PdfStandardFont2[PdfStandardFont2["Helvetica_Oblique"] = 7] = "Helvetica_Oblique";\n  PdfStandardFont2[PdfStandardFont2["Times_Roman"] = 8] = "Times_Roman";\n  PdfStandardFont2[PdfStandardFont2["Times_Bold"] = 9] = "Times_Bold";\n  PdfStandardFont2[PdfStandardFont2["Times_BoldItalic"] = 10] = "Times_BoldItalic";\n  PdfStandardFont2[PdfStandardFont2["Times_Italic"] = 11] = "Times_Italic";\n  PdfStandardFont2[PdfStandardFont2["Symbol"] = 12] = "Symbol";\n  PdfStandardFont2[PdfStandardFont2["ZapfDingbats"] = 13] = "ZapfDingbats";\n  return PdfStandardFont2;\n})(PdfStandardFont || {});\nvar PdfTextAlignment = /* @__PURE__ */ ((PdfTextAlignment2) => {\n  PdfTextAlignment2[PdfTextAlignment2["Left"] = 0] = "Left";\n  PdfTextAlignment2[PdfTextAlignment2["Center"] = 1] = "Center";\n  PdfTextAlignment2[PdfTextAlignment2["Right"] = 2] = "Right";\n  return PdfTextAlignment2;\n})(PdfTextAlignment || {});\nvar PdfBlendMode = /* @__PURE__ */ ((PdfBlendMode2) => {\n  PdfBlendMode2[PdfBlendMode2["Normal"] = 0] = "Normal";\n  PdfBlendMode2[PdfBlendMode2["Multiply"] = 1] = "Multiply";\n  PdfBlendMode2[PdfBlendMode2["Screen"] = 2] = "Screen";\n  PdfBlendMode2[PdfBlendMode2["Overlay"] = 3] = "Overlay";\n  PdfBlendMode2[PdfBlendMode2["Darken"] = 4] = "Darken";\n  PdfBlendMode2[PdfBlendMode2["Lighten"] = 5] = "Lighten";\n  PdfBlendMode2[PdfBlendMode2["ColorDodge"] = 6] = "ColorDodge";\n  PdfBlendMode2[PdfBlendMode2["ColorBurn"] = 7] = "ColorBurn";\n  PdfBlendMode2[PdfBlendMode2["HardLight"] = 8] = "HardLight";\n  PdfBlendMode2[PdfBlendMode2["SoftLight"] = 9] = "SoftLight";\n  PdfBlendMode2[PdfBlendMode2["Difference"] = 10] = "Difference";\n  PdfBlendMode2[PdfBlendMode2["Exclusion"] = 11] = "Exclusion";\n  PdfBlendMode2[PdfBlendMode2["Hue"] = 12] = "Hue";\n  PdfBlendMode2[PdfBlendMode2["Saturation"] = 13] = "Saturation";\n  PdfBlendMode2[PdfBlendMode2["Color"] = 14] = "Color";\n  PdfBlendMode2[PdfBlendMode2["Luminosity"] = 15] = "Luminosity";\n  return PdfBlendMode2;\n})(PdfBlendMode || {});\nvar PdfStampFit = /* @__PURE__ */ ((PdfStampFit2) => {\n  PdfStampFit2[PdfStampFit2["Contain"] = 0] = "Contain";\n  PdfStampFit2[PdfStampFit2["Cover"] = 1] = "Cover";\n  PdfStampFit2[PdfStampFit2["Stretch"] = 2] = "Stretch";\n  return PdfStampFit2;\n})(PdfStampFit || {});\nvar PdfActionType = /* @__PURE__ */ ((PdfActionType2) => {\n  PdfActionType2[PdfActionType2["Unsupported"] = 0] = "Unsupported";\n  PdfActionType2[PdfActionType2["Goto"] = 1] = "Goto";\n  PdfActionType2[PdfActionType2["RemoteGoto"] = 2] = "RemoteGoto";\n  PdfActionType2[PdfActionType2["URI"] = 3] = "URI";\n  PdfActionType2[PdfActionType2["LaunchAppOrOpenFile"] = 4] = "LaunchAppOrOpenFile";\n  return PdfActionType2;\n})(PdfActionType || {});\nvar PdfAnnotationSubtype = /* @__PURE__ */ ((PdfAnnotationSubtype2) => {\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["UNKNOWN"] = 0] = "UNKNOWN";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["TEXT"] = 1] = "TEXT";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["LINK"] = 2] = "LINK";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["FREETEXT"] = 3] = "FREETEXT";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["LINE"] = 4] = "LINE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["SQUARE"] = 5] = "SQUARE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["CIRCLE"] = 6] = "CIRCLE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["POLYGON"] = 7] = "POLYGON";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["POLYLINE"] = 8] = "POLYLINE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["HIGHLIGHT"] = 9] = "HIGHLIGHT";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["UNDERLINE"] = 10] = "UNDERLINE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["SQUIGGLY"] = 11] = "SQUIGGLY";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["STRIKEOUT"] = 12] = "STRIKEOUT";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["STAMP"] = 13] = "STAMP";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["CARET"] = 14] = "CARET";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["INK"] = 15] = "INK";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["POPUP"] = 16] = "POPUP";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["FILEATTACHMENT"] = 17] = "FILEATTACHMENT";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["SOUND"] = 18] = "SOUND";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["MOVIE"] = 19] = "MOVIE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["WIDGET"] = 20] = "WIDGET";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["SCREEN"] = 21] = "SCREEN";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["PRINTERMARK"] = 22] = "PRINTERMARK";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["TRAPNET"] = 23] = "TRAPNET";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["WATERMARK"] = 24] = "WATERMARK";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["THREED"] = 25] = "THREED";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["RICHMEDIA"] = 26] = "RICHMEDIA";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["XFAWIDGET"] = 27] = "XFAWIDGET";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["REDACT"] = 28] = "REDACT";\n  return PdfAnnotationSubtype2;\n})(PdfAnnotationSubtype || {});\nvar AppearanceMode = /* @__PURE__ */ ((AppearanceMode2) => {\n  AppearanceMode2[AppearanceMode2["Normal"] = 0] = "Normal";\n  AppearanceMode2[AppearanceMode2["Rollover"] = 1] = "Rollover";\n  AppearanceMode2[AppearanceMode2["Down"] = 2] = "Down";\n  return AppearanceMode2;\n})(AppearanceMode || {});\nvar PdfAnnotationIcon = /* @__PURE__ */ ((PdfAnnotationIcon2) => {\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Unknown"] = -1] = "Unknown";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Comment"] = 0] = "Comment";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Key"] = 1] = "Key";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Note"] = 2] = "Note";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Help"] = 3] = "Help";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["NewParagraph"] = 4] = "NewParagraph";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Paragraph"] = 5] = "Paragraph";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Insert"] = 6] = "Insert";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Graph"] = 7] = "Graph";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["PushPin"] = 8] = "PushPin";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Paperclip"] = 9] = "Paperclip";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Tag"] = 10] = "Tag";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Speaker"] = 11] = "Speaker";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Mic"] = 12] = "Mic";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Approved"] = 13] = "Approved";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Experimental"] = 14] = "Experimental";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["NotApproved"] = 15] = "NotApproved";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["AsIs"] = 16] = "AsIs";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Expired"] = 17] = "Expired";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["NotForPublicRelease"] = 18] = "NotForPublicRelease";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Confidential"] = 19] = "Confidential";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Final"] = 20] = "Final";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Sold"] = 21] = "Sold";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Departmental"] = 22] = "Departmental";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["ForComment"] = 23] = "ForComment";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["TopSecret"] = 24] = "TopSecret";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Draft"] = 25] = "Draft";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["ForPublicRelease"] = 26] = "ForPublicRelease";\n  return PdfAnnotationIcon2;\n})(PdfAnnotationIcon || {});\nvar PdfAnnotationLineEnding = /* @__PURE__ */ ((PdfAnnotationLineEnding2) => {\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["None"] = 0] = "None";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Square"] = 1] = "Square";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Circle"] = 2] = "Circle";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Diamond"] = 3] = "Diamond";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["OpenArrow"] = 4] = "OpenArrow";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["ClosedArrow"] = 5] = "ClosedArrow";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Butt"] = 6] = "Butt";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["ROpenArrow"] = 7] = "ROpenArrow";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["RClosedArrow"] = 8] = "RClosedArrow";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Slash"] = 9] = "Slash";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Unknown"] = 10] = "Unknown";\n  return PdfAnnotationLineEnding2;\n})(PdfAnnotationLineEnding || {});\nvar PDF_FORM_FIELD_TYPE = /* @__PURE__ */ ((PDF_FORM_FIELD_TYPE2) => {\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["PUSHBUTTON"] = 1] = "PUSHBUTTON";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["CHECKBOX"] = 2] = "CHECKBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["RADIOBUTTON"] = 3] = "RADIOBUTTON";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["COMBOBOX"] = 4] = "COMBOBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["LISTBOX"] = 5] = "LISTBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["TEXTFIELD"] = 6] = "TEXTFIELD";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["SIGNATURE"] = 7] = "SIGNATURE";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA"] = 8] = "XFA";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_CHECKBOX"] = 9] = "XFA_CHECKBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_COMBOBOX"] = 10] = "XFA_COMBOBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_IMAGEFIELD"] = 11] = "XFA_IMAGEFIELD";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_LISTBOX"] = 12] = "XFA_LISTBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_PUSHBUTTON"] = 13] = "XFA_PUSHBUTTON";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_SIGNATURE"] = 14] = "XFA_SIGNATURE";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_TEXTFIELD"] = 15] = "XFA_TEXTFIELD";\n  return PDF_FORM_FIELD_TYPE2;\n})(PDF_FORM_FIELD_TYPE || {});\nvar PdfAnnotationColorType = /* @__PURE__ */ ((PdfAnnotationColorType2) => {\n  PdfAnnotationColorType2[PdfAnnotationColorType2["Color"] = 0] = "Color";\n  PdfAnnotationColorType2[PdfAnnotationColorType2["InteriorColor"] = 1] = "InteriorColor";\n  return PdfAnnotationColorType2;\n})(PdfAnnotationColorType || {});\nvar PdfAnnotationBorderStyle = /* @__PURE__ */ ((PdfAnnotationBorderStyle2) => {\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["UNKNOWN"] = 0] = "UNKNOWN";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["SOLID"] = 1] = "SOLID";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["DASHED"] = 2] = "DASHED";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["BEVELED"] = 3] = "BEVELED";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["INSET"] = 4] = "INSET";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["UNDERLINE"] = 5] = "UNDERLINE";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["CLOUDY"] = 6] = "CLOUDY";\n  return PdfAnnotationBorderStyle2;\n})(PdfAnnotationBorderStyle || {});\nvar PdfPageObjectType = /* @__PURE__ */ ((PdfPageObjectType2) => {\n  PdfPageObjectType2[PdfPageObjectType2["UNKNOWN"] = 0] = "UNKNOWN";\n  PdfPageObjectType2[PdfPageObjectType2["TEXT"] = 1] = "TEXT";\n  PdfPageObjectType2[PdfPageObjectType2["PATH"] = 2] = "PATH";\n  PdfPageObjectType2[PdfPageObjectType2["IMAGE"] = 3] = "IMAGE";\n  PdfPageObjectType2[PdfPageObjectType2["SHADING"] = 4] = "SHADING";\n  PdfPageObjectType2[PdfPageObjectType2["FORM"] = 5] = "FORM";\n  return PdfPageObjectType2;\n})(PdfPageObjectType || {});\nconst PdfAnnotationFlagName = Object.freeze({\n  [\n    1\n    /* INVISIBLE */\n  ]: "invisible",\n  [\n    2\n    /* HIDDEN */\n  ]: "hidden",\n  [\n    4\n    /* PRINT */\n  ]: "print",\n  [\n    8\n    /* NO_ZOOM */\n  ]: "noZoom",\n  [\n    16\n    /* NO_ROTATE */\n  ]: "noRotate",\n  [\n    32\n    /* NO_VIEW */\n  ]: "noView",\n  [\n    64\n    /* READ_ONLY */\n  ]: "readOnly",\n  [\n    128\n    /* LOCKED */\n  ]: "locked",\n  [\n    256\n    /* TOGGLE_NOVIEW */\n  ]: "toggleNoView"\n});\nconst PdfAnnotationFlagValue = Object.entries(\n  PdfAnnotationFlagName\n).reduce(\n  (acc, [bit, name]) => {\n    acc[name] = Number(bit);\n    return acc;\n  },\n  {}\n);\nfunction flagsToNames(raw) {\n  return Object.keys(PdfAnnotationFlagName).filter((flag) => (raw & flag) !== 0).map((flag) => PdfAnnotationFlagName[flag]);\n}\nfunction namesToFlags(names) {\n  return names.reduce(\n    (mask, name) => mask | PdfAnnotationFlagValue[name],\n    0\n    /* NONE */\n  );\n}\nvar FontCharset = /* @__PURE__ */ ((FontCharset2) => {\n  FontCharset2[FontCharset2["ANSI"] = 0] = "ANSI";\n  FontCharset2[FontCharset2["DEFAULT"] = 1] = "DEFAULT";\n  FontCharset2[FontCharset2["SYMBOL"] = 2] = "SYMBOL";\n  FontCharset2[FontCharset2["SHIFTJIS"] = 128] = "SHIFTJIS";\n  FontCharset2[FontCharset2["HANGEUL"] = 129] = "HANGEUL";\n  FontCharset2[FontCharset2["GB2312"] = 134] = "GB2312";\n  FontCharset2[FontCharset2["CHINESEBIG5"] = 136] = "CHINESEBIG5";\n  FontCharset2[FontCharset2["GREEK"] = 161] = "GREEK";\n  FontCharset2[FontCharset2["VIETNAMESE"] = 163] = "VIETNAMESE";\n  FontCharset2[FontCharset2["HEBREW"] = 177] = "HEBREW";\n  FontCharset2[FontCharset2["ARABIC"] = 178] = "ARABIC";\n  FontCharset2[FontCharset2["CYRILLIC"] = 204] = "CYRILLIC";\n  FontCharset2[FontCharset2["THAI"] = 222] = "THAI";\n  FontCharset2[FontCharset2["EASTERNEUROPEAN"] = 238] = "EASTERNEUROPEAN";\n  return FontCharset2;\n})(FontCharset || {});\nvar PdfPageFlattenFlag = /* @__PURE__ */ ((PdfPageFlattenFlag2) => {\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2["Display"] = 0] = "Display";\n  PdfPageFlattenFlag2[PdfPageFlattenFlag2["Print"] = 1] = "Print";\n  return PdfPageFlattenFlag2;\n})(PdfPageFlattenFlag || {});\nvar PdfErrorCode = /* @__PURE__ */ ((PdfErrorCode2) => {\n  PdfErrorCode2[PdfErrorCode2["Ok"] = 0] = "Ok";\n  PdfErrorCode2[PdfErrorCode2["Unknown"] = 1] = "Unknown";\n  PdfErrorCode2[PdfErrorCode2["NotFound"] = 2] = "NotFound";\n  PdfErrorCode2[PdfErrorCode2["WrongFormat"] = 3] = "WrongFormat";\n  PdfErrorCode2[PdfErrorCode2["Password"] = 4] = "Password";\n  PdfErrorCode2[PdfErrorCode2["Security"] = 5] = "Security";\n  PdfErrorCode2[PdfErrorCode2["PageError"] = 6] = "PageError";\n  PdfErrorCode2[PdfErrorCode2["XFALoad"] = 7] = "XFALoad";\n  PdfErrorCode2[PdfErrorCode2["XFALayout"] = 8] = "XFALayout";\n  PdfErrorCode2[PdfErrorCode2["Cancelled"] = 9] = "Cancelled";\n  PdfErrorCode2[PdfErrorCode2["Initialization"] = 10] = "Initialization";\n  PdfErrorCode2[PdfErrorCode2["NotReady"] = 11] = "NotReady";\n  PdfErrorCode2[PdfErrorCode2["NotSupport"] = 12] = "NotSupport";\n  PdfErrorCode2[PdfErrorCode2["LoadDoc"] = 13] = "LoadDoc";\n  PdfErrorCode2[PdfErrorCode2["DocNotOpen"] = 14] = "DocNotOpen";\n  PdfErrorCode2[PdfErrorCode2["CantCloseDoc"] = 15] = "CantCloseDoc";\n  PdfErrorCode2[PdfErrorCode2["CantCreateNewDoc"] = 16] = "CantCreateNewDoc";\n  PdfErrorCode2[PdfErrorCode2["CantImportPages"] = 17] = "CantImportPages";\n  PdfErrorCode2[PdfErrorCode2["CantCreateAnnot"] = 18] = "CantCreateAnnot";\n  PdfErrorCode2[PdfErrorCode2["CantSetAnnotRect"] = 19] = "CantSetAnnotRect";\n  PdfErrorCode2[PdfErrorCode2["CantSetAnnotContent"] = 20] = "CantSetAnnotContent";\n  PdfErrorCode2[PdfErrorCode2["CantRemoveInkList"] = 21] = "CantRemoveInkList";\n  PdfErrorCode2[PdfErrorCode2["CantAddInkStoke"] = 22] = "CantAddInkStoke";\n  PdfErrorCode2[PdfErrorCode2["CantReadAttachmentSize"] = 23] = "CantReadAttachmentSize";\n  PdfErrorCode2[PdfErrorCode2["CantReadAttachmentContent"] = 24] = "CantReadAttachmentContent";\n  PdfErrorCode2[PdfErrorCode2["CantFocusAnnot"] = 25] = "CantFocusAnnot";\n  PdfErrorCode2[PdfErrorCode2["CantSelectText"] = 26] = "CantSelectText";\n  PdfErrorCode2[PdfErrorCode2["CantSelectOption"] = 27] = "CantSelectOption";\n  PdfErrorCode2[PdfErrorCode2["CantCheckField"] = 28] = "CantCheckField";\n  PdfErrorCode2[PdfErrorCode2["CantSetAnnotString"] = 29] = "CantSetAnnotString";\n  return PdfErrorCode2;\n})(PdfErrorCode || {});\nclass PdfTaskHelper {\n  /**\n   * Create a task\n   * @returns new task\n   */\n  static create() {\n    return new Task();\n  }\n  /**\n   * Create a task that has been resolved with value\n   * @param result - resolved value\n   * @returns resolved task\n   */\n  static resolve(result) {\n    const task = new Task();\n    task.resolve(result);\n    return task;\n  }\n  /**\n   * Create a task that has been rejected with error\n   * @param reason - rejected error\n   * @returns rejected task\n   */\n  static reject(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n  /**\n   * Create a task that has been aborted with error\n   * @param reason - aborted error\n   * @returns aborted task\n   */\n  static abort(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n}\nfunction pdfColorToWebColor(c) {\n  const clamp = (n) => Math.max(0, Math.min(255, n));\n  const toHex = (n) => clamp(n).toString(16).padStart(2, "0");\n  return `#${toHex(c.red)}${toHex(c.green)}${toHex(c.blue)}`;\n}\nfunction webColorToPdfColor(color) {\n  if (/^#?[0-9a-f]{3}$/i.test(color)) {\n    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, "#$1$1$2$2$3$3").toLowerCase();\n  }\n  const [, r, g, b] = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color) ?? (() => {\n    throw new Error(`Invalid hex colour: "${color}"`);\n  })();\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16)\n  };\n}\nfunction pdfAlphaToWebOpacity(alpha) {\n  const clamp = (n) => Math.max(0, Math.min(255, n));\n  return clamp(alpha) / 255;\n}\nfunction webOpacityToPdfAlpha(opacity) {\n  const clamp = (n, hi = 255) => Math.max(0, Math.min(hi, n));\n  return clamp(Math.round(opacity * 255));\n}\nfunction pdfDateToDate(pdf) {\n  if (!(pdf == null ? void 0 : pdf.startsWith("D:")) || pdf.length < 16) return;\n  const y = +pdf.slice(2, 6);\n  const mo = +pdf.slice(6, 8) - 1;\n  const d = +pdf.slice(8, 10);\n  const H = +pdf.slice(10, 12);\n  const M = +pdf.slice(12, 14);\n  const S = +pdf.slice(14, 16);\n  return new Date(Date.UTC(y, mo, d, H, M, S));\n}\nfunction dateToPdfDate(date = /* @__PURE__ */ new Date()) {\n  const z = (n, len = 2) => n.toString().padStart(len, "0");\n  const YYYY = date.getUTCFullYear();\n  const MM = z(date.getUTCMonth() + 1);\n  const DD = z(date.getUTCDate());\n  const HH = z(date.getUTCHours());\n  const mm = z(date.getUTCMinutes());\n  const SS = z(date.getUTCSeconds());\n  return `D:${YYYY}${MM}${DD}${HH}${mm}${SS}`;\n}\nconst TEXT_ALIGNMENT_INFOS = Object.freeze([\n  { id: PdfTextAlignment.Left, label: "Left", css: "left" },\n  { id: PdfTextAlignment.Center, label: "Center", css: "center" },\n  { id: PdfTextAlignment.Right, label: "Right", css: "right" }\n]);\nTEXT_ALIGNMENT_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {}\n);\nTEXT_ALIGNMENT_INFOS.reduce(\n  (m, info) => {\n    m[info.css] = info.id;\n    return m;\n  },\n  {}\n);\nTEXT_ALIGNMENT_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label\n}));\nvar PdfStandardFontFamily = /* @__PURE__ */ ((PdfStandardFontFamily2) => {\n  PdfStandardFontFamily2["Courier"] = "Courier";\n  PdfStandardFontFamily2["Helvetica"] = "Helvetica";\n  PdfStandardFontFamily2["Times"] = "Times";\n  PdfStandardFontFamily2["Symbol"] = "Symbol";\n  PdfStandardFontFamily2["ZapfDingbats"] = "ZapfDingbats";\n  PdfStandardFontFamily2["Unknown"] = "Unknown";\n  return PdfStandardFontFamily2;\n})(PdfStandardFontFamily || {});\nPdfStandardFont.Helvetica;\nconst HELVETICA_DESC = {\n  id: PdfStandardFont.Helvetica,\n  family: "Helvetica",\n  bold: false,\n  italic: false,\n  label: "Helvetica",\n  css: "Helvetica, Arial, sans-serif"\n};\nconst STANDARD_FONT_DESCRIPTORS = Object.freeze([\n  {\n    id: PdfStandardFont.Courier,\n    family: "Courier",\n    bold: false,\n    italic: false,\n    label: "Courier",\n    css: "Courier, monospace"\n  },\n  {\n    id: PdfStandardFont.Courier_Bold,\n    family: "Courier",\n    bold: true,\n    italic: false,\n    label: "Courier Bold",\n    css: \'"Courier-Bold", Courier, monospace\'\n  },\n  {\n    id: PdfStandardFont.Courier_BoldOblique,\n    family: "Courier",\n    bold: true,\n    italic: true,\n    label: "Courier Bold Oblique",\n    css: \'"Courier-BoldOblique", Courier, monospace\'\n  },\n  {\n    id: PdfStandardFont.Courier_Oblique,\n    family: "Courier",\n    bold: false,\n    italic: true,\n    label: "Courier Oblique",\n    css: \'"Courier-Oblique", Courier, monospace\'\n  },\n  HELVETICA_DESC,\n  {\n    id: PdfStandardFont.Helvetica_Bold,\n    family: "Helvetica",\n    bold: true,\n    italic: false,\n    label: "Helvetica Bold",\n    css: \'"Helvetica-Bold", Arial, sans-serif\'\n  },\n  {\n    id: PdfStandardFont.Helvetica_BoldOblique,\n    family: "Helvetica",\n    bold: true,\n    italic: true,\n    label: "Helvetica Bold Oblique",\n    css: \'"Helvetica-BoldOblique", Arial, sans-serif\'\n  },\n  {\n    id: PdfStandardFont.Helvetica_Oblique,\n    family: "Helvetica",\n    bold: false,\n    italic: true,\n    label: "Helvetica Oblique",\n    css: \'"Helvetica-Oblique", Arial, sans-serif\'\n  },\n  {\n    id: PdfStandardFont.Times_Roman,\n    family: "Times",\n    bold: false,\n    italic: false,\n    label: "Times Roman",\n    css: \'"Times New Roman", Times, serif\'\n  },\n  {\n    id: PdfStandardFont.Times_Bold,\n    family: "Times",\n    bold: true,\n    italic: false,\n    label: "Times Bold",\n    css: \'"Times New Roman Bold", Times, serif\'\n  },\n  {\n    id: PdfStandardFont.Times_BoldItalic,\n    family: "Times",\n    bold: true,\n    italic: true,\n    label: "Times Bold Italic",\n    css: \'"Times New Roman Bold Italic", Times, serif\'\n  },\n  {\n    id: PdfStandardFont.Times_Italic,\n    family: "Times",\n    bold: false,\n    italic: true,\n    label: "Times Italic",\n    css: \'"Times New Roman Italic", Times, serif\'\n  },\n  {\n    id: PdfStandardFont.Symbol,\n    family: "Symbol",\n    bold: false,\n    italic: false,\n    label: "Symbol",\n    css: "Symbol"\n  },\n  {\n    id: PdfStandardFont.ZapfDingbats,\n    family: "ZapfDingbats",\n    bold: false,\n    italic: false,\n    label: "Zapf Dingbats",\n    css: "ZapfDingbats"\n  }\n]);\nSTANDARD_FONT_DESCRIPTORS.reduce((m, d) => (m[d.id] = d, m), {});\nconst familyStyleToId = /* @__PURE__ */ new Map();\nfor (const d of STANDARD_FONT_DESCRIPTORS) {\n  familyStyleToId.set(`${d.family}_${d.bold}_${d.italic}`, d.id);\n}\nObject.values(PdfStandardFontFamily).filter(\n  (f) => f !== "Unknown"\n  /* Unknown */\n).map((family) => ({ value: family, label: family }));\n[\n  ...new Set(STANDARD_FONT_DESCRIPTORS.map((d) => d.family))\n];\nconst BLEND_MODE_INFOS = Object.freeze([\n  { id: PdfBlendMode.Normal, label: "Normal", css: "normal" },\n  { id: PdfBlendMode.Multiply, label: "Multiply", css: "multiply" },\n  { id: PdfBlendMode.Screen, label: "Screen", css: "screen" },\n  { id: PdfBlendMode.Overlay, label: "Overlay", css: "overlay" },\n  { id: PdfBlendMode.Darken, label: "Darken", css: "darken" },\n  { id: PdfBlendMode.Lighten, label: "Lighten", css: "lighten" },\n  { id: PdfBlendMode.ColorDodge, label: "Color Dodge", css: "color-dodge" },\n  { id: PdfBlendMode.ColorBurn, label: "Color Burn", css: "color-burn" },\n  { id: PdfBlendMode.HardLight, label: "Hard Light", css: "hard-light" },\n  { id: PdfBlendMode.SoftLight, label: "Soft Light", css: "soft-light" },\n  { id: PdfBlendMode.Difference, label: "Difference", css: "difference" },\n  { id: PdfBlendMode.Exclusion, label: "Exclusion", css: "exclusion" },\n  { id: PdfBlendMode.Hue, label: "Hue", css: "hue" },\n  { id: PdfBlendMode.Saturation, label: "Saturation", css: "saturation" },\n  { id: PdfBlendMode.Color, label: "Color", css: "color" },\n  { id: PdfBlendMode.Luminosity, label: "Luminosity", css: "luminosity" }\n]);\nBLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {}\n);\nBLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.css] = info.id;\n    return m;\n  },\n  {}\n);\nBLEND_MODE_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label\n}));\nBLEND_MODE_INFOS.map((info) => info.id);\nfunction deserializeLogger(serialized) {\n  var _a, _b, _c;\n  switch (serialized.type) {\n    case "noop":\n      return new NoopLogger();\n    case "console":\n      return new ConsoleLogger();\n    case "perf":\n      return new PerfLogger();\n    case "level":\n      if (!((_a = serialized.config) == null ? void 0 : _a.logger) || ((_b = serialized.config) == null ? void 0 : _b.level) === void 0) {\n        throw new Error("LevelLogger requires logger and level in config");\n      }\n      return new LevelLogger(deserializeLogger(serialized.config.logger), serialized.config.level);\n    case "all":\n      if (!((_c = serialized.config) == null ? void 0 : _c.loggers)) {\n        throw new Error("AllLogger requires loggers array in config");\n      }\n      return new AllLogger(serialized.config.loggers.map(deserializeLogger));\n    default:\n      return new NoopLogger();\n  }\n}\nconst V4_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nfunction isUuidV4(str) {\n  return V4_REGEX.test(str);\n}\nfunction getRandomBytes(len) {\n  var _a;\n  if (typeof ((_a = globalThis.crypto) == null ? void 0 : _a.getRandomValues) === "function") {\n    return globalThis.crypto.getRandomValues(new Uint8Array(len));\n  }\n  if (typeof require === "function") {\n    try {\n      const { randomBytes } = require("crypto");\n      return randomBytes(len);\n    } catch {\n    }\n  }\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) bytes[i] = Math.floor(Math.random() * 256);\n  return bytes;\n}\nfunction uuidV4() {\n  var _a;\n  if (typeof ((_a = globalThis.crypto) == null ? void 0 : _a.randomUUID) === "function") {\n    return globalThis.crypto.randomUUID();\n  }\n  const bytes = getRandomBytes(16);\n  bytes[6] = bytes[6] & 15 | 64;\n  bytes[8] = bytes[8] & 63 | 128;\n  const hex = Array.from(bytes, (b) => b.toString(16).padStart(2, "0")).join("");\n  return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;\n}\nvar createPdfium = (() => {\n  var _scriptName = import.meta.url;\n  return async function(moduleArg = {}) {\n    var moduleRtn;\n    var Module = moduleArg;\n    var readyPromiseResolve, readyPromiseReject;\n    var readyPromise = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    [\n      "_EPDF_GetMetaKeyCount",\n      "_EPDF_GetMetaKeyName",\n      "_EPDF_GetMetaTrapped",\n      "_EPDF_GetPageRotationByIndex",\n      "_EPDF_HasMetaText",\n      "_EPDF_PNG_EncodeRGBA",\n      "_EPDF_RenderAnnotBitmap",\n      "_EPDF_SetMetaText",\n      "_EPDF_SetMetaTrapped",\n      "_EPDFAction_CreateGoTo",\n      "_EPDFAction_CreateGoToNamed",\n      "_EPDFAction_CreateLaunch",\n      "_EPDFAction_CreateRemoteGoToByName",\n      "_EPDFAction_CreateRemoteGoToDest",\n      "_EPDFAction_CreateURI",\n      "_EPDFAnnot_ClearColor",\n      "_EPDFAnnot_GenerateAppearance",\n      "_EPDFAnnot_GenerateAppearanceWithBlend",\n      "_EPDFAnnot_GetBlendMode",\n      "_EPDFAnnot_GetBorderDashPattern",\n      "_EPDFAnnot_GetBorderDashPatternCount",\n      "_EPDFAnnot_GetBorderEffect",\n      "_EPDFAnnot_GetBorderStyle",\n      "_EPDFAnnot_GetColor",\n      "_EPDFAnnot_GetDefaultAppearance",\n      "_EPDFAnnot_GetIcon",\n      "_EPDFAnnot_GetIntent",\n      "_EPDFAnnot_GetLineEndings",\n      "_EPDFAnnot_GetOpacity",\n      "_EPDFAnnot_GetRectangleDifferences",\n      "_EPDFAnnot_GetRichContent",\n      "_EPDFAnnot_GetTextAlignment",\n      "_EPDFAnnot_GetVerticalAlignment",\n      "_EPDFAnnot_SetBorderDashPattern",\n      "_EPDFAnnot_SetBorderStyle",\n      "_EPDFAnnot_SetColor",\n      "_EPDFAnnot_SetDefaultAppearance",\n      "_EPDFAnnot_SetIcon",\n      "_EPDFAnnot_SetIntent",\n      "_EPDFAnnot_SetLine",\n      "_EPDFAnnot_SetLineEndings",\n      "_EPDFAnnot_SetLinkedAnnot",\n      "_EPDFAnnot_SetOpacity",\n      "_EPDFAnnot_SetTextAlignment",\n      "_EPDFAnnot_SetVerticalAlignment",\n      "_EPDFAnnot_SetVertices",\n      "_EPDFAnnot_UpdateAppearanceToRect",\n      "_EPDFAttachment_GetDescription",\n      "_EPDFAttachment_GetIntegerValue",\n      "_EPDFAttachment_SetDescription",\n      "_EPDFAttachment_SetSubtype",\n      "_EPDFBookmark_AppendChild",\n      "_EPDFBookmark_Clear",\n      "_EPDFBookmark_ClearTarget",\n      "_EPDFBookmark_Create",\n      "_EPDFBookmark_Delete",\n      "_EPDFBookmark_InsertAfter",\n      "_EPDFBookmark_SetAction",\n      "_EPDFBookmark_SetDest",\n      "_EPDFBookmark_SetTitle",\n      "_EPDFCatalog_GetLanguage",\n      "_EPDFDest_CreateRemoteView",\n      "_EPDFDest_CreateRemoteXYZ",\n      "_EPDFDest_CreateView",\n      "_EPDFDest_CreateXYZ",\n      "_EPDFNamedDest_Remove",\n      "_EPDFNamedDest_SetDest",\n      "_EPDFPage_CreateAnnot",\n      "_EPDFPage_GetAnnotByName",\n      "_EPDFPage_GetAnnotCountRaw",\n      "_EPDFPage_GetAnnotRaw",\n      "_EPDFPage_RemoveAnnotByName",\n      "_EPDFPage_RemoveAnnotRaw",\n      "_EPDFText_RedactInQuads",\n      "_EPDFText_RedactInRect",\n      "_FORM_CanRedo",\n      "_FORM_CanUndo",\n      "_FORM_DoDocumentAAction",\n      "_FORM_DoDocumentJSAction",\n      "_FORM_DoDocumentOpenAction",\n      "_FORM_DoPageAAction",\n      "_FORM_ForceToKillFocus",\n      "_FORM_GetFocusedAnnot",\n      "_FORM_GetFocusedText",\n      "_FORM_GetSelectedText",\n      "_FORM_IsIndexSelected",\n      "_FORM_OnAfterLoadPage",\n      "_FORM_OnBeforeClosePage",\n      "_FORM_OnChar",\n      "_FORM_OnFocus",\n      "_FORM_OnKeyDown",\n      "_FORM_OnKeyUp",\n      "_FORM_OnLButtonDoubleClick",\n      "_FORM_OnLButtonDown",\n      "_FORM_OnLButtonUp",\n      "_FORM_OnMouseMove",\n      "_FORM_OnMouseWheel",\n      "_FORM_OnRButtonDown",\n      "_FORM_OnRButtonUp",\n      "_FORM_Redo",\n      "_FORM_ReplaceAndKeepSelection",\n      "_FORM_ReplaceSelection",\n      "_FORM_SelectAllText",\n      "_FORM_SetFocusedAnnot",\n      "_FORM_SetIndexSelected",\n      "_FORM_Undo",\n      "_FPDF_AddInstalledFont",\n      "_FPDF_CloseDocument",\n      "_FPDF_ClosePage",\n      "_FPDF_CloseXObject",\n      "_FPDF_CopyViewerPreferences",\n      "_FPDF_CountNamedDests",\n      "_FPDF_CreateClipPath",\n      "_FPDF_CreateNewDocument",\n      "_FPDF_DestroyClipPath",\n      "_FPDF_DestroyLibrary",\n      "_FPDF_DeviceToPage",\n      "_FPDF_DocumentHasValidCrossReferenceTable",\n      "_FPDF_FFLDraw",\n      "_FPDF_FreeDefaultSystemFontInfo",\n      "_FPDF_GetDefaultSystemFontInfo",\n      "_FPDF_GetDefaultTTFMap",\n      "_FPDF_GetDefaultTTFMapCount",\n      "_FPDF_GetDefaultTTFMapEntry",\n      "_FPDF_GetDocPermissions",\n      "_FPDF_GetDocUserPermissions",\n      "_FPDF_GetFileIdentifier",\n      "_FPDF_GetFileVersion",\n      "_FPDF_GetFormType",\n      "_FPDF_GetLastError",\n      "_FPDF_GetMetaText",\n      "_FPDF_GetNamedDest",\n      "_FPDF_GetNamedDestByName",\n      "_FPDF_GetPageAAction",\n      "_FPDF_GetPageBoundingBox",\n      "_FPDF_GetPageCount",\n      "_FPDF_GetPageHeight",\n      "_FPDF_GetPageHeightF",\n      "_FPDF_GetPageLabel",\n      "_FPDF_GetPageSizeByIndex",\n      "_FPDF_GetPageSizeByIndexF",\n      "_FPDF_GetPageWidth",\n      "_FPDF_GetPageWidthF",\n      "_FPDF_GetSecurityHandlerRevision",\n      "_FPDF_GetSignatureCount",\n      "_FPDF_GetSignatureObject",\n      "_FPDF_GetTrailerEnds",\n      "_FPDF_GetXFAPacketContent",\n      "_FPDF_GetXFAPacketCount",\n      "_FPDF_GetXFAPacketName",\n      "_FPDF_ImportNPagesToOne",\n      "_FPDF_ImportPages",\n      "_FPDF_ImportPagesByIndex",\n      "_FPDF_InitLibrary",\n      "_FPDF_InitLibraryWithConfig",\n      "_FPDF_LoadCustomDocument",\n      "_FPDF_LoadDocument",\n      "_FPDF_LoadMemDocument",\n      "_FPDF_LoadMemDocument64",\n      "_FPDF_LoadPage",\n      "_FPDF_LoadXFA",\n      "_FPDF_MovePages",\n      "_FPDF_NewFormObjectFromXObject",\n      "_FPDF_NewXObjectFromPage",\n      "_FPDF_PageToDevice",\n      "_FPDF_RemoveFormFieldHighlight",\n      "_FPDF_RenderPage_Close",\n      "_FPDF_RenderPage_Continue",\n      "_FPDF_RenderPageBitmap",\n      "_FPDF_RenderPageBitmap_Start",\n      "_FPDF_RenderPageBitmapWithColorScheme_Start",\n      "_FPDF_RenderPageBitmapWithMatrix",\n      "_FPDF_SaveAsCopy",\n      "_FPDF_SaveWithVersion",\n      "_FPDF_SetFormFieldHighlightAlpha",\n      "_FPDF_SetFormFieldHighlightColor",\n      "_FPDF_SetSandBoxPolicy",\n      "_FPDF_SetSystemFontInfo",\n      "_FPDF_StructElement_Attr_CountChildren",\n      "_FPDF_StructElement_Attr_GetBlobValue",\n      "_FPDF_StructElement_Attr_GetBooleanValue",\n      "_FPDF_StructElement_Attr_GetChildAtIndex",\n      "_FPDF_StructElement_Attr_GetCount",\n      "_FPDF_StructElement_Attr_GetName",\n      "_FPDF_StructElement_Attr_GetNumberValue",\n      "_FPDF_StructElement_Attr_GetStringValue",\n      "_FPDF_StructElement_Attr_GetType",\n      "_FPDF_StructElement_Attr_GetValue",\n      "_FPDF_StructElement_CountChildren",\n      "_FPDF_StructElement_GetActualText",\n      "_FPDF_StructElement_GetAltText",\n      "_FPDF_StructElement_GetAttributeAtIndex",\n      "_FPDF_StructElement_GetAttributeCount",\n      "_FPDF_StructElement_GetChildAtIndex",\n      "_FPDF_StructElement_GetChildMarkedContentID",\n      "_FPDF_StructElement_GetID",\n      "_FPDF_StructElement_GetLang",\n      "_FPDF_StructElement_GetMarkedContentID",\n      "_FPDF_StructElement_GetMarkedContentIdAtIndex",\n      "_FPDF_StructElement_GetMarkedContentIdCount",\n      "_FPDF_StructElement_GetObjType",\n      "_FPDF_StructElement_GetParent",\n      "_FPDF_StructElement_GetStringAttribute",\n      "_FPDF_StructElement_GetTitle",\n      "_FPDF_StructElement_GetType",\n      "_FPDF_StructTree_Close",\n      "_FPDF_StructTree_CountChildren",\n      "_FPDF_StructTree_GetChildAtIndex",\n      "_FPDF_StructTree_GetForPage",\n      "_FPDF_VIEWERREF_GetDuplex",\n      "_FPDF_VIEWERREF_GetName",\n      "_FPDF_VIEWERREF_GetNumCopies",\n      "_FPDF_VIEWERREF_GetPrintPageRange",\n      "_FPDF_VIEWERREF_GetPrintPageRangeCount",\n      "_FPDF_VIEWERREF_GetPrintPageRangeElement",\n      "_FPDF_VIEWERREF_GetPrintScaling",\n      "_FPDFAction_GetDest",\n      "_FPDFAction_GetFilePath",\n      "_FPDFAction_GetType",\n      "_FPDFAction_GetURIPath",\n      "_FPDFAnnot_AddFileAttachment",\n      "_FPDFAnnot_AddInkStroke",\n      "_FPDFAnnot_AppendAttachmentPoints",\n      "_FPDFAnnot_AppendObject",\n      "_FPDFAnnot_CountAttachmentPoints",\n      "_FPDFAnnot_GetAP",\n      "_FPDFAnnot_GetAttachmentPoints",\n      "_FPDFAnnot_GetBorder",\n      "_FPDFAnnot_GetColor",\n      "_FPDFAnnot_GetFileAttachment",\n      "_FPDFAnnot_GetFlags",\n      "_FPDFAnnot_GetFocusableSubtypes",\n      "_FPDFAnnot_GetFocusableSubtypesCount",\n      "_FPDFAnnot_GetFontColor",\n      "_FPDFAnnot_GetFontSize",\n      "_FPDFAnnot_GetFormAdditionalActionJavaScript",\n      "_FPDFAnnot_GetFormControlCount",\n      "_FPDFAnnot_GetFormControlIndex",\n      "_FPDFAnnot_GetFormFieldAlternateName",\n      "_FPDFAnnot_GetFormFieldAtPoint",\n      "_FPDFAnnot_GetFormFieldExportValue",\n      "_FPDFAnnot_GetFormFieldFlags",\n      "_FPDFAnnot_GetFormFieldName",\n      "_FPDFAnnot_GetFormFieldType",\n      "_FPDFAnnot_GetFormFieldValue",\n      "_FPDFAnnot_GetInkListCount",\n      "_FPDFAnnot_GetInkListPath",\n      "_FPDFAnnot_GetLine",\n      "_FPDFAnnot_GetLink",\n      "_FPDFAnnot_GetLinkedAnnot",\n      "_FPDFAnnot_GetNumberValue",\n      "_FPDFAnnot_GetObject",\n      "_FPDFAnnot_GetObjectCount",\n      "_FPDFAnnot_GetOptionCount",\n      "_FPDFAnnot_GetOptionLabel",\n      "_FPDFAnnot_GetRect",\n      "_FPDFAnnot_GetStringValue",\n      "_FPDFAnnot_GetSubtype",\n      "_FPDFAnnot_GetValueType",\n      "_FPDFAnnot_GetVertices",\n      "_FPDFAnnot_HasAttachmentPoints",\n      "_FPDFAnnot_HasKey",\n      "_FPDFAnnot_IsChecked",\n      "_FPDFAnnot_IsObjectSupportedSubtype",\n      "_FPDFAnnot_IsOptionSelected",\n      "_FPDFAnnot_IsSupportedSubtype",\n      "_FPDFAnnot_RemoveInkList",\n      "_FPDFAnnot_RemoveObject",\n      "_FPDFAnnot_SetAP",\n      "_FPDFAnnot_SetAttachmentPoints",\n      "_FPDFAnnot_SetBorder",\n      "_FPDFAnnot_SetColor",\n      "_FPDFAnnot_SetFlags",\n      "_FPDFAnnot_SetFocusableSubtypes",\n      "_FPDFAnnot_SetFontColor",\n      "_FPDFAnnot_SetFormFieldFlags",\n      "_FPDFAnnot_SetRect",\n      "_FPDFAnnot_SetStringValue",\n      "_FPDFAnnot_SetURI",\n      "_FPDFAnnot_UpdateObject",\n      "_FPDFAttachment_GetFile",\n      "_FPDFAttachment_GetName",\n      "_FPDFAttachment_GetStringValue",\n      "_FPDFAttachment_GetSubtype",\n      "_FPDFAttachment_GetValueType",\n      "_FPDFAttachment_HasKey",\n      "_FPDFAttachment_SetFile",\n      "_FPDFAttachment_SetStringValue",\n      "_FPDFAvail_Create",\n      "_FPDFAvail_Destroy",\n      "_FPDFAvail_GetDocument",\n      "_FPDFAvail_GetFirstPageNum",\n      "_FPDFAvail_IsDocAvail",\n      "_FPDFAvail_IsFormAvail",\n      "_FPDFAvail_IsLinearized",\n      "_FPDFAvail_IsPageAvail",\n      "_FPDFBitmap_Create",\n      "_FPDFBitmap_CreateEx",\n      "_FPDFBitmap_Destroy",\n      "_FPDFBitmap_FillRect",\n      "_FPDFBitmap_GetBuffer",\n      "_FPDFBitmap_GetFormat",\n      "_FPDFBitmap_GetHeight",\n      "_FPDFBitmap_GetStride",\n      "_FPDFBitmap_GetWidth",\n      "_FPDFBookmark_Find",\n      "_FPDFBookmark_GetAction",\n      "_FPDFBookmark_GetCount",\n      "_FPDFBookmark_GetDest",\n      "_FPDFBookmark_GetFirstChild",\n      "_FPDFBookmark_GetNextSibling",\n      "_FPDFBookmark_GetTitle",\n      "_FPDFCatalog_IsTagged",\n      "_FPDFCatalog_SetLanguage",\n      "_FPDFClipPath_CountPaths",\n      "_FPDFClipPath_CountPathSegments",\n      "_FPDFClipPath_GetPathSegment",\n      "_FPDFDest_GetDestPageIndex",\n      "_FPDFDest_GetLocationInPage",\n      "_FPDFDest_GetView",\n      "_FPDFDoc_AddAttachment",\n      "_FPDFDoc_CloseJavaScriptAction",\n      "_FPDFDoc_DeleteAttachment",\n      "_FPDFDOC_ExitFormFillEnvironment",\n      "_FPDFDoc_GetAttachment",\n      "_FPDFDoc_GetAttachmentCount",\n      "_FPDFDoc_GetJavaScriptAction",\n      "_FPDFDoc_GetJavaScriptActionCount",\n      "_FPDFDoc_GetPageMode",\n      "_FPDFDOC_InitFormFillEnvironment",\n      "_FPDFFont_Close",\n      "_FPDFFont_GetAscent",\n      "_FPDFFont_GetBaseFontName",\n      "_FPDFFont_GetDescent",\n      "_FPDFFont_GetFamilyName",\n      "_FPDFFont_GetFlags",\n      "_FPDFFont_GetFontData",\n      "_FPDFFont_GetGlyphPath",\n      "_FPDFFont_GetGlyphWidth",\n      "_FPDFFont_GetIsEmbedded",\n      "_FPDFFont_GetItalicAngle",\n      "_FPDFFont_GetWeight",\n      "_FPDFFormObj_CountObjects",\n      "_FPDFFormObj_GetObject",\n      "_FPDFFormObj_RemoveObject",\n      "_FPDFGlyphPath_CountGlyphSegments",\n      "_FPDFGlyphPath_GetGlyphPathSegment",\n      "_FPDFImageObj_GetBitmap",\n      "_FPDFImageObj_GetIccProfileDataDecoded",\n      "_FPDFImageObj_GetImageDataDecoded",\n      "_FPDFImageObj_GetImageDataRaw",\n      "_FPDFImageObj_GetImageFilter",\n      "_FPDFImageObj_GetImageFilterCount",\n      "_FPDFImageObj_GetImageMetadata",\n      "_FPDFImageObj_GetImagePixelSize",\n      "_FPDFImageObj_GetRenderedBitmap",\n      "_FPDFImageObj_LoadJpegFile",\n      "_FPDFImageObj_LoadJpegFileInline",\n      "_FPDFImageObj_SetBitmap",\n      "_FPDFImageObj_SetMatrix",\n      "_FPDFJavaScriptAction_GetName",\n      "_FPDFJavaScriptAction_GetScript",\n      "_FPDFLink_CloseWebLinks",\n      "_FPDFLink_CountQuadPoints",\n      "_FPDFLink_CountRects",\n      "_FPDFLink_CountWebLinks",\n      "_FPDFLink_Enumerate",\n      "_FPDFLink_GetAction",\n      "_FPDFLink_GetAnnot",\n      "_FPDFLink_GetAnnotRect",\n      "_FPDFLink_GetDest",\n      "_FPDFLink_GetLinkAtPoint",\n      "_FPDFLink_GetLinkZOrderAtPoint",\n      "_FPDFLink_GetQuadPoints",\n      "_FPDFLink_GetRect",\n      "_FPDFLink_GetTextRange",\n      "_FPDFLink_GetURL",\n      "_FPDFLink_LoadWebLinks",\n      "_FPDFPage_CloseAnnot",\n      "_FPDFPage_CountObjects",\n      "_FPDFPage_CreateAnnot",\n      "_FPDFPage_Delete",\n      "_FPDFPage_Flatten",\n      "_FPDFPage_FormFieldZOrderAtPoint",\n      "_FPDFPage_GenerateContent",\n      "_FPDFPage_GetAnnot",\n      "_FPDFPage_GetAnnotCount",\n      "_FPDFPage_GetAnnotIndex",\n      "_FPDFPage_GetArtBox",\n      "_FPDFPage_GetBleedBox",\n      "_FPDFPage_GetCropBox",\n      "_FPDFPage_GetDecodedThumbnailData",\n      "_FPDFPage_GetMediaBox",\n      "_FPDFPage_GetObject",\n      "_FPDFPage_GetRawThumbnailData",\n      "_FPDFPage_GetRotation",\n      "_FPDFPage_GetThumbnailAsBitmap",\n      "_FPDFPage_GetTrimBox",\n      "_FPDFPage_HasFormFieldAtPoint",\n      "_FPDFPage_HasTransparency",\n      "_FPDFPage_InsertClipPath",\n      "_FPDFPage_InsertObject",\n      "_FPDFPage_InsertObjectAtIndex",\n      "_FPDFPage_New",\n      "_FPDFPage_RemoveAnnot",\n      "_FPDFPage_RemoveObject",\n      "_FPDFPage_SetArtBox",\n      "_FPDFPage_SetBleedBox",\n      "_FPDFPage_SetCropBox",\n      "_FPDFPage_SetMediaBox",\n      "_FPDFPage_SetRotation",\n      "_FPDFPage_SetTrimBox",\n      "_FPDFPage_TransformAnnots",\n      "_FPDFPage_TransFormWithClip",\n      "_FPDFPageObj_AddMark",\n      "_FPDFPageObj_CountMarks",\n      "_FPDFPageObj_CreateNewPath",\n      "_FPDFPageObj_CreateNewRect",\n      "_FPDFPageObj_CreateTextObj",\n      "_FPDFPageObj_Destroy",\n      "_FPDFPageObj_GetBounds",\n      "_FPDFPageObj_GetClipPath",\n      "_FPDFPageObj_GetDashArray",\n      "_FPDFPageObj_GetDashCount",\n      "_FPDFPageObj_GetDashPhase",\n      "_FPDFPageObj_GetFillColor",\n      "_FPDFPageObj_GetIsActive",\n      "_FPDFPageObj_GetLineCap",\n      "_FPDFPageObj_GetLineJoin",\n      "_FPDFPageObj_GetMark",\n      "_FPDFPageObj_GetMarkedContentID",\n      "_FPDFPageObj_GetMatrix",\n      "_FPDFPageObj_GetRotatedBounds",\n      "_FPDFPageObj_GetStrokeColor",\n      "_FPDFPageObj_GetStrokeWidth",\n      "_FPDFPageObj_GetType",\n      "_FPDFPageObj_HasTransparency",\n      "_FPDFPageObj_NewImageObj",\n      "_FPDFPageObj_NewTextObj",\n      "_FPDFPageObj_RemoveMark",\n      "_FPDFPageObj_SetBlendMode",\n      "_FPDFPageObj_SetDashArray",\n      "_FPDFPageObj_SetDashPhase",\n      "_FPDFPageObj_SetFillColor",\n      "_FPDFPageObj_SetIsActive",\n      "_FPDFPageObj_SetLineCap",\n      "_FPDFPageObj_SetLineJoin",\n      "_FPDFPageObj_SetMatrix",\n      "_FPDFPageObj_SetStrokeColor",\n      "_FPDFPageObj_SetStrokeWidth",\n      "_FPDFPageObj_Transform",\n      "_FPDFPageObj_TransformClipPath",\n      "_FPDFPageObj_TransformF",\n      "_FPDFPageObjMark_CountParams",\n      "_FPDFPageObjMark_GetName",\n      "_FPDFPageObjMark_GetParamBlobValue",\n      "_FPDFPageObjMark_GetParamIntValue",\n      "_FPDFPageObjMark_GetParamKey",\n      "_FPDFPageObjMark_GetParamStringValue",\n      "_FPDFPageObjMark_GetParamValueType",\n      "_FPDFPageObjMark_RemoveParam",\n      "_FPDFPageObjMark_SetBlobParam",\n      "_FPDFPageObjMark_SetIntParam",\n      "_FPDFPageObjMark_SetStringParam",\n      "_FPDFPath_BezierTo",\n      "_FPDFPath_Close",\n      "_FPDFPath_CountSegments",\n      "_FPDFPath_GetDrawMode",\n      "_FPDFPath_GetPathSegment",\n      "_FPDFPath_LineTo",\n      "_FPDFPath_MoveTo",\n      "_FPDFPath_SetDrawMode",\n      "_FPDFPathSegment_GetClose",\n      "_FPDFPathSegment_GetPoint",\n      "_FPDFPathSegment_GetType",\n      "_FPDFSignatureObj_GetByteRange",\n      "_FPDFSignatureObj_GetContents",\n      "_FPDFSignatureObj_GetDocMDPPermission",\n      "_FPDFSignatureObj_GetReason",\n      "_FPDFSignatureObj_GetSubFilter",\n      "_FPDFSignatureObj_GetTime",\n      "_FPDFText_ClosePage",\n      "_FPDFText_CountChars",\n      "_FPDFText_CountRects",\n      "_FPDFText_FindClose",\n      "_FPDFText_FindNext",\n      "_FPDFText_FindPrev",\n      "_FPDFText_FindStart",\n      "_FPDFText_GetBoundedText",\n      "_FPDFText_GetCharAngle",\n      "_FPDFText_GetCharBox",\n      "_FPDFText_GetCharIndexAtPos",\n      "_FPDFText_GetCharIndexFromTextIndex",\n      "_FPDFText_GetCharOrigin",\n      "_FPDFText_GetFillColor",\n      "_FPDFText_GetFontInfo",\n      "_FPDFText_GetFontSize",\n      "_FPDFText_GetFontWeight",\n      "_FPDFText_GetLooseCharBox",\n      "_FPDFText_GetMatrix",\n      "_FPDFText_GetRect",\n      "_FPDFText_GetSchCount",\n      "_FPDFText_GetSchResultIndex",\n      "_FPDFText_GetStrokeColor",\n      "_FPDFText_GetText",\n      "_FPDFText_GetTextIndexFromCharIndex",\n      "_FPDFText_GetTextObject",\n      "_FPDFText_GetUnicode",\n      "_FPDFText_HasUnicodeMapError",\n      "_FPDFText_IsGenerated",\n      "_FPDFText_IsHyphen",\n      "_FPDFText_LoadCidType2Font",\n      "_FPDFText_LoadFont",\n      "_FPDFText_LoadPage",\n      "_FPDFText_LoadStandardFont",\n      "_FPDFText_SetCharcodes",\n      "_FPDFText_SetText",\n      "_FPDFTextObj_GetFont",\n      "_FPDFTextObj_GetFontSize",\n      "_FPDFTextObj_GetRenderedBitmap",\n      "_FPDFTextObj_GetText",\n      "_FPDFTextObj_GetTextRenderMode",\n      "_FPDFTextObj_SetTextRenderMode",\n      "_PDFiumExt_CloseFileWriter",\n      "_PDFiumExt_CloseFormFillInfo",\n      "_PDFiumExt_ExitFormFillEnvironment",\n      "_PDFiumExt_GetFileWriterData",\n      "_PDFiumExt_GetFileWriterSize",\n      "_PDFiumExt_Init",\n      "_PDFiumExt_InitFormFillEnvironment",\n      "_PDFiumExt_OpenFileWriter",\n      "_PDFiumExt_OpenFormFillInfo",\n      "_PDFiumExt_SaveAsCopy",\n      "_malloc",\n      "_free",\n      "_memory",\n      "___indirect_function_table",\n      "onRuntimeInitialized"\n    ].forEach((prop) => {\n      if (!Object.getOwnPropertyDescriptor(readyPromise, prop)) {\n        Object.defineProperty(readyPromise, prop, {\n          get: () => abort(\n            "You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"\n          ),\n          set: () => abort(\n            "You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"\n          )\n        });\n      }\n    });\n    var ENVIRONMENT_IS_WEB = typeof window == "object";\n    var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";\n    typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";\n    var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && true && !ENVIRONMENT_IS_WORKER;\n    var moduleOverrides = Object.assign({}, Module);\n    var thisProgram = "./this.program";\n    var scriptDirectory = "";\n    function locateFile(path) {\n      if (Module["locateFile"]) {\n        return Module["locateFile"](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n    var readAsync, readBinary;\n    if (ENVIRONMENT_IS_SHELL) {\n      if (typeof window == "object" || typeof importScripts == "function")\n        throw new Error(\n          "not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)"\n        );\n      readBinary = (f) => {\n        if (typeof readbuffer == "function") {\n          return new Uint8Array(readbuffer(f));\n        }\n        let data = read(f, "binary");\n        assert(typeof data == "object");\n        return data;\n      };\n      readAsync = (f) => {\n        return new Promise((resolve, reject) => {\n          setTimeout(() => resolve(readBinary(f)));\n        });\n      };\n      globalThis.clearTimeout ?? (globalThis.clearTimeout = (id) => {\n      });\n      globalThis.setTimeout ?? (globalThis.setTimeout = (f) => typeof f == "function" ? f() : abort());\n      if (typeof print != "undefined") {\n        globalThis.console ?? (globalThis.console = /** @type{!Console} */\n        {});\n        console.log = /** @type{!function(this:Console, ...*): undefined} */\n        print;\n        console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */\n        globalThis.printErr ?? print;\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document != "undefined" && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n      if (_scriptName) {\n        scriptDirectory = _scriptName;\n      }\n      if (scriptDirectory.startsWith("blob:")) {\n        scriptDirectory = "";\n      } else {\n        scriptDirectory = scriptDirectory.substr(\n          0,\n          scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1\n        );\n      }\n      if (!(typeof window == "object" || typeof importScripts == "function"))\n        throw new Error(\n          "not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)"\n        );\n      {\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = (url) => {\n            var xhr = new XMLHttpRequest();\n            xhr.open("GET", url, false);\n            xhr.responseType = "arraybuffer";\n            xhr.send(null);\n            return new Uint8Array(\n              /** @type{!ArrayBuffer} */\n              xhr.response\n            );\n          };\n        }\n        readAsync = (url) => {\n          assert(!isFileURI(url), "readAsync does not work with file:// URLs");\n          return fetch(url, { credentials: "same-origin" }).then((response) => {\n            if (response.ok) {\n              return response.arrayBuffer();\n            }\n            return Promise.reject(new Error(response.status + " : " + response.url));\n          });\n        };\n      }\n    } else {\n      throw new Error("environment detection error");\n    }\n    var out = Module["print"] || console.log.bind(console);\n    var err = Module["printErr"] || console.error.bind(console);\n    Object.assign(Module, moduleOverrides);\n    moduleOverrides = null;\n    checkIncomingModuleAPI();\n    if (Module["arguments"]) Module["arguments"];\n    legacyModuleProp("arguments", "arguments_");\n    if (Module["thisProgram"]) thisProgram = Module["thisProgram"];\n    legacyModuleProp("thisProgram", "thisProgram");\n    assert(\n      typeof Module["memoryInitializerPrefixURL"] == "undefined",\n      "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead"\n    );\n    assert(\n      typeof Module["pthreadMainPrefixURL"] == "undefined",\n      "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead"\n    );\n    assert(\n      typeof Module["cdInitializerPrefixURL"] == "undefined",\n      "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead"\n    );\n    assert(\n      typeof Module["filePackagePrefixURL"] == "undefined",\n      "Module.filePackagePrefixURL option was removed, use Module.locateFile instead"\n    );\n    assert(typeof Module["read"] == "undefined", "Module.read option was removed");\n    assert(\n      typeof Module["readAsync"] == "undefined",\n      "Module.readAsync option was removed (modify readAsync in JS)"\n    );\n    assert(\n      typeof Module["readBinary"] == "undefined",\n      "Module.readBinary option was removed (modify readBinary in JS)"\n    );\n    assert(\n      typeof Module["setWindowTitle"] == "undefined",\n      "Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)"\n    );\n    assert(\n      typeof Module["TOTAL_MEMORY"] == "undefined",\n      "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY"\n    );\n    legacyModuleProp("asm", "wasmExports");\n    legacyModuleProp("readAsync", "readAsync");\n    legacyModuleProp("readBinary", "readBinary");\n    legacyModuleProp("setWindowTitle", "setWindowTitle");\n    var wasmBinary = Module["wasmBinary"];\n    legacyModuleProp("wasmBinary", "wasmBinary");\n    if (typeof WebAssembly != "object") {\n      err("no native wasm support detected");\n    }\n    var wasmMemory;\n    var ABORT = false;\n    function assert(condition, text) {\n      if (!condition) {\n        abort("Assertion failed" + (text ? ": " + text : ""));\n      }\n    }\n    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module["HEAP8"] = HEAP8 = new Int8Array(b);\n      Module["HEAP16"] = HEAP16 = new Int16Array(b);\n      Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);\n      Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);\n      Module["HEAP32"] = HEAP32 = new Int32Array(b);\n      Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);\n      Module["HEAPF32"] = HEAPF32 = new Float32Array(b);\n      Module["HEAPF64"] = HEAPF64 = new Float64Array(b);\n    }\n    assert(\n      !Module["STACK_SIZE"],\n      "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time"\n    );\n    assert(\n      typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != void 0 && Int32Array.prototype.set != void 0,\n      "JS engine does not provide full typed array support"\n    );\n    assert(\n      !Module["wasmMemory"],\n      "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally"\n    );\n    assert(\n      !Module["INITIAL_MEMORY"],\n      "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically"\n    );\n    function writeStackCookie() {\n      var max = _emscripten_stack_get_end();\n      assert((max & 3) == 0);\n      if (max == 0) {\n        max += 4;\n      }\n      HEAPU32[max >> 2] = 34821223;\n      HEAPU32[max + 4 >> 2] = 2310721022;\n      HEAPU32[0 >> 2] = 1668509029;\n    }\n    function checkStackCookie() {\n      if (ABORT) return;\n      var max = _emscripten_stack_get_end();\n      if (max == 0) {\n        max += 4;\n      }\n      var cookie1 = HEAPU32[max >> 2];\n      var cookie2 = HEAPU32[max + 4 >> 2];\n      if (cookie1 != 34821223 || cookie2 != 2310721022) {\n        abort(\n          `Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`\n        );\n      }\n      if (HEAPU32[0 >> 2] != 1668509029) {\n        abort("Runtime error: The application has corrupted its heap memory area (address zero)!");\n      }\n    }\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    function preRun() {\n      var preRuns = Module["preRun"];\n      if (preRuns) {\n        if (typeof preRuns == "function") preRuns = [preRuns];\n        preRuns.forEach(addOnPreRun);\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function initRuntime() {\n      assert(!runtimeInitialized);\n      runtimeInitialized = true;\n      checkStackCookie();\n      if (!Module["noFSInit"] && !FS.initialized) FS.init();\n      FS.ignorePermissions = false;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function postRun() {\n      checkStackCookie();\n      var postRuns = Module["postRun"];\n      if (postRuns) {\n        if (typeof postRuns == "function") postRuns = [postRuns];\n        postRuns.forEach(addOnPostRun);\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n    assert(\n      Math.imul,\n      "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"\n    );\n    assert(\n      Math.fround,\n      "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"\n    );\n    assert(\n      Math.clz32,\n      "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"\n    );\n    assert(\n      Math.trunc,\n      "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"\n    );\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n    var runDependencyTracking = {};\n    function getUniqueRunDependency(id) {\n      var orig = id;\n      while (1) {\n        if (!runDependencyTracking[id]) return id;\n        id = orig + Math.random();\n      }\n    }\n    function addRunDependency(id) {\n      var _a;\n      runDependencies++;\n      (_a = Module["monitorRunDependencies"]) == null ? void 0 : _a.call(Module, runDependencies);\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n        if (runDependencyWatcher === null && typeof setInterval != "undefined") {\n          runDependencyWatcher = setInterval(() => {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n            var shown = false;\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err("still waiting on run dependencies:");\n              }\n              err(`dependency: ${dep}`);\n            }\n            if (shown) {\n              err("(end of list)");\n            }\n          }, 1e4);\n        }\n      } else {\n        err("warning: run dependency added without ID");\n      }\n    }\n    function removeRunDependency(id) {\n      var _a;\n      runDependencies--;\n      (_a = Module["monitorRunDependencies"]) == null ? void 0 : _a.call(Module, runDependencies);\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err("warning: run dependency removed without ID");\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n    function abort(what) {\n      var _a;\n      (_a = Module["onAbort"]) == null ? void 0 : _a.call(Module, what);\n      what = "Aborted(" + what + ")";\n      err(what);\n      ABORT = true;\n      var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      throw e;\n    }\n    var dataURIPrefix = "data:application/octet-stream;base64,";\n    var isDataURI = (filename) => filename.startsWith(dataURIPrefix);\n    var isFileURI = (filename) => filename.startsWith("file://");\n    function createExportWrapper(name, nargs) {\n      return (...args) => {\n        assert(\n          runtimeInitialized,\n          `native function \\`${name}\\` called before runtime initialization`\n        );\n        var f = wasmExports[name];\n        assert(f, `exported native function \\`${name}\\` not found`);\n        assert(\n          args.length <= nargs,\n          `native function \\`${name}\\` called with ${args.length} args but expects ${nargs}`\n        );\n        return f(...args);\n      };\n    }\n    function findWasmBinary() {\n      if (Module["locateFile"]) {\n        var f = "pdfium.wasm";\n        if (!isDataURI(f)) {\n          return locateFile(f);\n        }\n        return f;\n      }\n      if (ENVIRONMENT_IS_SHELL) return "pdfium.wasm";\n      return "pdfium.wasm";\n    }\n    var wasmBinaryFile;\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw "both async and sync fetching of the wasm failed";\n    }\n    function getBinaryPromise(binaryFile) {\n      if (!wasmBinary) {\n        return readAsync(binaryFile).then(\n          (response) => new Uint8Array(\n            /** @type{!ArrayBuffer} */\n            response\n          ),\n          // Fall back to getBinarySync if readAsync fails\n          () => getBinarySync(binaryFile)\n        );\n      }\n      return Promise.resolve().then(() => getBinarySync(binaryFile));\n    }\n    function instantiateArrayBuffer(binaryFile, imports, receiver) {\n      return getBinaryPromise(binaryFile).then((binary) => {\n        return WebAssembly.instantiate(binary, imports);\n      }).then(receiver, (reason) => {\n        err(`failed to asynchronously prepare wasm: ${reason}`);\n        if (isFileURI(wasmBinaryFile)) {\n          err(\n            `warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`\n          );\n        }\n        abort(reason);\n      });\n    }\n    function instantiateAsync(binary, binaryFile, imports, callback) {\n      if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && // Avoid instantiateStreaming() on Node.js environment for now, as while\n      // Node.js v18.1.0 implements it, it does not have a full fetch()\n      // implementation yet.\n      //\n      // Reference:\n      //   https://github.com/emscripten-core/emscripten/pull/16917\n      true && typeof fetch == "function") {\n        return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {\n          var result = WebAssembly.instantiateStreaming(response, imports);\n          return result.then(callback, function(reason) {\n            err(`wasm streaming compile failed: ${reason}`);\n            err("falling back to ArrayBuffer instantiation");\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n          });\n        });\n      }\n      return instantiateArrayBuffer(binaryFile, imports, callback);\n    }\n    function getWasmImports() {\n      return {\n        env: wasmImports,\n        wasi_snapshot_preview1: wasmImports\n      };\n    }\n    function createWasm() {\n      var info = getWasmImports();\n      function receiveInstance(instance, module) {\n        wasmExports = instance.exports;\n        Module["wasmExports"] = wasmExports;\n        wasmMemory = wasmExports["memory"];\n        assert(wasmMemory, "memory not found in wasm exports");\n        updateMemoryViews();\n        wasmTable = wasmExports["__indirect_function_table"];\n        assert(wasmTable, "table not found in wasm exports");\n        addOnInit(wasmExports["__wasm_call_ctors"]);\n        removeRunDependency("wasm-instantiate");\n        return wasmExports;\n      }\n      addRunDependency("wasm-instantiate");\n      var trueModule = Module;\n      function receiveInstantiationResult(result) {\n        assert(\n          Module === trueModule,\n          "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?"\n        );\n        trueModule = null;\n        receiveInstance(result["instance"]);\n      }\n      if (Module["instantiateWasm"]) {\n        try {\n          return Module["instantiateWasm"](info, receiveInstance);\n        } catch (e) {\n          err(`Module.instantiateWasm callback failed with error: ${e}`);\n          readyPromiseReject(e);\n        }\n      }\n      wasmBinaryFile ?? (wasmBinaryFile = findWasmBinary());\n      instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(\n        readyPromiseReject\n      );\n      return {};\n    }\n    var tempDouble;\n    var tempI64;\n    (() => {\n      var h16 = new Int16Array(1);\n      var h8 = new Int8Array(h16.buffer);\n      h16[0] = 25459;\n      if (h8[0] !== 115 || h8[1] !== 99)\n        throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";\n    })();\n    if (Module["ENVIRONMENT"]) {\n      throw new Error(\n        "Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)"\n      );\n    }\n    function legacyModuleProp(prop, newName, incoming = true) {\n      if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n        Object.defineProperty(Module, prop, {\n          configurable: true,\n          get() {\n            let extra = incoming ? " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)" : "";\n            abort(`\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra);\n          }\n        });\n      }\n    }\n    function ignoredModuleProp(prop) {\n      if (Object.getOwnPropertyDescriptor(Module, prop)) {\n        abort(\n          `\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`\n        );\n      }\n    }\n    function isExportedByForceFilesystem(name) {\n      return name === "FS_createPath" || name === "FS_createDataFile" || name === "FS_createPreloadedFile" || name === "FS_unlink" || name === "addRunDependency" || // The old FS has some functionality that WasmFS lacks.\n      name === "FS_createLazyFile" || name === "FS_createDevice" || name === "removeRunDependency";\n    }\n    function hookGlobalSymbolAccess(sym, func) {\n      if (typeof globalThis != "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\n        Object.defineProperty(globalThis, sym, {\n          configurable: true,\n          get() {\n            func();\n            return void 0;\n          }\n        });\n      }\n    }\n    function missingGlobal(sym, msg) {\n      hookGlobalSymbolAccess(sym, () => {\n        warnOnce(`\\`${sym}\\` is not longer defined by emscripten. ${msg}`);\n      });\n    }\n    missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");\n    missingGlobal("asm", "Please use wasmExports instead");\n    function missingLibrarySymbol(sym) {\n      hookGlobalSymbolAccess(sym, () => {\n        var msg = `\\`${sym}\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\n        var librarySymbol = sym;\n        if (!librarySymbol.startsWith("_")) {\n          librarySymbol = "$" + sym;\n        }\n        msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=\'${librarySymbol}\')`;\n        if (isExportedByForceFilesystem(sym)) {\n          msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";\n        }\n        warnOnce(msg);\n      });\n      unexportedRuntimeSymbol(sym);\n    }\n    function unexportedRuntimeSymbol(sym) {\n      if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n        Object.defineProperty(Module, sym, {\n          configurable: true,\n          get() {\n            var msg = `\'${sym}\' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\n            if (isExportedByForceFilesystem(sym)) {\n              msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";\n            }\n            abort(msg);\n          }\n        });\n      }\n    }\n    var callRuntimeCallbacks = (callbacks) => {\n      callbacks.forEach((f) => f(Module));\n    };\n    function getValue(ptr, type = "i8") {\n      if (type.endsWith("*")) type = "*";\n      switch (type) {\n        case "i1":\n          return HEAP8[ptr];\n        case "i8":\n          return HEAP8[ptr];\n        case "i16":\n          return HEAP16[ptr >> 1];\n        case "i32":\n          return HEAP32[ptr >> 2];\n        case "i64":\n          abort("to do getValue(i64) use WASM_BIGINT");\n        case "float":\n          return HEAPF32[ptr >> 2];\n        case "double":\n          return HEAPF64[ptr >> 3];\n        case "*":\n          return HEAPU32[ptr >> 2];\n        default:\n          abort(`invalid type for getValue: ${type}`);\n      }\n    }\n    Module["noExitRuntime"] || true;\n    var ptrToString = (ptr) => {\n      assert(typeof ptr === "number");\n      ptr >>>= 0;\n      return "0x" + ptr.toString(16).padStart(8, "0");\n    };\n    function setValue(ptr, value, type = "i8") {\n      if (type.endsWith("*")) type = "*";\n      switch (type) {\n        case "i1":\n          HEAP8[ptr] = value;\n          break;\n        case "i8":\n          HEAP8[ptr] = value;\n          break;\n        case "i16":\n          HEAP16[ptr >> 1] = value;\n          break;\n        case "i32":\n          HEAP32[ptr >> 2] = value;\n          break;\n        case "i64":\n          abort("to do setValue(i64) use WASM_BIGINT");\n        case "float":\n          HEAPF32[ptr >> 2] = value;\n          break;\n        case "double":\n          HEAPF64[ptr >> 3] = value;\n          break;\n        case "*":\n          HEAPU32[ptr >> 2] = value;\n          break;\n        default:\n          abort(`invalid type for setValue: ${type}`);\n      }\n    }\n    var stackRestore = (val) => __emscripten_stack_restore(val);\n    var stackSave = () => _emscripten_stack_get_current();\n    var warnOnce = (text) => {\n      warnOnce.shown || (warnOnce.shown = {});\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    };\n    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;\n    var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = "";\n      while (idx < endPtr) {\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 128)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 224) == 192) {\n          str += String.fromCharCode((u0 & 31) << 6 | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 240) == 224) {\n          u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n        } else {\n          if ((u0 & 248) != 240)\n            warnOnce(\n              "Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!"\n            );\n          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n        }\n        if (u0 < 65536) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 65536;\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n        }\n      }\n      return str;\n    };\n    var UTF8ToString = (ptr, maxBytesToRead) => {\n      assert(typeof ptr == "number", `UTF8ToString expects a number (got ${typeof ptr})`);\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";\n    };\n    var ___assert_fail = (condition, filename, line, func) => {\n      abort(\n        `Assertion failed: ${UTF8ToString(condition)}, at: ` + [\n          filename ? UTF8ToString(filename) : "unknown filename",\n          line,\n          func ? UTF8ToString(func) : "unknown function"\n        ]\n      );\n    };\n    function syscallGetVarargI() {\n      assert(SYSCALLS.varargs != void 0);\n      var ret = HEAP32[+SYSCALLS.varargs >> 2];\n      SYSCALLS.varargs += 4;\n      return ret;\n    }\n    var syscallGetVarargP = syscallGetVarargI;\n    var PATH = {\n      isAbs: (path) => path.charAt(0) === "/",\n      splitPath: (filename) => {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: (parts, allowAboveRoot) => {\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === ".") {\n            parts.splice(i, 1);\n          } else if (last === "..") {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift("..");\n          }\n        }\n        return parts;\n      },\n      normalize: (path) => {\n        var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";\n        path = PATH.normalizeArray(\n          path.split("/").filter((p) => !!p),\n          !isAbsolute\n        ).join("/");\n        if (!path && !isAbsolute) {\n          path = ".";\n        }\n        if (path && trailingSlash) {\n          path += "/";\n        }\n        return (isAbsolute ? "/" : "") + path;\n      },\n      dirname: (path) => {\n        var result = PATH.splitPath(path), root = result[0], dir = result[1];\n        if (!root && !dir) {\n          return ".";\n        }\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },\n      basename: (path) => {\n        if (path === "/") return "/";\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, "");\n        var lastSlash = path.lastIndexOf("/");\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      join: (...paths) => PATH.normalize(paths.join("/")),\n      join2: (l, r) => PATH.normalize(l + "/" + r)\n    };\n    var initRandomFill = () => {\n      if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {\n        return (view) => crypto.getRandomValues(view);\n      }\n      abort(\n        "no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };"\n      );\n    };\n    var randomFill = (view) => {\n      return (randomFill = initRandomFill())(view);\n    };\n    var PATH_FS = {\n      resolve: (...args) => {\n        var resolvedPath = "", resolvedAbsolute = false;\n        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? args[i] : FS.cwd();\n          if (typeof path != "string") {\n            throw new TypeError("Arguments to path.resolve must be strings");\n          } else if (!path) {\n            return "";\n          }\n          resolvedPath = path + "/" + resolvedPath;\n          resolvedAbsolute = PATH.isAbs(path);\n        }\n        resolvedPath = PATH.normalizeArray(\n          resolvedPath.split("/").filter((p) => !!p),\n          !resolvedAbsolute\n        ).join("/");\n        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";\n      },\n      relative: (from, to) => {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== "") break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== "") break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split("/"));\n        var toParts = trim(to.split("/"));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push("..");\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join("/");\n      }\n    };\n    var FS_stdin_getChar_buffer = [];\n    var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var c = str.charCodeAt(i);\n        if (c <= 127) {\n          len++;\n        } else if (c <= 2047) {\n          len += 2;\n        } else if (c >= 55296 && c <= 57343) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      assert(typeof str === "string", `stringToUTF8Array expects a string (got ${typeof str})`);\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n        }\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 192 | u >> 6;\n          heap[outIdx++] = 128 | u & 63;\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 224 | u >> 12;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u > 1114111)\n            warnOnce(\n              "Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF)."\n            );\n          heap[outIdx++] = 240 | u >> 18;\n          heap[outIdx++] = 128 | u >> 12 & 63;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        }\n      }\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      u8array.length = numBytesWritten;\n      return u8array;\n    }\n    var FS_stdin_getChar = () => {\n      if (!FS_stdin_getChar_buffer.length) {\n        var result = null;\n        if (typeof window != "undefined" && typeof window.prompt == "function") {\n          result = window.prompt("Input: ");\n          if (result !== null) {\n            result += "\\n";\n          }\n        } else if (typeof readline == "function") {\n          result = readline();\n          if (result) {\n            result += "\\n";\n          }\n        } else ;\n        if (!result) {\n          return null;\n        }\n        FS_stdin_getChar_buffer = intArrayFromString(result);\n      }\n      return FS_stdin_getChar_buffer.shift();\n    };\n    var TTY = {\n      ttys: [],\n      init() {\n      },\n      shutdown() {\n      },\n      register(dev, ops) {\n        TTY.ttys[dev] = { input: [], output: [], ops };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        fsync(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        read(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === void 0 && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === void 0) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },\n        write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        }\n      },\n      default_tty_ops: {\n        get_char(tty) {\n          return FS_stdin_getChar();\n        },\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        },\n        ioctl_tcgets(tty) {\n          return {\n            c_iflag: 25856,\n            c_oflag: 5,\n            c_cflag: 191,\n            c_lflag: 35387,\n            c_cc: [\n              3,\n              28,\n              127,\n              21,\n              4,\n              0,\n              1,\n              0,\n              17,\n              19,\n              26,\n              0,\n              18,\n              15,\n              23,\n              22,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0\n            ]\n          };\n        },\n        ioctl_tcsets(tty, optional_actions, data) {\n          return 0;\n        },\n        ioctl_tiocgwinsz(tty) {\n          return [24, 80];\n        }\n      },\n      default_tty1_ops: {\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        }\n      }\n    };\n    var zeroMemory = (address, size) => {\n      HEAPU8.fill(0, address, address + size);\n    };\n    var alignMemory = (size, alignment) => {\n      assert(alignment, "alignment argument is required");\n      return Math.ceil(size / alignment) * alignment;\n    };\n    var mmapAlloc = (size) => {\n      size = alignMemory(size, 65536);\n      var ptr = _emscripten_builtin_memalign(65536, size);\n      if (ptr) zeroMemory(ptr, size);\n      return ptr;\n    };\n    var MEMFS = {\n      ops_table: null,\n      mount(mount) {\n        return MEMFS.createNode(null, "/", 16384 | 511, 0);\n      },\n      createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          throw new FS.ErrnoError(63);\n        }\n        MEMFS.ops_table || (MEMFS.ops_table = {\n          dir: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              lookup: MEMFS.node_ops.lookup,\n              mknod: MEMFS.node_ops.mknod,\n              rename: MEMFS.node_ops.rename,\n              unlink: MEMFS.node_ops.unlink,\n              rmdir: MEMFS.node_ops.rmdir,\n              readdir: MEMFS.node_ops.readdir,\n              symlink: MEMFS.node_ops.symlink\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek\n            }\n          },\n          file: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n              read: MEMFS.stream_ops.read,\n              write: MEMFS.stream_ops.write,\n              allocate: MEMFS.stream_ops.allocate,\n              mmap: MEMFS.stream_ops.mmap,\n              msync: MEMFS.stream_ops.msync\n            }\n          },\n          link: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              readlink: MEMFS.node_ops.readlink\n            },\n            stream: {}\n          },\n          chrdev: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: FS.chrdev_stream_ops\n          }\n        });\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0;\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n        return node;\n      },\n      getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return;\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(\n          newCapacity,\n          prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0\n        );\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity);\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n      },\n      resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null;\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize);\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n          }\n          node.usedBytes = newSize;\n        }\n      },\n      node_ops: {\n        getattr(node) {\n          var attr = {};\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr(node, attr) {\n          if (attr.mode !== void 0) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== void 0) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== void 0) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup(parent, name) {\n          throw FS.genericErrors[44];\n        },\n        mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename(old_node, new_dir, new_name) {\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {\n            }\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now();\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n        },\n        unlink(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        readdir(node) {\n          var entries = [".", ".."];\n          for (var key of Object.keys(node.contents)) {\n            entries.push(key);\n          }\n          return entries;\n        },\n        symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        }\n      },\n      stream_ops: {\n        read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          assert(size >= 0);\n          if (size > 8 && contents.subarray) {\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },\n        write(stream, buffer, offset, length, position, canOwn) {\n          assert(!(buffer instanceof ArrayBuffer));\n          if (buffer.buffer === HEAP8.buffer) {\n            canOwn = false;\n          }\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            if (canOwn) {\n              assert(position === 0, "canOwn must imply no weird position inside the file");\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer.subarray) {\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n          } else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i];\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n        allocate(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n        mmap(stream, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            if (contents) {\n              if (position > 0 || position + length < contents.length) {\n                if (contents.subarray) {\n                  contents = contents.subarray(position, position + length);\n                } else {\n                  contents = Array.prototype.slice.call(contents, position, position + length);\n                }\n              }\n              HEAP8.set(contents, ptr);\n            }\n          }\n          return { ptr, allocated };\n        },\n        msync(stream, buffer, offset, length, mmapFlags) {\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          return 0;\n        }\n      }\n    };\n    var asyncLoad = (url, onload, onerror, noRunDep) => {\n      var dep = getUniqueRunDependency(`al ${url}`);\n      readAsync(url).then(\n        (arrayBuffer) => {\n          assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);\n          onload(new Uint8Array(arrayBuffer));\n          if (dep) removeRunDependency(dep);\n        },\n        (err2) => {\n          if (onerror) {\n            onerror();\n          } else {\n            throw `Loading data file "${url}" failed.`;\n          }\n        }\n      );\n      if (dep) addRunDependency(dep);\n    };\n    var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {\n      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n    };\n    var preloadPlugins = Module["preloadPlugins"] || [];\n    var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\n      if (typeof Browser != "undefined") Browser.init();\n      var handled = false;\n      preloadPlugins.forEach((plugin) => {\n        if (handled) return;\n        if (plugin["canHandle"](fullname)) {\n          plugin["handle"](byteArray, fullname, finish, onerror);\n          handled = true;\n        }\n      });\n      return handled;\n    };\n    var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n      var dep = getUniqueRunDependency(`cp ${fullname}`);\n      function processData(byteArray) {\n        function finish(byteArray2) {\n          preFinish == null ? void 0 : preFinish();\n          if (!dontCreateFile) {\n            FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);\n          }\n          onload == null ? void 0 : onload();\n          removeRunDependency(dep);\n        }\n        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\n          onerror == null ? void 0 : onerror();\n          removeRunDependency(dep);\n        })) {\n          return;\n        }\n        finish(byteArray);\n      }\n      addRunDependency(dep);\n      if (typeof url == "string") {\n        asyncLoad(url, processData, onerror);\n      } else {\n        processData(url);\n      }\n    };\n    var FS_modeStringToFlags = (str) => {\n      var flagModes = {\n        r: 0,\n        "r+": 2,\n        w: 512 | 64 | 1,\n        "w+": 512 | 64 | 2,\n        a: 1024 | 64 | 1,\n        "a+": 1024 | 64 | 2\n      };\n      var flags = flagModes[str];\n      if (typeof flags == "undefined") {\n        throw new Error(`Unknown file open mode: ${str}`);\n      }\n      return flags;\n    };\n    var FS_getMode = (canRead, canWrite) => {\n      var mode = 0;\n      if (canRead) mode |= 292 | 73;\n      if (canWrite) mode |= 146;\n      return mode;\n    };\n    var strError = (errno) => {\n      return UTF8ToString(_strerror(errno));\n    };\n    var ERRNO_CODES = {\n      EPERM: 63,\n      ENOENT: 44,\n      ESRCH: 71,\n      EINTR: 27,\n      EIO: 29,\n      ENXIO: 60,\n      E2BIG: 1,\n      ENOEXEC: 45,\n      EBADF: 8,\n      ECHILD: 12,\n      EAGAIN: 6,\n      EWOULDBLOCK: 6,\n      ENOMEM: 48,\n      EACCES: 2,\n      EFAULT: 21,\n      ENOTBLK: 105,\n      EBUSY: 10,\n      EEXIST: 20,\n      EXDEV: 75,\n      ENODEV: 43,\n      ENOTDIR: 54,\n      EISDIR: 31,\n      EINVAL: 28,\n      ENFILE: 41,\n      EMFILE: 33,\n      ENOTTY: 59,\n      ETXTBSY: 74,\n      EFBIG: 22,\n      ENOSPC: 51,\n      ESPIPE: 70,\n      EROFS: 69,\n      EMLINK: 34,\n      EPIPE: 64,\n      EDOM: 18,\n      ERANGE: 68,\n      ENOMSG: 49,\n      EIDRM: 24,\n      ECHRNG: 106,\n      EL2NSYNC: 156,\n      EL3HLT: 107,\n      EL3RST: 108,\n      ELNRNG: 109,\n      EUNATCH: 110,\n      ENOCSI: 111,\n      EL2HLT: 112,\n      EDEADLK: 16,\n      ENOLCK: 46,\n      EBADE: 113,\n      EBADR: 114,\n      EXFULL: 115,\n      ENOANO: 104,\n      EBADRQC: 103,\n      EBADSLT: 102,\n      EDEADLOCK: 16,\n      EBFONT: 101,\n      ENOSTR: 100,\n      ENODATA: 116,\n      ETIME: 117,\n      ENOSR: 118,\n      ENONET: 119,\n      ENOPKG: 120,\n      EREMOTE: 121,\n      ENOLINK: 47,\n      EADV: 122,\n      ESRMNT: 123,\n      ECOMM: 124,\n      EPROTO: 65,\n      EMULTIHOP: 36,\n      EDOTDOT: 125,\n      EBADMSG: 9,\n      ENOTUNIQ: 126,\n      EBADFD: 127,\n      EREMCHG: 128,\n      ELIBACC: 129,\n      ELIBBAD: 130,\n      ELIBSCN: 131,\n      ELIBMAX: 132,\n      ELIBEXEC: 133,\n      ENOSYS: 52,\n      ENOTEMPTY: 55,\n      ENAMETOOLONG: 37,\n      ELOOP: 32,\n      EOPNOTSUPP: 138,\n      EPFNOSUPPORT: 139,\n      ECONNRESET: 15,\n      ENOBUFS: 42,\n      EAFNOSUPPORT: 5,\n      EPROTOTYPE: 67,\n      ENOTSOCK: 57,\n      ENOPROTOOPT: 50,\n      ESHUTDOWN: 140,\n      ECONNREFUSED: 14,\n      EADDRINUSE: 3,\n      ECONNABORTED: 13,\n      ENETUNREACH: 40,\n      ENETDOWN: 38,\n      ETIMEDOUT: 73,\n      EHOSTDOWN: 142,\n      EHOSTUNREACH: 23,\n      EINPROGRESS: 26,\n      EALREADY: 7,\n      EDESTADDRREQ: 17,\n      EMSGSIZE: 35,\n      EPROTONOSUPPORT: 66,\n      ESOCKTNOSUPPORT: 137,\n      EADDRNOTAVAIL: 4,\n      ENETRESET: 39,\n      EISCONN: 30,\n      ENOTCONN: 53,\n      ETOOMANYREFS: 141,\n      EUSERS: 136,\n      EDQUOT: 19,\n      ESTALE: 72,\n      ENOTSUP: 138,\n      ENOMEDIUM: 148,\n      EILSEQ: 25,\n      EOVERFLOW: 61,\n      ECANCELED: 11,\n      ENOTRECOVERABLE: 56,\n      EOWNERDEAD: 62,\n      ESTRPIPE: 135\n    };\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: "/",\n      initialized: false,\n      ignorePermissions: true,\n      ErrnoError: class extends Error {\n        // We set the `name` property to be able to identify `FS.ErrnoError`\n        // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\n        // - when using PROXYFS, an error can come from an underlying FS\n        // as different FS objects have their own FS.ErrnoError each,\n        // the test `err instanceof FS.ErrnoError` won\'t detect an error coming from another filesystem, causing bugs.\n        // we\'ll use the reliable test `err.name == "ErrnoError"` instead\n        constructor(errno) {\n          super(runtimeInitialized ? strError(errno) : "");\n          this.name = "ErrnoError";\n          this.errno = errno;\n          for (var key in ERRNO_CODES) {\n            if (ERRNO_CODES[key] === errno) {\n              this.code = key;\n              break;\n            }\n          }\n        }\n      },\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      readFiles: {},\n      FSStream: class {\n        constructor() {\n          this.shared = {};\n        }\n        get object() {\n          return this.node;\n        }\n        set object(val) {\n          this.node = val;\n        }\n        get isRead() {\n          return (this.flags & 2097155) !== 1;\n        }\n        get isWrite() {\n          return (this.flags & 2097155) !== 0;\n        }\n        get isAppend() {\n          return this.flags & 1024;\n        }\n        get flags() {\n          return this.shared.flags;\n        }\n        set flags(val) {\n          this.shared.flags = val;\n        }\n        get position() {\n          return this.shared.position;\n        }\n        set position(val) {\n          this.shared.position = val;\n        }\n      },\n      FSNode: class {\n        constructor(parent, name, mode, rdev) {\n          if (!parent) {\n            parent = this;\n          }\n          this.parent = parent;\n          this.mount = parent.mount;\n          this.mounted = null;\n          this.id = FS.nextInode++;\n          this.name = name;\n          this.mode = mode;\n          this.node_ops = {};\n          this.stream_ops = {};\n          this.rdev = rdev;\n          this.readMode = 292 | 73;\n          this.writeMode = 146;\n        }\n        get read() {\n          return (this.mode & this.readMode) === this.readMode;\n        }\n        set read(val) {\n          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;\n        }\n        get write() {\n          return (this.mode & this.writeMode) === this.writeMode;\n        }\n        set write(val) {\n          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;\n        }\n        get isFolder() {\n          return FS.isDir(this.mode);\n        }\n        get isDevice() {\n          return FS.isChrdev(this.mode);\n        }\n      },\n      lookupPath(path, opts = {}) {\n        path = PATH_FS.resolve(path);\n        if (!path) return { path: "", node: null };\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n        opts = Object.assign(defaults, opts);\n        if (opts.recurse_count > 8) {\n          throw new FS.ErrnoError(32);\n        }\n        var parts = path.split("/").filter((p) => !!p);\n        var current = FS.root;\n        var current_path = "/";\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n          if (islast && opts.parent) {\n            break;\n          }\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n          if (FS.isMountpoint(current)) {\n            if (!islast || islast && opts.follow_mount) {\n              current = current.mounted.root;\n            }\n          }\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });\n              current = lookup.node;\n              if (count++ > 40) {\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n        return { path: current_path, node: current };\n      },\n      getPath(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;\n          }\n          path = path ? `${node.name}/${path}` : node.name;\n          node = node.parent;\n        }\n      },\n      hashName(parentid, name) {\n        var hash = 0;\n        for (var i = 0; i < name.length; i++) {\n          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n        }\n        return (parentid + hash >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        return FS.lookup(parent, name);\n      },\n      createNode(parent, name, mode, rdev) {\n        assert(typeof parent == "object");\n        var node = new FS.FSNode(parent, name, mode, rdev);\n        FS.hashAddNode(node);\n        return node;\n      },\n      destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot(node) {\n        return node === node.parent;\n      },\n      isMountpoint(node) {\n        return !!node.mounted;\n      },\n      isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagsToPermissionString(flag) {\n        var perms = ["r", "w", "rw"][flag & 3];\n        if (flag & 512) {\n          perms += "w";\n        }\n        return perms;\n      },\n      nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        if (perms.includes("r") && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes("w") && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes("x") && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n      mayLookup(dir) {\n        if (!FS.isDir(dir.mode)) return 54;\n        var errCode = FS.nodePermissions(dir, "x");\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n      mayCreate(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {\n        }\n        return FS.nodePermissions(dir, "wx");\n      },\n      mayDelete(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, "wx");\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n      mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== "r" || // opening for write\n          flags & 512) {\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd() {\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n      getStreamChecked(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        return stream;\n      },\n      getStream: (fd) => FS.streams[fd],\n      createStream(stream, fd = -1) {\n        assert(fd >= -1);\n        stream = Object.assign(new FS.FSStream(), stream);\n        if (fd == -1) {\n          fd = FS.nextfd();\n        }\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n      dupStream(origStream, fd = -1) {\n        var _a, _b;\n        var stream = FS.createStream(origStream, fd);\n        (_b = (_a = stream.stream_ops) == null ? void 0 : _a.dup) == null ? void 0 : _b.call(_a, stream);\n        return stream;\n      },\n      chrdev_stream_ops: {\n        open(stream) {\n          var _a, _b;\n          var device = FS.getDevice(stream.node.rdev);\n          stream.stream_ops = device.stream_ops;\n          (_b = (_a = stream.stream_ops).open) == null ? void 0 : _b.call(_a, stream);\n        },\n        llseek() {\n          throw new FS.ErrnoError(70);\n        }\n      },\n      major: (dev) => dev >> 8,\n      minor: (dev) => dev & 255,\n      makedev: (ma, mi) => ma << 8 | mi,\n      registerDevice(dev, ops) {\n        FS.devices[dev] = { stream_ops: ops };\n      },\n      getDevice: (dev) => FS.devices[dev],\n      getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n        while (check.length) {\n          var m = check.pop();\n          mounts.push(m);\n          check.push(...m.mounts);\n        }\n        return mounts;\n      },\n      syncfs(populate, callback) {\n        if (typeof populate == "function") {\n          callback = populate;\n          populate = false;\n        }\n        FS.syncFSRequests++;\n        if (FS.syncFSRequests > 1) {\n          err(\n            `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`\n          );\n        }\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n        function doCallback(errCode) {\n          assert(FS.syncFSRequests > 0);\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n        mounts.forEach((mount) => {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount(type, opts, mountpoint) {\n        if (typeof type == "string") {\n          throw type;\n        }\n        var root = mountpoint === "/";\n        var pseudo = !mountpoint;\n        var node;\n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n          mountpoint = lookup.path;\n          node = lookup.node;\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n        var mount = {\n          type,\n          opts,\n          mountpoint,\n          mounts: []\n        };\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          node.mounted = mount;\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n        return mountRoot;\n      },\n      unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n        Object.keys(FS.nameTable).forEach((hash) => {\n          var current = FS.nameTable[hash];\n          while (current) {\n            var next = current.name_next;\n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n            current = next;\n          }\n        });\n        node.mounted = null;\n        var idx = node.mount.mounts.indexOf(mount);\n        assert(idx !== -1);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === "." || name === "..") {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create(path, mode) {\n        mode = mode !== void 0 ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir(path, mode) {\n        mode = mode !== void 0 ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree(path, mode) {\n        var dirs = path.split("/");\n        var d = "";\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += "/" + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n      mkdev(path, mode, dev) {\n        if (typeof dev == "undefined") {\n          dev = mode;\n          mode = 438;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        var lookup, old_dir, new_dir;\n        lookup = FS.lookupPath(old_path, { parent: true });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, { parent: true });\n        new_dir = lookup.node;\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n        var old_node = FS.lookupNode(old_dir, old_name);\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== ".") {\n          throw new FS.ErrnoError(28);\n        }\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== ".") {\n          throw new FS.ErrnoError(55);\n        }\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n        }\n        if (old_node === new_node) {\n          return;\n        }\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n          throw new FS.ErrnoError(10);\n        }\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, "w");\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        FS.hashRemoveNode(old_node);\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n          old_node.parent = new_dir;\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.hashAddNode(old_node);\n        }\n      },\n      rmdir(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },\n      readdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },\n      unlink(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },\n      readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n      stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },\n      lstat(path) {\n        return FS.stat(path, true);\n      },\n      chmod(path, mode, dontFollow) {\n        var node;\n        if (typeof path == "string") {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: mode & 4095 | node.mode & -4096,\n          timestamp: Date.now()\n        });\n      },\n      lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod(fd, mode) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chmod(stream.node, mode);\n      },\n      chown(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path == "string") {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n          // we ignore the uid / gid for now\n        });\n      },\n      lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown(fd, uid, gid) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path == "string") {\n          var lookup = FS.lookupPath(path, { follow: true });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, "w");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },\n      ftruncate(fd, len) {\n        var stream = FS.getStreamChecked(fd);\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },\n      utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },\n      open(path, flags, mode) {\n        if (path === "") {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;\n        if (flags & 64) {\n          mode = typeof mode == "undefined" ? 438 : mode;\n          mode = mode & 4095 | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path == "object") {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {\n          }\n        }\n        var created = false;\n        if (flags & 64) {\n          if (node) {\n            if (flags & 128) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (FS.isChrdev(node.mode)) {\n          flags &= -513;\n        }\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        if (flags & 512 && !created) {\n          FS.truncate(node, 0);\n        }\n        flags &= -131713;\n        var stream = FS.createStream({\n          node,\n          path: FS.getPath(node),\n          // we want the absolute path to the node\n          flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n          ungotten: [],\n          error: false\n        });\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module["logReadFiles"] && !(flags & 1)) {\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },\n      close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null;\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n      isClosed(stream) {\n        return stream.fd === null;\n      },\n      llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read(stream, buffer, offset, length, position) {\n        assert(offset >= 0);\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position != "undefined";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write(stream, buffer, offset, length, position, canOwn) {\n        assert(offset >= 0);\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position != "undefined";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(\n          stream,\n          buffer,\n          offset,\n          length,\n          position,\n          canOwn\n        );\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },\n      allocate(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap(stream, length, position, prot, flags) {\n        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!length) {\n          throw new FS.ErrnoError(28);\n        }\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\n      },\n      msync(stream, buffer, offset, length, mmapFlags) {\n        assert(offset >= 0);\n        if (!stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n      ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile(path, opts = {}) {\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || "binary";\n        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {\n          throw new Error(`Invalid encoding type "${opts.encoding}"`);\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === "utf8") {\n          ret = UTF8ArrayToString(buf);\n        } else if (opts.encoding === "binary") {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },\n      writeFile(path, data, opts = {}) {\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data == "string") {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);\n        } else {\n          throw new Error("Unsupported data type");\n        }\n        FS.close(stream);\n      },\n      cwd: () => FS.currentPath,\n      chdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, "x");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories() {\n        FS.mkdir("/tmp");\n        FS.mkdir("/home");\n        FS.mkdir("/home/web_user");\n      },\n      createDefaultDevices() {\n        FS.mkdir("/dev");\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: () => 0,\n          write: (stream, buffer, offset, length, pos) => length\n        });\n        FS.mkdev("/dev/null", FS.makedev(1, 3));\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev("/dev/tty", FS.makedev(5, 0));\n        FS.mkdev("/dev/tty1", FS.makedev(6, 0));\n        var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n        var randomByte = () => {\n          if (randomLeft === 0) {\n            randomLeft = randomFill(randomBuffer).byteLength;\n          }\n          return randomBuffer[--randomLeft];\n        };\n        FS.createDevice("/dev", "random", randomByte);\n        FS.createDevice("/dev", "urandom", randomByte);\n        FS.mkdir("/dev/shm");\n        FS.mkdir("/dev/shm/tmp");\n      },\n      createSpecialDirectories() {\n        FS.mkdir("/proc");\n        var proc_self = FS.mkdir("/proc/self");\n        FS.mkdir("/proc/self/fd");\n        FS.mount(\n          {\n            mount() {\n              var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);\n              node.node_ops = {\n                lookup(parent, name) {\n                  var fd = +name;\n                  var stream = FS.getStreamChecked(fd);\n                  var ret = {\n                    parent: null,\n                    mount: { mountpoint: "fake" },\n                    node_ops: { readlink: () => stream.path }\n                  };\n                  ret.parent = ret;\n                  return ret;\n                }\n              };\n              return node;\n            }\n          },\n          {},\n          "/proc/self/fd"\n        );\n      },\n      createStandardStreams(input, output, error) {\n        if (input) {\n          FS.createDevice("/dev", "stdin", input);\n        } else {\n          FS.symlink("/dev/tty", "/dev/stdin");\n        }\n        if (output) {\n          FS.createDevice("/dev", "stdout", null, output);\n        } else {\n          FS.symlink("/dev/tty", "/dev/stdout");\n        }\n        if (error) {\n          FS.createDevice("/dev", "stderr", null, error);\n        } else {\n          FS.symlink("/dev/tty1", "/dev/stderr");\n        }\n        var stdin = FS.open("/dev/stdin", 0);\n        var stdout = FS.open("/dev/stdout", 1);\n        var stderr = FS.open("/dev/stderr", 1);\n        assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\n        assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\n        assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\n      },\n      staticInit() {\n        [44].forEach((code) => {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = "<generic error, no stack>";\n        });\n        FS.nameTable = new Array(4096);\n        FS.mount(MEMFS, {}, "/");\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n        FS.filesystems = {\n          MEMFS\n        };\n      },\n      init(input, output, error) {\n        assert(\n          !FS.initialized,\n          "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)"\n        );\n        FS.initialized = true;\n        input ?? (input = Module["stdin"]);\n        output ?? (output = Module["stdout"]);\n        error ?? (error = Module["stderr"]);\n        FS.createStandardStreams(input, output, error);\n      },\n      quit() {\n        FS.initialized = false;\n        _fflush(0);\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },\n      findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (!ret.exists) {\n          return null;\n        }\n        return ret.object;\n      },\n      analyzePath(path, dontResolveLastLink) {\n        try {\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          path = lookup.path;\n        } catch (e) {\n        }\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, { parent: true });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === "/";\n        } catch (e) {\n          ret.error = e.errno;\n        }\n        return ret;\n      },\n      createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent == "string" ? parent : FS.getPath(parent);\n        var parts = path.split("/").reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {\n          }\n          parent = current;\n        }\n        return current;\n      },\n      createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name;\n        if (parent) {\n          parent = typeof parent == "string" ? parent : FS.getPath(parent);\n          path = name ? PATH.join2(parent, name) : parent;\n        }\n        var mode = FS_getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data == "string") {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n      },\n      createDevice(parent, name, input, output) {\n        var _a;\n        var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(!!input, !!output);\n        (_a = FS.createDevice).major ?? (_a.major = 64);\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        FS.registerDevice(dev, {\n          open(stream) {\n            stream.seekable = false;\n          },\n          close(stream) {\n            var _a2;\n            if ((_a2 = output == null ? void 0 : output.buffer) == null ? void 0 : _a2.length) {\n              output(10);\n            }\n          },\n          read(stream, buffer, offset, length, pos) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === void 0 && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === void 0) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        if (typeof XMLHttpRequest != "undefined") {\n          throw new Error(\n            "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."\n          );\n        } else {\n          try {\n            obj.contents = readBinary(obj.url);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        }\n      },\n      createLazyFile(parent, name, url, canRead, canWrite) {\n        class LazyUint8Array {\n          constructor() {\n            this.lengthKnown = false;\n            this.chunks = [];\n          }\n          get(idx) {\n            if (idx > this.length - 1 || idx < 0) {\n              return void 0;\n            }\n            var chunkOffset = idx % this.chunkSize;\n            var chunkNum = idx / this.chunkSize | 0;\n            return this.getter(chunkNum)[chunkOffset];\n          }\n          setDataGetter(getter) {\n            this.getter = getter;\n          }\n          cacheLength() {\n            var xhr = new XMLHttpRequest();\n            xhr.open("HEAD", url, false);\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))\n              throw new Error("Couldn\'t load " + url + ". Status: " + xhr.status);\n            var datalength = Number(xhr.getResponseHeader("Content-length"));\n            var header;\n            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";\n            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";\n            var chunkSize = 1024 * 1024;\n            if (!hasByteServing) chunkSize = datalength;\n            var doXHR = (from, to) => {\n              if (from > to)\n                throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");\n              if (to > datalength - 1)\n                throw new Error("only " + datalength + " bytes available! programmer error!");\n              var xhr2 = new XMLHttpRequest();\n              xhr2.open("GET", url, false);\n              if (datalength !== chunkSize)\n                xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);\n              xhr2.responseType = "arraybuffer";\n              if (xhr2.overrideMimeType) {\n                xhr2.overrideMimeType("text/plain; charset=x-user-defined");\n              }\n              xhr2.send(null);\n              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))\n                throw new Error("Couldn\'t load " + url + ". Status: " + xhr2.status);\n              if (xhr2.response !== void 0) {\n                return new Uint8Array(\n                  /** @type{Array<number>} */\n                  xhr2.response || []\n                );\n              }\n              return intArrayFromString(xhr2.responseText || "");\n            };\n            var lazyArray2 = this;\n            lazyArray2.setDataGetter((chunkNum) => {\n              var start = chunkNum * chunkSize;\n              var end = (chunkNum + 1) * chunkSize - 1;\n              end = Math.min(end, datalength - 1);\n              if (typeof lazyArray2.chunks[chunkNum] == "undefined") {\n                lazyArray2.chunks[chunkNum] = doXHR(start, end);\n              }\n              if (typeof lazyArray2.chunks[chunkNum] == "undefined")\n                throw new Error("doXHR failed!");\n              return lazyArray2.chunks[chunkNum];\n            });\n            if (usesGzip || !datalength) {\n              chunkSize = datalength = 1;\n              datalength = this.getter(0).length;\n              chunkSize = datalength;\n              out("LazyFiles on gzip forces download of the whole file when length is accessed");\n            }\n            this._length = datalength;\n            this._chunkSize = chunkSize;\n            this.lengthKnown = true;\n          }\n          get length() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._length;\n          }\n          get chunkSize() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._chunkSize;\n          }\n        }\n        if (typeof XMLHttpRequest != "undefined") {\n          if (!ENVIRONMENT_IS_WORKER)\n            throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";\n          var lazyArray = new LazyUint8Array();\n          var properties = { isDevice: false, contents: lazyArray };\n        } else {\n          var properties = { isDevice: false, url };\n        }\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function() {\n              return this.contents.length;\n            }\n          }\n        });\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach((key) => {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = (...args) => {\n            FS.forceLoadFile(node);\n            return fn(...args);\n          };\n        });\n        function writeChunks(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n          assert(size >= 0);\n          if (contents.slice) {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        }\n        stream_ops.read = (stream, buffer, offset, length, position) => {\n          FS.forceLoadFile(node);\n          return writeChunks(stream, buffer, offset, length, position);\n        };\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\n          FS.forceLoadFile(node);\n          var ptr = mmapAlloc(length);\n          if (!ptr) {\n            throw new FS.ErrnoError(48);\n          }\n          writeChunks(stream, HEAP8, ptr, length, position);\n          return { ptr, allocated: true };\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },\n      absolutePath() {\n        abort("FS.absolutePath has been removed; use PATH_FS.resolve instead");\n      },\n      createFolder() {\n        abort("FS.createFolder has been removed; use FS.mkdir instead");\n      },\n      createLink() {\n        abort("FS.createLink has been removed; use FS.symlink instead");\n      },\n      joinPath() {\n        abort("FS.joinPath has been removed; use PATH.join instead");\n      },\n      mmapAlloc() {\n        abort("FS.mmapAlloc has been replaced by the top level function mmapAlloc");\n      },\n      standardizePath() {\n        abort("FS.standardizePath has been removed; use PATH.normalize instead");\n      }\n    };\n    var SYSCALLS = {\n      DEFAULT_POLLMASK: 5,\n      calculateAt(dirfd, path, allowEmpty) {\n        if (PATH.isAbs(path)) {\n          return path;\n        }\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);\n          }\n          return dir;\n        }\n        return PATH.join2(dir, path);\n      },\n      doStat(func, path, buf) {\n        var stat = func(path);\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[buf + 4 >> 2] = stat.mode;\n        HEAPU32[buf + 8 >> 2] = stat.nlink;\n        HEAP32[buf + 12 >> 2] = stat.uid;\n        HEAP32[buf + 16 >> 2] = stat.gid;\n        HEAP32[buf + 20 >> 2] = stat.rdev;\n        tempI64 = [\n          stat.size >>> 0,\n          (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];\n        HEAP32[buf + 32 >> 2] = 4096;\n        HEAP32[buf + 36 >> 2] = stat.blocks;\n        var atime = stat.atime.getTime();\n        var mtime = stat.mtime.getTime();\n        var ctime = stat.ctime.getTime();\n        tempI64 = [\n          Math.floor(atime / 1e3) >>> 0,\n          (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n        HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;\n        tempI64 = [\n          Math.floor(mtime / 1e3) >>> 0,\n          (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];\n        HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;\n        tempI64 = [\n          Math.floor(ctime / 1e3) >>> 0,\n          (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];\n        HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;\n        tempI64 = [\n          stat.ino >>> 0,\n          (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];\n        return 0;\n      },\n      doMsync(addr, stream, len, flags, offset) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (flags & 2) {\n          return 0;\n        }\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n      getStreamFromFD(fd) {\n        var stream = FS.getStreamChecked(fd);\n        return stream;\n      },\n      varargs: void 0,\n      getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      }\n    };\n    function ___syscall_fcntl64(fd, cmd, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (cmd) {\n          case 0: {\n            var arg = syscallGetVarargI();\n            if (arg < 0) {\n              return -28;\n            }\n            while (FS.streams[arg]) {\n              arg++;\n            }\n            var newStream;\n            newStream = FS.dupStream(stream, arg);\n            return newStream.fd;\n          }\n          case 1:\n          case 2:\n            return 0;\n          // FD_CLOEXEC makes no sense for a single process.\n          case 3:\n            return stream.flags;\n          case 4: {\n            var arg = syscallGetVarargI();\n            stream.flags |= arg;\n            return 0;\n          }\n          case 12: {\n            var arg = syscallGetVarargP();\n            var offset = 0;\n            HEAP16[arg + offset >> 1] = 2;\n            return 0;\n          }\n          case 13:\n          case 14:\n            return 0;\n        }\n        return -28;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_fstat64(fd, buf) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        return SYSCALLS.doStat(FS.stat, stream.path, buf);\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    var convertI32PairToI53Checked = (lo, hi) => {\n      assert(lo == lo >>> 0 || lo == (lo | 0));\n      assert(hi === (hi | 0));\n      return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n    };\n    function ___syscall_ftruncate64(fd, length_low, length_high) {\n      var length = convertI32PairToI53Checked(length_low, length_high);\n      try {\n        if (isNaN(length)) return 61;\n        FS.ftruncate(fd, length);\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n      assert(\n        typeof maxBytesToWrite == "number",\n        "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"\n      );\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n    function ___syscall_getdents64(fd, dirp, count) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        stream.getdents || (stream.getdents = FS.readdir(stream.path));\n        var struct_size = 280;\n        var pos = 0;\n        var off = FS.llseek(stream, 0, 1);\n        var idx = Math.floor(off / struct_size);\n        while (idx < stream.getdents.length && pos + struct_size <= count) {\n          var id;\n          var type;\n          var name = stream.getdents[idx];\n          if (name === ".") {\n            id = stream.node.id;\n            type = 4;\n          } else if (name === "..") {\n            var lookup = FS.lookupPath(stream.path, { parent: true });\n            id = lookup.node.id;\n            type = 4;\n          } else {\n            var child = FS.lookupNode(stream.node, name);\n            id = child.id;\n            type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;\n          }\n          assert(id);\n          tempI64 = [\n            id >>> 0,\n            (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n          ], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];\n          tempI64 = [\n            (idx + 1) * struct_size >>> 0,\n            (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n          ], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];\n          HEAP16[dirp + pos + 16 >> 1] = 280;\n          HEAP8[dirp + pos + 18] = type;\n          stringToUTF8(name, dirp + pos + 19, 256);\n          pos += struct_size;\n          idx += 1;\n        }\n        FS.llseek(stream, idx * struct_size, 0);\n        return pos;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_ioctl(fd, op, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (op) {\n          case 21509: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21505: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tcgets) {\n              var termios = stream.tty.ops.ioctl_tcgets(stream);\n              var argp = syscallGetVarargP();\n              HEAP32[argp >> 2] = termios.c_iflag || 0;\n              HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;\n              HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;\n              HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;\n              for (var i = 0; i < 32; i++) {\n                HEAP8[argp + i + 17] = termios.c_cc[i] || 0;\n              }\n              return 0;\n            }\n            return 0;\n          }\n          case 21510:\n          case 21511:\n          case 21512: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21506:\n          case 21507:\n          case 21508: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tcsets) {\n              var argp = syscallGetVarargP();\n              var c_iflag = HEAP32[argp >> 2];\n              var c_oflag = HEAP32[argp + 4 >> 2];\n              var c_cflag = HEAP32[argp + 8 >> 2];\n              var c_lflag = HEAP32[argp + 12 >> 2];\n              var c_cc = [];\n              for (var i = 0; i < 32; i++) {\n                c_cc.push(HEAP8[argp + i + 17]);\n              }\n              return stream.tty.ops.ioctl_tcsets(stream.tty, op, {\n                c_iflag,\n                c_oflag,\n                c_cflag,\n                c_lflag,\n                c_cc\n              });\n            }\n            return 0;\n          }\n          case 21519: {\n            if (!stream.tty) return -59;\n            var argp = syscallGetVarargP();\n            HEAP32[argp >> 2] = 0;\n            return 0;\n          }\n          case 21520: {\n            if (!stream.tty) return -59;\n            return -28;\n          }\n          case 21531: {\n            var argp = syscallGetVarargP();\n            return FS.ioctl(stream, op, argp);\n          }\n          case 21523: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tiocgwinsz) {\n              var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);\n              var argp = syscallGetVarargP();\n              HEAP16[argp >> 1] = winsize[0];\n              HEAP16[argp + 2 >> 1] = winsize[1];\n            }\n            return 0;\n          }\n          case 21524: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21515: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          default:\n            return -28;\n        }\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_lstat64(path, buf) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doStat(FS.lstat, path, buf);\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_newfstatat(dirfd, path, buf, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        var nofollow = flags & 256;\n        var allowEmpty = flags & 4096;\n        flags = flags & ~6400;\n        assert(!flags, `unknown flags in __syscall_newfstatat: ${flags}`);\n        path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);\n        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_openat(dirfd, path, flags, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        var mode = varargs ? syscallGetVarargI() : 0;\n        return FS.open(path, flags, mode).fd;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_rmdir(path) {\n      try {\n        path = SYSCALLS.getStr(path);\n        FS.rmdir(path);\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_stat64(path, buf) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doStat(FS.stat, path, buf);\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_unlinkat(dirfd, path, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        if (flags === 0) {\n          FS.unlink(path);\n        } else if (flags === 512) {\n          FS.rmdir(path);\n        } else {\n          abort("Invalid flags passed to unlinkat");\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    var __abort_js = () => {\n      abort("native code called abort()");\n    };\n    var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);\n    var __emscripten_throw_longjmp = () => {\n      throw Infinity;\n    };\n    function __gmtime_js(time_low, time_high, tmPtr) {\n      var time = convertI32PairToI53Checked(time_low, time_high);\n      var date = new Date(time * 1e3);\n      HEAP32[tmPtr >> 2] = date.getUTCSeconds();\n      HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();\n      HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();\n      HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();\n      HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();\n      HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;\n      HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();\n      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);\n      var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;\n      HEAP32[tmPtr + 28 >> 2] = yday;\n    }\n    var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n    var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];\n    var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n    var ydayFromDate = (date) => {\n      var leap = isLeapYear(date.getFullYear());\n      var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;\n      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;\n      return yday;\n    };\n    function __localtime_js(time_low, time_high, tmPtr) {\n      var time = convertI32PairToI53Checked(time_low, time_high);\n      var date = new Date(time * 1e3);\n      HEAP32[tmPtr >> 2] = date.getSeconds();\n      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();\n      HEAP32[tmPtr + 8 >> 2] = date.getHours();\n      HEAP32[tmPtr + 12 >> 2] = date.getDate();\n      HEAP32[tmPtr + 16 >> 2] = date.getMonth();\n      HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;\n      HEAP32[tmPtr + 24 >> 2] = date.getDay();\n      var yday = ydayFromDate(date) | 0;\n      HEAP32[tmPtr + 28 >> 2] = yday;\n      HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);\n      var start = new Date(date.getFullYear(), 0, 1);\n      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n      var winterOffset = start.getTimezoneOffset();\n      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\n      HEAP32[tmPtr + 32 >> 2] = dst;\n    }\n    var __tzset_js = (timezone, daylight, std_name, dst_name) => {\n      var currentYear = (/* @__PURE__ */ new Date()).getFullYear();\n      var winter = new Date(currentYear, 0, 1);\n      var summer = new Date(currentYear, 6, 1);\n      var winterOffset = winter.getTimezoneOffset();\n      var summerOffset = summer.getTimezoneOffset();\n      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;\n      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\n      var extractZone = (timezoneOffset) => {\n        var sign = timezoneOffset >= 0 ? "-" : "+";\n        var absOffset = Math.abs(timezoneOffset);\n        var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");\n        var minutes = String(absOffset % 60).padStart(2, "0");\n        return `UTC${sign}${hours}${minutes}`;\n      };\n      var winterName = extractZone(winterOffset);\n      var summerName = extractZone(summerOffset);\n      assert(winterName);\n      assert(summerName);\n      assert(\n        lengthBytesUTF8(winterName) <= 16,\n        `timezone name truncated to fit in TZNAME_MAX (${winterName})`\n      );\n      assert(\n        lengthBytesUTF8(summerName) <= 16,\n        `timezone name truncated to fit in TZNAME_MAX (${summerName})`\n      );\n      if (summerOffset < winterOffset) {\n        stringToUTF8(winterName, std_name, 17);\n        stringToUTF8(summerName, dst_name, 17);\n      } else {\n        stringToUTF8(winterName, dst_name, 17);\n        stringToUTF8(summerName, std_name, 17);\n      }\n    };\n    var _emscripten_date_now = () => Date.now();\n    var getHeapMax = () => (\n      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n      // for any code that deals with heap sizes, which would require special\n      // casing all heap size related code to treat 0 specially.\n      2147483648\n    );\n    var growMemory = (size) => {\n      var b = wasmMemory.buffer;\n      var pages = (size - b.byteLength + 65535) / 65536 | 0;\n      try {\n        wasmMemory.grow(pages);\n        updateMemoryViews();\n        return 1;\n      } catch (e) {\n        err(\n          `growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`\n        );\n      }\n    };\n    var _emscripten_resize_heap = (requestedSize) => {\n      var oldSize = HEAPU8.length;\n      requestedSize >>>= 0;\n      assert(requestedSize > oldSize);\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        err(\n          `Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`\n        );\n        return false;\n      }\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(\n          maxHeapSize,\n          alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)\n        );\n        var replacement = growMemory(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);\n      return false;\n    };\n    var ENV = {};\n    var getExecutableName = () => {\n      return thisProgram || "./this.program";\n    };\n    var getEnvStrings = () => {\n      if (!getEnvStrings.strings) {\n        var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";\n        var env = {\n          USER: "web_user",\n          LOGNAME: "web_user",\n          PATH: "/",\n          PWD: "/",\n          HOME: "/home/web_user",\n          LANG: lang,\n          _: getExecutableName()\n        };\n        for (var x in ENV) {\n          if (ENV[x] === void 0) delete env[x];\n          else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(`${x}=${env[x]}`);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    };\n    var stringToAscii = (str, buffer) => {\n      for (var i = 0; i < str.length; ++i) {\n        assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));\n        HEAP8[buffer++] = str.charCodeAt(i);\n      }\n      HEAP8[buffer] = 0;\n    };\n    var _environ_get = (__environ, environ_buf) => {\n      var bufSize = 0;\n      getEnvStrings().forEach((string, i) => {\n        var ptr = environ_buf + bufSize;\n        HEAPU32[__environ + i * 4 >> 2] = ptr;\n        stringToAscii(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    };\n    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n      var strings = getEnvStrings();\n      HEAPU32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach((string) => bufSize += string.length + 1);\n      HEAPU32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    };\n    function _fd_close(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return e.errno;\n      }\n    }\n    var doReadv = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[iov + 4 >> 2];\n        iov += 8;\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) break;\n      }\n      return ret;\n    };\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doReadv(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return e.errno;\n      }\n    }\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n      var offset = convertI32PairToI53Checked(offset_low, offset_high);\n      try {\n        if (isNaN(offset)) return 61;\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.llseek(stream, offset, whence);\n        tempI64 = [\n          stream.position >>> 0,\n          (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return e.errno;\n      }\n    }\n    function _fd_sync(fd) {\n      var _a;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        if ((_a = stream.stream_ops) == null ? void 0 : _a.fsync) {\n          return stream.stream_ops.fsync(stream);\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return e.errno;\n      }\n    }\n    var doWritev = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[iov + 4 >> 2];\n        iov += 8;\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) {\n          break;\n        }\n      }\n      return ret;\n    };\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doWritev(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return e.errno;\n      }\n    }\n    var wasmTableMirror = [];\n    var wasmTable;\n    var getWasmTableEntry = (funcPtr) => {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      assert(\n        wasmTable.get(funcPtr) == func,\n        "JavaScript-side Wasm function table mirror is out of date!"\n      );\n      return func;\n    };\n    var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;\n    var UTF16ToString = (ptr, maxBytesToRead) => {\n      assert(ptr % 2 == 0, "Pointer passed to UTF16ToString must be aligned to two bytes!");\n      var endPtr = ptr;\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n      endPtr = idx << 1;\n      if (endPtr - ptr > 32 && UTF16Decoder)\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      var str = "";\n      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n        var codeUnit = HEAP16[ptr + i * 2 >> 1];\n        if (codeUnit == 0) break;\n        str += String.fromCharCode(codeUnit);\n      }\n      return str;\n    };\n    var uleb128Encode = (n, target) => {\n      assert(n < 16384);\n      if (n < 128) {\n        target.push(n);\n      } else {\n        target.push(n % 128 | 128, n >> 7);\n      }\n    };\n    var sigToWasmTypes = (sig) => {\n      assert(\n        !sig.includes("j"),\n        "i64 not permitted in function signatures when WASM_BIGINT is disabled"\n      );\n      var typeNames = {\n        i: "i32",\n        j: "i64",\n        f: "f32",\n        d: "f64",\n        e: "externref",\n        p: "i32"\n      };\n      var type = {\n        parameters: [],\n        results: sig[0] == "v" ? [] : [typeNames[sig[0]]]\n      };\n      for (var i = 1; i < sig.length; ++i) {\n        assert(sig[i] in typeNames, "invalid signature char: " + sig[i]);\n        type.parameters.push(typeNames[sig[i]]);\n      }\n      return type;\n    };\n    var generateFuncType = (sig, target) => {\n      var sigRet = sig.slice(0, 1);\n      var sigParam = sig.slice(1);\n      var typeCodes = {\n        i: 127,\n        // i32\n        p: 127,\n        // i32\n        j: 126,\n        // i64\n        f: 125,\n        // f32\n        d: 124,\n        // f64\n        e: 111\n        // externref\n      };\n      target.push(\n        96\n        /* form: func */\n      );\n      uleb128Encode(sigParam.length, target);\n      for (var i = 0; i < sigParam.length; ++i) {\n        assert(sigParam[i] in typeCodes, "invalid signature char: " + sigParam[i]);\n        target.push(typeCodes[sigParam[i]]);\n      }\n      if (sigRet == "v") {\n        target.push(0);\n      } else {\n        target.push(1, typeCodes[sigRet]);\n      }\n    };\n    var convertJsFunctionToWasm = (func, sig) => {\n      assert(\n        !sig.includes("j"),\n        "i64 not permitted in function signatures when WASM_BIGINT is disabled"\n      );\n      if (typeof WebAssembly.Function == "function") {\n        return new WebAssembly.Function(sigToWasmTypes(sig), func);\n      }\n      var typeSectionBody = [\n        1\n        // count: 1\n      ];\n      generateFuncType(sig, typeSectionBody);\n      var bytes = [\n        0,\n        97,\n        115,\n        109,\n        // magic ("\\0asm")\n        1,\n        0,\n        0,\n        0,\n        // version: 1\n        1\n        // Type section code\n      ];\n      uleb128Encode(typeSectionBody.length, bytes);\n      bytes.push(...typeSectionBody);\n      bytes.push(\n        2,\n        7,\n        // import section\n        // (import "e" "f" (func 0 (type 0)))\n        1,\n        1,\n        101,\n        1,\n        102,\n        0,\n        0,\n        7,\n        5,\n        // export section\n        // (export "f" (func 0 (type 0)))\n        1,\n        1,\n        102,\n        0,\n        0\n      );\n      var module = new WebAssembly.Module(new Uint8Array(bytes));\n      var instance = new WebAssembly.Instance(module, { e: { f: func } });\n      var wrappedFunc = instance.exports["f"];\n      return wrappedFunc;\n    };\n    var updateTableMap = (offset, count) => {\n      if (functionsInTableMap) {\n        for (var i = offset; i < offset + count; i++) {\n          var item = getWasmTableEntry(i);\n          if (item) {\n            functionsInTableMap.set(item, i);\n          }\n        }\n      }\n    };\n    var functionsInTableMap;\n    var getFunctionAddress = (func) => {\n      if (!functionsInTableMap) {\n        functionsInTableMap = /* @__PURE__ */ new WeakMap();\n        updateTableMap(0, wasmTable.length);\n      }\n      return functionsInTableMap.get(func) || 0;\n    };\n    var freeTableIndexes = [];\n    var getEmptyTableSlot = () => {\n      if (freeTableIndexes.length) {\n        return freeTableIndexes.pop();\n      }\n      try {\n        wasmTable.grow(1);\n      } catch (err2) {\n        if (!(err2 instanceof RangeError)) {\n          throw err2;\n        }\n        throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";\n      }\n      return wasmTable.length - 1;\n    };\n    var setWasmTableEntry = (idx, func) => {\n      wasmTable.set(idx, func);\n      wasmTableMirror[idx] = wasmTable.get(idx);\n    };\n    var addFunction = (func, sig) => {\n      assert(typeof func != "undefined");\n      var rtn = getFunctionAddress(func);\n      if (rtn) {\n        return rtn;\n      }\n      var ret = getEmptyTableSlot();\n      try {\n        setWasmTableEntry(ret, func);\n      } catch (err2) {\n        if (!(err2 instanceof TypeError)) {\n          throw err2;\n        }\n        assert(typeof sig != "undefined", "Missing signature argument to addFunction: " + func);\n        var wrapped = convertJsFunctionToWasm(func, sig);\n        setWasmTableEntry(ret, wrapped);\n      }\n      functionsInTableMap.set(func, ret);\n      return ret;\n    };\n    var getCFunc = (ident) => {\n      var func = Module["_" + ident];\n      assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");\n      return func;\n    };\n    var writeArrayToMemory = (array, buffer) => {\n      assert(\n        array.length >= 0,\n        "writeArrayToMemory array must have a length (should be an array or typed array)"\n      );\n      HEAP8.set(array, buffer);\n    };\n    var stackAlloc = (sz) => __emscripten_stack_alloc(sz);\n    var stringToUTF8OnStack = (str) => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8(str, ret, size);\n      return ret;\n    };\n    var ccall = (ident, returnType, argTypes, args, opts) => {\n      var toC = {\n        string: (str) => {\n          var ret2 = 0;\n          if (str !== null && str !== void 0 && str !== 0) {\n            ret2 = stringToUTF8OnStack(str);\n          }\n          return ret2;\n        },\n        array: (arr) => {\n          var ret2 = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret2);\n          return ret2;\n        }\n      };\n      function convertReturnValue(ret2) {\n        if (returnType === "string") {\n          return UTF8ToString(ret2);\n        }\n        if (returnType === "boolean") return Boolean(ret2);\n        return ret2;\n      }\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== "array", \'Return type should not be "array".\');\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func(...cArgs);\n      function onDone(ret2) {\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret2);\n      }\n      ret = onDone(ret);\n      return ret;\n    };\n    var cwrap = (ident, returnType, argTypes, opts) => {\n      return (...args) => ccall(ident, returnType, argTypes, args);\n    };\n    var removeFunction = (index) => {\n      functionsInTableMap.delete(getWasmTableEntry(index));\n      setWasmTableEntry(index, null);\n      freeTableIndexes.push(index);\n    };\n    var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n      assert(outPtr % 2 == 0, "Pointer passed to stringToUTF16 must be aligned to two bytes!");\n      assert(\n        typeof maxBytesToWrite == "number",\n        "stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"\n      );\n      maxBytesToWrite ?? (maxBytesToWrite = 2147483647);\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2;\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      }\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    };\n    FS.createPreloadedFile = FS_createPreloadedFile;\n    FS.staticInit();\n    function checkIncomingModuleAPI() {\n      ignoredModuleProp("fetchSettings");\n    }\n    var wasmImports = {\n      /** @export */\n      __assert_fail: ___assert_fail,\n      /** @export */\n      __syscall_fcntl64: ___syscall_fcntl64,\n      /** @export */\n      __syscall_fstat64: ___syscall_fstat64,\n      /** @export */\n      __syscall_ftruncate64: ___syscall_ftruncate64,\n      /** @export */\n      __syscall_getdents64: ___syscall_getdents64,\n      /** @export */\n      __syscall_ioctl: ___syscall_ioctl,\n      /** @export */\n      __syscall_lstat64: ___syscall_lstat64,\n      /** @export */\n      __syscall_newfstatat: ___syscall_newfstatat,\n      /** @export */\n      __syscall_openat: ___syscall_openat,\n      /** @export */\n      __syscall_rmdir: ___syscall_rmdir,\n      /** @export */\n      __syscall_stat64: ___syscall_stat64,\n      /** @export */\n      __syscall_unlinkat: ___syscall_unlinkat,\n      /** @export */\n      _abort_js: __abort_js,\n      /** @export */\n      _emscripten_memcpy_js: __emscripten_memcpy_js,\n      /** @export */\n      _emscripten_throw_longjmp: __emscripten_throw_longjmp,\n      /** @export */\n      _gmtime_js: __gmtime_js,\n      /** @export */\n      _localtime_js: __localtime_js,\n      /** @export */\n      _tzset_js: __tzset_js,\n      /** @export */\n      emscripten_date_now: _emscripten_date_now,\n      /** @export */\n      emscripten_resize_heap: _emscripten_resize_heap,\n      /** @export */\n      environ_get: _environ_get,\n      /** @export */\n      environ_sizes_get: _environ_sizes_get,\n      /** @export */\n      fd_close: _fd_close,\n      /** @export */\n      fd_read: _fd_read,\n      /** @export */\n      fd_seek: _fd_seek,\n      /** @export */\n      fd_sync: _fd_sync,\n      /** @export */\n      fd_write: _fd_write,\n      /** @export */\n      invoke_ii,\n      /** @export */\n      invoke_iii,\n      /** @export */\n      invoke_iiii,\n      /** @export */\n      invoke_iiiii,\n      /** @export */\n      invoke_v,\n      /** @export */\n      invoke_vii,\n      /** @export */\n      invoke_viii,\n      /** @export */\n      invoke_viiii,\n      /** @export */\n      invoke_viiiiiiiii\n    };\n    var wasmExports = createWasm();\n    Module["_PDFiumExt_Init"] = createExportWrapper("PDFiumExt_Init", 0);\n    Module["_FPDF_InitLibraryWithConfig"] = createExportWrapper(\n      "FPDF_InitLibraryWithConfig",\n      1\n    );\n    Module["_PDFiumExt_OpenFileWriter"] = createExportWrapper(\n      "PDFiumExt_OpenFileWriter",\n      0\n    );\n    Module["_PDFiumExt_GetFileWriterSize"] = createExportWrapper("PDFiumExt_GetFileWriterSize", 1);\n    Module["_PDFiumExt_GetFileWriterData"] = createExportWrapper("PDFiumExt_GetFileWriterData", 3);\n    Module["_PDFiumExt_CloseFileWriter"] = createExportWrapper(\n      "PDFiumExt_CloseFileWriter",\n      1\n    );\n    Module["_PDFiumExt_SaveAsCopy"] = createExportWrapper(\n      "PDFiumExt_SaveAsCopy",\n      2\n    );\n    Module["_FPDF_SaveAsCopy"] = createExportWrapper("FPDF_SaveAsCopy", 3);\n    Module["_PDFiumExt_OpenFormFillInfo"] = createExportWrapper(\n      "PDFiumExt_OpenFormFillInfo",\n      0\n    );\n    Module["_PDFiumExt_CloseFormFillInfo"] = createExportWrapper("PDFiumExt_CloseFormFillInfo", 1);\n    Module["_PDFiumExt_InitFormFillEnvironment"] = createExportWrapper("PDFiumExt_InitFormFillEnvironment", 2);\n    Module["_FPDFDOC_InitFormFillEnvironment"] = createExportWrapper("FPDFDOC_InitFormFillEnvironment", 2);\n    Module["_PDFiumExt_ExitFormFillEnvironment"] = createExportWrapper("PDFiumExt_ExitFormFillEnvironment", 1);\n    Module["_FPDFDOC_ExitFormFillEnvironment"] = createExportWrapper("FPDFDOC_ExitFormFillEnvironment", 1);\n    Module["_EPDFNamedDest_SetDest"] = createExportWrapper(\n      "EPDFNamedDest_SetDest",\n      3\n    );\n    Module["_EPDFNamedDest_Remove"] = createExportWrapper(\n      "EPDFNamedDest_Remove",\n      2\n    );\n    Module["_EPDFDest_CreateView"] = createExportWrapper(\n      "EPDFDest_CreateView",\n      4\n    );\n    Module["_EPDFDest_CreateXYZ"] = createExportWrapper(\n      "EPDFDest_CreateXYZ",\n      7\n    );\n    Module["_EPDFDest_CreateRemoteView"] = createExportWrapper(\n      "EPDFDest_CreateRemoteView",\n      5\n    );\n    Module["_EPDFDest_CreateRemoteXYZ"] = createExportWrapper(\n      "EPDFDest_CreateRemoteXYZ",\n      8\n    );\n    Module["_EPDFAction_CreateGoTo"] = createExportWrapper(\n      "EPDFAction_CreateGoTo",\n      2\n    );\n    Module["_EPDFAction_CreateGoToNamed"] = createExportWrapper(\n      "EPDFAction_CreateGoToNamed",\n      2\n    );\n    Module["_EPDFAction_CreateLaunch"] = createExportWrapper(\n      "EPDFAction_CreateLaunch",\n      2\n    );\n    Module["_EPDFAction_CreateRemoteGoToByName"] = createExportWrapper("EPDFAction_CreateRemoteGoToByName", 3);\n    Module["_EPDFAction_CreateRemoteGoToDest"] = createExportWrapper("EPDFAction_CreateRemoteGoToDest", 3);\n    Module["_EPDFAction_CreateURI"] = createExportWrapper(\n      "EPDFAction_CreateURI",\n      2\n    );\n    Module["_EPDFBookmark_Create"] = createExportWrapper(\n      "EPDFBookmark_Create",\n      2\n    );\n    Module["_EPDFBookmark_Delete"] = createExportWrapper(\n      "EPDFBookmark_Delete",\n      2\n    );\n    Module["_EPDFBookmark_AppendChild"] = createExportWrapper(\n      "EPDFBookmark_AppendChild",\n      3\n    );\n    Module["_EPDFBookmark_InsertAfter"] = createExportWrapper(\n      "EPDFBookmark_InsertAfter",\n      4\n    );\n    Module["_EPDFBookmark_Clear"] = createExportWrapper(\n      "EPDFBookmark_Clear",\n      1\n    );\n    Module["_EPDFBookmark_SetTitle"] = createExportWrapper(\n      "EPDFBookmark_SetTitle",\n      2\n    );\n    Module["_EPDFBookmark_SetDest"] = createExportWrapper(\n      "EPDFBookmark_SetDest",\n      3\n    );\n    Module["_EPDFBookmark_SetAction"] = createExportWrapper(\n      "EPDFBookmark_SetAction",\n      3\n    );\n    Module["_EPDFBookmark_ClearTarget"] = createExportWrapper(\n      "EPDFBookmark_ClearTarget",\n      1\n    );\n    Module["_EPDF_PNG_EncodeRGBA"] = createExportWrapper(\n      "EPDF_PNG_EncodeRGBA",\n      6\n    );\n    Module["_FPDFAnnot_IsSupportedSubtype"] = createExportWrapper("FPDFAnnot_IsSupportedSubtype", 1);\n    Module["_FPDFPage_CreateAnnot"] = createExportWrapper(\n      "FPDFPage_CreateAnnot",\n      2\n    );\n    Module["_FPDFPage_GetAnnotCount"] = createExportWrapper(\n      "FPDFPage_GetAnnotCount",\n      1\n    );\n    Module["_FPDFPage_GetAnnot"] = createExportWrapper(\n      "FPDFPage_GetAnnot",\n      2\n    );\n    Module["_FPDFPage_GetAnnotIndex"] = createExportWrapper(\n      "FPDFPage_GetAnnotIndex",\n      2\n    );\n    Module["_FPDFPage_CloseAnnot"] = createExportWrapper(\n      "FPDFPage_CloseAnnot",\n      1\n    );\n    Module["_FPDFPage_RemoveAnnot"] = createExportWrapper(\n      "FPDFPage_RemoveAnnot",\n      2\n    );\n    Module["_FPDFAnnot_GetSubtype"] = createExportWrapper(\n      "FPDFAnnot_GetSubtype",\n      1\n    );\n    Module["_FPDFAnnot_IsObjectSupportedSubtype"] = createExportWrapper("FPDFAnnot_IsObjectSupportedSubtype", 1);\n    Module["_FPDFAnnot_UpdateObject"] = createExportWrapper(\n      "FPDFAnnot_UpdateObject",\n      2\n    );\n    Module["_FPDFAnnot_AddInkStroke"] = createExportWrapper(\n      "FPDFAnnot_AddInkStroke",\n      3\n    );\n    Module["_FPDFAnnot_RemoveInkList"] = createExportWrapper(\n      "FPDFAnnot_RemoveInkList",\n      1\n    );\n    Module["_FPDFAnnot_AppendObject"] = createExportWrapper(\n      "FPDFAnnot_AppendObject",\n      2\n    );\n    Module["_FPDFAnnot_GetObjectCount"] = createExportWrapper(\n      "FPDFAnnot_GetObjectCount",\n      1\n    );\n    Module["_FPDFAnnot_GetObject"] = createExportWrapper(\n      "FPDFAnnot_GetObject",\n      2\n    );\n    Module["_FPDFAnnot_RemoveObject"] = createExportWrapper(\n      "FPDFAnnot_RemoveObject",\n      2\n    );\n    Module["_FPDFAnnot_SetColor"] = createExportWrapper(\n      "FPDFAnnot_SetColor",\n      6\n    );\n    Module["_FPDFAnnot_GetColor"] = createExportWrapper(\n      "FPDFAnnot_GetColor",\n      6\n    );\n    Module["_FPDFAnnot_HasAttachmentPoints"] = createExportWrapper("FPDFAnnot_HasAttachmentPoints", 1);\n    Module["_FPDFAnnot_SetAttachmentPoints"] = createExportWrapper("FPDFAnnot_SetAttachmentPoints", 3);\n    Module["_FPDFAnnot_AppendAttachmentPoints"] = createExportWrapper("FPDFAnnot_AppendAttachmentPoints", 2);\n    Module["_FPDFAnnot_CountAttachmentPoints"] = createExportWrapper("FPDFAnnot_CountAttachmentPoints", 1);\n    Module["_FPDFAnnot_GetAttachmentPoints"] = createExportWrapper("FPDFAnnot_GetAttachmentPoints", 3);\n    Module["_FPDFAnnot_SetRect"] = createExportWrapper(\n      "FPDFAnnot_SetRect",\n      2\n    );\n    Module["_FPDFAnnot_GetRect"] = createExportWrapper(\n      "FPDFAnnot_GetRect",\n      2\n    );\n    Module["_FPDFAnnot_GetVertices"] = createExportWrapper(\n      "FPDFAnnot_GetVertices",\n      3\n    );\n    Module["_FPDFAnnot_GetInkListCount"] = createExportWrapper(\n      "FPDFAnnot_GetInkListCount",\n      1\n    );\n    Module["_FPDFAnnot_GetInkListPath"] = createExportWrapper(\n      "FPDFAnnot_GetInkListPath",\n      4\n    );\n    Module["_FPDFAnnot_GetLine"] = createExportWrapper(\n      "FPDFAnnot_GetLine",\n      3\n    );\n    Module["_FPDFAnnot_SetBorder"] = createExportWrapper(\n      "FPDFAnnot_SetBorder",\n      4\n    );\n    Module["_FPDFAnnot_GetBorder"] = createExportWrapper(\n      "FPDFAnnot_GetBorder",\n      4\n    );\n    Module["_FPDFAnnot_HasKey"] = createExportWrapper(\n      "FPDFAnnot_HasKey",\n      2\n    );\n    Module["_FPDFAnnot_GetValueType"] = createExportWrapper(\n      "FPDFAnnot_GetValueType",\n      2\n    );\n    Module["_FPDFAnnot_SetStringValue"] = createExportWrapper(\n      "FPDFAnnot_SetStringValue",\n      3\n    );\n    Module["_FPDFAnnot_GetStringValue"] = createExportWrapper(\n      "FPDFAnnot_GetStringValue",\n      4\n    );\n    Module["_FPDFAnnot_GetNumberValue"] = createExportWrapper(\n      "FPDFAnnot_GetNumberValue",\n      3\n    );\n    Module["_FPDFAnnot_SetAP"] = createExportWrapper("FPDFAnnot_SetAP", 3);\n    Module["_FPDFAnnot_GetAP"] = createExportWrapper("FPDFAnnot_GetAP", 4);\n    Module["_FPDFAnnot_GetLinkedAnnot"] = createExportWrapper(\n      "FPDFAnnot_GetLinkedAnnot",\n      2\n    );\n    Module["_FPDFAnnot_GetFlags"] = createExportWrapper(\n      "FPDFAnnot_GetFlags",\n      1\n    );\n    Module["_FPDFAnnot_SetFlags"] = createExportWrapper(\n      "FPDFAnnot_SetFlags",\n      2\n    );\n    Module["_FPDFAnnot_GetFormFieldFlags"] = createExportWrapper("FPDFAnnot_GetFormFieldFlags", 2);\n    Module["_FPDFAnnot_SetFormFieldFlags"] = createExportWrapper("FPDFAnnot_SetFormFieldFlags", 3);\n    Module["_FPDFAnnot_GetFormFieldAtPoint"] = createExportWrapper("FPDFAnnot_GetFormFieldAtPoint", 3);\n    Module["_FPDFAnnot_GetFormFieldName"] = createExportWrapper(\n      "FPDFAnnot_GetFormFieldName",\n      4\n    );\n    Module["_FPDFAnnot_GetFormFieldType"] = createExportWrapper(\n      "FPDFAnnot_GetFormFieldType",\n      2\n    );\n    Module["_FPDFAnnot_GetFormAdditionalActionJavaScript"] = createExportWrapper("FPDFAnnot_GetFormAdditionalActionJavaScript", 5);\n    Module["_FPDFAnnot_GetFormFieldAlternateName"] = createExportWrapper("FPDFAnnot_GetFormFieldAlternateName", 4);\n    Module["_FPDFAnnot_GetFormFieldValue"] = createExportWrapper("FPDFAnnot_GetFormFieldValue", 4);\n    Module["_FPDFAnnot_GetOptionCount"] = createExportWrapper(\n      "FPDFAnnot_GetOptionCount",\n      2\n    );\n    Module["_FPDFAnnot_GetOptionLabel"] = createExportWrapper(\n      "FPDFAnnot_GetOptionLabel",\n      5\n    );\n    Module["_FPDFAnnot_IsOptionSelected"] = createExportWrapper(\n      "FPDFAnnot_IsOptionSelected",\n      3\n    );\n    Module["_FPDFAnnot_GetFontSize"] = createExportWrapper(\n      "FPDFAnnot_GetFontSize",\n      3\n    );\n    Module["_FPDFAnnot_SetFontColor"] = createExportWrapper(\n      "FPDFAnnot_SetFontColor",\n      5\n    );\n    Module["_FPDFAnnot_GetFontColor"] = createExportWrapper(\n      "FPDFAnnot_GetFontColor",\n      5\n    );\n    Module["_FPDFAnnot_IsChecked"] = createExportWrapper(\n      "FPDFAnnot_IsChecked",\n      2\n    );\n    Module["_FPDFAnnot_SetFocusableSubtypes"] = createExportWrapper("FPDFAnnot_SetFocusableSubtypes", 3);\n    Module["_FPDFAnnot_GetFocusableSubtypesCount"] = createExportWrapper("FPDFAnnot_GetFocusableSubtypesCount", 1);\n    Module["_FPDFAnnot_GetFocusableSubtypes"] = createExportWrapper("FPDFAnnot_GetFocusableSubtypes", 3);\n    Module["_FPDFAnnot_GetLink"] = createExportWrapper(\n      "FPDFAnnot_GetLink",\n      1\n    );\n    Module["_FPDFAnnot_GetFormControlCount"] = createExportWrapper("FPDFAnnot_GetFormControlCount", 2);\n    Module["_FPDFAnnot_GetFormControlIndex"] = createExportWrapper("FPDFAnnot_GetFormControlIndex", 2);\n    Module["_FPDFAnnot_GetFormFieldExportValue"] = createExportWrapper("FPDFAnnot_GetFormFieldExportValue", 4);\n    Module["_FPDFAnnot_SetURI"] = createExportWrapper(\n      "FPDFAnnot_SetURI",\n      2\n    );\n    Module["_FPDFAnnot_GetFileAttachment"] = createExportWrapper("FPDFAnnot_GetFileAttachment", 1);\n    Module["_FPDFAnnot_AddFileAttachment"] = createExportWrapper("FPDFAnnot_AddFileAttachment", 2);\n    Module["_EPDFAnnot_SetColor"] = createExportWrapper(\n      "EPDFAnnot_SetColor",\n      5\n    );\n    Module["_EPDFAnnot_GetColor"] = createExportWrapper(\n      "EPDFAnnot_GetColor",\n      5\n    );\n    Module["_EPDFAnnot_ClearColor"] = createExportWrapper(\n      "EPDFAnnot_ClearColor",\n      2\n    );\n    Module["_EPDFAnnot_SetOpacity"] = createExportWrapper(\n      "EPDFAnnot_SetOpacity",\n      2\n    );\n    Module["_EPDFAnnot_GetOpacity"] = createExportWrapper(\n      "EPDFAnnot_GetOpacity",\n      2\n    );\n    Module["_EPDFAnnot_GetBorderEffect"] = createExportWrapper(\n      "EPDFAnnot_GetBorderEffect",\n      2\n    );\n    Module["_EPDFAnnot_GetRectangleDifferences"] = createExportWrapper("EPDFAnnot_GetRectangleDifferences", 5);\n    Module["_EPDFAnnot_GetBorderDashPatternCount"] = createExportWrapper("EPDFAnnot_GetBorderDashPatternCount", 1);\n    Module["_EPDFAnnot_GetBorderDashPattern"] = createExportWrapper("EPDFAnnot_GetBorderDashPattern", 3);\n    Module["_EPDFAnnot_SetBorderDashPattern"] = createExportWrapper("EPDFAnnot_SetBorderDashPattern", 3);\n    Module["_EPDFAnnot_GetBorderStyle"] = createExportWrapper(\n      "EPDFAnnot_GetBorderStyle",\n      2\n    );\n    Module["_EPDFAnnot_SetBorderStyle"] = createExportWrapper(\n      "EPDFAnnot_SetBorderStyle",\n      3\n    );\n    Module["_EPDFAnnot_GenerateAppearance"] = createExportWrapper("EPDFAnnot_GenerateAppearance", 1);\n    Module["_EPDFAnnot_GenerateAppearanceWithBlend"] = createExportWrapper("EPDFAnnot_GenerateAppearanceWithBlend", 2);\n    Module["_EPDFAnnot_GetBlendMode"] = createExportWrapper(\n      "EPDFAnnot_GetBlendMode",\n      1\n    );\n    Module["_EPDFAnnot_SetIntent"] = createExportWrapper(\n      "EPDFAnnot_SetIntent",\n      2\n    );\n    Module["_EPDFAnnot_GetIntent"] = createExportWrapper(\n      "EPDFAnnot_GetIntent",\n      3\n    );\n    Module["_EPDFAnnot_GetRichContent"] = createExportWrapper(\n      "EPDFAnnot_GetRichContent",\n      3\n    );\n    Module["_EPDFAnnot_SetLineEndings"] = createExportWrapper(\n      "EPDFAnnot_SetLineEndings",\n      3\n    );\n    Module["_EPDFAnnot_GetLineEndings"] = createExportWrapper(\n      "EPDFAnnot_GetLineEndings",\n      3\n    );\n    Module["_EPDFAnnot_SetVertices"] = createExportWrapper(\n      "EPDFAnnot_SetVertices",\n      3\n    );\n    Module["_EPDFAnnot_SetLine"] = createExportWrapper(\n      "EPDFAnnot_SetLine",\n      3\n    );\n    Module["_EPDFAnnot_SetDefaultAppearance"] = createExportWrapper("EPDFAnnot_SetDefaultAppearance", 6);\n    Module["_EPDFAnnot_GetDefaultAppearance"] = createExportWrapper("EPDFAnnot_GetDefaultAppearance", 6);\n    Module["_EPDFAnnot_SetTextAlignment"] = createExportWrapper(\n      "EPDFAnnot_SetTextAlignment",\n      2\n    );\n    Module["_EPDFAnnot_GetTextAlignment"] = createExportWrapper(\n      "EPDFAnnot_GetTextAlignment",\n      1\n    );\n    Module["_EPDFAnnot_SetVerticalAlignment"] = createExportWrapper("EPDFAnnot_SetVerticalAlignment", 2);\n    Module["_EPDFAnnot_GetVerticalAlignment"] = createExportWrapper("EPDFAnnot_GetVerticalAlignment", 1);\n    Module["_EPDFPage_GetAnnotByName"] = createExportWrapper(\n      "EPDFPage_GetAnnotByName",\n      2\n    );\n    Module["_EPDFPage_RemoveAnnotByName"] = createExportWrapper(\n      "EPDFPage_RemoveAnnotByName",\n      2\n    );\n    Module["_EPDFAnnot_SetLinkedAnnot"] = createExportWrapper(\n      "EPDFAnnot_SetLinkedAnnot",\n      3\n    );\n    Module["_EPDFPage_GetAnnotCountRaw"] = createExportWrapper(\n      "EPDFPage_GetAnnotCountRaw",\n      2\n    );\n    Module["_EPDFPage_GetAnnotRaw"] = createExportWrapper(\n      "EPDFPage_GetAnnotRaw",\n      3\n    );\n    Module["_EPDFPage_RemoveAnnotRaw"] = createExportWrapper(\n      "EPDFPage_RemoveAnnotRaw",\n      3\n    );\n    Module["_EPDFAnnot_SetIcon"] = createExportWrapper(\n      "EPDFAnnot_SetIcon",\n      2\n    );\n    Module["_EPDFAnnot_GetIcon"] = createExportWrapper(\n      "EPDFAnnot_GetIcon",\n      1\n    );\n    Module["_EPDFAnnot_UpdateAppearanceToRect"] = createExportWrapper("EPDFAnnot_UpdateAppearanceToRect", 2);\n    Module["_EPDFPage_CreateAnnot"] = createExportWrapper(\n      "EPDFPage_CreateAnnot",\n      2\n    );\n    Module["_FPDFDoc_GetAttachmentCount"] = createExportWrapper(\n      "FPDFDoc_GetAttachmentCount",\n      1\n    );\n    Module["_FPDFDoc_AddAttachment"] = createExportWrapper(\n      "FPDFDoc_AddAttachment",\n      2\n    );\n    Module["_FPDFDoc_GetAttachment"] = createExportWrapper(\n      "FPDFDoc_GetAttachment",\n      2\n    );\n    Module["_FPDFDoc_DeleteAttachment"] = createExportWrapper(\n      "FPDFDoc_DeleteAttachment",\n      2\n    );\n    Module["_FPDFAttachment_GetName"] = createExportWrapper(\n      "FPDFAttachment_GetName",\n      3\n    );\n    Module["_FPDFAttachment_HasKey"] = createExportWrapper(\n      "FPDFAttachment_HasKey",\n      2\n    );\n    Module["_FPDFAttachment_GetValueType"] = createExportWrapper("FPDFAttachment_GetValueType", 2);\n    Module["_FPDFAttachment_SetStringValue"] = createExportWrapper("FPDFAttachment_SetStringValue", 3);\n    Module["_FPDFAttachment_GetStringValue"] = createExportWrapper("FPDFAttachment_GetStringValue", 4);\n    Module["_FPDFAttachment_SetFile"] = createExportWrapper(\n      "FPDFAttachment_SetFile",\n      4\n    );\n    Module["_FPDFAttachment_GetFile"] = createExportWrapper(\n      "FPDFAttachment_GetFile",\n      4\n    );\n    Module["_FPDFAttachment_GetSubtype"] = createExportWrapper(\n      "FPDFAttachment_GetSubtype",\n      3\n    );\n    Module["_EPDFAttachment_SetSubtype"] = createExportWrapper(\n      "EPDFAttachment_SetSubtype",\n      2\n    );\n    Module["_EPDFAttachment_SetDescription"] = createExportWrapper("EPDFAttachment_SetDescription", 2);\n    Module["_EPDFAttachment_GetDescription"] = createExportWrapper("EPDFAttachment_GetDescription", 3);\n    Module["_EPDFAttachment_GetIntegerValue"] = createExportWrapper("EPDFAttachment_GetIntegerValue", 3);\n    Module["_FPDFCatalog_IsTagged"] = createExportWrapper(\n      "FPDFCatalog_IsTagged",\n      1\n    );\n    Module["_FPDFCatalog_SetLanguage"] = createExportWrapper(\n      "FPDFCatalog_SetLanguage",\n      2\n    );\n    Module["_EPDFCatalog_GetLanguage"] = createExportWrapper(\n      "EPDFCatalog_GetLanguage",\n      3\n    );\n    Module["_FPDFAvail_Create"] = createExportWrapper(\n      "FPDFAvail_Create",\n      2\n    );\n    Module["_FPDFAvail_Destroy"] = createExportWrapper(\n      "FPDFAvail_Destroy",\n      1\n    );\n    Module["_FPDFAvail_IsDocAvail"] = createExportWrapper(\n      "FPDFAvail_IsDocAvail",\n      2\n    );\n    Module["_FPDFAvail_GetDocument"] = createExportWrapper(\n      "FPDFAvail_GetDocument",\n      2\n    );\n    Module["_FPDFAvail_GetFirstPageNum"] = createExportWrapper(\n      "FPDFAvail_GetFirstPageNum",\n      1\n    );\n    Module["_FPDFAvail_IsPageAvail"] = createExportWrapper(\n      "FPDFAvail_IsPageAvail",\n      3\n    );\n    Module["_FPDFAvail_IsFormAvail"] = createExportWrapper(\n      "FPDFAvail_IsFormAvail",\n      2\n    );\n    Module["_FPDFAvail_IsLinearized"] = createExportWrapper(\n      "FPDFAvail_IsLinearized",\n      1\n    );\n    Module["_FPDFBookmark_GetFirstChild"] = createExportWrapper(\n      "FPDFBookmark_GetFirstChild",\n      2\n    );\n    Module["_FPDFBookmark_GetNextSibling"] = createExportWrapper("FPDFBookmark_GetNextSibling", 2);\n    Module["_FPDFBookmark_GetTitle"] = createExportWrapper(\n      "FPDFBookmark_GetTitle",\n      3\n    );\n    Module["_FPDFBookmark_GetCount"] = createExportWrapper(\n      "FPDFBookmark_GetCount",\n      1\n    );\n    Module["_FPDFBookmark_Find"] = createExportWrapper(\n      "FPDFBookmark_Find",\n      2\n    );\n    Module["_FPDFBookmark_GetDest"] = createExportWrapper(\n      "FPDFBookmark_GetDest",\n      2\n    );\n    Module["_FPDFBookmark_GetAction"] = createExportWrapper(\n      "FPDFBookmark_GetAction",\n      1\n    );\n    Module["_FPDFAction_GetType"] = createExportWrapper(\n      "FPDFAction_GetType",\n      1\n    );\n    Module["_FPDFAction_GetDest"] = createExportWrapper(\n      "FPDFAction_GetDest",\n      2\n    );\n    Module["_FPDFAction_GetFilePath"] = createExportWrapper(\n      "FPDFAction_GetFilePath",\n      3\n    );\n    Module["_FPDFAction_GetURIPath"] = createExportWrapper(\n      "FPDFAction_GetURIPath",\n      4\n    );\n    Module["_FPDFDest_GetDestPageIndex"] = createExportWrapper(\n      "FPDFDest_GetDestPageIndex",\n      2\n    );\n    Module["_FPDFDest_GetView"] = createExportWrapper(\n      "FPDFDest_GetView",\n      3\n    );\n    Module["_FPDFDest_GetLocationInPage"] = createExportWrapper(\n      "FPDFDest_GetLocationInPage",\n      7\n    );\n    Module["_FPDFLink_GetLinkAtPoint"] = createExportWrapper(\n      "FPDFLink_GetLinkAtPoint",\n      3\n    );\n    Module["_FPDFLink_GetLinkZOrderAtPoint"] = createExportWrapper("FPDFLink_GetLinkZOrderAtPoint", 3);\n    Module["_FPDFLink_GetDest"] = createExportWrapper(\n      "FPDFLink_GetDest",\n      2\n    );\n    Module["_FPDFLink_GetAction"] = createExportWrapper(\n      "FPDFLink_GetAction",\n      1\n    );\n    Module["_FPDFLink_Enumerate"] = createExportWrapper(\n      "FPDFLink_Enumerate",\n      3\n    );\n    Module["_FPDFLink_GetAnnot"] = createExportWrapper(\n      "FPDFLink_GetAnnot",\n      2\n    );\n    Module["_FPDFLink_GetAnnotRect"] = createExportWrapper(\n      "FPDFLink_GetAnnotRect",\n      2\n    );\n    Module["_FPDFLink_CountQuadPoints"] = createExportWrapper(\n      "FPDFLink_CountQuadPoints",\n      1\n    );\n    Module["_FPDFLink_GetQuadPoints"] = createExportWrapper(\n      "FPDFLink_GetQuadPoints",\n      3\n    );\n    Module["_FPDF_GetPageAAction"] = createExportWrapper(\n      "FPDF_GetPageAAction",\n      2\n    );\n    Module["_FPDF_GetFileIdentifier"] = createExportWrapper(\n      "FPDF_GetFileIdentifier",\n      4\n    );\n    Module["_FPDF_GetMetaText"] = createExportWrapper(\n      "FPDF_GetMetaText",\n      4\n    );\n    Module["_FPDF_GetPageLabel"] = createExportWrapper(\n      "FPDF_GetPageLabel",\n      4\n    );\n    Module["_EPDF_SetMetaText"] = createExportWrapper(\n      "EPDF_SetMetaText",\n      3\n    );\n    Module["_EPDF_HasMetaText"] = createExportWrapper(\n      "EPDF_HasMetaText",\n      2\n    );\n    Module["_EPDF_GetMetaTrapped"] = createExportWrapper(\n      "EPDF_GetMetaTrapped",\n      1\n    );\n    Module["_EPDF_SetMetaTrapped"] = createExportWrapper(\n      "EPDF_SetMetaTrapped",\n      2\n    );\n    Module["_EPDF_GetMetaKeyCount"] = createExportWrapper(\n      "EPDF_GetMetaKeyCount",\n      2\n    );\n    Module["_EPDF_GetMetaKeyName"] = createExportWrapper(\n      "EPDF_GetMetaKeyName",\n      5\n    );\n    Module["_FPDFPageObj_NewImageObj"] = createExportWrapper(\n      "FPDFPageObj_NewImageObj",\n      1\n    );\n    Module["_FPDFImageObj_LoadJpegFile"] = createExportWrapper(\n      "FPDFImageObj_LoadJpegFile",\n      4\n    );\n    Module["_FPDFImageObj_LoadJpegFileInline"] = createExportWrapper("FPDFImageObj_LoadJpegFileInline", 4);\n    Module["_FPDFImageObj_SetMatrix"] = createExportWrapper(\n      "FPDFImageObj_SetMatrix",\n      7\n    );\n    Module["_FPDFImageObj_SetBitmap"] = createExportWrapper(\n      "FPDFImageObj_SetBitmap",\n      4\n    );\n    Module["_FPDFImageObj_GetBitmap"] = createExportWrapper(\n      "FPDFImageObj_GetBitmap",\n      1\n    );\n    Module["_FPDFImageObj_GetRenderedBitmap"] = createExportWrapper("FPDFImageObj_GetRenderedBitmap", 3);\n    Module["_FPDFImageObj_GetImageDataDecoded"] = createExportWrapper("FPDFImageObj_GetImageDataDecoded", 3);\n    Module["_FPDFImageObj_GetImageDataRaw"] = createExportWrapper("FPDFImageObj_GetImageDataRaw", 3);\n    Module["_FPDFImageObj_GetImageFilterCount"] = createExportWrapper("FPDFImageObj_GetImageFilterCount", 1);\n    Module["_FPDFImageObj_GetImageFilter"] = createExportWrapper("FPDFImageObj_GetImageFilter", 4);\n    Module["_FPDFImageObj_GetImageMetadata"] = createExportWrapper("FPDFImageObj_GetImageMetadata", 3);\n    Module["_FPDFImageObj_GetImagePixelSize"] = createExportWrapper("FPDFImageObj_GetImagePixelSize", 3);\n    Module["_FPDFImageObj_GetIccProfileDataDecoded"] = createExportWrapper("FPDFImageObj_GetIccProfileDataDecoded", 5);\n    Module["_FPDF_CreateNewDocument"] = createExportWrapper(\n      "FPDF_CreateNewDocument",\n      0\n    );\n    Module["_FPDFPage_Delete"] = createExportWrapper("FPDFPage_Delete", 2);\n    Module["_FPDF_MovePages"] = createExportWrapper("FPDF_MovePages", 4);\n    Module["_FPDFPage_New"] = createExportWrapper("FPDFPage_New", 4);\n    Module["_FPDFPage_GetRotation"] = createExportWrapper(\n      "FPDFPage_GetRotation",\n      1\n    );\n    Module["_FPDFPage_InsertObject"] = createExportWrapper(\n      "FPDFPage_InsertObject",\n      2\n    );\n    Module["_FPDFPage_InsertObjectAtIndex"] = createExportWrapper("FPDFPage_InsertObjectAtIndex", 3);\n    Module["_FPDFPage_RemoveObject"] = createExportWrapper(\n      "FPDFPage_RemoveObject",\n      2\n    );\n    Module["_FPDFPage_CountObjects"] = createExportWrapper(\n      "FPDFPage_CountObjects",\n      1\n    );\n    Module["_FPDFPage_GetObject"] = createExportWrapper(\n      "FPDFPage_GetObject",\n      2\n    );\n    Module["_FPDFPage_HasTransparency"] = createExportWrapper(\n      "FPDFPage_HasTransparency",\n      1\n    );\n    Module["_FPDFPageObj_Destroy"] = createExportWrapper(\n      "FPDFPageObj_Destroy",\n      1\n    );\n    Module["_FPDFPageObj_GetMarkedContentID"] = createExportWrapper("FPDFPageObj_GetMarkedContentID", 1);\n    Module["_FPDFPageObj_CountMarks"] = createExportWrapper(\n      "FPDFPageObj_CountMarks",\n      1\n    );\n    Module["_FPDFPageObj_GetMark"] = createExportWrapper(\n      "FPDFPageObj_GetMark",\n      2\n    );\n    Module["_FPDFPageObj_AddMark"] = createExportWrapper(\n      "FPDFPageObj_AddMark",\n      2\n    );\n    Module["_FPDFPageObj_RemoveMark"] = createExportWrapper(\n      "FPDFPageObj_RemoveMark",\n      2\n    );\n    Module["_FPDFPageObjMark_GetName"] = createExportWrapper(\n      "FPDFPageObjMark_GetName",\n      4\n    );\n    Module["_FPDFPageObjMark_CountParams"] = createExportWrapper("FPDFPageObjMark_CountParams", 1);\n    Module["_FPDFPageObjMark_GetParamKey"] = createExportWrapper("FPDFPageObjMark_GetParamKey", 5);\n    Module["_FPDFPageObjMark_GetParamValueType"] = createExportWrapper("FPDFPageObjMark_GetParamValueType", 2);\n    Module["_FPDFPageObjMark_GetParamIntValue"] = createExportWrapper("FPDFPageObjMark_GetParamIntValue", 3);\n    Module["_FPDFPageObjMark_GetParamStringValue"] = createExportWrapper("FPDFPageObjMark_GetParamStringValue", 5);\n    Module["_FPDFPageObjMark_GetParamBlobValue"] = createExportWrapper("FPDFPageObjMark_GetParamBlobValue", 5);\n    Module["_FPDFPageObj_HasTransparency"] = createExportWrapper("FPDFPageObj_HasTransparency", 1);\n    Module["_FPDFPageObjMark_SetIntParam"] = createExportWrapper("FPDFPageObjMark_SetIntParam", 5);\n    Module["_FPDFPageObjMark_SetStringParam"] = createExportWrapper("FPDFPageObjMark_SetStringParam", 5);\n    Module["_FPDFPageObjMark_SetBlobParam"] = createExportWrapper("FPDFPageObjMark_SetBlobParam", 6);\n    Module["_FPDFPageObjMark_RemoveParam"] = createExportWrapper("FPDFPageObjMark_RemoveParam", 3);\n    Module["_FPDFPageObj_GetType"] = createExportWrapper(\n      "FPDFPageObj_GetType",\n      1\n    );\n    Module["_FPDFPageObj_GetIsActive"] = createExportWrapper(\n      "FPDFPageObj_GetIsActive",\n      2\n    );\n    Module["_FPDFPageObj_SetIsActive"] = createExportWrapper(\n      "FPDFPageObj_SetIsActive",\n      2\n    );\n    Module["_FPDFPage_GenerateContent"] = createExportWrapper(\n      "FPDFPage_GenerateContent",\n      1\n    );\n    Module["_FPDFPageObj_Transform"] = createExportWrapper(\n      "FPDFPageObj_Transform",\n      7\n    );\n    Module["_FPDFPageObj_TransformF"] = createExportWrapper(\n      "FPDFPageObj_TransformF",\n      2\n    );\n    Module["_FPDFPageObj_GetMatrix"] = createExportWrapper(\n      "FPDFPageObj_GetMatrix",\n      2\n    );\n    Module["_FPDFPageObj_SetMatrix"] = createExportWrapper(\n      "FPDFPageObj_SetMatrix",\n      2\n    );\n    Module["_FPDFPageObj_SetBlendMode"] = createExportWrapper(\n      "FPDFPageObj_SetBlendMode",\n      2\n    );\n    Module["_FPDFPage_TransformAnnots"] = createExportWrapper(\n      "FPDFPage_TransformAnnots",\n      7\n    );\n    Module["_FPDFPage_SetRotation"] = createExportWrapper(\n      "FPDFPage_SetRotation",\n      2\n    );\n    Module["_FPDFPageObj_SetFillColor"] = createExportWrapper(\n      "FPDFPageObj_SetFillColor",\n      5\n    );\n    Module["_FPDFPageObj_GetFillColor"] = createExportWrapper(\n      "FPDFPageObj_GetFillColor",\n      5\n    );\n    Module["_FPDFPageObj_GetBounds"] = createExportWrapper(\n      "FPDFPageObj_GetBounds",\n      5\n    );\n    Module["_FPDFPageObj_GetRotatedBounds"] = createExportWrapper("FPDFPageObj_GetRotatedBounds", 2);\n    Module["_FPDFPageObj_SetStrokeColor"] = createExportWrapper(\n      "FPDFPageObj_SetStrokeColor",\n      5\n    );\n    Module["_FPDFPageObj_GetStrokeColor"] = createExportWrapper(\n      "FPDFPageObj_GetStrokeColor",\n      5\n    );\n    Module["_FPDFPageObj_SetStrokeWidth"] = createExportWrapper(\n      "FPDFPageObj_SetStrokeWidth",\n      2\n    );\n    Module["_FPDFPageObj_GetStrokeWidth"] = createExportWrapper(\n      "FPDFPageObj_GetStrokeWidth",\n      2\n    );\n    Module["_FPDFPageObj_GetLineJoin"] = createExportWrapper(\n      "FPDFPageObj_GetLineJoin",\n      1\n    );\n    Module["_FPDFPageObj_SetLineJoin"] = createExportWrapper(\n      "FPDFPageObj_SetLineJoin",\n      2\n    );\n    Module["_FPDFPageObj_GetLineCap"] = createExportWrapper(\n      "FPDFPageObj_GetLineCap",\n      1\n    );\n    Module["_FPDFPageObj_SetLineCap"] = createExportWrapper(\n      "FPDFPageObj_SetLineCap",\n      2\n    );\n    Module["_FPDFPageObj_GetDashPhase"] = createExportWrapper(\n      "FPDFPageObj_GetDashPhase",\n      2\n    );\n    Module["_FPDFPageObj_SetDashPhase"] = createExportWrapper(\n      "FPDFPageObj_SetDashPhase",\n      2\n    );\n    Module["_FPDFPageObj_GetDashCount"] = createExportWrapper(\n      "FPDFPageObj_GetDashCount",\n      1\n    );\n    Module["_FPDFPageObj_GetDashArray"] = createExportWrapper(\n      "FPDFPageObj_GetDashArray",\n      3\n    );\n    Module["_FPDFPageObj_SetDashArray"] = createExportWrapper(\n      "FPDFPageObj_SetDashArray",\n      4\n    );\n    Module["_FPDFFormObj_CountObjects"] = createExportWrapper(\n      "FPDFFormObj_CountObjects",\n      1\n    );\n    Module["_FPDFFormObj_GetObject"] = createExportWrapper(\n      "FPDFFormObj_GetObject",\n      2\n    );\n    Module["_FPDFFormObj_RemoveObject"] = createExportWrapper(\n      "FPDFFormObj_RemoveObject",\n      2\n    );\n    Module["_FPDFPageObj_CreateNewPath"] = createExportWrapper(\n      "FPDFPageObj_CreateNewPath",\n      2\n    );\n    Module["_FPDFPageObj_CreateNewRect"] = createExportWrapper(\n      "FPDFPageObj_CreateNewRect",\n      4\n    );\n    Module["_FPDFPath_CountSegments"] = createExportWrapper(\n      "FPDFPath_CountSegments",\n      1\n    );\n    Module["_FPDFPath_GetPathSegment"] = createExportWrapper(\n      "FPDFPath_GetPathSegment",\n      2\n    );\n    Module["_FPDFPath_MoveTo"] = createExportWrapper("FPDFPath_MoveTo", 3);\n    Module["_FPDFPath_LineTo"] = createExportWrapper("FPDFPath_LineTo", 3);\n    Module["_FPDFPath_BezierTo"] = createExportWrapper(\n      "FPDFPath_BezierTo",\n      7\n    );\n    Module["_FPDFPath_Close"] = createExportWrapper("FPDFPath_Close", 1);\n    Module["_FPDFPath_SetDrawMode"] = createExportWrapper(\n      "FPDFPath_SetDrawMode",\n      3\n    );\n    Module["_FPDFPath_GetDrawMode"] = createExportWrapper(\n      "FPDFPath_GetDrawMode",\n      3\n    );\n    Module["_FPDFPathSegment_GetPoint"] = createExportWrapper(\n      "FPDFPathSegment_GetPoint",\n      3\n    );\n    Module["_FPDFPathSegment_GetType"] = createExportWrapper(\n      "FPDFPathSegment_GetType",\n      1\n    );\n    Module["_FPDFPathSegment_GetClose"] = createExportWrapper(\n      "FPDFPathSegment_GetClose",\n      1\n    );\n    Module["_FPDFPageObj_NewTextObj"] = createExportWrapper(\n      "FPDFPageObj_NewTextObj",\n      3\n    );\n    Module["_FPDFText_SetText"] = createExportWrapper(\n      "FPDFText_SetText",\n      2\n    );\n    Module["_FPDFText_SetCharcodes"] = createExportWrapper(\n      "FPDFText_SetCharcodes",\n      3\n    );\n    Module["_FPDFText_LoadFont"] = createExportWrapper(\n      "FPDFText_LoadFont",\n      5\n    );\n    Module["_FPDFText_LoadStandardFont"] = createExportWrapper(\n      "FPDFText_LoadStandardFont",\n      2\n    );\n    Module["_FPDFText_LoadCidType2Font"] = createExportWrapper(\n      "FPDFText_LoadCidType2Font",\n      6\n    );\n    Module["_FPDFTextObj_GetFontSize"] = createExportWrapper(\n      "FPDFTextObj_GetFontSize",\n      2\n    );\n    Module["_FPDFTextObj_GetText"] = createExportWrapper(\n      "FPDFTextObj_GetText",\n      4\n    );\n    Module["_FPDFTextObj_GetRenderedBitmap"] = createExportWrapper("FPDFTextObj_GetRenderedBitmap", 4);\n    Module["_FPDFFont_Close"] = createExportWrapper("FPDFFont_Close", 1);\n    Module["_FPDFPageObj_CreateTextObj"] = createExportWrapper(\n      "FPDFPageObj_CreateTextObj",\n      3\n    );\n    Module["_FPDFTextObj_GetTextRenderMode"] = createExportWrapper("FPDFTextObj_GetTextRenderMode", 1);\n    Module["_FPDFTextObj_SetTextRenderMode"] = createExportWrapper("FPDFTextObj_SetTextRenderMode", 2);\n    Module["_FPDFTextObj_GetFont"] = createExportWrapper(\n      "FPDFTextObj_GetFont",\n      1\n    );\n    Module["_FPDFFont_GetBaseFontName"] = createExportWrapper(\n      "FPDFFont_GetBaseFontName",\n      3\n    );\n    Module["_FPDFFont_GetFamilyName"] = createExportWrapper(\n      "FPDFFont_GetFamilyName",\n      3\n    );\n    Module["_FPDFFont_GetFontData"] = createExportWrapper(\n      "FPDFFont_GetFontData",\n      4\n    );\n    Module["_FPDFFont_GetIsEmbedded"] = createExportWrapper(\n      "FPDFFont_GetIsEmbedded",\n      1\n    );\n    Module["_FPDFFont_GetFlags"] = createExportWrapper(\n      "FPDFFont_GetFlags",\n      1\n    );\n    Module["_FPDFFont_GetWeight"] = createExportWrapper(\n      "FPDFFont_GetWeight",\n      1\n    );\n    Module["_FPDFFont_GetItalicAngle"] = createExportWrapper(\n      "FPDFFont_GetItalicAngle",\n      2\n    );\n    Module["_FPDFFont_GetAscent"] = createExportWrapper(\n      "FPDFFont_GetAscent",\n      3\n    );\n    Module["_FPDFFont_GetDescent"] = createExportWrapper(\n      "FPDFFont_GetDescent",\n      3\n    );\n    Module["_FPDFFont_GetGlyphWidth"] = createExportWrapper(\n      "FPDFFont_GetGlyphWidth",\n      4\n    );\n    Module["_FPDFFont_GetGlyphPath"] = createExportWrapper(\n      "FPDFFont_GetGlyphPath",\n      3\n    );\n    Module["_FPDFGlyphPath_CountGlyphSegments"] = createExportWrapper("FPDFGlyphPath_CountGlyphSegments", 1);\n    Module["_FPDFGlyphPath_GetGlyphPathSegment"] = createExportWrapper("FPDFGlyphPath_GetGlyphPathSegment", 2);\n    Module["_EPDFText_RedactInRect"] = createExportWrapper(\n      "EPDFText_RedactInRect",\n      4\n    );\n    Module["_EPDFText_RedactInQuads"] = createExportWrapper(\n      "EPDFText_RedactInQuads",\n      5\n    );\n    Module["_FPDFDoc_GetPageMode"] = createExportWrapper(\n      "FPDFDoc_GetPageMode",\n      1\n    );\n    Module["_FPDFPage_Flatten"] = createExportWrapper(\n      "FPDFPage_Flatten",\n      2\n    );\n    Module["_FPDFPage_HasFormFieldAtPoint"] = createExportWrapper("FPDFPage_HasFormFieldAtPoint", 4);\n    Module["_FPDFPage_FormFieldZOrderAtPoint"] = createExportWrapper("FPDFPage_FormFieldZOrderAtPoint", 4);\n    Module["_malloc"] = createExportWrapper("malloc", 1);\n    Module["_free"] = createExportWrapper("free", 1);\n    Module["_FORM_OnMouseMove"] = createExportWrapper(\n      "FORM_OnMouseMove",\n      5\n    );\n    Module["_FORM_OnMouseWheel"] = createExportWrapper(\n      "FORM_OnMouseWheel",\n      6\n    );\n    Module["_FORM_OnFocus"] = createExportWrapper("FORM_OnFocus", 5);\n    Module["_FORM_OnLButtonDown"] = createExportWrapper(\n      "FORM_OnLButtonDown",\n      5\n    );\n    Module["_FORM_OnLButtonUp"] = createExportWrapper(\n      "FORM_OnLButtonUp",\n      5\n    );\n    Module["_FORM_OnLButtonDoubleClick"] = createExportWrapper(\n      "FORM_OnLButtonDoubleClick",\n      5\n    );\n    Module["_FORM_OnRButtonDown"] = createExportWrapper(\n      "FORM_OnRButtonDown",\n      5\n    );\n    Module["_FORM_OnRButtonUp"] = createExportWrapper(\n      "FORM_OnRButtonUp",\n      5\n    );\n    Module["_FORM_OnKeyDown"] = createExportWrapper("FORM_OnKeyDown", 4);\n    Module["_FORM_OnKeyUp"] = createExportWrapper("FORM_OnKeyUp", 4);\n    Module["_FORM_OnChar"] = createExportWrapper("FORM_OnChar", 4);\n    Module["_FORM_GetFocusedText"] = createExportWrapper(\n      "FORM_GetFocusedText",\n      4\n    );\n    Module["_FORM_GetSelectedText"] = createExportWrapper(\n      "FORM_GetSelectedText",\n      4\n    );\n    Module["_FORM_ReplaceAndKeepSelection"] = createExportWrapper("FORM_ReplaceAndKeepSelection", 3);\n    Module["_FORM_ReplaceSelection"] = createExportWrapper(\n      "FORM_ReplaceSelection",\n      3\n    );\n    Module["_FORM_SelectAllText"] = createExportWrapper(\n      "FORM_SelectAllText",\n      2\n    );\n    Module["_FORM_CanUndo"] = createExportWrapper("FORM_CanUndo", 2);\n    Module["_FORM_CanRedo"] = createExportWrapper("FORM_CanRedo", 2);\n    Module["_FORM_Undo"] = createExportWrapper("FORM_Undo", 2);\n    Module["_FORM_Redo"] = createExportWrapper("FORM_Redo", 2);\n    Module["_FORM_ForceToKillFocus"] = createExportWrapper(\n      "FORM_ForceToKillFocus",\n      1\n    );\n    Module["_FORM_GetFocusedAnnot"] = createExportWrapper(\n      "FORM_GetFocusedAnnot",\n      3\n    );\n    Module["_FORM_SetFocusedAnnot"] = createExportWrapper(\n      "FORM_SetFocusedAnnot",\n      2\n    );\n    Module["_FPDF_FFLDraw"] = createExportWrapper("FPDF_FFLDraw", 9);\n    Module["_FPDF_SetFormFieldHighlightColor"] = createExportWrapper("FPDF_SetFormFieldHighlightColor", 3);\n    Module["_FPDF_SetFormFieldHighlightAlpha"] = createExportWrapper("FPDF_SetFormFieldHighlightAlpha", 2);\n    Module["_FPDF_RemoveFormFieldHighlight"] = createExportWrapper("FPDF_RemoveFormFieldHighlight", 1);\n    Module["_FORM_OnAfterLoadPage"] = createExportWrapper(\n      "FORM_OnAfterLoadPage",\n      2\n    );\n    Module["_FORM_OnBeforeClosePage"] = createExportWrapper(\n      "FORM_OnBeforeClosePage",\n      2\n    );\n    Module["_FORM_DoDocumentJSAction"] = createExportWrapper(\n      "FORM_DoDocumentJSAction",\n      1\n    );\n    Module["_FORM_DoDocumentOpenAction"] = createExportWrapper(\n      "FORM_DoDocumentOpenAction",\n      1\n    );\n    Module["_FORM_DoDocumentAAction"] = createExportWrapper(\n      "FORM_DoDocumentAAction",\n      2\n    );\n    Module["_FORM_DoPageAAction"] = createExportWrapper(\n      "FORM_DoPageAAction",\n      3\n    );\n    Module["_FORM_SetIndexSelected"] = createExportWrapper(\n      "FORM_SetIndexSelected",\n      4\n    );\n    Module["_FORM_IsIndexSelected"] = createExportWrapper(\n      "FORM_IsIndexSelected",\n      3\n    );\n    Module["_FPDFDoc_GetJavaScriptActionCount"] = createExportWrapper("FPDFDoc_GetJavaScriptActionCount", 1);\n    Module["_FPDFDoc_GetJavaScriptAction"] = createExportWrapper("FPDFDoc_GetJavaScriptAction", 2);\n    Module["_FPDFDoc_CloseJavaScriptAction"] = createExportWrapper("FPDFDoc_CloseJavaScriptAction", 1);\n    Module["_FPDFJavaScriptAction_GetName"] = createExportWrapper("FPDFJavaScriptAction_GetName", 3);\n    Module["_FPDFJavaScriptAction_GetScript"] = createExportWrapper("FPDFJavaScriptAction_GetScript", 3);\n    Module["_FPDF_ImportPagesByIndex"] = createExportWrapper(\n      "FPDF_ImportPagesByIndex",\n      5\n    );\n    Module["_FPDF_ImportPages"] = createExportWrapper(\n      "FPDF_ImportPages",\n      4\n    );\n    Module["_FPDF_ImportNPagesToOne"] = createExportWrapper(\n      "FPDF_ImportNPagesToOne",\n      5\n    );\n    Module["_FPDF_NewXObjectFromPage"] = createExportWrapper(\n      "FPDF_NewXObjectFromPage",\n      3\n    );\n    Module["_FPDF_CloseXObject"] = createExportWrapper(\n      "FPDF_CloseXObject",\n      1\n    );\n    Module["_FPDF_NewFormObjectFromXObject"] = createExportWrapper("FPDF_NewFormObjectFromXObject", 1);\n    Module["_FPDF_CopyViewerPreferences"] = createExportWrapper(\n      "FPDF_CopyViewerPreferences",\n      2\n    );\n    Module["_FPDF_RenderPageBitmapWithColorScheme_Start"] = createExportWrapper("FPDF_RenderPageBitmapWithColorScheme_Start", 10);\n    Module["_FPDF_RenderPageBitmap_Start"] = createExportWrapper("FPDF_RenderPageBitmap_Start", 9);\n    Module["_FPDF_RenderPage_Continue"] = createExportWrapper(\n      "FPDF_RenderPage_Continue",\n      2\n    );\n    Module["_FPDF_RenderPage_Close"] = createExportWrapper(\n      "FPDF_RenderPage_Close",\n      1\n    );\n    Module["_FPDF_SaveWithVersion"] = createExportWrapper(\n      "FPDF_SaveWithVersion",\n      4\n    );\n    Module["_FPDFText_GetCharIndexFromTextIndex"] = createExportWrapper("FPDFText_GetCharIndexFromTextIndex", 2);\n    Module["_FPDFText_GetTextIndexFromCharIndex"] = createExportWrapper("FPDFText_GetTextIndexFromCharIndex", 2);\n    Module["_FPDF_GetSignatureCount"] = createExportWrapper(\n      "FPDF_GetSignatureCount",\n      1\n    );\n    Module["_FPDF_GetSignatureObject"] = createExportWrapper(\n      "FPDF_GetSignatureObject",\n      2\n    );\n    Module["_FPDFSignatureObj_GetContents"] = createExportWrapper("FPDFSignatureObj_GetContents", 3);\n    Module["_FPDFSignatureObj_GetByteRange"] = createExportWrapper("FPDFSignatureObj_GetByteRange", 3);\n    Module["_FPDFSignatureObj_GetSubFilter"] = createExportWrapper("FPDFSignatureObj_GetSubFilter", 3);\n    Module["_FPDFSignatureObj_GetReason"] = createExportWrapper(\n      "FPDFSignatureObj_GetReason",\n      3\n    );\n    Module["_FPDFSignatureObj_GetTime"] = createExportWrapper(\n      "FPDFSignatureObj_GetTime",\n      3\n    );\n    Module["_FPDFSignatureObj_GetDocMDPPermission"] = createExportWrapper("FPDFSignatureObj_GetDocMDPPermission", 1);\n    Module["_FPDF_StructTree_GetForPage"] = createExportWrapper(\n      "FPDF_StructTree_GetForPage",\n      1\n    );\n    Module["_FPDF_StructTree_Close"] = createExportWrapper(\n      "FPDF_StructTree_Close",\n      1\n    );\n    Module["_FPDF_StructTree_CountChildren"] = createExportWrapper("FPDF_StructTree_CountChildren", 1);\n    Module["_FPDF_StructTree_GetChildAtIndex"] = createExportWrapper("FPDF_StructTree_GetChildAtIndex", 2);\n    Module["_FPDF_StructElement_GetAltText"] = createExportWrapper("FPDF_StructElement_GetAltText", 3);\n    Module["_FPDF_StructElement_GetActualText"] = createExportWrapper("FPDF_StructElement_GetActualText", 3);\n    Module["_FPDF_StructElement_GetID"] = createExportWrapper(\n      "FPDF_StructElement_GetID",\n      3\n    );\n    Module["_FPDF_StructElement_GetLang"] = createExportWrapper(\n      "FPDF_StructElement_GetLang",\n      3\n    );\n    Module["_FPDF_StructElement_GetAttributeCount"] = createExportWrapper("FPDF_StructElement_GetAttributeCount", 1);\n    Module["_FPDF_StructElement_GetAttributeAtIndex"] = createExportWrapper("FPDF_StructElement_GetAttributeAtIndex", 2);\n    Module["_FPDF_StructElement_GetStringAttribute"] = createExportWrapper("FPDF_StructElement_GetStringAttribute", 4);\n    Module["_FPDF_StructElement_GetMarkedContentID"] = createExportWrapper("FPDF_StructElement_GetMarkedContentID", 1);\n    Module["_FPDF_StructElement_GetType"] = createExportWrapper(\n      "FPDF_StructElement_GetType",\n      3\n    );\n    Module["_FPDF_StructElement_GetObjType"] = createExportWrapper("FPDF_StructElement_GetObjType", 3);\n    Module["_FPDF_StructElement_GetTitle"] = createExportWrapper("FPDF_StructElement_GetTitle", 3);\n    Module["_FPDF_StructElement_CountChildren"] = createExportWrapper("FPDF_StructElement_CountChildren", 1);\n    Module["_FPDF_StructElement_GetChildAtIndex"] = createExportWrapper("FPDF_StructElement_GetChildAtIndex", 2);\n    Module["_FPDF_StructElement_GetChildMarkedContentID"] = createExportWrapper("FPDF_StructElement_GetChildMarkedContentID", 2);\n    Module["_FPDF_StructElement_GetParent"] = createExportWrapper("FPDF_StructElement_GetParent", 1);\n    Module["_FPDF_StructElement_Attr_GetCount"] = createExportWrapper("FPDF_StructElement_Attr_GetCount", 1);\n    Module["_FPDF_StructElement_Attr_GetName"] = createExportWrapper("FPDF_StructElement_Attr_GetName", 5);\n    Module["_FPDF_StructElement_Attr_GetValue"] = createExportWrapper("FPDF_StructElement_Attr_GetValue", 2);\n    Module["_FPDF_StructElement_Attr_GetType"] = createExportWrapper("FPDF_StructElement_Attr_GetType", 1);\n    Module["_FPDF_StructElement_Attr_GetBooleanValue"] = createExportWrapper("FPDF_StructElement_Attr_GetBooleanValue", 2);\n    Module["_FPDF_StructElement_Attr_GetNumberValue"] = createExportWrapper("FPDF_StructElement_Attr_GetNumberValue", 2);\n    Module["_FPDF_StructElement_Attr_GetStringValue"] = createExportWrapper("FPDF_StructElement_Attr_GetStringValue", 4);\n    Module["_FPDF_StructElement_Attr_GetBlobValue"] = createExportWrapper("FPDF_StructElement_Attr_GetBlobValue", 4);\n    Module["_FPDF_StructElement_Attr_CountChildren"] = createExportWrapper("FPDF_StructElement_Attr_CountChildren", 1);\n    Module["_FPDF_StructElement_Attr_GetChildAtIndex"] = createExportWrapper("FPDF_StructElement_Attr_GetChildAtIndex", 2);\n    Module["_FPDF_StructElement_GetMarkedContentIdCount"] = createExportWrapper("FPDF_StructElement_GetMarkedContentIdCount", 1);\n    Module["_FPDF_StructElement_GetMarkedContentIdAtIndex"] = createExportWrapper("FPDF_StructElement_GetMarkedContentIdAtIndex", 2);\n    Module["_FPDF_AddInstalledFont"] = createExportWrapper(\n      "FPDF_AddInstalledFont",\n      3\n    );\n    Module["_FPDF_SetSystemFontInfo"] = createExportWrapper(\n      "FPDF_SetSystemFontInfo",\n      1\n    );\n    Module["_FPDF_GetDefaultTTFMap"] = createExportWrapper(\n      "FPDF_GetDefaultTTFMap",\n      0\n    );\n    Module["_FPDF_GetDefaultTTFMapCount"] = createExportWrapper(\n      "FPDF_GetDefaultTTFMapCount",\n      0\n    );\n    Module["_FPDF_GetDefaultTTFMapEntry"] = createExportWrapper(\n      "FPDF_GetDefaultTTFMapEntry",\n      1\n    );\n    Module["_FPDF_GetDefaultSystemFontInfo"] = createExportWrapper("FPDF_GetDefaultSystemFontInfo", 0);\n    Module["_FPDF_FreeDefaultSystemFontInfo"] = createExportWrapper("FPDF_FreeDefaultSystemFontInfo", 1);\n    Module["_FPDFText_LoadPage"] = createExportWrapper(\n      "FPDFText_LoadPage",\n      1\n    );\n    Module["_FPDFText_ClosePage"] = createExportWrapper(\n      "FPDFText_ClosePage",\n      1\n    );\n    Module["_FPDFText_CountChars"] = createExportWrapper(\n      "FPDFText_CountChars",\n      1\n    );\n    Module["_FPDFText_GetUnicode"] = createExportWrapper(\n      "FPDFText_GetUnicode",\n      2\n    );\n    Module["_FPDFText_GetTextObject"] = createExportWrapper(\n      "FPDFText_GetTextObject",\n      2\n    );\n    Module["_FPDFText_IsGenerated"] = createExportWrapper(\n      "FPDFText_IsGenerated",\n      2\n    );\n    Module["_FPDFText_IsHyphen"] = createExportWrapper(\n      "FPDFText_IsHyphen",\n      2\n    );\n    Module["_FPDFText_HasUnicodeMapError"] = createExportWrapper("FPDFText_HasUnicodeMapError", 2);\n    Module["_FPDFText_GetFontSize"] = createExportWrapper(\n      "FPDFText_GetFontSize",\n      2\n    );\n    Module["_FPDFText_GetFontInfo"] = createExportWrapper(\n      "FPDFText_GetFontInfo",\n      5\n    );\n    Module["_FPDFText_GetFontWeight"] = createExportWrapper(\n      "FPDFText_GetFontWeight",\n      2\n    );\n    Module["_FPDFText_GetFillColor"] = createExportWrapper(\n      "FPDFText_GetFillColor",\n      6\n    );\n    Module["_FPDFText_GetStrokeColor"] = createExportWrapper(\n      "FPDFText_GetStrokeColor",\n      6\n    );\n    Module["_FPDFText_GetCharAngle"] = createExportWrapper(\n      "FPDFText_GetCharAngle",\n      2\n    );\n    Module["_FPDFText_GetCharBox"] = createExportWrapper(\n      "FPDFText_GetCharBox",\n      6\n    );\n    Module["_FPDFText_GetLooseCharBox"] = createExportWrapper(\n      "FPDFText_GetLooseCharBox",\n      3\n    );\n    Module["_FPDFText_GetMatrix"] = createExportWrapper(\n      "FPDFText_GetMatrix",\n      3\n    );\n    Module["_FPDFText_GetCharOrigin"] = createExportWrapper(\n      "FPDFText_GetCharOrigin",\n      4\n    );\n    Module["_FPDFText_GetCharIndexAtPos"] = createExportWrapper(\n      "FPDFText_GetCharIndexAtPos",\n      5\n    );\n    Module["_FPDFText_GetText"] = createExportWrapper(\n      "FPDFText_GetText",\n      4\n    );\n    Module["_FPDFText_CountRects"] = createExportWrapper(\n      "FPDFText_CountRects",\n      3\n    );\n    Module["_FPDFText_GetRect"] = createExportWrapper(\n      "FPDFText_GetRect",\n      6\n    );\n    Module["_FPDFText_GetBoundedText"] = createExportWrapper(\n      "FPDFText_GetBoundedText",\n      7\n    );\n    Module["_FPDFText_FindStart"] = createExportWrapper(\n      "FPDFText_FindStart",\n      4\n    );\n    Module["_FPDFText_FindNext"] = createExportWrapper(\n      "FPDFText_FindNext",\n      1\n    );\n    Module["_FPDFText_FindPrev"] = createExportWrapper(\n      "FPDFText_FindPrev",\n      1\n    );\n    Module["_FPDFText_GetSchResultIndex"] = createExportWrapper(\n      "FPDFText_GetSchResultIndex",\n      1\n    );\n    Module["_FPDFText_GetSchCount"] = createExportWrapper(\n      "FPDFText_GetSchCount",\n      1\n    );\n    Module["_FPDFText_FindClose"] = createExportWrapper(\n      "FPDFText_FindClose",\n      1\n    );\n    Module["_FPDFLink_LoadWebLinks"] = createExportWrapper(\n      "FPDFLink_LoadWebLinks",\n      1\n    );\n    Module["_FPDFLink_CountWebLinks"] = createExportWrapper(\n      "FPDFLink_CountWebLinks",\n      1\n    );\n    Module["_FPDFLink_GetURL"] = createExportWrapper("FPDFLink_GetURL", 4);\n    Module["_FPDFLink_CountRects"] = createExportWrapper(\n      "FPDFLink_CountRects",\n      2\n    );\n    Module["_FPDFLink_GetRect"] = createExportWrapper(\n      "FPDFLink_GetRect",\n      7\n    );\n    Module["_FPDFLink_GetTextRange"] = createExportWrapper(\n      "FPDFLink_GetTextRange",\n      4\n    );\n    Module["_FPDFLink_CloseWebLinks"] = createExportWrapper(\n      "FPDFLink_CloseWebLinks",\n      1\n    );\n    Module["_FPDFPage_GetDecodedThumbnailData"] = createExportWrapper("FPDFPage_GetDecodedThumbnailData", 3);\n    Module["_FPDFPage_GetRawThumbnailData"] = createExportWrapper("FPDFPage_GetRawThumbnailData", 3);\n    Module["_FPDFPage_GetThumbnailAsBitmap"] = createExportWrapper("FPDFPage_GetThumbnailAsBitmap", 1);\n    Module["_FPDFPage_SetMediaBox"] = createExportWrapper(\n      "FPDFPage_SetMediaBox",\n      5\n    );\n    Module["_FPDFPage_SetCropBox"] = createExportWrapper(\n      "FPDFPage_SetCropBox",\n      5\n    );\n    Module["_FPDFPage_SetBleedBox"] = createExportWrapper(\n      "FPDFPage_SetBleedBox",\n      5\n    );\n    Module["_FPDFPage_SetTrimBox"] = createExportWrapper(\n      "FPDFPage_SetTrimBox",\n      5\n    );\n    Module["_FPDFPage_SetArtBox"] = createExportWrapper(\n      "FPDFPage_SetArtBox",\n      5\n    );\n    Module["_FPDFPage_GetMediaBox"] = createExportWrapper(\n      "FPDFPage_GetMediaBox",\n      5\n    );\n    Module["_FPDFPage_GetCropBox"] = createExportWrapper(\n      "FPDFPage_GetCropBox",\n      5\n    );\n    Module["_FPDFPage_GetBleedBox"] = createExportWrapper(\n      "FPDFPage_GetBleedBox",\n      5\n    );\n    Module["_FPDFPage_GetTrimBox"] = createExportWrapper(\n      "FPDFPage_GetTrimBox",\n      5\n    );\n    Module["_FPDFPage_GetArtBox"] = createExportWrapper(\n      "FPDFPage_GetArtBox",\n      5\n    );\n    Module["_FPDFPage_TransFormWithClip"] = createExportWrapper(\n      "FPDFPage_TransFormWithClip",\n      3\n    );\n    Module["_FPDFPageObj_TransformClipPath"] = createExportWrapper("FPDFPageObj_TransformClipPath", 7);\n    Module["_FPDFPageObj_GetClipPath"] = createExportWrapper(\n      "FPDFPageObj_GetClipPath",\n      1\n    );\n    Module["_FPDFClipPath_CountPaths"] = createExportWrapper(\n      "FPDFClipPath_CountPaths",\n      1\n    );\n    Module["_FPDFClipPath_CountPathSegments"] = createExportWrapper("FPDFClipPath_CountPathSegments", 2);\n    Module["_FPDFClipPath_GetPathSegment"] = createExportWrapper("FPDFClipPath_GetPathSegment", 3);\n    Module["_FPDF_CreateClipPath"] = createExportWrapper(\n      "FPDF_CreateClipPath",\n      4\n    );\n    Module["_FPDF_DestroyClipPath"] = createExportWrapper(\n      "FPDF_DestroyClipPath",\n      1\n    );\n    Module["_FPDFPage_InsertClipPath"] = createExportWrapper(\n      "FPDFPage_InsertClipPath",\n      2\n    );\n    Module["_FPDF_InitLibrary"] = createExportWrapper(\n      "FPDF_InitLibrary",\n      0\n    );\n    Module["_FPDF_DestroyLibrary"] = createExportWrapper(\n      "FPDF_DestroyLibrary",\n      0\n    );\n    Module["_FPDF_SetSandBoxPolicy"] = createExportWrapper(\n      "FPDF_SetSandBoxPolicy",\n      2\n    );\n    Module["_FPDF_LoadDocument"] = createExportWrapper(\n      "FPDF_LoadDocument",\n      2\n    );\n    Module["_FPDF_GetFormType"] = createExportWrapper(\n      "FPDF_GetFormType",\n      1\n    );\n    Module["_FPDF_LoadXFA"] = createExportWrapper("FPDF_LoadXFA", 1);\n    Module["_FPDF_LoadMemDocument"] = createExportWrapper(\n      "FPDF_LoadMemDocument",\n      3\n    );\n    Module["_FPDF_LoadMemDocument64"] = createExportWrapper(\n      "FPDF_LoadMemDocument64",\n      3\n    );\n    Module["_FPDF_LoadCustomDocument"] = createExportWrapper(\n      "FPDF_LoadCustomDocument",\n      2\n    );\n    Module["_FPDF_GetFileVersion"] = createExportWrapper(\n      "FPDF_GetFileVersion",\n      2\n    );\n    Module["_FPDF_DocumentHasValidCrossReferenceTable"] = createExportWrapper("FPDF_DocumentHasValidCrossReferenceTable", 1);\n    Module["_FPDF_GetDocPermissions"] = createExportWrapper(\n      "FPDF_GetDocPermissions",\n      1\n    );\n    Module["_FPDF_GetDocUserPermissions"] = createExportWrapper(\n      "FPDF_GetDocUserPermissions",\n      1\n    );\n    Module["_FPDF_GetSecurityHandlerRevision"] = createExportWrapper("FPDF_GetSecurityHandlerRevision", 1);\n    Module["_FPDF_GetPageCount"] = createExportWrapper(\n      "FPDF_GetPageCount",\n      1\n    );\n    Module["_FPDF_LoadPage"] = createExportWrapper("FPDF_LoadPage", 2);\n    Module["_FPDF_GetPageWidthF"] = createExportWrapper(\n      "FPDF_GetPageWidthF",\n      1\n    );\n    Module["_FPDF_GetPageWidth"] = createExportWrapper(\n      "FPDF_GetPageWidth",\n      1\n    );\n    Module["_FPDF_GetPageHeightF"] = createExportWrapper(\n      "FPDF_GetPageHeightF",\n      1\n    );\n    Module["_FPDF_GetPageHeight"] = createExportWrapper(\n      "FPDF_GetPageHeight",\n      1\n    );\n    Module["_FPDF_GetPageBoundingBox"] = createExportWrapper(\n      "FPDF_GetPageBoundingBox",\n      2\n    );\n    Module["_FPDF_RenderPageBitmap"] = createExportWrapper(\n      "FPDF_RenderPageBitmap",\n      8\n    );\n    Module["_FPDF_RenderPageBitmapWithMatrix"] = createExportWrapper("FPDF_RenderPageBitmapWithMatrix", 5);\n    Module["_EPDF_RenderAnnotBitmap"] = createExportWrapper(\n      "EPDF_RenderAnnotBitmap",\n      6\n    );\n    Module["_FPDF_ClosePage"] = createExportWrapper("FPDF_ClosePage", 1);\n    Module["_FPDF_CloseDocument"] = createExportWrapper(\n      "FPDF_CloseDocument",\n      1\n    );\n    Module["_FPDF_GetLastError"] = createExportWrapper(\n      "FPDF_GetLastError",\n      0\n    );\n    Module["_FPDF_DeviceToPage"] = createExportWrapper(\n      "FPDF_DeviceToPage",\n      10\n    );\n    Module["_FPDF_PageToDevice"] = createExportWrapper(\n      "FPDF_PageToDevice",\n      10\n    );\n    Module["_FPDFBitmap_Create"] = createExportWrapper(\n      "FPDFBitmap_Create",\n      3\n    );\n    Module["_FPDFBitmap_CreateEx"] = createExportWrapper(\n      "FPDFBitmap_CreateEx",\n      5\n    );\n    Module["_FPDFBitmap_GetFormat"] = createExportWrapper(\n      "FPDFBitmap_GetFormat",\n      1\n    );\n    Module["_FPDFBitmap_FillRect"] = createExportWrapper(\n      "FPDFBitmap_FillRect",\n      6\n    );\n    Module["_FPDFBitmap_GetBuffer"] = createExportWrapper(\n      "FPDFBitmap_GetBuffer",\n      1\n    );\n    Module["_FPDFBitmap_GetWidth"] = createExportWrapper(\n      "FPDFBitmap_GetWidth",\n      1\n    );\n    Module["_FPDFBitmap_GetHeight"] = createExportWrapper(\n      "FPDFBitmap_GetHeight",\n      1\n    );\n    Module["_FPDFBitmap_GetStride"] = createExportWrapper(\n      "FPDFBitmap_GetStride",\n      1\n    );\n    Module["_FPDFBitmap_Destroy"] = createExportWrapper(\n      "FPDFBitmap_Destroy",\n      1\n    );\n    Module["_FPDF_GetPageSizeByIndexF"] = createExportWrapper(\n      "FPDF_GetPageSizeByIndexF",\n      3\n    );\n    Module["_EPDF_GetPageRotationByIndex"] = createExportWrapper("EPDF_GetPageRotationByIndex", 2);\n    Module["_FPDF_GetPageSizeByIndex"] = createExportWrapper(\n      "FPDF_GetPageSizeByIndex",\n      4\n    );\n    Module["_FPDF_VIEWERREF_GetPrintScaling"] = createExportWrapper("FPDF_VIEWERREF_GetPrintScaling", 1);\n    Module["_FPDF_VIEWERREF_GetNumCopies"] = createExportWrapper("FPDF_VIEWERREF_GetNumCopies", 1);\n    Module["_FPDF_VIEWERREF_GetPrintPageRange"] = createExportWrapper("FPDF_VIEWERREF_GetPrintPageRange", 1);\n    Module["_FPDF_VIEWERREF_GetPrintPageRangeCount"] = createExportWrapper("FPDF_VIEWERREF_GetPrintPageRangeCount", 1);\n    Module["_FPDF_VIEWERREF_GetPrintPageRangeElement"] = createExportWrapper("FPDF_VIEWERREF_GetPrintPageRangeElement", 2);\n    Module["_FPDF_VIEWERREF_GetDuplex"] = createExportWrapper(\n      "FPDF_VIEWERREF_GetDuplex",\n      1\n    );\n    Module["_FPDF_VIEWERREF_GetName"] = createExportWrapper(\n      "FPDF_VIEWERREF_GetName",\n      4\n    );\n    Module["_FPDF_CountNamedDests"] = createExportWrapper(\n      "FPDF_CountNamedDests",\n      1\n    );\n    Module["_FPDF_GetNamedDestByName"] = createExportWrapper(\n      "FPDF_GetNamedDestByName",\n      2\n    );\n    Module["_FPDF_GetNamedDest"] = createExportWrapper(\n      "FPDF_GetNamedDest",\n      4\n    );\n    Module["_FPDF_GetXFAPacketCount"] = createExportWrapper(\n      "FPDF_GetXFAPacketCount",\n      1\n    );\n    Module["_FPDF_GetXFAPacketName"] = createExportWrapper(\n      "FPDF_GetXFAPacketName",\n      4\n    );\n    Module["_FPDF_GetXFAPacketContent"] = createExportWrapper(\n      "FPDF_GetXFAPacketContent",\n      5\n    );\n    Module["_FPDF_GetTrailerEnds"] = createExportWrapper(\n      "FPDF_GetTrailerEnds",\n      3\n    );\n    var _fflush = createExportWrapper("fflush", 1);\n    var _emscripten_builtin_memalign = createExportWrapper("emscripten_builtin_memalign", 2);\n    var _strerror = createExportWrapper("strerror", 1);\n    var _setThrew = createExportWrapper("setThrew", 2);\n    var _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports["emscripten_stack_init"])();\n    var _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports["emscripten_stack_get_end"])();\n    var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(a0);\n    var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);\n    var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();\n    Module["dynCall_ji"] = createExportWrapper("dynCall_ji", 2);\n    Module["dynCall_jij"] = createExportWrapper("dynCall_jij", 4);\n    Module["dynCall_iiij"] = createExportWrapper("dynCall_iiij", 5);\n    Module["dynCall_iij"] = createExportWrapper("dynCall_iij", 4);\n    Module["dynCall_j"] = createExportWrapper("dynCall_j", 1);\n    Module["dynCall_jji"] = createExportWrapper("dynCall_jji", 4);\n    Module["dynCall_iji"] = createExportWrapper("dynCall_iji", 4);\n    Module["dynCall_viijii"] = createExportWrapper("dynCall_viijii", 7);\n    Module["dynCall_iiji"] = createExportWrapper("dynCall_iiji", 5);\n    Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji", 5);\n    Module["dynCall_iiiiij"] = createExportWrapper("dynCall_iiiiij", 7);\n    Module["dynCall_iiiiijj"] = createExportWrapper("dynCall_iiiiijj", 9);\n    Module["dynCall_iiiiiijj"] = createExportWrapper(\n      "dynCall_iiiiiijj",\n      10\n    );\n    Module["dynCall_viji"] = createExportWrapper("dynCall_viji", 5);\n    function invoke_viii(index, a1, a2, a3) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)(a1, a2, a3);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_ii(index, a1) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_iii(index, a1, a2) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_iiii(index, a1, a2, a3) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2, a3);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_viiii(index, a1, a2, a3, a4) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)(a1, a2, a3, a4);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_iiiii(index, a1, a2, a3, a4) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2, a3, a4);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_v(index) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)();\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_vii(index, a1, a2) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)(a1, a2);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    Module["wasmExports"] = wasmExports;\n    Module["ccall"] = ccall;\n    Module["cwrap"] = cwrap;\n    Module["addFunction"] = addFunction;\n    Module["removeFunction"] = removeFunction;\n    Module["setValue"] = setValue;\n    Module["getValue"] = getValue;\n    Module["UTF8ToString"] = UTF8ToString;\n    Module["stringToUTF8"] = stringToUTF8;\n    Module["UTF16ToString"] = UTF16ToString;\n    Module["stringToUTF16"] = stringToUTF16;\n    var missingLibrarySymbols = [\n      "writeI53ToI64",\n      "writeI53ToI64Clamped",\n      "writeI53ToI64Signaling",\n      "writeI53ToU64Clamped",\n      "writeI53ToU64Signaling",\n      "readI53FromI64",\n      "readI53FromU64",\n      "convertI32PairToI53",\n      "convertU32PairToI53",\n      "getTempRet0",\n      "setTempRet0",\n      "exitJS",\n      "inetPton4",\n      "inetNtop4",\n      "inetPton6",\n      "inetNtop6",\n      "readSockaddr",\n      "writeSockaddr",\n      "emscriptenLog",\n      "readEmAsmArgs",\n      "jstoi_q",\n      "listenOnce",\n      "autoResumeAudioContext",\n      "dynCallLegacy",\n      "getDynCaller",\n      "dynCall",\n      "handleException",\n      "keepRuntimeAlive",\n      "runtimeKeepalivePush",\n      "runtimeKeepalivePop",\n      "callUserCallback",\n      "maybeExit",\n      "asmjsMangle",\n      "HandleAllocator",\n      "getNativeTypeSize",\n      "STACK_SIZE",\n      "STACK_ALIGN",\n      "POINTER_SIZE",\n      "ASSERTIONS",\n      "reallyNegative",\n      "unSign",\n      "strLen",\n      "reSign",\n      "formatString",\n      "intArrayToString",\n      "AsciiToString",\n      "lengthBytesUTF16",\n      "UTF32ToString",\n      "stringToUTF32",\n      "lengthBytesUTF32",\n      "stringToNewUTF8",\n      "registerKeyEventCallback",\n      "maybeCStringToJsString",\n      "findEventTarget",\n      "getBoundingClientRect",\n      "fillMouseEventData",\n      "registerMouseEventCallback",\n      "registerWheelEventCallback",\n      "registerUiEventCallback",\n      "registerFocusEventCallback",\n      "fillDeviceOrientationEventData",\n      "registerDeviceOrientationEventCallback",\n      "fillDeviceMotionEventData",\n      "registerDeviceMotionEventCallback",\n      "screenOrientation",\n      "fillOrientationChangeEventData",\n      "registerOrientationChangeEventCallback",\n      "fillFullscreenChangeEventData",\n      "registerFullscreenChangeEventCallback",\n      "JSEvents_requestFullscreen",\n      "JSEvents_resizeCanvasForFullscreen",\n      "registerRestoreOldStyle",\n      "hideEverythingExceptGivenElement",\n      "restoreHiddenElements",\n      "setLetterbox",\n      "softFullscreenResizeWebGLRenderTarget",\n      "doRequestFullscreen",\n      "fillPointerlockChangeEventData",\n      "registerPointerlockChangeEventCallback",\n      "registerPointerlockErrorEventCallback",\n      "requestPointerLock",\n      "fillVisibilityChangeEventData",\n      "registerVisibilityChangeEventCallback",\n      "registerTouchEventCallback",\n      "fillGamepadEventData",\n      "registerGamepadEventCallback",\n      "registerBeforeUnloadEventCallback",\n      "fillBatteryEventData",\n      "battery",\n      "registerBatteryEventCallback",\n      "setCanvasElementSize",\n      "getCanvasElementSize",\n      "jsStackTrace",\n      "getCallstack",\n      "convertPCtoSourceLocation",\n      "checkWasiClock",\n      "wasiRightsToMuslOFlags",\n      "wasiOFlagsToMuslOFlags",\n      "createDyncallWrapper",\n      "safeSetTimeout",\n      "setImmediateWrapped",\n      "clearImmediateWrapped",\n      "polyfillSetImmediate",\n      "registerPostMainLoop",\n      "registerPreMainLoop",\n      "getPromise",\n      "makePromise",\n      "idsToPromises",\n      "makePromiseCallback",\n      "ExceptionInfo",\n      "findMatchingCatch",\n      "Browser_asyncPrepareDataCounter",\n      "safeRequestAnimationFrame",\n      "arraySum",\n      "addDays",\n      "getSocketFromFD",\n      "getSocketAddress",\n      "FS_unlink",\n      "FS_mkdirTree",\n      "_setNetworkCallback",\n      "heapObjectForWebGLType",\n      "toTypedArrayIndex",\n      "webgl_enable_ANGLE_instanced_arrays",\n      "webgl_enable_OES_vertex_array_object",\n      "webgl_enable_WEBGL_draw_buffers",\n      "webgl_enable_WEBGL_multi_draw",\n      "webgl_enable_EXT_polygon_offset_clamp",\n      "webgl_enable_EXT_clip_control",\n      "webgl_enable_WEBGL_polygon_mode",\n      "emscriptenWebGLGet",\n      "computeUnpackAlignedImageSize",\n      "colorChannelsInGlTextureFormat",\n      "emscriptenWebGLGetTexPixelData",\n      "emscriptenWebGLGetUniform",\n      "webglGetUniformLocation",\n      "webglPrepareUniformLocationsBeforeFirstUse",\n      "webglGetLeftBracePos",\n      "emscriptenWebGLGetVertexAttrib",\n      "__glGetActiveAttribOrUniform",\n      "writeGLArray",\n      "registerWebGlEventCallback",\n      "runAndAbortIfError",\n      "ALLOC_NORMAL",\n      "ALLOC_STACK",\n      "allocate",\n      "writeStringToMemory",\n      "writeAsciiToMemory",\n      "setErrNo",\n      "demangle",\n      "stackTrace"\n    ];\n    missingLibrarySymbols.forEach(missingLibrarySymbol);\n    var unexportedSymbols = [\n      "run",\n      "addOnPreRun",\n      "addOnInit",\n      "addOnPreMain",\n      "addOnExit",\n      "addOnPostRun",\n      "addRunDependency",\n      "removeRunDependency",\n      "out",\n      "err",\n      "callMain",\n      "abort",\n      "wasmMemory",\n      "writeStackCookie",\n      "checkStackCookie",\n      "convertI32PairToI53Checked",\n      "stackSave",\n      "stackRestore",\n      "stackAlloc",\n      "ptrToString",\n      "zeroMemory",\n      "getHeapMax",\n      "growMemory",\n      "ENV",\n      "ERRNO_CODES",\n      "strError",\n      "DNS",\n      "Protocols",\n      "Sockets",\n      "initRandomFill",\n      "randomFill",\n      "timers",\n      "warnOnce",\n      "readEmAsmArgsArray",\n      "jstoi_s",\n      "getExecutableName",\n      "asyncLoad",\n      "alignMemory",\n      "mmapAlloc",\n      "wasmTable",\n      "noExitRuntime",\n      "getCFunc",\n      "uleb128Encode",\n      "sigToWasmTypes",\n      "generateFuncType",\n      "convertJsFunctionToWasm",\n      "freeTableIndexes",\n      "functionsInTableMap",\n      "getEmptyTableSlot",\n      "updateTableMap",\n      "getFunctionAddress",\n      "PATH",\n      "PATH_FS",\n      "UTF8Decoder",\n      "UTF8ArrayToString",\n      "stringToUTF8Array",\n      "lengthBytesUTF8",\n      "intArrayFromString",\n      "stringToAscii",\n      "UTF16Decoder",\n      "stringToUTF8OnStack",\n      "writeArrayToMemory",\n      "JSEvents",\n      "specialHTMLTargets",\n      "findCanvasEventTarget",\n      "currentFullscreenStrategy",\n      "restoreOldWindowedStyle",\n      "UNWIND_CACHE",\n      "ExitStatus",\n      "getEnvStrings",\n      "doReadv",\n      "doWritev",\n      "promiseMap",\n      "uncaughtExceptionCount",\n      "exceptionLast",\n      "exceptionCaught",\n      "Browser",\n      "getPreloadedImageData__data",\n      "wget",\n      "MONTH_DAYS_REGULAR",\n      "MONTH_DAYS_LEAP",\n      "MONTH_DAYS_REGULAR_CUMULATIVE",\n      "MONTH_DAYS_LEAP_CUMULATIVE",\n      "isLeapYear",\n      "ydayFromDate",\n      "SYSCALLS",\n      "preloadPlugins",\n      "FS_createPreloadedFile",\n      "FS_modeStringToFlags",\n      "FS_getMode",\n      "FS_stdin_getChar_buffer",\n      "FS_stdin_getChar",\n      "FS_createPath",\n      "FS_createDevice",\n      "FS_readFile",\n      "FS",\n      "FS_createDataFile",\n      "FS_createLazyFile",\n      "MEMFS",\n      "TTY",\n      "PIPEFS",\n      "SOCKFS",\n      "tempFixedLengthArray",\n      "miniTempWebGLFloatBuffers",\n      "miniTempWebGLIntBuffers",\n      "GL",\n      "AL",\n      "GLUT",\n      "EGL",\n      "GLEW",\n      "IDBStore",\n      "SDL",\n      "SDL_gfx",\n      "allocateUTF8",\n      "allocateUTF8OnStack",\n      "print",\n      "printErr"\n    ];\n    unexportedSymbols.forEach(unexportedRuntimeSymbol);\n    var calledRun;\n    var calledPrerun;\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n    function stackCheckInit() {\n      _emscripten_stack_init();\n      writeStackCookie();\n    }\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n      stackCheckInit();\n      if (!calledPrerun) {\n        calledPrerun = 1;\n        preRun();\n        if (runDependencies > 0) {\n          return;\n        }\n      }\n      function doRun() {\n        var _a;\n        if (calledRun) return;\n        calledRun = 1;\n        Module["calledRun"] = 1;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        (_a = Module["onRuntimeInitialized"]) == null ? void 0 : _a.call(Module);\n        assert(\n          !Module["_main"],\n          \'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]\'\n        );\n        postRun();\n      }\n      if (Module["setStatus"]) {\n        Module["setStatus"]("Running...");\n        setTimeout(() => {\n          setTimeout(() => Module["setStatus"](""), 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n      checkStackCookie();\n    }\n    if (Module["preInit"]) {\n      if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];\n      while (Module["preInit"].length > 0) {\n        Module["preInit"].pop()();\n      }\n    }\n    run();\n    moduleRtn = readyPromise;\n    for (const prop of Object.keys(Module)) {\n      if (!(prop in moduleArg)) {\n        Object.defineProperty(moduleArg, prop, {\n          configurable: true,\n          get() {\n            abort(\n              `Access to module property (\'${prop}\') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`\n            );\n          }\n        });\n      }\n    }\n    return moduleRtn;\n  };\n})();\nconst functions = {\n  EPDF_GetMetaKeyCount: [["number", "boolean"], "number"],\n  EPDF_GetMetaKeyName: [\n    ["number", "number", "boolean", "number", "number"],\n    "number"\n  ],\n  EPDF_GetMetaTrapped: [["number"], "number"],\n  EPDF_GetPageRotationByIndex: [["number", "number"], "number"],\n  EPDF_HasMetaText: [["number", "string"], "boolean"],\n  EPDF_PNG_EncodeRGBA: [\n    ["number", "number", "number", "number", "number", "number"],\n    "number"\n  ],\n  EPDF_RenderAnnotBitmap: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDF_SetMetaText: [["number", "string", "number"], "boolean"],\n  EPDF_SetMetaTrapped: [["number", "number"], "boolean"],\n  EPDFAction_CreateGoTo: [["number", "number"], "number"],\n  EPDFAction_CreateGoToNamed: [["number", "string"], "number"],\n  EPDFAction_CreateLaunch: [["number", "number"], "number"],\n  EPDFAction_CreateRemoteGoToByName: [["number", "number", "number"], "number"],\n  EPDFAction_CreateRemoteGoToDest: [["number", "number", "number"], "number"],\n  EPDFAction_CreateURI: [["number", "string"], "number"],\n  EPDFAnnot_ClearColor: [["number", "number"], "boolean"],\n  EPDFAnnot_GenerateAppearance: [["number"], "boolean"],\n  EPDFAnnot_GenerateAppearanceWithBlend: [["number", "number"], "boolean"],\n  EPDFAnnot_GetBlendMode: [["number"], "number"],\n  EPDFAnnot_GetBorderDashPattern: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_GetBorderDashPatternCount: [["number"], "number"],\n  EPDFAnnot_GetBorderEffect: [["number", "number"], "boolean"],\n  EPDFAnnot_GetBorderStyle: [["number", "number"], "number"],\n  EPDFAnnot_GetColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDFAnnot_GetDefaultAppearance: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDFAnnot_GetIcon: [["number"], "number"],\n  EPDFAnnot_GetIntent: [["number", "number", "number"], "number"],\n  EPDFAnnot_GetLineEndings: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_GetOpacity: [["number", "number"], "boolean"],\n  EPDFAnnot_GetRectangleDifferences: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDFAnnot_GetRichContent: [["number", "number", "number"], "number"],\n  EPDFAnnot_GetTextAlignment: [["number"], "number"],\n  EPDFAnnot_GetVerticalAlignment: [["number"], "number"],\n  EPDFAnnot_SetBorderDashPattern: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_SetBorderStyle: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_SetColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDFAnnot_SetDefaultAppearance: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDFAnnot_SetIcon: [["number", "number"], "boolean"],\n  EPDFAnnot_SetIntent: [["number", "string"], "boolean"],\n  EPDFAnnot_SetLine: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_SetLineEndings: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_SetLinkedAnnot: [["number", "string", "number"], "boolean"],\n  EPDFAnnot_SetOpacity: [["number", "number"], "boolean"],\n  EPDFAnnot_SetTextAlignment: [["number", "number"], "boolean"],\n  EPDFAnnot_SetVerticalAlignment: [["number", "number"], "boolean"],\n  EPDFAnnot_SetVertices: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_UpdateAppearanceToRect: [["number", "number"], "boolean"],\n  EPDFAttachment_GetDescription: [["number", "number", "number"], "number"],\n  EPDFAttachment_GetIntegerValue: [["number", "string", "number"], "boolean"],\n  EPDFAttachment_SetDescription: [["number", "number"], "boolean"],\n  EPDFAttachment_SetSubtype: [["number", "string"], "boolean"],\n  EPDFBookmark_AppendChild: [["number", "number", "number"], "number"],\n  EPDFBookmark_Clear: [["number"], "boolean"],\n  EPDFBookmark_ClearTarget: [["number"], "boolean"],\n  EPDFBookmark_Create: [["number", "number"], "number"],\n  EPDFBookmark_Delete: [["number", "number"], "boolean"],\n  EPDFBookmark_InsertAfter: [["number", "number", "number", "number"], "number"],\n  EPDFBookmark_SetAction: [["number", "number", "number"], "boolean"],\n  EPDFBookmark_SetDest: [["number", "number", "number"], "boolean"],\n  EPDFBookmark_SetTitle: [["number", "number"], "boolean"],\n  EPDFCatalog_GetLanguage: [["number", "number", "number"], "number"],\n  EPDFDest_CreateRemoteView: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  EPDFDest_CreateRemoteXYZ: [\n    ["number", "number", "boolean", "number", "boolean", "number", "boolean", "number"],\n    "number"\n  ],\n  EPDFDest_CreateView: [["number", "number", "number", "number"], "number"],\n  EPDFDest_CreateXYZ: [\n    ["number", "boolean", "number", "boolean", "number", "boolean", "number"],\n    "number"\n  ],\n  EPDFNamedDest_Remove: [["number", "string"], "boolean"],\n  EPDFNamedDest_SetDest: [["number", "string", "number"], "boolean"],\n  EPDFPage_CreateAnnot: [["number", "number"], "number"],\n  EPDFPage_GetAnnotByName: [["number", "number"], "number"],\n  EPDFPage_GetAnnotCountRaw: [["number", "number"], "number"],\n  EPDFPage_GetAnnotRaw: [["number", "number", "number"], "number"],\n  EPDFPage_RemoveAnnotByName: [["number", "number"], "boolean"],\n  EPDFPage_RemoveAnnotRaw: [["number", "number", "number"], "boolean"],\n  EPDFText_RedactInQuads: [\n    ["number", "number", "number", "boolean", "boolean"],\n    "boolean"\n  ],\n  EPDFText_RedactInRect: [["number", "number", "boolean", "boolean"], "boolean"],\n  FORM_CanRedo: [["number", "number"], "boolean"],\n  FORM_CanUndo: [["number", "number"], "boolean"],\n  FORM_DoDocumentAAction: [["number", "number"], null],\n  FORM_DoDocumentJSAction: [["number"], null],\n  FORM_DoDocumentOpenAction: [["number"], null],\n  FORM_DoPageAAction: [["number", "number", "number"], null],\n  FORM_ForceToKillFocus: [["number"], "boolean"],\n  FORM_GetFocusedAnnot: [["number", "number", "number"], "boolean"],\n  FORM_GetFocusedText: [["number", "number", "number", "number"], "number"],\n  FORM_GetSelectedText: [["number", "number", "number", "number"], "number"],\n  FORM_IsIndexSelected: [["number", "number", "number"], "boolean"],\n  FORM_OnAfterLoadPage: [["number", "number"], null],\n  FORM_OnBeforeClosePage: [["number", "number"], null],\n  FORM_OnChar: [["number", "number", "number", "number"], "boolean"],\n  FORM_OnFocus: [["number", "number", "number", "number", "number"], "boolean"],\n  FORM_OnKeyDown: [["number", "number", "number", "number"], "boolean"],\n  FORM_OnKeyUp: [["number", "number", "number", "number"], "boolean"],\n  FORM_OnLButtonDoubleClick: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnLButtonDown: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnLButtonUp: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnMouseMove: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnMouseWheel: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnRButtonDown: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnRButtonUp: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_Redo: [["number", "number"], "boolean"],\n  FORM_ReplaceAndKeepSelection: [["number", "number", "number"], null],\n  FORM_ReplaceSelection: [["number", "number", "number"], null],\n  FORM_SelectAllText: [["number", "number"], "boolean"],\n  FORM_SetFocusedAnnot: [["number", "number"], "boolean"],\n  FORM_SetIndexSelected: [["number", "number", "number", "boolean"], "boolean"],\n  FORM_Undo: [["number", "number"], "boolean"],\n  FPDF_AddInstalledFont: [["number", "number", "number"], null],\n  FPDF_CloseDocument: [["number"], null],\n  FPDF_ClosePage: [["number"], null],\n  FPDF_CloseXObject: [["number"], null],\n  FPDF_CopyViewerPreferences: [["number", "number"], "boolean"],\n  FPDF_CountNamedDests: [["number"], "number"],\n  FPDF_CreateClipPath: [["number", "number", "number", "number"], "number"],\n  FPDF_CreateNewDocument: [[], "number"],\n  FPDF_DestroyClipPath: [["number"], null],\n  FPDF_DestroyLibrary: [[], null],\n  FPDF_DeviceToPage: [\n    [\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number"\n    ],\n    "boolean"\n  ],\n  FPDF_DocumentHasValidCrossReferenceTable: [["number"], "boolean"],\n  FPDF_FFLDraw: [\n    [\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number"\n    ],\n    null\n  ],\n  FPDF_FreeDefaultSystemFontInfo: [["number"], null],\n  FPDF_GetDefaultSystemFontInfo: [[], "number"],\n  FPDF_GetDefaultTTFMap: [[], "number"],\n  FPDF_GetDefaultTTFMapCount: [[], "number"],\n  FPDF_GetDefaultTTFMapEntry: [["number"], "number"],\n  FPDF_GetDocPermissions: [["number"], "number"],\n  FPDF_GetDocUserPermissions: [["number"], "number"],\n  FPDF_GetFileIdentifier: [["number", "number", "number", "number"], "number"],\n  FPDF_GetFileVersion: [["number", "number"], "boolean"],\n  FPDF_GetFormType: [["number"], "number"],\n  FPDF_GetLastError: [[], "number"],\n  FPDF_GetMetaText: [["number", "string", "number", "number"], "number"],\n  FPDF_GetNamedDest: [["number", "number", "number", "number"], "number"],\n  FPDF_GetNamedDestByName: [["number", "string"], "number"],\n  FPDF_GetPageAAction: [["number", "number"], "number"],\n  FPDF_GetPageBoundingBox: [["number", "number"], "boolean"],\n  FPDF_GetPageCount: [["number"], "number"],\n  FPDF_GetPageHeight: [["number"], "number"],\n  FPDF_GetPageHeightF: [["number"], "number"],\n  FPDF_GetPageLabel: [["number", "number", "number", "number"], "number"],\n  FPDF_GetPageSizeByIndex: [["number", "number", "number", "number"], "number"],\n  FPDF_GetPageSizeByIndexF: [["number", "number", "number"], "boolean"],\n  FPDF_GetPageWidth: [["number"], "number"],\n  FPDF_GetPageWidthF: [["number"], "number"],\n  FPDF_GetSecurityHandlerRevision: [["number"], "number"],\n  FPDF_GetSignatureCount: [["number"], "number"],\n  FPDF_GetSignatureObject: [["number", "number"], "number"],\n  FPDF_GetTrailerEnds: [["number", "number", "number"], "number"],\n  FPDF_GetXFAPacketContent: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDF_GetXFAPacketCount: [["number"], "number"],\n  FPDF_GetXFAPacketName: [["number", "number", "number", "number"], "number"],\n  FPDF_ImportNPagesToOne: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDF_ImportPages: [["number", "number", "string", "number"], "boolean"],\n  FPDF_ImportPagesByIndex: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDF_InitLibrary: [[], null],\n  FPDF_InitLibraryWithConfig: [["number"], null],\n  FPDF_LoadCustomDocument: [["number", "string"], "number"],\n  FPDF_LoadDocument: [["number", "string"], "number"],\n  FPDF_LoadMemDocument: [["number", "number", "string"], "number"],\n  FPDF_LoadMemDocument64: [["number", "number", "string"], "number"],\n  FPDF_LoadPage: [["number", "number"], "number"],\n  FPDF_LoadXFA: [["number"], "boolean"],\n  FPDF_MovePages: [["number", "number", "number", "number"], "boolean"],\n  FPDF_NewFormObjectFromXObject: [["number"], "number"],\n  FPDF_NewXObjectFromPage: [["number", "number", "number"], "number"],\n  FPDF_PageToDevice: [\n    [\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number"\n    ],\n    "boolean"\n  ],\n  FPDF_RemoveFormFieldHighlight: [["number"], null],\n  FPDF_RenderPage_Close: [["number"], null],\n  FPDF_RenderPage_Continue: [["number", "number"], "number"],\n  FPDF_RenderPageBitmap: [\n    ["number", "number", "number", "number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDF_RenderPageBitmap_Start: [\n    [\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number"\n    ],\n    "number"\n  ],\n  FPDF_RenderPageBitmapWithColorScheme_Start: [\n    [\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number"\n    ],\n    "number"\n  ],\n  FPDF_RenderPageBitmapWithMatrix: [\n    ["number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDF_SaveAsCopy: [["number", "number", "number"], "boolean"],\n  FPDF_SaveWithVersion: [["number", "number", "number", "number"], "boolean"],\n  FPDF_SetFormFieldHighlightAlpha: [["number", "number"], null],\n  FPDF_SetFormFieldHighlightColor: [["number", "number", "number"], null],\n  FPDF_SetSandBoxPolicy: [["number", "boolean"], null],\n  FPDF_SetSystemFontInfo: [["number"], null],\n  FPDF_StructElement_Attr_CountChildren: [["number"], "number"],\n  FPDF_StructElement_Attr_GetBlobValue: [\n    ["number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDF_StructElement_Attr_GetBooleanValue: [["number", "number"], "boolean"],\n  FPDF_StructElement_Attr_GetChildAtIndex: [["number", "number"], "number"],\n  FPDF_StructElement_Attr_GetCount: [["number"], "number"],\n  FPDF_StructElement_Attr_GetName: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDF_StructElement_Attr_GetNumberValue: [["number", "number"], "boolean"],\n  FPDF_StructElement_Attr_GetStringValue: [\n    ["number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDF_StructElement_Attr_GetType: [["number"], "number"],\n  FPDF_StructElement_Attr_GetValue: [["number", "string"], "number"],\n  FPDF_StructElement_CountChildren: [["number"], "number"],\n  FPDF_StructElement_GetActualText: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetAltText: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetAttributeAtIndex: [["number", "number"], "number"],\n  FPDF_StructElement_GetAttributeCount: [["number"], "number"],\n  FPDF_StructElement_GetChildAtIndex: [["number", "number"], "number"],\n  FPDF_StructElement_GetChildMarkedContentID: [["number", "number"], "number"],\n  FPDF_StructElement_GetID: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetLang: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetMarkedContentID: [["number"], "number"],\n  FPDF_StructElement_GetMarkedContentIdAtIndex: [["number", "number"], "number"],\n  FPDF_StructElement_GetMarkedContentIdCount: [["number"], "number"],\n  FPDF_StructElement_GetObjType: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetParent: [["number"], "number"],\n  FPDF_StructElement_GetStringAttribute: [\n    ["number", "string", "number", "number"],\n    "number"\n  ],\n  FPDF_StructElement_GetTitle: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetType: [["number", "number", "number"], "number"],\n  FPDF_StructTree_Close: [["number"], null],\n  FPDF_StructTree_CountChildren: [["number"], "number"],\n  FPDF_StructTree_GetChildAtIndex: [["number", "number"], "number"],\n  FPDF_StructTree_GetForPage: [["number"], "number"],\n  FPDF_VIEWERREF_GetDuplex: [["number"], "number"],\n  FPDF_VIEWERREF_GetName: [["number", "string", "number", "number"], "number"],\n  FPDF_VIEWERREF_GetNumCopies: [["number"], "number"],\n  FPDF_VIEWERREF_GetPrintPageRange: [["number"], "number"],\n  FPDF_VIEWERREF_GetPrintPageRangeCount: [["number"], "number"],\n  FPDF_VIEWERREF_GetPrintPageRangeElement: [["number", "number"], "number"],\n  FPDF_VIEWERREF_GetPrintScaling: [["number"], "boolean"],\n  FPDFAction_GetDest: [["number", "number"], "number"],\n  FPDFAction_GetFilePath: [["number", "number", "number"], "number"],\n  FPDFAction_GetType: [["number"], "number"],\n  FPDFAction_GetURIPath: [["number", "number", "number", "number"], "number"],\n  FPDFAnnot_AddFileAttachment: [["number", "number"], "number"],\n  FPDFAnnot_AddInkStroke: [["number", "number", "number"], "number"],\n  FPDFAnnot_AppendAttachmentPoints: [["number", "number"], "boolean"],\n  FPDFAnnot_AppendObject: [["number", "number"], "boolean"],\n  FPDFAnnot_CountAttachmentPoints: [["number"], "number"],\n  FPDFAnnot_GetAP: [["number", "number", "number", "number"], "number"],\n  FPDFAnnot_GetAttachmentPoints: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_GetBorder: [["number", "number", "number", "number"], "boolean"],\n  FPDFAnnot_GetColor: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFAnnot_GetFileAttachment: [["number"], "number"],\n  FPDFAnnot_GetFlags: [["number"], "number"],\n  FPDFAnnot_GetFocusableSubtypes: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_GetFocusableSubtypesCount: [["number"], "number"],\n  FPDFAnnot_GetFontColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFAnnot_GetFontSize: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_GetFormAdditionalActionJavaScript: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetFormControlCount: [["number", "number"], "number"],\n  FPDFAnnot_GetFormControlIndex: [["number", "number"], "number"],\n  FPDFAnnot_GetFormFieldAlternateName: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetFormFieldAtPoint: [["number", "number", "number"], "number"],\n  FPDFAnnot_GetFormFieldExportValue: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetFormFieldFlags: [["number", "number"], "number"],\n  FPDFAnnot_GetFormFieldName: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetFormFieldType: [["number", "number"], "number"],\n  FPDFAnnot_GetFormFieldValue: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetInkListCount: [["number"], "number"],\n  FPDFAnnot_GetInkListPath: [["number", "number", "number", "number"], "number"],\n  FPDFAnnot_GetLine: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_GetLink: [["number"], "number"],\n  FPDFAnnot_GetLinkedAnnot: [["number", "string"], "number"],\n  FPDFAnnot_GetNumberValue: [["number", "string", "number"], "boolean"],\n  FPDFAnnot_GetObject: [["number", "number"], "number"],\n  FPDFAnnot_GetObjectCount: [["number"], "number"],\n  FPDFAnnot_GetOptionCount: [["number", "number"], "number"],\n  FPDFAnnot_GetOptionLabel: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetRect: [["number", "number"], "boolean"],\n  FPDFAnnot_GetStringValue: [["number", "string", "number", "number"], "number"],\n  FPDFAnnot_GetSubtype: [["number"], "number"],\n  FPDFAnnot_GetValueType: [["number", "string"], "number"],\n  FPDFAnnot_GetVertices: [["number", "number", "number"], "number"],\n  FPDFAnnot_HasAttachmentPoints: [["number"], "boolean"],\n  FPDFAnnot_HasKey: [["number", "string"], "boolean"],\n  FPDFAnnot_IsChecked: [["number", "number"], "boolean"],\n  FPDFAnnot_IsObjectSupportedSubtype: [["number"], "boolean"],\n  FPDFAnnot_IsOptionSelected: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_IsSupportedSubtype: [["number"], "boolean"],\n  FPDFAnnot_RemoveInkList: [["number"], "boolean"],\n  FPDFAnnot_RemoveObject: [["number", "number"], "boolean"],\n  FPDFAnnot_SetAP: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_SetAttachmentPoints: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_SetBorder: [["number", "number", "number", "number"], "boolean"],\n  FPDFAnnot_SetColor: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFAnnot_SetFlags: [["number", "number"], "boolean"],\n  FPDFAnnot_SetFocusableSubtypes: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_SetFontColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFAnnot_SetFormFieldFlags: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_SetRect: [["number", "number"], "boolean"],\n  FPDFAnnot_SetStringValue: [["number", "string", "number"], "boolean"],\n  FPDFAnnot_SetURI: [["number", "number"], "boolean"],\n  FPDFAnnot_UpdateObject: [["number", "number"], "boolean"],\n  FPDFAttachment_GetFile: [["number", "number", "number", "number"], "boolean"],\n  FPDFAttachment_GetName: [["number", "number", "number"], "number"],\n  FPDFAttachment_GetStringValue: [\n    ["number", "string", "number", "number"],\n    "number"\n  ],\n  FPDFAttachment_GetSubtype: [["number", "number", "number"], "number"],\n  FPDFAttachment_GetValueType: [["number", "string"], "number"],\n  FPDFAttachment_HasKey: [["number", "string"], "boolean"],\n  FPDFAttachment_SetFile: [["number", "number", "number", "number"], "boolean"],\n  FPDFAttachment_SetStringValue: [["number", "string", "number"], "boolean"],\n  FPDFAvail_Create: [["number", "number"], "number"],\n  FPDFAvail_Destroy: [["number"], null],\n  FPDFAvail_GetDocument: [["number", "string"], "number"],\n  FPDFAvail_GetFirstPageNum: [["number"], "number"],\n  FPDFAvail_IsDocAvail: [["number", "number"], "number"],\n  FPDFAvail_IsFormAvail: [["number", "number"], "number"],\n  FPDFAvail_IsLinearized: [["number"], "number"],\n  FPDFAvail_IsPageAvail: [["number", "number", "number"], "number"],\n  FPDFBitmap_Create: [["number", "number", "number"], "number"],\n  FPDFBitmap_CreateEx: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFBitmap_Destroy: [["number"], null],\n  FPDFBitmap_FillRect: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFBitmap_GetBuffer: [["number"], "number"],\n  FPDFBitmap_GetFormat: [["number"], "number"],\n  FPDFBitmap_GetHeight: [["number"], "number"],\n  FPDFBitmap_GetStride: [["number"], "number"],\n  FPDFBitmap_GetWidth: [["number"], "number"],\n  FPDFBookmark_Find: [["number", "number"], "number"],\n  FPDFBookmark_GetAction: [["number"], "number"],\n  FPDFBookmark_GetCount: [["number"], "number"],\n  FPDFBookmark_GetDest: [["number", "number"], "number"],\n  FPDFBookmark_GetFirstChild: [["number", "number"], "number"],\n  FPDFBookmark_GetNextSibling: [["number", "number"], "number"],\n  FPDFBookmark_GetTitle: [["number", "number", "number"], "number"],\n  FPDFCatalog_IsTagged: [["number"], "boolean"],\n  FPDFCatalog_SetLanguage: [["number", "string"], "boolean"],\n  FPDFClipPath_CountPaths: [["number"], "number"],\n  FPDFClipPath_CountPathSegments: [["number", "number"], "number"],\n  FPDFClipPath_GetPathSegment: [["number", "number", "number"], "number"],\n  FPDFDest_GetDestPageIndex: [["number", "number"], "number"],\n  FPDFDest_GetLocationInPage: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFDest_GetView: [["number", "number", "number"], "number"],\n  FPDFDoc_AddAttachment: [["number", "number"], "number"],\n  FPDFDoc_CloseJavaScriptAction: [["number"], null],\n  FPDFDoc_DeleteAttachment: [["number", "number"], "boolean"],\n  FPDFDOC_ExitFormFillEnvironment: [["number"], null],\n  FPDFDoc_GetAttachment: [["number", "number"], "number"],\n  FPDFDoc_GetAttachmentCount: [["number"], "number"],\n  FPDFDoc_GetJavaScriptAction: [["number", "number"], "number"],\n  FPDFDoc_GetJavaScriptActionCount: [["number"], "number"],\n  FPDFDoc_GetPageMode: [["number"], "number"],\n  FPDFDOC_InitFormFillEnvironment: [["number", "number"], "number"],\n  FPDFFont_Close: [["number"], null],\n  FPDFFont_GetAscent: [["number", "number", "number"], "boolean"],\n  FPDFFont_GetBaseFontName: [["number", "number", "number"], "number"],\n  FPDFFont_GetDescent: [["number", "number", "number"], "boolean"],\n  FPDFFont_GetFamilyName: [["number", "number", "number"], "number"],\n  FPDFFont_GetFlags: [["number"], "number"],\n  FPDFFont_GetFontData: [["number", "number", "number", "number"], "boolean"],\n  FPDFFont_GetGlyphPath: [["number", "number", "number"], "number"],\n  FPDFFont_GetGlyphWidth: [["number", "number", "number", "number"], "boolean"],\n  FPDFFont_GetIsEmbedded: [["number"], "number"],\n  FPDFFont_GetItalicAngle: [["number", "number"], "boolean"],\n  FPDFFont_GetWeight: [["number"], "number"],\n  FPDFFormObj_CountObjects: [["number"], "number"],\n  FPDFFormObj_GetObject: [["number", "number"], "number"],\n  FPDFFormObj_RemoveObject: [["number", "number"], "boolean"],\n  FPDFGlyphPath_CountGlyphSegments: [["number"], "number"],\n  FPDFGlyphPath_GetGlyphPathSegment: [["number", "number"], "number"],\n  FPDFImageObj_GetBitmap: [["number"], "number"],\n  FPDFImageObj_GetIccProfileDataDecoded: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFImageObj_GetImageDataDecoded: [["number", "number", "number"], "number"],\n  FPDFImageObj_GetImageDataRaw: [["number", "number", "number"], "number"],\n  FPDFImageObj_GetImageFilter: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFImageObj_GetImageFilterCount: [["number"], "number"],\n  FPDFImageObj_GetImageMetadata: [["number", "number", "number"], "boolean"],\n  FPDFImageObj_GetImagePixelSize: [["number", "number", "number"], "boolean"],\n  FPDFImageObj_GetRenderedBitmap: [["number", "number", "number"], "number"],\n  FPDFImageObj_LoadJpegFile: [\n    ["number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFImageObj_LoadJpegFileInline: [\n    ["number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFImageObj_SetBitmap: [["number", "number", "number", "number"], "boolean"],\n  FPDFImageObj_SetMatrix: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFJavaScriptAction_GetName: [["number", "number", "number"], "number"],\n  FPDFJavaScriptAction_GetScript: [["number", "number", "number"], "number"],\n  FPDFLink_CloseWebLinks: [["number"], null],\n  FPDFLink_CountQuadPoints: [["number"], "number"],\n  FPDFLink_CountRects: [["number", "number"], "number"],\n  FPDFLink_CountWebLinks: [["number"], "number"],\n  FPDFLink_Enumerate: [["number", "number", "number"], "boolean"],\n  FPDFLink_GetAction: [["number"], "number"],\n  FPDFLink_GetAnnot: [["number", "number"], "number"],\n  FPDFLink_GetAnnotRect: [["number", "number"], "boolean"],\n  FPDFLink_GetDest: [["number", "number"], "number"],\n  FPDFLink_GetLinkAtPoint: [["number", "number", "number"], "number"],\n  FPDFLink_GetLinkZOrderAtPoint: [["number", "number", "number"], "number"],\n  FPDFLink_GetQuadPoints: [["number", "number", "number"], "boolean"],\n  FPDFLink_GetRect: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFLink_GetTextRange: [["number", "number", "number", "number"], "boolean"],\n  FPDFLink_GetURL: [["number", "number", "number", "number"], "number"],\n  FPDFLink_LoadWebLinks: [["number"], "number"],\n  FPDFPage_CloseAnnot: [["number"], null],\n  FPDFPage_CountObjects: [["number"], "number"],\n  FPDFPage_CreateAnnot: [["number", "number"], "number"],\n  FPDFPage_Delete: [["number", "number"], null],\n  FPDFPage_Flatten: [["number", "number"], "number"],\n  FPDFPage_FormFieldZOrderAtPoint: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFPage_GenerateContent: [["number"], "boolean"],\n  FPDFPage_GetAnnot: [["number", "number"], "number"],\n  FPDFPage_GetAnnotCount: [["number"], "number"],\n  FPDFPage_GetAnnotIndex: [["number", "number"], "number"],\n  FPDFPage_GetArtBox: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPage_GetBleedBox: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPage_GetCropBox: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPage_GetDecodedThumbnailData: [["number", "number", "number"], "number"],\n  FPDFPage_GetMediaBox: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPage_GetObject: [["number", "number"], "number"],\n  FPDFPage_GetRawThumbnailData: [["number", "number", "number"], "number"],\n  FPDFPage_GetRotation: [["number"], "number"],\n  FPDFPage_GetThumbnailAsBitmap: [["number"], "number"],\n  FPDFPage_GetTrimBox: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPage_HasFormFieldAtPoint: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFPage_HasTransparency: [["number"], "boolean"],\n  FPDFPage_InsertClipPath: [["number", "number"], null],\n  FPDFPage_InsertObject: [["number", "number"], null],\n  FPDFPage_InsertObjectAtIndex: [["number", "number", "number"], "boolean"],\n  FPDFPage_New: [["number", "number", "number", "number"], "number"],\n  FPDFPage_RemoveAnnot: [["number", "number"], "boolean"],\n  FPDFPage_RemoveObject: [["number", "number"], "boolean"],\n  FPDFPage_SetArtBox: [["number", "number", "number", "number", "number"], null],\n  FPDFPage_SetBleedBox: [\n    ["number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDFPage_SetCropBox: [["number", "number", "number", "number", "number"], null],\n  FPDFPage_SetMediaBox: [\n    ["number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDFPage_SetRotation: [["number", "number"], null],\n  FPDFPage_SetTrimBox: [["number", "number", "number", "number", "number"], null],\n  FPDFPage_TransformAnnots: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDFPage_TransFormWithClip: [["number", "number", "number"], "boolean"],\n  FPDFPageObj_AddMark: [["number", "string"], "number"],\n  FPDFPageObj_CountMarks: [["number"], "number"],\n  FPDFPageObj_CreateNewPath: [["number", "number"], "number"],\n  FPDFPageObj_CreateNewRect: [["number", "number", "number", "number"], "number"],\n  FPDFPageObj_CreateTextObj: [["number", "number", "number"], "number"],\n  FPDFPageObj_Destroy: [["number"], null],\n  FPDFPageObj_GetBounds: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObj_GetClipPath: [["number"], "number"],\n  FPDFPageObj_GetDashArray: [["number", "number", "number"], "boolean"],\n  FPDFPageObj_GetDashCount: [["number"], "number"],\n  FPDFPageObj_GetDashPhase: [["number", "number"], "boolean"],\n  FPDFPageObj_GetFillColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObj_GetIsActive: [["number", "number"], "boolean"],\n  FPDFPageObj_GetLineCap: [["number"], "number"],\n  FPDFPageObj_GetLineJoin: [["number"], "number"],\n  FPDFPageObj_GetMark: [["number", "number"], "number"],\n  FPDFPageObj_GetMarkedContentID: [["number"], "number"],\n  FPDFPageObj_GetMatrix: [["number", "number"], "boolean"],\n  FPDFPageObj_GetRotatedBounds: [["number", "number"], "boolean"],\n  FPDFPageObj_GetStrokeColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObj_GetStrokeWidth: [["number", "number"], "boolean"],\n  FPDFPageObj_GetType: [["number"], "number"],\n  FPDFPageObj_HasTransparency: [["number"], "boolean"],\n  FPDFPageObj_NewImageObj: [["number"], "number"],\n  FPDFPageObj_NewTextObj: [["number", "string", "number"], "number"],\n  FPDFPageObj_RemoveMark: [["number", "number"], "boolean"],\n  FPDFPageObj_SetBlendMode: [["number", "string"], null],\n  FPDFPageObj_SetDashArray: [["number", "number", "number", "number"], "boolean"],\n  FPDFPageObj_SetDashPhase: [["number", "number"], "boolean"],\n  FPDFPageObj_SetFillColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObj_SetIsActive: [["number", "boolean"], "boolean"],\n  FPDFPageObj_SetLineCap: [["number", "number"], "boolean"],\n  FPDFPageObj_SetLineJoin: [["number", "number"], "boolean"],\n  FPDFPageObj_SetMatrix: [["number", "number"], "boolean"],\n  FPDFPageObj_SetStrokeColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObj_SetStrokeWidth: [["number", "number"], "boolean"],\n  FPDFPageObj_Transform: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDFPageObj_TransformClipPath: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDFPageObj_TransformF: [["number", "number"], "boolean"],\n  FPDFPageObjMark_CountParams: [["number"], "number"],\n  FPDFPageObjMark_GetName: [["number", "number", "number", "number"], "boolean"],\n  FPDFPageObjMark_GetParamBlobValue: [\n    ["number", "string", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObjMark_GetParamIntValue: [["number", "string", "number"], "boolean"],\n  FPDFPageObjMark_GetParamKey: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObjMark_GetParamStringValue: [\n    ["number", "string", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObjMark_GetParamValueType: [["number", "string"], "number"],\n  FPDFPageObjMark_RemoveParam: [["number", "number", "string"], "boolean"],\n  FPDFPageObjMark_SetBlobParam: [\n    ["number", "number", "number", "string", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObjMark_SetIntParam: [\n    ["number", "number", "number", "string", "number"],\n    "boolean"\n  ],\n  FPDFPageObjMark_SetStringParam: [\n    ["number", "number", "number", "string", "string"],\n    "boolean"\n  ],\n  FPDFPath_BezierTo: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPath_Close: [["number"], "boolean"],\n  FPDFPath_CountSegments: [["number"], "number"],\n  FPDFPath_GetDrawMode: [["number", "number", "number"], "boolean"],\n  FPDFPath_GetPathSegment: [["number", "number"], "number"],\n  FPDFPath_LineTo: [["number", "number", "number"], "boolean"],\n  FPDFPath_MoveTo: [["number", "number", "number"], "boolean"],\n  FPDFPath_SetDrawMode: [["number", "number", "boolean"], "boolean"],\n  FPDFPathSegment_GetClose: [["number"], "boolean"],\n  FPDFPathSegment_GetPoint: [["number", "number", "number"], "boolean"],\n  FPDFPathSegment_GetType: [["number"], "number"],\n  FPDFSignatureObj_GetByteRange: [["number", "number", "number"], "number"],\n  FPDFSignatureObj_GetContents: [["number", "number", "number"], "number"],\n  FPDFSignatureObj_GetDocMDPPermission: [["number"], "number"],\n  FPDFSignatureObj_GetReason: [["number", "number", "number"], "number"],\n  FPDFSignatureObj_GetSubFilter: [["number", "number", "number"], "number"],\n  FPDFSignatureObj_GetTime: [["number", "number", "number"], "number"],\n  FPDFText_ClosePage: [["number"], null],\n  FPDFText_CountChars: [["number"], "number"],\n  FPDFText_CountRects: [["number", "number", "number"], "number"],\n  FPDFText_FindClose: [["number"], null],\n  FPDFText_FindNext: [["number"], "boolean"],\n  FPDFText_FindPrev: [["number"], "boolean"],\n  FPDFText_FindStart: [["number", "number", "number", "number"], "number"],\n  FPDFText_GetBoundedText: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFText_GetCharAngle: [["number", "number"], "number"],\n  FPDFText_GetCharBox: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFText_GetCharIndexAtPos: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFText_GetCharIndexFromTextIndex: [["number", "number"], "number"],\n  FPDFText_GetCharOrigin: [["number", "number", "number", "number"], "boolean"],\n  FPDFText_GetFillColor: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFText_GetFontInfo: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFText_GetFontSize: [["number", "number"], "number"],\n  FPDFText_GetFontWeight: [["number", "number"], "number"],\n  FPDFText_GetLooseCharBox: [["number", "number", "number"], "boolean"],\n  FPDFText_GetMatrix: [["number", "number", "number"], "boolean"],\n  FPDFText_GetRect: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFText_GetSchCount: [["number"], "number"],\n  FPDFText_GetSchResultIndex: [["number"], "number"],\n  FPDFText_GetStrokeColor: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFText_GetText: [["number", "number", "number", "number"], "number"],\n  FPDFText_GetTextIndexFromCharIndex: [["number", "number"], "number"],\n  FPDFText_GetTextObject: [["number", "number"], "number"],\n  FPDFText_GetUnicode: [["number", "number"], "number"],\n  FPDFText_HasUnicodeMapError: [["number", "number"], "number"],\n  FPDFText_IsGenerated: [["number", "number"], "number"],\n  FPDFText_IsHyphen: [["number", "number"], "number"],\n  FPDFText_LoadCidType2Font: [\n    ["number", "number", "number", "string", "number", "number"],\n    "number"\n  ],\n  FPDFText_LoadFont: [\n    ["number", "number", "number", "number", "boolean"],\n    "number"\n  ],\n  FPDFText_LoadPage: [["number"], "number"],\n  FPDFText_LoadStandardFont: [["number", "string"], "number"],\n  FPDFText_SetCharcodes: [["number", "number", "number"], "boolean"],\n  FPDFText_SetText: [["number", "number"], "boolean"],\n  FPDFTextObj_GetFont: [["number"], "number"],\n  FPDFTextObj_GetFontSize: [["number", "number"], "boolean"],\n  FPDFTextObj_GetRenderedBitmap: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFTextObj_GetText: [["number", "number", "number", "number"], "number"],\n  FPDFTextObj_GetTextRenderMode: [["number"], "number"],\n  FPDFTextObj_SetTextRenderMode: [["number", "number"], "boolean"],\n  PDFiumExt_CloseFileWriter: [["number"], null],\n  PDFiumExt_CloseFormFillInfo: [["number"], null],\n  PDFiumExt_ExitFormFillEnvironment: [["number"], null],\n  PDFiumExt_GetFileWriterData: [["number", "number", "number"], "number"],\n  PDFiumExt_GetFileWriterSize: [["number"], "number"],\n  PDFiumExt_Init: [[], null],\n  PDFiumExt_InitFormFillEnvironment: [["number", "number"], "number"],\n  PDFiumExt_OpenFileWriter: [[], "number"],\n  PDFiumExt_OpenFormFillInfo: [[], "number"],\n  PDFiumExt_SaveAsCopy: [["number", "number"], "number"]\n};\nasync function createWrappedModule(pdfium) {\n  const module = {\n    pdfium\n  };\n  for (const key in functions) {\n    const ident = key;\n    const args = functions[ident][0];\n    const ret = functions[ident][1];\n    module[ident] = pdfium.cwrap(key, ret, args);\n  }\n  return module;\n}\nasync function init(moduleOverrides) {\n  const pdfium = await createPdfium(moduleOverrides);\n  return createWrappedModule(pdfium);\n}\nfunction readString(wasmModule, readChars, parseChars, defaultLength = 100) {\n  let buffer = wasmModule.wasmExports.malloc(defaultLength);\n  for (let i = 0; i < defaultLength; i++) {\n    wasmModule.HEAP8[buffer + i] = 0;\n  }\n  const actualLength = readChars(buffer, defaultLength);\n  let str;\n  if (actualLength > defaultLength) {\n    wasmModule.wasmExports.free(buffer);\n    buffer = wasmModule.wasmExports.malloc(actualLength);\n    for (let i = 0; i < actualLength; i++) {\n      wasmModule.HEAP8[buffer + i] = 0;\n    }\n    readChars(buffer, actualLength);\n    str = parseChars(buffer);\n  } else {\n    str = parseChars(buffer);\n  }\n  wasmModule.wasmExports.free(buffer);\n  return str;\n}\nfunction readArrayBuffer(wasmModule, readChars) {\n  const bufferSize = readChars(0, 0);\n  const bufferPtr = wasmModule.wasmExports.malloc(bufferSize);\n  readChars(bufferPtr, bufferSize);\n  const arrayBuffer = new ArrayBuffer(bufferSize);\n  const view = new DataView(arrayBuffer);\n  for (let i = 0; i < bufferSize; i++) {\n    view.setInt8(i, wasmModule.getValue(bufferPtr + i, "i8"));\n  }\n  wasmModule.wasmExports.free(bufferPtr);\n  return arrayBuffer;\n}\nconst RESERVED_INFO_KEYS = /* @__PURE__ */ new Set([\n  "Title",\n  "Author",\n  "Subject",\n  "Keywords",\n  "Producer",\n  "Creator",\n  "CreationDate",\n  "ModDate",\n  "Trapped"\n]);\nfunction isValidCustomKey(key) {\n  if (!key || key.length > 127) return false;\n  if (RESERVED_INFO_KEYS.has(key)) return false;\n  if (key[0] === "/") return false;\n  for (let i = 0; i < key.length; i++) {\n    const c = key.charCodeAt(i);\n    if (c < 32 || c > 126) return false;\n  }\n  return true;\n}\nfunction computeFormDrawParams(matrix, rect, pageSize, rotation) {\n  const rectLeft = rect.origin.x;\n  const rectBottom = rect.origin.y;\n  const rectRight = rectLeft + rect.size.width;\n  const rectTop = rectBottom + rect.size.height;\n  const pageWidth = pageSize.width;\n  const pageHeight = pageSize.height;\n  const scaleX = Math.hypot(matrix.a, matrix.b);\n  const scaleY = Math.hypot(matrix.c, matrix.d);\n  const swap2 = (rotation & 1) === 1;\n  const formsWidth = swap2 ? Math.max(1, Math.round(pageHeight * scaleX)) : Math.max(1, Math.round(pageWidth * scaleX));\n  const formsHeight = swap2 ? Math.max(1, Math.round(pageWidth * scaleY)) : Math.max(1, Math.round(pageHeight * scaleY));\n  let startX;\n  let startY;\n  switch (rotation) {\n    case Rotation.Degree0:\n      startX = -Math.round(rectLeft * scaleX);\n      startY = -Math.round(rectBottom * scaleY);\n      break;\n    case Rotation.Degree90:\n      startX = Math.round((rectTop - pageHeight) * scaleX);\n      startY = -Math.round(rectLeft * scaleY);\n      break;\n    case Rotation.Degree180:\n      startX = Math.round((rectRight - pageWidth) * scaleX);\n      startY = Math.round((rectTop - pageHeight) * scaleY);\n      break;\n    case Rotation.Degree270:\n      startX = -Math.round(rectBottom * scaleX);\n      startY = Math.round((rectRight - pageWidth) * scaleY);\n      break;\n    default:\n      startX = -Math.round(rectLeft * scaleX);\n      startY = -Math.round(rectBottom * scaleY);\n      break;\n  }\n  return { startX, startY, formsWidth, formsHeight, scaleX, scaleY };\n}\nconst WasmPointer = (ptr) => ptr;\nconst DEFAULT_CONFIG = {\n  pageTtl: 5e3,\n  // 5 seconds\n  maxPagesPerDocument: 10\n};\nclass PdfCache {\n  constructor(pdfium, memoryManager, config = {}) {\n    this.pdfium = pdfium;\n    this.memoryManager = memoryManager;\n    this.docs = /* @__PURE__ */ new Map();\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n  /** Open (or re-use) a document */\n  setDocument(id, filePtr, docPtr) {\n    let ctx = this.docs.get(id);\n    if (!ctx) {\n      ctx = new DocumentContext(filePtr, docPtr, this.pdfium, this.memoryManager, this.config);\n      this.docs.set(id, ctx);\n    }\n  }\n  /** Retrieve the DocumentContext for a given PdfDocumentObject */\n  getContext(docId) {\n    return this.docs.get(docId);\n  }\n  /** Close & fully release a document and all its pages */\n  closeDocument(docId) {\n    const ctx = this.docs.get(docId);\n    if (!ctx) return false;\n    ctx.dispose();\n    this.docs.delete(docId);\n    return true;\n  }\n  /** Close all documents */\n  closeAllDocuments() {\n    for (const ctx of this.docs.values()) {\n      ctx.dispose();\n    }\n    this.docs.clear();\n  }\n  /** Update cache configuration for all existing documents */\n  updateConfig(newConfig) {\n    Object.assign(this.config, newConfig);\n    for (const ctx of this.docs.values()) {\n      ctx.updateConfig(this.config);\n    }\n  }\n  /** Get current cache statistics */\n  getCacheStats() {\n    const pagesByDocument = {};\n    let totalPages = 0;\n    for (const [docId, ctx] of this.docs.entries()) {\n      const pageCount = ctx.getCacheSize();\n      pagesByDocument[docId] = pageCount;\n      totalPages += pageCount;\n    }\n    return {\n      documents: this.docs.size,\n      totalPages,\n      pagesByDocument\n    };\n  }\n}\nclass DocumentContext {\n  constructor(filePtr, docPtr, pdfium, memoryManager, config) {\n    this.filePtr = filePtr;\n    this.docPtr = docPtr;\n    this.memoryManager = memoryManager;\n    this.pageCache = new PageCache(pdfium, docPtr, config);\n  }\n  /** Main accessor for pages */\n  acquirePage(pageIdx) {\n    return this.pageCache.acquire(pageIdx);\n  }\n  /** Scoped accessor for one-off / bulk operations */\n  borrowPage(pageIdx, fn) {\n    return this.pageCache.borrowPage(pageIdx, fn);\n  }\n  /** Update cache configuration */\n  updateConfig(config) {\n    this.pageCache.updateConfig(config);\n  }\n  /** Get number of pages currently in cache */\n  getCacheSize() {\n    return this.pageCache.size();\n  }\n  /** Tear down all pages + this document */\n  dispose() {\n    this.pageCache.forceReleaseAll();\n    this.pageCache.pdf.FPDF_CloseDocument(this.docPtr);\n    this.memoryManager.free(WasmPointer(this.filePtr));\n  }\n}\nclass PageCache {\n  constructor(pdf, docPtr, config) {\n    this.pdf = pdf;\n    this.docPtr = docPtr;\n    this.cache = /* @__PURE__ */ new Map();\n    this.accessOrder = [];\n    this.config = config;\n  }\n  acquire(pageIdx) {\n    let ctx = this.cache.get(pageIdx);\n    if (!ctx) {\n      this.evictIfNeeded();\n      const pagePtr = this.pdf.FPDF_LoadPage(this.docPtr, pageIdx);\n      ctx = new PageContext(this.pdf, this.docPtr, pageIdx, pagePtr, this.config.pageTtl, () => {\n        this.cache.delete(pageIdx);\n        this.removeFromAccessOrder(pageIdx);\n      });\n      this.cache.set(pageIdx, ctx);\n    }\n    this.updateAccessOrder(pageIdx);\n    ctx.clearExpiryTimer();\n    ctx.bumpRefCount();\n    return ctx;\n  }\n  /** Helper: run a function "scoped" to a page.\n   *    \u2013 if the page was already cached  \u2192 .release() (keeps TTL logic)\n   *    \u2013 if the page was loaded just now \u2192 .disposeImmediate() (free right away)\n   */\n  borrowPage(pageIdx, fn) {\n    const existed = this.cache.has(pageIdx);\n    const ctx = this.acquire(pageIdx);\n    try {\n      return fn(ctx);\n    } finally {\n      existed ? ctx.release() : ctx.disposeImmediate();\n    }\n  }\n  forceReleaseAll() {\n    for (const ctx of this.cache.values()) {\n      ctx.disposeImmediate();\n    }\n    this.cache.clear();\n    this.accessOrder.length = 0;\n  }\n  /** Update cache configuration */\n  updateConfig(config) {\n    this.config = config;\n    for (const ctx of this.cache.values()) {\n      ctx.updateTtl(config.pageTtl);\n    }\n    this.evictIfNeeded();\n  }\n  /** Get current cache size */\n  size() {\n    return this.cache.size;\n  }\n  /** Evict least recently used pages if cache exceeds max size */\n  evictIfNeeded() {\n    while (this.cache.size >= this.config.maxPagesPerDocument) {\n      const lruPageIdx = this.accessOrder[0];\n      if (lruPageIdx !== void 0) {\n        const ctx = this.cache.get(lruPageIdx);\n        if (ctx) {\n          if (ctx.getRefCount() === 0) {\n            ctx.disposeImmediate();\n          } else {\n            break;\n          }\n        } else {\n          this.removeFromAccessOrder(lruPageIdx);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  /** Update the access order for LRU tracking */\n  updateAccessOrder(pageIdx) {\n    this.removeFromAccessOrder(pageIdx);\n    this.accessOrder.push(pageIdx);\n  }\n  /** Remove a page from the access order array */\n  removeFromAccessOrder(pageIdx) {\n    const index = this.accessOrder.indexOf(pageIdx);\n    if (index > -1) {\n      this.accessOrder.splice(index, 1);\n    }\n  }\n}\nclass PageContext {\n  constructor(pdf, docPtr, pageIdx, pagePtr, ttl, onFinalDispose) {\n    this.pdf = pdf;\n    this.docPtr = docPtr;\n    this.pageIdx = pageIdx;\n    this.pagePtr = pagePtr;\n    this.onFinalDispose = onFinalDispose;\n    this.refCount = 0;\n    this.disposed = false;\n    this.ttl = ttl;\n  }\n  /** Called by PageCache.acquire() */\n  bumpRefCount() {\n    if (this.disposed) throw new Error("Context already disposed");\n    this.refCount++;\n  }\n  /** Get current reference count */\n  getRefCount() {\n    return this.refCount;\n  }\n  /** Called by PageCache.acquire() */\n  clearExpiryTimer() {\n    if (this.expiryTimer) {\n      clearTimeout(this.expiryTimer);\n      this.expiryTimer = void 0;\n    }\n  }\n  /** Update TTL configuration */\n  updateTtl(newTtl) {\n    this.ttl = newTtl;\n    if (this.expiryTimer && this.refCount === 0) {\n      this.clearExpiryTimer();\n      this.expiryTimer = setTimeout(() => this.disposeImmediate(), this.ttl);\n    }\n  }\n  /** Called by PageCache.release() internally */\n  release() {\n    if (this.disposed) return;\n    this.refCount--;\n    if (this.refCount === 0) {\n      this.expiryTimer = setTimeout(() => this.disposeImmediate(), this.ttl);\n    }\n  }\n  /** Tear down _all_ sub-pointers & the page. */\n  disposeImmediate() {\n    if (this.disposed) return;\n    this.disposed = true;\n    this.clearExpiryTimer();\n    if (this.textPagePtr !== void 0) {\n      this.pdf.FPDFText_ClosePage(this.textPagePtr);\n    }\n    if (this.formHandle !== void 0) {\n      this.pdf.FORM_OnBeforeClosePage(this.pagePtr, this.formHandle);\n      this.pdf.PDFiumExt_ExitFormFillEnvironment(this.formHandle);\n    }\n    if (this.formInfoPtr !== void 0) {\n      this.pdf.PDFiumExt_CloseFormFillInfo(this.formInfoPtr);\n    }\n    this.pdf.FPDF_ClosePage(this.pagePtr);\n    this.onFinalDispose();\n  }\n  // \u2500\u2500 public helpers \u2500\u2500\n  /** Always safe: opens (once) and returns the text-page ptr. */\n  getTextPage() {\n    this.ensureAlive();\n    if (this.textPagePtr === void 0) {\n      this.textPagePtr = this.pdf.FPDFText_LoadPage(this.pagePtr);\n    }\n    return this.textPagePtr;\n  }\n  /** Always safe: opens (once) and returns the form-fill handle. */\n  getFormHandle() {\n    this.ensureAlive();\n    if (this.formHandle === void 0) {\n      this.formInfoPtr = this.pdf.PDFiumExt_OpenFormFillInfo();\n      this.formHandle = this.pdf.PDFiumExt_InitFormFillEnvironment(this.docPtr, this.formInfoPtr);\n      this.pdf.FORM_OnAfterLoadPage(this.pagePtr, this.formHandle);\n    }\n    return this.formHandle;\n  }\n  /**\n   * Safely execute `fn` with an annotation pointer.\n   * Pointer is ALWAYS closed afterwards.\n   */\n  withAnnotation(annotIdx, fn) {\n    this.ensureAlive();\n    const annotPtr = this.pdf.FPDFPage_GetAnnot(this.pagePtr, annotIdx);\n    try {\n      return fn(annotPtr);\n    } finally {\n      this.pdf.FPDFPage_CloseAnnot(annotPtr);\n    }\n  }\n  ensureAlive() {\n    if (this.disposed) throw new Error("PageContext already disposed");\n  }\n}\nconst MEMORY_LIMITS = {\n  /** Maximum total memory that can be allocated (2GB) */\n  MAX_TOTAL_MEMORY: 2 * 1024 * 1024 * 1024\n};\nconst LIMITS = {\n  MEMORY: MEMORY_LIMITS\n};\nconst LOG_SOURCE$3 = "PDFiumEngine";\nconst LOG_CATEGORY$3 = "MemoryManager";\nclass MemoryManager {\n  constructor(pdfiumModule, logger) {\n    this.pdfiumModule = pdfiumModule;\n    this.logger = logger;\n    this.allocations = /* @__PURE__ */ new Map();\n    this.totalAllocated = 0;\n  }\n  /**\n   * Allocate memory with tracking and validation\n   */\n  malloc(size) {\n    if (this.totalAllocated + size > LIMITS.MEMORY.MAX_TOTAL_MEMORY) {\n      throw new Error(\n        `Total memory usage would exceed limit: ${this.totalAllocated + size} > ${LIMITS.MEMORY.MAX_TOTAL_MEMORY}`\n      );\n    }\n    const ptr = this.pdfiumModule.pdfium.wasmExports.malloc(size);\n    if (!ptr) {\n      throw new Error(`Failed to allocate ${size} bytes`);\n    }\n    const allocation = {\n      ptr: WasmPointer(ptr),\n      size,\n      timestamp: Date.now(),\n      stack: this.logger.isEnabled("debug") ? new Error().stack : void 0\n    };\n    this.allocations.set(ptr, allocation);\n    this.totalAllocated += size;\n    return WasmPointer(ptr);\n  }\n  /**\n   * Free memory with validation\n   */\n  free(ptr) {\n    const allocation = this.allocations.get(ptr);\n    if (!allocation) {\n      this.logger.warn(LOG_SOURCE$3, LOG_CATEGORY$3, `Freeing untracked pointer: ${ptr}`);\n    } else {\n      this.totalAllocated -= allocation.size;\n      this.allocations.delete(ptr);\n    }\n    this.pdfiumModule.pdfium.wasmExports.free(ptr);\n  }\n  /**\n   * Get memory statistics\n   */\n  getStats() {\n    return {\n      totalAllocated: this.totalAllocated,\n      allocationCount: this.allocations.size,\n      allocations: this.logger.isEnabled("debug") ? Array.from(this.allocations.values()) : []\n    };\n  }\n  /**\n   * Check for memory leaks\n   */\n  checkLeaks() {\n    if (this.allocations.size > 0) {\n      this.logger.warn(\n        LOG_SOURCE$3,\n        LOG_CATEGORY$3,\n        `Potential memory leak: ${this.allocations.size} unfreed allocations`\n      );\n      for (const [ptr, alloc] of this.allocations) {\n        this.logger.warn(LOG_SOURCE$3, LOG_CATEGORY$3, `  - ${ptr}: ${alloc.size} bytes`, alloc.stack);\n      }\n    }\n  }\n}\nconst SYSFONTINFO_SIZE = 36;\nconst OFFSET_VERSION = 0;\nconst OFFSET_RELEASE = 4;\nconst OFFSET_ENUMFONTS = 8;\nconst OFFSET_MAPFONT = 12;\nconst OFFSET_GETFONT = 16;\nconst OFFSET_GETFONTDATA = 20;\nconst OFFSET_GETFACENAME = 24;\nconst OFFSET_GETFONTCHARSET = 28;\nconst OFFSET_DELETEFONT = 32;\nconst LOG_SOURCE$2 = "pdfium";\nconst LOG_CATEGORY$2 = "font-fallback";\nclass FontFallbackManager {\n  constructor(config, logger = new NoopLogger()) {\n    this.fontHandles = /* @__PURE__ */ new Map();\n    this.fontCache = /* @__PURE__ */ new Map();\n    this.nextHandleId = 1;\n    this.module = null;\n    this.enabled = false;\n    this.structPtr = 0;\n    this.releaseFnPtr = 0;\n    this.enumFontsFnPtr = 0;\n    this.mapFontFnPtr = 0;\n    this.getFontFnPtr = 0;\n    this.getFontDataFnPtr = 0;\n    this.getFaceNameFnPtr = 0;\n    this.getFontCharsetFnPtr = 0;\n    this.deleteFontFnPtr = 0;\n    this.fontConfig = config;\n    this.logger = logger;\n  }\n  /**\n   * Initialize the font fallback system and attach to PDFium module\n   */\n  initialize(module) {\n    if (this.enabled) {\n      this.logger.warn(LOG_SOURCE$2, LOG_CATEGORY$2, "Font fallback already initialized");\n      return;\n    }\n    this.module = module;\n    const pdfium = module.pdfium;\n    if (typeof pdfium.addFunction !== "function") {\n      this.logger.error(\n        LOG_SOURCE$2,\n        LOG_CATEGORY$2,\n        "addFunction not available. Make sure WASM is compiled with -sALLOW_TABLE_GROWTH"\n      );\n      return;\n    }\n    try {\n      this.structPtr = pdfium.wasmExports.malloc(SYSFONTINFO_SIZE);\n      if (!this.structPtr) {\n        throw new Error("Failed to allocate FPDF_SYSFONTINFO struct");\n      }\n      for (let i = 0; i < SYSFONTINFO_SIZE; i++) {\n        pdfium.setValue(this.structPtr + i, 0, "i8");\n      }\n      this.releaseFnPtr = pdfium.addFunction((_pThis) => {\n      }, "vi");\n      this.enumFontsFnPtr = pdfium.addFunction((_pThis, _pMapper) => {\n      }, "vii");\n      this.mapFontFnPtr = pdfium.addFunction(\n        (_pThis, weight, bItalic, charset, pitchFamily, facePtr, bExactPtr) => {\n          const face = facePtr ? pdfium.UTF8ToString(facePtr) : "";\n          const handle = this.mapFont(weight, bItalic, charset, pitchFamily, face);\n          if (bExactPtr) {\n            pdfium.setValue(bExactPtr, 0, "i32");\n          }\n          return handle;\n        },\n        "iiiiiiii"\n      );\n      this.getFontFnPtr = pdfium.addFunction((_pThis, facePtr) => {\n        const face = facePtr ? pdfium.UTF8ToString(facePtr) : "";\n        return this.mapFont(400, 0, 0, 0, face);\n      }, "iii");\n      this.getFontDataFnPtr = pdfium.addFunction(\n        (_pThis, hFont, table, buffer, bufSize) => {\n          return this.getFontData(hFont, table, buffer, bufSize);\n        },\n        "iiiiii"\n      );\n      this.getFaceNameFnPtr = pdfium.addFunction(\n        (_pThis, _hFont, _buffer, _bufSize) => {\n          return 0;\n        },\n        "iiiii"\n      );\n      this.getFontCharsetFnPtr = pdfium.addFunction((_pThis, hFont) => {\n        const handle = this.fontHandles.get(hFont);\n        return (handle == null ? void 0 : handle.charset) ?? 0;\n      }, "iii");\n      this.deleteFontFnPtr = pdfium.addFunction((_pThis, hFont) => {\n        this.deleteFont(hFont);\n      }, "vii");\n      pdfium.setValue(this.structPtr + OFFSET_VERSION, 1, "i32");\n      pdfium.setValue(this.structPtr + OFFSET_RELEASE, this.releaseFnPtr, "i32");\n      pdfium.setValue(this.structPtr + OFFSET_ENUMFONTS, this.enumFontsFnPtr, "i32");\n      pdfium.setValue(this.structPtr + OFFSET_MAPFONT, this.mapFontFnPtr, "i32");\n      pdfium.setValue(this.structPtr + OFFSET_GETFONT, this.getFontFnPtr, "i32");\n      pdfium.setValue(this.structPtr + OFFSET_GETFONTDATA, this.getFontDataFnPtr, "i32");\n      pdfium.setValue(this.structPtr + OFFSET_GETFACENAME, this.getFaceNameFnPtr, "i32");\n      pdfium.setValue(this.structPtr + OFFSET_GETFONTCHARSET, this.getFontCharsetFnPtr, "i32");\n      pdfium.setValue(this.structPtr + OFFSET_DELETEFONT, this.deleteFontFnPtr, "i32");\n      module.FPDF_SetSystemFontInfo(this.structPtr);\n      this.enabled = true;\n      this.logger.info(\n        LOG_SOURCE$2,\n        LOG_CATEGORY$2,\n        "Font fallback system initialized (pure TypeScript)",\n        Object.keys(this.fontConfig.fonts)\n      );\n    } catch (error) {\n      this.logger.error(LOG_SOURCE$2, LOG_CATEGORY$2, "Failed to initialize font fallback", error);\n      this.cleanup();\n      throw error;\n    }\n  }\n  /**\n   * Disable the font fallback system and clean up resources\n   */\n  disable() {\n    if (!this.enabled || !this.module) {\n      return;\n    }\n    this.module.FPDF_SetSystemFontInfo(0);\n    this.cleanup();\n    this.enabled = false;\n    this.logger.debug(LOG_SOURCE$2, LOG_CATEGORY$2, "Font fallback system disabled");\n  }\n  /**\n   * Clean up allocated resources\n   */\n  cleanup() {\n    if (!this.module) return;\n    const pdfium = this.module.pdfium;\n    if (this.structPtr) {\n      pdfium.wasmExports.free(this.structPtr);\n      this.structPtr = 0;\n    }\n    const removeIfExists = (ptr) => {\n      if (ptr && typeof pdfium.removeFunction === "function") {\n        try {\n          pdfium.removeFunction(ptr);\n        } catch {\n        }\n      }\n    };\n    removeIfExists(this.releaseFnPtr);\n    removeIfExists(this.enumFontsFnPtr);\n    removeIfExists(this.mapFontFnPtr);\n    removeIfExists(this.getFontFnPtr);\n    removeIfExists(this.getFontDataFnPtr);\n    removeIfExists(this.getFaceNameFnPtr);\n    removeIfExists(this.getFontCharsetFnPtr);\n    removeIfExists(this.deleteFontFnPtr);\n    this.releaseFnPtr = 0;\n    this.enumFontsFnPtr = 0;\n    this.mapFontFnPtr = 0;\n    this.getFontFnPtr = 0;\n    this.getFontDataFnPtr = 0;\n    this.getFaceNameFnPtr = 0;\n    this.getFontCharsetFnPtr = 0;\n    this.deleteFontFnPtr = 0;\n  }\n  /**\n   * Check if font fallback is enabled\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Get statistics about font loading\n   */\n  getStats() {\n    return {\n      handleCount: this.fontHandles.size,\n      cacheSize: this.fontCache.size,\n      cachedUrls: Array.from(this.fontCache.keys())\n    };\n  }\n  /**\n   * Pre-load fonts for specific charsets (optional optimization)\n   * This can be called to warm the cache before rendering\n   */\n  async preloadFonts(charsets) {\n    const urls = charsets.map((charset) => this.getFontUrlForCharset(charset)).filter((url) => url !== null);\n    const uniqueUrls = [...new Set(urls)];\n    await Promise.all(\n      uniqueUrls.map(async (url) => {\n        if (!this.fontCache.has(url)) {\n          try {\n            const data = await this.fetchFontAsync(url);\n            if (data) {\n              this.fontCache.set(url, data);\n              this.logger.debug(LOG_SOURCE$2, LOG_CATEGORY$2, `Pre-loaded font: ${url}`);\n            }\n          } catch (error) {\n            this.logger.warn(LOG_SOURCE$2, LOG_CATEGORY$2, `Failed to pre-load font: ${url}`, error);\n          }\n        }\n      })\n    );\n  }\n  // ============================================================================\n  // PDFium Callback Implementations\n  // ============================================================================\n  /**\n   * MapFont - called by PDFium when it needs a font\n   */\n  mapFont(weight, bItalic, charset, pitchFamily, face) {\n    const italic = bItalic !== 0;\n    this.logger.debug(LOG_SOURCE$2, LOG_CATEGORY$2, "MapFont called", {\n      weight,\n      italic,\n      charset,\n      pitchFamily,\n      face\n    });\n    const result = this.findBestFontMatch(charset, weight, italic);\n    if (!result) {\n      this.logger.debug(LOG_SOURCE$2, LOG_CATEGORY$2, `No font configured for charset ${charset}`);\n      return 0;\n    }\n    const handle = {\n      id: this.nextHandleId++,\n      charset,\n      weight,\n      italic,\n      url: result.url,\n      data: null\n    };\n    this.fontHandles.set(handle.id, handle);\n    this.logger.debug(\n      LOG_SOURCE$2,\n      LOG_CATEGORY$2,\n      `Created font handle ${handle.id} for ${result.url} (requested: weight=${weight}, italic=${italic}, matched: weight=${result.matchedWeight}, italic=${result.matchedItalic})`\n    );\n    return handle.id;\n  }\n  /**\n   * GetFontData - called by PDFium to get font bytes\n   */\n  getFontData(fontHandle, table, bufferPtr, bufSize) {\n    const handle = this.fontHandles.get(fontHandle);\n    if (!handle) {\n      this.logger.warn(LOG_SOURCE$2, LOG_CATEGORY$2, `Unknown font handle: ${fontHandle}`);\n      return 0;\n    }\n    if (!handle.data) {\n      if (this.fontCache.has(handle.url)) {\n        handle.data = this.fontCache.get(handle.url);\n      } else {\n        handle.data = this.fetchFontSync(handle.url);\n        if (handle.data) {\n          this.fontCache.set(handle.url, handle.data);\n        }\n      }\n    }\n    if (!handle.data) {\n      this.logger.warn(LOG_SOURCE$2, LOG_CATEGORY$2, `Failed to load font: ${handle.url}`);\n      return 0;\n    }\n    const fontData = handle.data;\n    if (table !== 0) {\n      this.logger.debug(\n        LOG_SOURCE$2,\n        LOG_CATEGORY$2,\n        `Table ${table} requested - returning 0 to request whole file`\n      );\n      return 0;\n    }\n    if (bufferPtr === 0 || bufSize < fontData.length) {\n      return fontData.length;\n    }\n    if (this.module) {\n      const heap = this.module.pdfium.HEAPU8;\n      heap.set(fontData, bufferPtr);\n      this.logger.debug(\n        LOG_SOURCE$2,\n        LOG_CATEGORY$2,\n        `Copied ${fontData.length} bytes to buffer for handle ${fontHandle}`\n      );\n    }\n    return fontData.length;\n  }\n  /**\n   * DeleteFont - called by PDFium when done with a font\n   */\n  deleteFont(fontHandle) {\n    const handle = this.fontHandles.get(fontHandle);\n    if (handle) {\n      this.logger.debug(LOG_SOURCE$2, LOG_CATEGORY$2, `Deleting font handle ${fontHandle}`);\n      this.fontHandles.delete(fontHandle);\n    }\n  }\n  // ============================================================================\n  // Helper Methods\n  // ============================================================================\n  /**\n   * Find the best matching font variant for the given parameters\n   */\n  findBestFontMatch(charset, requestedWeight, requestedItalic) {\n    const { fonts: fonts2, defaultFont, baseUrl } = this.fontConfig;\n    const entry = fonts2[charset] ?? defaultFont;\n    if (!entry) {\n      return null;\n    }\n    const variants = this.normalizeToVariants(entry);\n    if (variants.length === 0) {\n      return null;\n    }\n    const best = this.selectBestVariant(variants, requestedWeight, requestedItalic);\n    let url = best.url;\n    if (baseUrl && !url.startsWith("http://") && !url.startsWith("https://") && !url.startsWith("/")) {\n      url = `${baseUrl}/${url}`;\n    }\n    return {\n      url,\n      matchedWeight: best.weight ?? 400,\n      matchedItalic: best.italic ?? false\n    };\n  }\n  /**\n   * Normalize a FontEntry to an array of FontVariants\n   */\n  normalizeToVariants(entry) {\n    if (typeof entry === "string") {\n      return [{ url: entry, weight: 400, italic: false }];\n    }\n    if (Array.isArray(entry)) {\n      return entry.map((v) => ({\n        url: v.url,\n        weight: v.weight ?? 400,\n        italic: v.italic ?? false\n      }));\n    }\n    return [{ url: entry.url, weight: entry.weight ?? 400, italic: entry.italic ?? false }];\n  }\n  /**\n   * Select the best matching variant based on weight and italic\n   * Uses CSS font matching algorithm principles:\n   * 1. Exact italic match preferred\n   * 2. Closest weight (with bias toward bolder for weights >= 400)\n   */\n  selectBestVariant(variants, requestedWeight, requestedItalic) {\n    if (variants.length === 1) {\n      return variants[0];\n    }\n    const italicMatches = variants.filter((v) => (v.italic ?? false) === requestedItalic);\n    const candidates = italicMatches.length > 0 ? italicMatches : variants;\n    let bestMatch = candidates[0];\n    let bestDistance = Math.abs((bestMatch.weight ?? 400) - requestedWeight);\n    for (const variant of candidates) {\n      const variantWeight = variant.weight ?? 400;\n      const distance = Math.abs(variantWeight - requestedWeight);\n      if (distance < bestDistance) {\n        bestMatch = variant;\n        bestDistance = distance;\n      } else if (distance === bestDistance) {\n        const currentWeight = bestMatch.weight ?? 400;\n        if (requestedWeight >= 500) {\n          if (variantWeight > currentWeight) {\n            bestMatch = variant;\n          }\n        } else {\n          if (variantWeight < currentWeight) {\n            bestMatch = variant;\n          }\n        }\n      }\n    }\n    return bestMatch;\n  }\n  /**\n   * Get font URL for a charset (backward compatible helper)\n   */\n  getFontUrlForCharset(charset) {\n    const result = this.findBestFontMatch(charset, 400, false);\n    return (result == null ? void 0 : result.url) ?? null;\n  }\n  /**\n   * Fetch font data synchronously\n   * Uses custom fontLoader if provided, otherwise falls back to XMLHttpRequest (browser)\n   */\n  fetchFontSync(pathOrUrl) {\n    this.logger.debug(LOG_SOURCE$2, LOG_CATEGORY$2, `Fetching font synchronously: ${pathOrUrl}`);\n    if (this.fontConfig.fontLoader) {\n      try {\n        const data = this.fontConfig.fontLoader(pathOrUrl);\n        if (data) {\n          this.logger.info(\n            LOG_SOURCE$2,\n            LOG_CATEGORY$2,\n            `Loaded font via custom loader: ${pathOrUrl} (${data.length} bytes)`\n          );\n        } else {\n          this.logger.warn(\n            LOG_SOURCE$2,\n            LOG_CATEGORY$2,\n            `Custom font loader returned null for: ${pathOrUrl}`\n          );\n        }\n        return data;\n      } catch (error) {\n        this.logger.error(\n          LOG_SOURCE$2,\n          LOG_CATEGORY$2,\n          `Error in custom font loader: ${pathOrUrl}`,\n          error\n        );\n        return null;\n      }\n    }\n    try {\n      const xhr = new XMLHttpRequest();\n      xhr.open("GET", pathOrUrl, false);\n      xhr.responseType = "arraybuffer";\n      xhr.send();\n      if (xhr.status === 200) {\n        const data = new Uint8Array(xhr.response);\n        this.logger.info(\n          LOG_SOURCE$2,\n          LOG_CATEGORY$2,\n          `Loaded font: ${pathOrUrl} (${data.length} bytes)`\n        );\n        return data;\n      } else {\n        this.logger.error(\n          LOG_SOURCE$2,\n          LOG_CATEGORY$2,\n          `Failed to load font: ${pathOrUrl} (HTTP ${xhr.status})`\n        );\n        return null;\n      }\n    } catch (error) {\n      this.logger.error(LOG_SOURCE$2, LOG_CATEGORY$2, `Error fetching font: ${pathOrUrl}`, error);\n      return null;\n    }\n  }\n  /**\n   * Fetch font data asynchronously (for preloading)\n   * Uses custom fontLoader if provided, otherwise falls back to fetch API\n   */\n  async fetchFontAsync(pathOrUrl) {\n    if (this.fontConfig.fontLoader) {\n      try {\n        return this.fontConfig.fontLoader(pathOrUrl);\n      } catch {\n        return null;\n      }\n    }\n    try {\n      const response = await fetch(pathOrUrl);\n      if (response.ok) {\n        const buffer = await response.arrayBuffer();\n        return new Uint8Array(buffer);\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  }\n}\nconst LOG_SOURCE$1 = "PDFiumEngine";\nconst LOG_CATEGORY$1 = "Engine";\nclass PdfiumNative {\n  /**\n   * Create an instance of PdfiumNative and initialize PDFium\n   * @param wasmModule - pdfium wasm module\n   * @param options - configuration options\n   */\n  constructor(pdfiumModule, options = {}) {\n    this.pdfiumModule = pdfiumModule;\n    this.memoryLeakCheckInterval = null;\n    this.fontFallbackManager = null;\n    const { logger = new NoopLogger(), fontFallback } = options;\n    this.logger = logger;\n    this.memoryManager = new MemoryManager(this.pdfiumModule, this.logger);\n    this.cache = new PdfCache(this.pdfiumModule, this.memoryManager);\n    if (this.logger.isEnabled("debug")) {\n      this.memoryLeakCheckInterval = setInterval(() => {\n        this.memoryManager.checkLeaks();\n      }, 1e4);\n    }\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "initialize");\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `Initialize`, "Begin", "General");\n    this.pdfiumModule.PDFiumExt_Init();\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `Initialize`, "End", "General");\n    if (fontFallback) {\n      this.fontFallbackManager = new FontFallbackManager(fontFallback, this.logger);\n      this.fontFallbackManager.initialize(this.pdfiumModule);\n      this.logger.info(LOG_SOURCE$1, LOG_CATEGORY$1, "Font fallback system enabled");\n    }\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.destroy}\n   *\n   * @public\n   */\n  destroy() {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "destroy");\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `Destroy`, "Begin", "General");\n    if (this.fontFallbackManager) {\n      this.fontFallbackManager.disable();\n      this.fontFallbackManager = null;\n    }\n    this.pdfiumModule.FPDF_DestroyLibrary();\n    if (this.memoryLeakCheckInterval) {\n      clearInterval(this.memoryLeakCheckInterval);\n      this.memoryLeakCheckInterval = null;\n    }\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `Destroy`, "End", "General");\n    return PdfTaskHelper.resolve(true);\n  }\n  /**\n   * Get the font fallback manager instance\n   * Useful for pre-loading fonts or checking stats\n   */\n  getFontFallbackManager() {\n    return this.fontFallbackManager;\n  }\n  /** Write a UTF-16LE (WIDESTRING) to wasm, call `fn(ptr)`, then free. */\n  withWString(value, fn) {\n    const length = (value.length + 1) * 2;\n    const ptr = this.memoryManager.malloc(length);\n    try {\n      this.pdfiumModule.pdfium.stringToUTF16(value, ptr, length);\n      return fn(ptr);\n    } finally {\n      this.memoryManager.free(ptr);\n    }\n  }\n  /** Write a float[] to wasm, call `fn(ptr, count)`, then free. */\n  withFloatArray(values, fn) {\n    const arr = values ?? [];\n    const bytes = arr.length * 4;\n    const ptr = bytes ? this.memoryManager.malloc(bytes) : WasmPointer(0);\n    try {\n      if (bytes) {\n        for (let i = 0; i < arr.length; i++) {\n          this.pdfiumModule.pdfium.setValue(ptr + i * 4, arr[i], "float");\n        }\n      }\n      return fn(ptr, arr.length);\n    } finally {\n      if (bytes) this.memoryManager.free(ptr);\n    }\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.openDocument}\n   *\n   * @public\n   */\n  openDocumentBuffer(file, options) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "openDocumentBuffer", file, options);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `OpenDocumentBuffer`, "Begin", file.id);\n    const array = new Uint8Array(file.content);\n    const length = array.length;\n    const filePtr = this.memoryManager.malloc(length);\n    this.pdfiumModule.pdfium.HEAPU8.set(array, filePtr);\n    const docPtr = this.pdfiumModule.FPDF_LoadMemDocument(filePtr, length, (options == null ? void 0 : options.password) ?? "");\n    if (!docPtr) {\n      const lastError = this.pdfiumModule.FPDF_GetLastError();\n      this.logger.error(LOG_SOURCE$1, LOG_CATEGORY$1, `FPDF_LoadMemDocument failed with ${lastError}`);\n      this.memoryManager.free(filePtr);\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `OpenDocumentBuffer`, "End", file.id);\n      return PdfTaskHelper.reject({\n        code: lastError,\n        message: `FPDF_LoadMemDocument failed`\n      });\n    }\n    const pageCount = this.pdfiumModule.FPDF_GetPageCount(docPtr);\n    const pages = [];\n    const sizePtr = this.memoryManager.malloc(8);\n    for (let index = 0; index < pageCount; index++) {\n      const result = this.pdfiumModule.FPDF_GetPageSizeByIndexF(docPtr, index, sizePtr);\n      if (!result) {\n        const lastError = this.pdfiumModule.FPDF_GetLastError();\n        this.logger.error(\n          LOG_SOURCE$1,\n          LOG_CATEGORY$1,\n          `FPDF_GetPageSizeByIndexF failed with ${lastError}`\n        );\n        this.memoryManager.free(sizePtr);\n        this.pdfiumModule.FPDF_CloseDocument(docPtr);\n        this.memoryManager.free(filePtr);\n        this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `OpenDocumentBuffer`, "End", file.id);\n        return PdfTaskHelper.reject({\n          code: lastError,\n          message: `FPDF_GetPageSizeByIndexF failed`\n        });\n      }\n      const rotation = this.pdfiumModule.EPDF_GetPageRotationByIndex(docPtr, index);\n      const page = {\n        index,\n        size: {\n          width: this.pdfiumModule.pdfium.getValue(sizePtr, "float"),\n          height: this.pdfiumModule.pdfium.getValue(sizePtr + 4, "float")\n        },\n        rotation\n      };\n      pages.push(page);\n    }\n    this.memoryManager.free(sizePtr);\n    const pdfDoc = {\n      id: file.id,\n      pageCount,\n      pages\n    };\n    this.cache.setDocument(file.id, filePtr, docPtr);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `OpenDocumentBuffer`, "End", file.id);\n    return PdfTaskHelper.resolve(pdfDoc);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getMetadata}\n   *\n   * @public\n   */\n  getMetadata(doc) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getMetadata", doc);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `GetMetadata`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `GetMetadata`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const creationRaw = this.readMetaText(ctx.docPtr, "CreationDate");\n    const modRaw = this.readMetaText(ctx.docPtr, "ModDate");\n    const metadata = {\n      title: this.readMetaText(ctx.docPtr, "Title"),\n      author: this.readMetaText(ctx.docPtr, "Author"),\n      subject: this.readMetaText(ctx.docPtr, "Subject"),\n      keywords: this.readMetaText(ctx.docPtr, "Keywords"),\n      producer: this.readMetaText(ctx.docPtr, "Producer"),\n      creator: this.readMetaText(ctx.docPtr, "Creator"),\n      creationDate: creationRaw ? pdfDateToDate(creationRaw) ?? null : null,\n      modificationDate: modRaw ? pdfDateToDate(modRaw) ?? null : null,\n      trapped: this.getMetaTrapped(ctx.docPtr),\n      custom: this.readAllMeta(ctx.docPtr, true)\n    };\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `GetMetadata`, "End", doc.id);\n    return PdfTaskHelper.resolve(metadata);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.setMetadata}\n   *\n   * @public\n   */\n  setMetadata(doc, meta) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "setMetadata", doc, meta);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "SetMetadata", "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "SetMetadata", "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const strMap = [\n      ["title", "Title"],\n      ["author", "Author"],\n      ["subject", "Subject"],\n      ["keywords", "Keywords"],\n      ["producer", "Producer"],\n      ["creator", "Creator"]\n    ];\n    let ok = true;\n    for (const [field, key] of strMap) {\n      const v = meta[field];\n      if (v === void 0) continue;\n      const s = v === null ? null : v;\n      if (!this.setMetaText(ctx.docPtr, key, s)) ok = false;\n    }\n    const writeDate = (field, key) => {\n      const v = meta[field];\n      if (v === void 0) return;\n      if (v === null) {\n        if (!this.setMetaText(ctx.docPtr, key, null)) ok = false;\n        return;\n      }\n      const d = v;\n      const raw = dateToPdfDate(d);\n      if (!this.setMetaText(ctx.docPtr, key, raw)) ok = false;\n    };\n    writeDate("creationDate", "CreationDate");\n    writeDate("modificationDate", "ModDate");\n    if (meta.trapped !== void 0) {\n      if (!this.setMetaTrapped(ctx.docPtr, meta.trapped ?? null)) ok = false;\n    }\n    if (meta.custom !== void 0) {\n      for (const [key, value] of Object.entries(meta.custom)) {\n        if (!isValidCustomKey(key)) {\n          this.logger.warn(LOG_SOURCE$1, LOG_CATEGORY$1, "Invalid custom metadata key skipped", key);\n          continue;\n        }\n        if (!this.setMetaText(ctx.docPtr, key, value ?? null)) ok = false;\n      }\n    }\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "SetMetadata", "End", doc.id);\n    return ok ? PdfTaskHelper.resolve(true) : PdfTaskHelper.reject({\n      code: PdfErrorCode.Unknown,\n      message: "one or more metadata fields could not be written"\n    });\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getDocPermissions}\n   *\n   * @public\n   */\n  getDocPermissions(doc) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getDocPermissions", doc);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `getDocPermissions`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `getDocPermissions`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const permissions = this.pdfiumModule.FPDF_GetDocPermissions(ctx.docPtr);\n    return PdfTaskHelper.resolve(permissions);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getDocUserPermissions}\n   *\n   * @public\n   */\n  getDocUserPermissions(doc) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getDocUserPermissions", doc);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `getDocUserPermissions`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `getDocUserPermissions`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const permissions = this.pdfiumModule.FPDF_GetDocUserPermissions(ctx.docPtr);\n    return PdfTaskHelper.resolve(permissions);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getSignatures}\n   *\n   * @public\n   */\n  getSignatures(doc) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getSignatures", doc);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `GetSignatures`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `GetSignatures`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const signatures = [];\n    const count = this.pdfiumModule.FPDF_GetSignatureCount(ctx.docPtr);\n    for (let i = 0; i < count; i++) {\n      const signatureObjPtr = this.pdfiumModule.FPDF_GetSignatureObject(ctx.docPtr, i);\n      const contents = readArrayBuffer(this.pdfiumModule.pdfium, (buffer, bufferSize) => {\n        return this.pdfiumModule.FPDFSignatureObj_GetContents(signatureObjPtr, buffer, bufferSize);\n      });\n      const byteRange = readArrayBuffer(this.pdfiumModule.pdfium, (buffer, bufferSize) => {\n        return this.pdfiumModule.FPDFSignatureObj_GetByteRange(signatureObjPtr, buffer, bufferSize) * 4;\n      });\n      const subFilter = readArrayBuffer(this.pdfiumModule.pdfium, (buffer, bufferSize) => {\n        return this.pdfiumModule.FPDFSignatureObj_GetSubFilter(signatureObjPtr, buffer, bufferSize);\n      });\n      const reason = readString(\n        this.pdfiumModule.pdfium,\n        (buffer, bufferLength) => {\n          return this.pdfiumModule.FPDFSignatureObj_GetReason(\n            signatureObjPtr,\n            buffer,\n            bufferLength\n          );\n        },\n        this.pdfiumModule.pdfium.UTF16ToString\n      );\n      const time = readString(\n        this.pdfiumModule.pdfium,\n        (buffer, bufferLength) => {\n          return this.pdfiumModule.FPDFSignatureObj_GetTime(signatureObjPtr, buffer, bufferLength);\n        },\n        this.pdfiumModule.pdfium.UTF8ToString\n      );\n      const docMDP = this.pdfiumModule.FPDFSignatureObj_GetDocMDPPermission(signatureObjPtr);\n      signatures.push({\n        contents,\n        byteRange,\n        subFilter,\n        reason,\n        time,\n        docMDP\n      });\n    }\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `GetSignatures`, "End", doc.id);\n    return PdfTaskHelper.resolve(signatures);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getBookmarks}\n   *\n   * @public\n   */\n  getBookmarks(doc) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getBookmarks", doc);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `GetBookmarks`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `getBookmarks`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const bookmarks = this.readPdfBookmarks(ctx.docPtr, 0);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `GetBookmarks`, "End", doc.id);\n    return PdfTaskHelper.resolve({\n      bookmarks\n    });\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.setBookmarks}\n   *\n   * @public\n   */\n  setBookmarks(doc, list) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "setBookmarks", doc, list);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `SetBookmarks`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `SetBookmarks`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    if (!this.pdfiumModule.EPDFBookmark_Clear(ctx.docPtr)) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `SetBookmarks`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.Unknown,\n        message: "failed to clear existing bookmarks"\n      });\n    }\n    const build = (parentPtr, items) => {\n      var _a;\n      for (const item of items) {\n        const bmPtr = this.withWString(\n          item.title ?? "",\n          (wptr) => this.pdfiumModule.EPDFBookmark_AppendChild(ctx.docPtr, parentPtr, wptr)\n        );\n        if (!bmPtr) return false;\n        if (item.target) {\n          const ok2 = this.applyBookmarkTarget(ctx.docPtr, bmPtr, item.target);\n          if (!ok2) return false;\n        }\n        if ((_a = item.children) == null ? void 0 : _a.length) {\n          const ok2 = build(bmPtr, item.children);\n          if (!ok2) return false;\n        }\n      }\n      return true;\n    };\n    const ok = build(\n      /*top-level*/\n      0,\n      list\n    );\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `SetBookmarks`, "End", doc.id);\n    if (!ok) {\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.Unknown,\n        message: "failed to build bookmark tree"\n      });\n    }\n    return PdfTaskHelper.resolve(true);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.deleteBookmarks}\n   *\n   * @public\n   */\n  deleteBookmarks(doc) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "deleteBookmarks", doc);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `DeleteBookmarks`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `DeleteBookmarks`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const ok = this.pdfiumModule.EPDFBookmark_Clear(ctx.docPtr);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `DeleteBookmarks`, "End", doc.id);\n    return ok ? PdfTaskHelper.resolve(true) : PdfTaskHelper.reject({\n      code: PdfErrorCode.Unknown,\n      message: "failed to clear bookmarks"\n    });\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.renderPage}\n   *\n   * @public\n   */\n  renderPageRaw(doc, page, options) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "renderPage", doc, page, options);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `RenderPage`, "Begin", `${doc.id}-${page.index}`);\n    const rect = { origin: { x: 0, y: 0 }, size: page.size };\n    const task = this.renderRectEncoded(doc, page, rect, options);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `RenderPage`, "End", `${doc.id}-${page.index}`);\n    return task;\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.renderPageRect}\n   *\n   * @public\n   */\n  renderPageRect(doc, page, rect, options) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "renderPageRect", doc, page, rect, options);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `RenderPageRect`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const task = this.renderRectEncoded(doc, page, rect, options);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `RenderPageRect`, "End", `${doc.id}-${page.index}`);\n    return task;\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getPageAnnotations}\n   *\n   * @public\n   */\n  getPageAnnotations(doc, page) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getPageAnnotations", doc, page);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `GetPageAnnotations`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `GetPageAnnotations`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const annotations = this.readPageAnnotations(ctx, page);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `GetPageAnnotations`,\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    this.logger.debug(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `GetPageAnnotations`,\n      `${doc.id}-${page.index}`,\n      annotations\n    );\n    return PdfTaskHelper.resolve(annotations);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.createPageAnnotation}\n   *\n   * @public\n   */\n  createPageAnnotation(doc, page, annotation, context) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "createPageAnnotation", doc, page, annotation);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `CreatePageAnnotation`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `CreatePageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const annotationPtr = this.pdfiumModule.EPDFPage_CreateAnnot(pageCtx.pagePtr, annotation.type);\n    if (!annotationPtr) {\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `CreatePageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      pageCtx.release();\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantCreateAnnot,\n        message: "can not create annotation with specified type"\n      });\n    }\n    if (!isUuidV4(annotation.id)) {\n      annotation.id = uuidV4();\n    }\n    if (!this.setAnnotString(annotationPtr, "NM", annotation.id)) {\n      this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n      pageCtx.release();\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantSetAnnotString,\n        message: "can not set the name of the annotation"\n      });\n    }\n    if (!this.setPageAnnoRect(page, annotationPtr, annotation.rect)) {\n      this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n      pageCtx.release();\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `CreatePageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantSetAnnotRect,\n        message: "can not set the rect of the annotation"\n      });\n    }\n    let isSucceed = false;\n    switch (annotation.type) {\n      case PdfAnnotationSubtype.INK:\n        isSucceed = this.addInkStroke(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.STAMP:\n        isSucceed = this.addStampContent(\n          ctx.docPtr,\n          page,\n          pageCtx.pagePtr,\n          annotationPtr,\n          annotation,\n          context == null ? void 0 : context.imageData\n        );\n        break;\n      case PdfAnnotationSubtype.TEXT:\n        isSucceed = this.addTextContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.FREETEXT:\n        isSucceed = this.addFreeTextContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.LINE:\n        isSucceed = this.addLineContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.POLYLINE:\n      case PdfAnnotationSubtype.POLYGON:\n        isSucceed = this.addPolyContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.CIRCLE:\n      case PdfAnnotationSubtype.SQUARE:\n        isSucceed = this.addShapeContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.UNDERLINE:\n      case PdfAnnotationSubtype.STRIKEOUT:\n      case PdfAnnotationSubtype.SQUIGGLY:\n      case PdfAnnotationSubtype.HIGHLIGHT:\n        isSucceed = this.addTextMarkupContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n    }\n    if (!isSucceed) {\n      this.pdfiumModule.FPDFPage_RemoveAnnot(pageCtx.pagePtr, annotationPtr);\n      pageCtx.release();\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `CreatePageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantSetAnnotContent,\n        message: "can not add content of the annotation"\n      });\n    }\n    if (annotation.blendMode !== void 0) {\n      this.pdfiumModule.EPDFAnnot_GenerateAppearanceWithBlend(annotationPtr, annotation.blendMode);\n    } else {\n      this.pdfiumModule.EPDFAnnot_GenerateAppearance(annotationPtr);\n    }\n    this.pdfiumModule.FPDFPage_GenerateContent(pageCtx.pagePtr);\n    this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n    pageCtx.release();\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `CreatePageAnnotation`,\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    return PdfTaskHelper.resolve(annotation.id);\n  }\n  /**\n   * Update an existing page annotation in-place\n   *\n   *  \u2022 Locates the annot by page-local index (`annotation.id`)\n   *  \u2022 Re-writes its /Rect and type-specific payload\n   *  \u2022 Calls FPDFPage_GenerateContent so the new appearance is rendered\n   *\n   * @returns PdfTask<boolean>  \u2013  true on success\n   */\n  updatePageAnnotation(doc, page, annotation) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "updatePageAnnotation", doc, page, annotation);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      "UpdatePageAnnotation",\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        "UpdatePageAnnotation",\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const annotPtr = this.getAnnotationByName(pageCtx.pagePtr, annotation.id);\n    if (!annotPtr) {\n      pageCtx.release();\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        "UpdatePageAnnotation",\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({ code: PdfErrorCode.NotFound, message: "annotation not found" });\n    }\n    if (!this.setPageAnnoRect(page, annotPtr, annotation.rect)) {\n      this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n      pageCtx.release();\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        "UpdatePageAnnotation",\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantSetAnnotRect,\n        message: "failed to move annotation"\n      });\n    }\n    let ok = false;\n    switch (annotation.type) {\n      /* \u2500\u2500 Ink \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n      case PdfAnnotationSubtype.INK: {\n        if (!this.pdfiumModule.FPDFAnnot_RemoveInkList(annotPtr)) break;\n        ok = this.addInkStroke(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* \u2500\u2500 Stamp \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n      case PdfAnnotationSubtype.STAMP: {\n        ok = this.addStampContent(ctx.docPtr, page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      case PdfAnnotationSubtype.TEXT: {\n        ok = this.addTextContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* \u2500\u2500 Free text \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n      case PdfAnnotationSubtype.FREETEXT: {\n        ok = this.addFreeTextContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* \u2500\u2500 Shape \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n      case PdfAnnotationSubtype.CIRCLE:\n      case PdfAnnotationSubtype.SQUARE: {\n        ok = this.addShapeContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* \u2500\u2500 Line \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n      case PdfAnnotationSubtype.LINE: {\n        ok = this.addLineContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* \u2500\u2500 Polygon / Polyline \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n      case PdfAnnotationSubtype.POLYGON:\n      case PdfAnnotationSubtype.POLYLINE: {\n        ok = this.addPolyContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* \u2500\u2500 Text-markup family \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n      case PdfAnnotationSubtype.HIGHLIGHT:\n      case PdfAnnotationSubtype.UNDERLINE:\n      case PdfAnnotationSubtype.STRIKEOUT:\n      case PdfAnnotationSubtype.SQUIGGLY: {\n        ok = this.addTextMarkupContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* \u2500\u2500 Unsupported edits \u2013 fall through to error \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n      default:\n        ok = false;\n    }\n    if (ok) {\n      if (annotation.blendMode !== void 0) {\n        this.pdfiumModule.EPDFAnnot_GenerateAppearanceWithBlend(annotPtr, annotation.blendMode);\n      } else {\n        this.pdfiumModule.EPDFAnnot_GenerateAppearance(annotPtr);\n      }\n      this.pdfiumModule.FPDFPage_GenerateContent(pageCtx.pagePtr);\n    }\n    this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n    pageCtx.release();\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      "UpdatePageAnnotation",\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    return ok ? PdfTaskHelper.resolve(true) : PdfTaskHelper.reject({\n      code: PdfErrorCode.CantSetAnnotContent,\n      message: "failed to update annotation"\n    });\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.removePageAnnotation}\n   *\n   * @public\n   */\n  removePageAnnotation(doc, page, annotation) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "removePageAnnotation", doc, page, annotation);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `RemovePageAnnotation`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `RemovePageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    let result = false;\n    result = this.removeAnnotationByName(pageCtx.pagePtr, annotation.id);\n    if (!result) {\n      this.logger.error(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `FPDFPage_RemoveAnnot Failed`,\n        `${doc.id}-${page.index}`\n      );\n    } else {\n      result = this.pdfiumModule.FPDFPage_GenerateContent(pageCtx.pagePtr);\n      if (!result) {\n        this.logger.error(\n          LOG_SOURCE$1,\n          LOG_CATEGORY$1,\n          `FPDFPage_GenerateContent Failed`,\n          `${doc.id}-${page.index}`\n        );\n      }\n    }\n    pageCtx.release();\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `RemovePageAnnotation`,\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    return PdfTaskHelper.resolve(result);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getPageTextRects}\n   *\n   * @public\n   */\n  getPageTextRects(doc, page) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getPageTextRects", doc, page);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `GetPageTextRects`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `GetPageTextRects`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const textPagePtr = this.pdfiumModule.FPDFText_LoadPage(pageCtx.pagePtr);\n    const textRects = this.readPageTextRects(page, pageCtx.docPtr, pageCtx.pagePtr, textPagePtr);\n    this.pdfiumModule.FPDFText_ClosePage(textPagePtr);\n    pageCtx.release();\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `GetPageTextRects`,\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    return PdfTaskHelper.resolve(textRects);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.renderThumbnail}\n   *\n   * @public\n   */\n  renderThumbnailRaw(doc, page, options) {\n    const { scaleFactor = 1, ...rest } = options ?? {};\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "renderThumbnail", doc, page, options);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `RenderThumbnail`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `RenderThumbnail`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const result = this.renderPageRaw(doc, page, {\n      scaleFactor: Math.max(scaleFactor, 0.5),\n      ...rest\n    });\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `RenderThumbnail`, "End", `${doc.id}-${page.index}`);\n    return result;\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getAttachments}\n   *\n   * @public\n   */\n  getAttachments(doc) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getAttachments", doc);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `GetAttachments`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `GetAttachments`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const attachments = [];\n    const count = this.pdfiumModule.FPDFDoc_GetAttachmentCount(ctx.docPtr);\n    for (let i = 0; i < count; i++) {\n      const attachment = this.readPdfAttachment(ctx.docPtr, i);\n      attachments.push(attachment);\n    }\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `GetAttachments`, "End", doc.id);\n    return PdfTaskHelper.resolve(attachments);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.addAttachment}\n   *\n   * @public\n   */\n  addAttachment(doc, params) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "addAttachment", doc, params == null ? void 0 : params.name);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `AddAttachment`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `AddAttachment`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const { name, description, mimeType, data } = params ?? {};\n    if (!name) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `AddAttachment`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.NotFound,\n        message: "attachment name is required"\n      });\n    }\n    if (!data || (data instanceof Uint8Array ? data.byteLength === 0 : data.byteLength === 0)) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `AddAttachment`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.NotFound,\n        message: "attachment data is empty"\n      });\n    }\n    const attachmentPtr = this.withWString(\n      name,\n      (wNamePtr) => this.pdfiumModule.FPDFDoc_AddAttachment(ctx.docPtr, wNamePtr)\n    );\n    if (!attachmentPtr) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `AddAttachment`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.Unknown,\n        message: `An attachment named "${name}" already exists`\n      });\n    }\n    this.withWString(\n      description,\n      (wDescriptionPtr) => this.pdfiumModule.EPDFAttachment_SetDescription(attachmentPtr, wDescriptionPtr)\n    );\n    this.pdfiumModule.EPDFAttachment_SetSubtype(attachmentPtr, mimeType);\n    const u8 = data instanceof Uint8Array ? data : new Uint8Array(data);\n    const len = u8.byteLength;\n    const contentPtr = this.memoryManager.malloc(len);\n    try {\n      this.pdfiumModule.pdfium.HEAPU8.set(u8, contentPtr);\n      const ok = this.pdfiumModule.FPDFAttachment_SetFile(\n        attachmentPtr,\n        ctx.docPtr,\n        contentPtr,\n        len\n      );\n      if (!ok) {\n        this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `AddAttachment`, "End", doc.id);\n        return PdfTaskHelper.reject({\n          code: PdfErrorCode.Unknown,\n          message: "failed to write attachment bytes"\n        });\n      }\n    } finally {\n      this.memoryManager.free(contentPtr);\n    }\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `AddAttachment`, "End", doc.id);\n    return PdfTaskHelper.resolve(true);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.removeAttachment}\n   *\n   * @public\n   */\n  removeAttachment(doc, attachment) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "deleteAttachment", doc, attachment);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `DeleteAttachment`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `DeleteAttachment`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const count = this.pdfiumModule.FPDFDoc_GetAttachmentCount(ctx.docPtr);\n    if (attachment.index < 0 || attachment.index >= count) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `DeleteAttachment`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.Unknown,\n        message: `attachment index ${attachment.index} out of range`\n      });\n    }\n    const ok = this.pdfiumModule.FPDFDoc_DeleteAttachment(ctx.docPtr, attachment.index);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `DeleteAttachment`, "End", doc.id);\n    if (!ok) {\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.Unknown,\n        message: "failed to delete attachment"\n      });\n    }\n    return PdfTaskHelper.resolve(true);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.readAttachmentContent}\n   *\n   * @public\n   */\n  readAttachmentContent(doc, attachment) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "readAttachmentContent", doc, attachment);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ReadAttachmentContent`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ReadAttachmentContent`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const attachmentPtr = this.pdfiumModule.FPDFDoc_GetAttachment(ctx.docPtr, attachment.index);\n    const sizePtr = this.memoryManager.malloc(4);\n    if (!this.pdfiumModule.FPDFAttachment_GetFile(attachmentPtr, 0, 0, sizePtr)) {\n      this.memoryManager.free(sizePtr);\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ReadAttachmentContent`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantReadAttachmentSize,\n        message: "can not read attachment size"\n      });\n    }\n    const size = this.pdfiumModule.pdfium.getValue(sizePtr, "i32") >>> 0;\n    const contentPtr = this.memoryManager.malloc(size);\n    if (!this.pdfiumModule.FPDFAttachment_GetFile(attachmentPtr, contentPtr, size, sizePtr)) {\n      this.memoryManager.free(sizePtr);\n      this.memoryManager.free(contentPtr);\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ReadAttachmentContent`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantReadAttachmentContent,\n        message: "can not read attachment content"\n      });\n    }\n    const buffer = new ArrayBuffer(size);\n    const view = new DataView(buffer);\n    for (let i = 0; i < size; i++) {\n      view.setInt8(i, this.pdfiumModule.pdfium.getValue(contentPtr + i, "i8"));\n    }\n    this.memoryManager.free(sizePtr);\n    this.memoryManager.free(contentPtr);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ReadAttachmentContent`, "End", doc.id);\n    return PdfTaskHelper.resolve(buffer);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.setFormFieldValue}\n   *\n   * @public\n   */\n  setFormFieldValue(doc, page, annotation, value) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "SetFormFieldValue", doc, annotation, value);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `SetFormFieldValue`,\n      "Begin",\n      `${doc.id}-${annotation.id}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "SetFormFieldValue", "document is not opened");\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `SetFormFieldValue`,\n        "End",\n        `${doc.id}-${annotation.id}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const formFillInfoPtr = this.pdfiumModule.PDFiumExt_OpenFormFillInfo();\n    const formHandle = this.pdfiumModule.PDFiumExt_InitFormFillEnvironment(\n      ctx.docPtr,\n      formFillInfoPtr\n    );\n    const pageCtx = ctx.acquirePage(page.index);\n    this.pdfiumModule.FORM_OnAfterLoadPage(pageCtx.pagePtr, formHandle);\n    const annotationPtr = this.getAnnotationByName(pageCtx.pagePtr, annotation.id);\n    if (!annotationPtr) {\n      pageCtx.release();\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        "SetFormFieldValue",\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({ code: PdfErrorCode.NotFound, message: "annotation not found" });\n    }\n    if (!this.pdfiumModule.FORM_SetFocusedAnnot(formHandle, annotationPtr)) {\n      this.logger.debug(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        "SetFormFieldValue",\n        "failed to set focused annotation"\n      );\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `SetFormFieldValue`,\n        "End",\n        `${doc.id}-${annotation.id}`\n      );\n      this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n      this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n      pageCtx.release();\n      this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n      this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantFocusAnnot,\n        message: "failed to set focused annotation"\n      });\n    }\n    switch (value.kind) {\n      case "text":\n        {\n          if (!this.pdfiumModule.FORM_SelectAllText(formHandle, pageCtx.pagePtr)) {\n            this.logger.debug(\n              LOG_SOURCE$1,\n              LOG_CATEGORY$1,\n              "SetFormFieldValue",\n              "failed to select all text"\n            );\n            this.logger.perf(\n              LOG_SOURCE$1,\n              LOG_CATEGORY$1,\n              `SetFormFieldValue`,\n              "End",\n              `${doc.id}-${annotation.id}`\n            );\n            this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n            this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n            this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n            pageCtx.release();\n            this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n            this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n            return PdfTaskHelper.reject({\n              code: PdfErrorCode.CantSelectText,\n              message: "failed to select all text"\n            });\n          }\n          const length = 2 * (value.text.length + 1);\n          const textPtr = this.memoryManager.malloc(length);\n          this.pdfiumModule.pdfium.stringToUTF16(value.text, textPtr, length);\n          this.pdfiumModule.FORM_ReplaceSelection(formHandle, pageCtx.pagePtr, textPtr);\n          this.memoryManager.free(textPtr);\n        }\n        break;\n      case "selection":\n        {\n          if (!this.pdfiumModule.FORM_SetIndexSelected(\n            formHandle,\n            pageCtx.pagePtr,\n            value.index,\n            value.isSelected\n          )) {\n            this.logger.debug(\n              LOG_SOURCE$1,\n              LOG_CATEGORY$1,\n              "SetFormFieldValue",\n              "failed to set index selected"\n            );\n            this.logger.perf(\n              LOG_SOURCE$1,\n              LOG_CATEGORY$1,\n              `SetFormFieldValue`,\n              "End",\n              `${doc.id}-${annotation.id}`\n            );\n            this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n            this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n            this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n            pageCtx.release();\n            this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n            this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n            return PdfTaskHelper.reject({\n              code: PdfErrorCode.CantSelectOption,\n              message: "failed to set index selected"\n            });\n          }\n        }\n        break;\n      case "checked":\n        {\n          const kReturn = 13;\n          if (!this.pdfiumModule.FORM_OnChar(formHandle, pageCtx.pagePtr, kReturn, 0)) {\n            this.logger.debug(\n              LOG_SOURCE$1,\n              LOG_CATEGORY$1,\n              "SetFormFieldValue",\n              "failed to set field checked"\n            );\n            this.logger.perf(\n              LOG_SOURCE$1,\n              LOG_CATEGORY$1,\n              `SetFormFieldValue`,\n              "End",\n              `${doc.id}-${annotation.id}`\n            );\n            this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n            this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n            this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n            pageCtx.release();\n            this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n            this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n            return PdfTaskHelper.reject({\n              code: PdfErrorCode.CantCheckField,\n              message: "failed to set field checked"\n            });\n          }\n        }\n        break;\n    }\n    this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n    this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n    this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n    pageCtx.release();\n    this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n    this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n    return PdfTaskHelper.resolve(true);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.flattenPage}\n   *\n   * @public\n   */\n  flattenPage(doc, page, options) {\n    const { flag = PdfPageFlattenFlag.Display } = options ?? {};\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "flattenPage", doc, page, flag);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `flattenPage`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `flattenPage`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const result = this.pdfiumModule.FPDFPage_Flatten(pageCtx.pagePtr, flag);\n    pageCtx.release();\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `flattenPage`, "End", doc.id);\n    return PdfTaskHelper.resolve(result);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.extractPages}\n   *\n   * @public\n   */\n  extractPages(doc, pageIndexes) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "extractPages", doc, pageIndexes);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ExtractPages`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ExtractPages`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const newDocPtr = this.pdfiumModule.FPDF_CreateNewDocument();\n    if (!newDocPtr) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ExtractPages`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantCreateNewDoc,\n        message: "can not create new document"\n      });\n    }\n    const pageIndexesPtr = this.memoryManager.malloc(pageIndexes.length * 4);\n    for (let i = 0; i < pageIndexes.length; i++) {\n      this.pdfiumModule.pdfium.setValue(pageIndexesPtr + i * 4, pageIndexes[i], "i32");\n    }\n    if (!this.pdfiumModule.FPDF_ImportPagesByIndex(\n      newDocPtr,\n      ctx.docPtr,\n      pageIndexesPtr,\n      pageIndexes.length,\n      0\n    )) {\n      this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ExtractPages`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantImportPages,\n        message: "can not import pages to new document"\n      });\n    }\n    const buffer = this.saveDocument(newDocPtr);\n    this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ExtractPages`, "End", doc.id);\n    return PdfTaskHelper.resolve(buffer);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.extractText}\n   *\n   * @public\n   */\n  extractText(doc, pageIndexes) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "extractText", doc, pageIndexes);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ExtractText`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ExtractText`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const strings = [];\n    for (let i = 0; i < pageIndexes.length; i++) {\n      const pageCtx = ctx.acquirePage(pageIndexes[i]);\n      const textPagePtr = this.pdfiumModule.FPDFText_LoadPage(pageCtx.pagePtr);\n      const charCount = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n      const bufferPtr = this.memoryManager.malloc((charCount + 1) * 2);\n      this.pdfiumModule.FPDFText_GetText(textPagePtr, 0, charCount, bufferPtr);\n      const text2 = this.pdfiumModule.pdfium.UTF16ToString(bufferPtr);\n      this.memoryManager.free(bufferPtr);\n      strings.push(text2);\n      this.pdfiumModule.FPDFText_ClosePage(textPagePtr);\n      pageCtx.release();\n    }\n    const text = strings.join("\\n\\n");\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `ExtractText`, "End", doc.id);\n    return PdfTaskHelper.resolve(text);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getTextSlices}\n   *\n   * @public\n   */\n  getTextSlices(doc, slices) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getTextSlices", doc, slices);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "GetTextSlices", "Begin", doc.id);\n    if (slices.length === 0) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "GetTextSlices", "End", doc.id);\n      return PdfTaskHelper.resolve([]);\n    }\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "GetTextSlices", "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    try {\n      const out = new Array(slices.length);\n      const byPage = /* @__PURE__ */ new Map();\n      slices.forEach((s, i) => {\n        (byPage.get(s.pageIndex) ?? byPage.set(s.pageIndex, []).get(s.pageIndex)).push({\n          slice: s,\n          pos: i\n        });\n      });\n      for (const [pageIdx, list] of byPage) {\n        const pageCtx = ctx.acquirePage(pageIdx);\n        const textPagePtr = pageCtx.getTextPage();\n        for (const { slice, pos } of list) {\n          const bufPtr = this.memoryManager.malloc(2 * (slice.charCount + 1));\n          this.pdfiumModule.FPDFText_GetText(textPagePtr, slice.charIndex, slice.charCount, bufPtr);\n          out[pos] = stripPdfUnwantedMarkers(this.pdfiumModule.pdfium.UTF16ToString(bufPtr));\n          this.memoryManager.free(bufPtr);\n        }\n        pageCtx.release();\n      }\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "GetTextSlices", "End", doc.id);\n      return PdfTaskHelper.resolve(out);\n    } catch (e) {\n      this.logger.error(LOG_SOURCE$1, LOG_CATEGORY$1, "getTextSlices error", e);\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "GetTextSlices", "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.Unknown,\n        message: String(e)\n      });\n    }\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.merge}\n   *\n   * @public\n   */\n  merge(files) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "merge", files);\n    const fileIds = files.map((file2) => file2.id).join(".");\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `Merge`, "Begin", fileIds);\n    const newDocPtr = this.pdfiumModule.FPDF_CreateNewDocument();\n    if (!newDocPtr) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `Merge`, "End", fileIds);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantCreateNewDoc,\n        message: "can not create new document"\n      });\n    }\n    const ptrs = [];\n    for (const file2 of files.reverse()) {\n      const array = new Uint8Array(file2.content);\n      const length = array.length;\n      const filePtr = this.memoryManager.malloc(length);\n      this.pdfiumModule.pdfium.HEAPU8.set(array, filePtr);\n      const docPtr = this.pdfiumModule.FPDF_LoadMemDocument(filePtr, length, "");\n      if (!docPtr) {\n        const lastError = this.pdfiumModule.FPDF_GetLastError();\n        this.logger.error(\n          LOG_SOURCE$1,\n          LOG_CATEGORY$1,\n          `FPDF_LoadMemDocument failed with ${lastError}`\n        );\n        this.memoryManager.free(filePtr);\n        for (const ptr of ptrs) {\n          this.pdfiumModule.FPDF_CloseDocument(ptr.docPtr);\n          this.memoryManager.free(ptr.filePtr);\n        }\n        this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `Merge`, "End", fileIds);\n        return PdfTaskHelper.reject({\n          code: lastError,\n          message: `FPDF_LoadMemDocument failed`\n        });\n      }\n      ptrs.push({ filePtr, docPtr });\n      if (!this.pdfiumModule.FPDF_ImportPages(newDocPtr, docPtr, "", 0)) {\n        this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n        for (const ptr of ptrs) {\n          this.pdfiumModule.FPDF_CloseDocument(ptr.docPtr);\n          this.memoryManager.free(ptr.filePtr);\n        }\n        this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `Merge`, "End", fileIds);\n        return PdfTaskHelper.reject({\n          code: PdfErrorCode.CantImportPages,\n          message: "can not import pages to new document"\n        });\n      }\n    }\n    const buffer = this.saveDocument(newDocPtr);\n    this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n    for (const ptr of ptrs) {\n      this.pdfiumModule.FPDF_CloseDocument(ptr.docPtr);\n      this.memoryManager.free(ptr.filePtr);\n    }\n    const file = {\n      id: `${Math.random()}`,\n      content: buffer\n    };\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `Merge`, "End", fileIds);\n    return PdfTaskHelper.resolve(file);\n  }\n  /**\n   * Merges specific pages from multiple PDF documents in a custom order\n   *\n   * @param mergeConfigs Array of configurations specifying which pages to merge from which documents\n   * @returns A PdfTask that resolves with the merged PDF file\n   * @public\n   */\n  mergePages(mergeConfigs) {\n    const configIds = mergeConfigs.map((config) => `${config.docId}:${config.pageIndices.join(",")}`).join("|");\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "mergePages", mergeConfigs);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `MergePages`, "Begin", configIds);\n    const newDocPtr = this.pdfiumModule.FPDF_CreateNewDocument();\n    if (!newDocPtr) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `MergePages`, "End", configIds);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantCreateNewDoc,\n        message: "Cannot create new document"\n      });\n    }\n    try {\n      for (const config of [...mergeConfigs].reverse()) {\n        const ctx = this.cache.getContext(config.docId);\n        if (!ctx) {\n          this.logger.warn(\n            LOG_SOURCE$1,\n            LOG_CATEGORY$1,\n            `Document ${config.docId} is not open, skipping`\n          );\n          continue;\n        }\n        const pageCount = this.pdfiumModule.FPDF_GetPageCount(ctx.docPtr);\n        const validPageIndices = config.pageIndices.filter(\n          (index) => index >= 0 && index < pageCount\n        );\n        if (validPageIndices.length === 0) {\n          continue;\n        }\n        const pageString = validPageIndices.map((index) => index + 1).join(",");\n        try {\n          if (!this.pdfiumModule.FPDF_ImportPages(\n            newDocPtr,\n            ctx.docPtr,\n            pageString,\n            0\n            // Insert at the beginning\n          )) {\n            throw new Error(`Failed to import pages ${pageString} from document ${config.docId}`);\n          }\n        } finally {\n        }\n      }\n      const buffer = this.saveDocument(newDocPtr);\n      const file = {\n        id: `${Math.random()}`,\n        content: buffer\n      };\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `MergePages`, "End", configIds);\n      return PdfTaskHelper.resolve(file);\n    } catch (error) {\n      this.logger.error(LOG_SOURCE$1, LOG_CATEGORY$1, "mergePages failed", error);\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `MergePages`, "End", configIds);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantImportPages,\n        message: error instanceof Error ? error.message : "Failed to merge pages"\n      });\n    } finally {\n      if (newDocPtr) {\n        this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n      }\n    }\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.saveAsCopy}\n   *\n   * @public\n   */\n  saveAsCopy(doc) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "saveAsCopy", doc);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `SaveAsCopy`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `SaveAsCopy`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const buffer = this.saveDocument(ctx.docPtr);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `SaveAsCopy`, "End", doc.id);\n    return PdfTaskHelper.resolve(buffer);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.closeDocument}\n   *\n   * @public\n   */\n  closeDocument(doc) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "closeDocument", doc);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `CloseDocument`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) return PdfTaskHelper.resolve(true);\n    ctx.dispose();\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `CloseDocument`, "End", doc.id);\n    return PdfTaskHelper.resolve(true);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.closeAllDocuments}\n   *\n   * @public\n   */\n  closeAllDocuments() {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "closeAllDocuments");\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `CloseAllDocuments`, "Begin");\n    this.cache.closeAllDocuments();\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `CloseAllDocuments`, "End");\n    return PdfTaskHelper.resolve(true);\n  }\n  /**\n   * Add text content to annotation\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to text annotation\n   * @param annotation - text annotation\n   * @returns whether text content is added to annotation\n   *\n   * @private\n   */\n  addTextContent(page, pagePtr, annotationPtr, annotation) {\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (annotation.custom && !this.setAnnotCustom(annotationPtr, annotation.custom)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.inReplyToId && !this.setInReplyToId(pagePtr, annotationPtr, annotation.inReplyToId)) {\n      return false;\n    }\n    if (!this.setAnnotationIcon(annotationPtr, annotation.icon || PdfAnnotationIcon.Comment)) {\n      return false;\n    }\n    if (!this.setAnnotationFlags(annotationPtr, annotation.flags || ["print", "noZoom", "noRotate"])) {\n      return false;\n    }\n    if (annotation.state && !this.setAnnotString(annotationPtr, "State", annotation.state)) {\n      return false;\n    }\n    if (annotation.stateModel && !this.setAnnotString(annotationPtr, "StateModel", annotation.stateModel)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add free text content to annotation\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to free text annotation\n   * @param annotation - free text annotation\n   * @returns whether free text content is added to annotation\n   *\n   * @private\n   */\n  addFreeTextContent(page, pagePtr, annotationPtr, annotation) {\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.custom && !this.setAnnotCustom(annotationPtr, annotation.custom)) {\n      return false;\n    }\n    if (annotation.flags && !this.setAnnotationFlags(annotationPtr, annotation.flags)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.setBorderStyle(annotationPtr, PdfAnnotationBorderStyle.SOLID, 0)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationTextAlignment(annotationPtr, annotation.textAlign)) {\n      return false;\n    }\n    if (!this.setAnnotationVerticalAlignment(annotationPtr, annotation.verticalAlign)) {\n      return false;\n    }\n    if (!this.setAnnotationDefaultAppearance(\n      annotationPtr,\n      annotation.fontFamily,\n      annotation.fontSize,\n      annotation.fontColor\n    )) {\n      return false;\n    }\n    if (annotation.intent && !this.setAnnotIntent(annotationPtr, annotation.intent)) {\n      return false;\n    }\n    if (!annotation.backgroundColor || annotation.backgroundColor === "transparent") {\n      if (!this.pdfiumModule.EPDFAnnot_ClearColor(annotationPtr, PdfAnnotationColorType.Color)) {\n        return false;\n      }\n    } else if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.backgroundColor ?? "#FFFFFF",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Set the rect of specified annotation\n   * @param page - page info that the annotation is belonged to\n   * @param pagePtr - pointer of page object\n   * @param annotationPtr - pointer to annotation object\n   * @param inkList - ink lists that added to the annotation\n   * @returns whether the ink lists is setted\n   *\n   * @private\n   */\n  addInkStroke(page, pagePtr, annotationPtr, annotation) {\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.custom && !this.setAnnotCustom(annotationPtr, annotation.custom)) {\n      return false;\n    }\n    if (annotation.flags && !this.setAnnotationFlags(annotationPtr, annotation.flags)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setBorderStyle(annotationPtr, PdfAnnotationBorderStyle.SOLID, annotation.strokeWidth)) {\n      return false;\n    }\n    if (!this.setInkList(page, annotationPtr, annotation.inkList)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.color ?? "#FFFF00",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add line content to annotation\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to line annotation\n   * @param annotation - line annotation\n   * @returns whether line content is added to annotation\n   *\n   * @private\n   */\n  addLineContent(page, pagePtr, annotationPtr, annotation) {\n    var _a, _b;\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.custom && !this.setAnnotCustom(annotationPtr, annotation.custom)) {\n      return false;\n    }\n    if (annotation.flags && !this.setAnnotationFlags(annotationPtr, annotation.flags)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.setLinePoints(\n      page,\n      annotationPtr,\n      annotation.linePoints.start,\n      annotation.linePoints.end\n    )) {\n      return false;\n    }\n    if (!this.setLineEndings(\n      annotationPtr,\n      ((_a = annotation.lineEndings) == null ? void 0 : _a.start) ?? PdfAnnotationLineEnding.None,\n      ((_b = annotation.lineEndings) == null ? void 0 : _b.end) ?? PdfAnnotationLineEnding.None\n    )) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setBorderStyle(annotationPtr, annotation.strokeStyle, annotation.strokeWidth)) {\n      return false;\n    }\n    if (!this.setBorderDashPattern(annotationPtr, annotation.strokeDashArray ?? [])) {\n      return false;\n    }\n    if (annotation.intent && !this.setAnnotIntent(annotationPtr, annotation.intent)) {\n      return false;\n    }\n    if (!annotation.color || annotation.color === "transparent") {\n      if (!this.pdfiumModule.EPDFAnnot_ClearColor(annotationPtr, PdfAnnotationColorType.InteriorColor)) {\n        return false;\n      }\n    } else if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.color ?? "#FFFF00",\n      PdfAnnotationColorType.InteriorColor\n    )) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.strokeColor ?? "#FFFF00",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add polygon or polyline content to annotation\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to polygon or polyline annotation\n   * @param annotation - polygon or polyline annotation\n   * @returns whether polygon or polyline content is added to annotation\n   *\n   * @private\n   */\n  addPolyContent(page, pagePtr, annotationPtr, annotation) {\n    var _a, _b;\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.custom && !this.setAnnotCustom(annotationPtr, annotation.custom)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (annotation.flags && !this.setAnnotationFlags(annotationPtr, annotation.flags)) {\n      return false;\n    }\n    if (annotation.type === PdfAnnotationSubtype.POLYLINE && !this.setLineEndings(\n      annotationPtr,\n      ((_a = annotation.lineEndings) == null ? void 0 : _a.start) ?? PdfAnnotationLineEnding.None,\n      ((_b = annotation.lineEndings) == null ? void 0 : _b.end) ?? PdfAnnotationLineEnding.None\n    )) {\n      return false;\n    }\n    if (!this.setPdfAnnoVertices(page, annotationPtr, annotation.vertices)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setBorderStyle(annotationPtr, annotation.strokeStyle, annotation.strokeWidth)) {\n      return false;\n    }\n    if (!this.setBorderDashPattern(annotationPtr, annotation.strokeDashArray ?? [])) {\n      return false;\n    }\n    if (annotation.intent && !this.setAnnotIntent(annotationPtr, annotation.intent)) {\n      return false;\n    }\n    if (!annotation.color || annotation.color === "transparent") {\n      if (!this.pdfiumModule.EPDFAnnot_ClearColor(annotationPtr, PdfAnnotationColorType.InteriorColor)) {\n        return false;\n      }\n    } else if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.color ?? "#FFFF00",\n      PdfAnnotationColorType.InteriorColor\n    )) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.strokeColor ?? "#FFFF00",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add shape content to annotation\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to shape annotation\n   * @param annotation - shape annotation\n   * @returns whether shape content is added to annotation\n   *\n   * @private\n   */\n  addShapeContent(page, pagePtr, annotationPtr, annotation) {\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.custom && !this.setAnnotCustom(annotationPtr, annotation.custom)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setBorderStyle(annotationPtr, annotation.strokeStyle, annotation.strokeWidth)) {\n      return false;\n    }\n    if (!this.setBorderDashPattern(annotationPtr, annotation.strokeDashArray ?? [])) {\n      return false;\n    }\n    if (!this.setAnnotationFlags(annotationPtr, annotation.flags)) {\n      return false;\n    }\n    if (!annotation.color || annotation.color === "transparent") {\n      if (!this.pdfiumModule.EPDFAnnot_ClearColor(annotationPtr, PdfAnnotationColorType.InteriorColor)) {\n        return false;\n      }\n    } else if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.color ?? "#FFFF00",\n      PdfAnnotationColorType.InteriorColor\n    )) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.strokeColor ?? "#FFFF00",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add highlight content to annotation\n   * @param page - page info\n   * @param annotationPtr - pointer to highlight annotation\n   * @param annotation - highlight annotation\n   * @returns whether highlight content is added to annotation\n   *\n   * @private\n   */\n  addTextMarkupContent(page, pagePtr, annotationPtr, annotation) {\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.custom && !this.setAnnotCustom(annotationPtr, annotation.custom)) {\n      return false;\n    }\n    if (annotation.flags && !this.setAnnotationFlags(annotationPtr, annotation.flags)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.syncQuadPointsAnno(page, annotationPtr, annotation.segmentRects)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.color ?? "#FFFF00",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add contents to stamp annotation\n   * @param docPtr - pointer to pdf document object\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to stamp annotation\n   * @param rect - rect of stamp annotation\n   * @param contents - contents of stamp annotation\n   * @returns whether contents is added to annotation\n   *\n   * @private\n   */\n  addStampContent(docPtr, page, pagePtr, annotationPtr, annotation, imageData) {\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.custom && !this.setAnnotCustom(annotationPtr, annotation.custom)) {\n      return false;\n    }\n    if (annotation.flags && !this.setAnnotationFlags(annotationPtr, annotation.flags)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (annotation.icon && !this.setAnnotationIcon(annotationPtr, annotation.icon)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (annotation.subject && !this.setAnnotString(annotationPtr, "Subj", annotation.subject)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (imageData) {\n      for (let i = this.pdfiumModule.FPDFAnnot_GetObjectCount(annotationPtr) - 1; i >= 0; i--) {\n        this.pdfiumModule.FPDFAnnot_RemoveObject(annotationPtr, i);\n      }\n      if (!this.addImageObject(docPtr, page, pagePtr, annotationPtr, annotation.rect, imageData)) {\n        return false;\n      }\n    }\n    if (!this.pdfiumModule.EPDFAnnot_UpdateAppearanceToRect(annotationPtr, PdfStampFit.Cover)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add image object to annotation\n   * @param docPtr - pointer to pdf document object\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to stamp annotation\n   * @param position - position of image\n   * @param imageData - data of image\n   * @returns whether image is added to annotation\n   *\n   * @private\n   */\n  addImageObject(docPtr, page, pagePtr, annotationPtr, rect, imageData) {\n    const bytesPerPixel = 4;\n    const pixelCount = imageData.width * imageData.height;\n    const bitmapBufferPtr = this.memoryManager.malloc(bytesPerPixel * pixelCount);\n    if (!bitmapBufferPtr) {\n      return false;\n    }\n    for (let i = 0; i < pixelCount; i++) {\n      const red = imageData.data[i * bytesPerPixel];\n      const green = imageData.data[i * bytesPerPixel + 1];\n      const blue = imageData.data[i * bytesPerPixel + 2];\n      const alpha = imageData.data[i * bytesPerPixel + 3];\n      this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel, blue, "i8");\n      this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel + 1, green, "i8");\n      this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel + 2, red, "i8");\n      this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel + 3, alpha, "i8");\n    }\n    const format = 4;\n    const bitmapPtr = this.pdfiumModule.FPDFBitmap_CreateEx(\n      imageData.width,\n      imageData.height,\n      format,\n      bitmapBufferPtr,\n      0\n    );\n    if (!bitmapPtr) {\n      this.memoryManager.free(bitmapBufferPtr);\n      return false;\n    }\n    const imageObjectPtr = this.pdfiumModule.FPDFPageObj_NewImageObj(docPtr);\n    if (!imageObjectPtr) {\n      this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n      this.memoryManager.free(bitmapBufferPtr);\n      return false;\n    }\n    if (!this.pdfiumModule.FPDFImageObj_SetBitmap(pagePtr, 0, imageObjectPtr, bitmapPtr)) {\n      this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n      this.pdfiumModule.FPDFPageObj_Destroy(imageObjectPtr);\n      this.memoryManager.free(bitmapBufferPtr);\n      return false;\n    }\n    const matrixPtr = this.memoryManager.malloc(6 * 4);\n    this.pdfiumModule.pdfium.setValue(matrixPtr, imageData.width, "float");\n    this.pdfiumModule.pdfium.setValue(matrixPtr + 4, 0, "float");\n    this.pdfiumModule.pdfium.setValue(matrixPtr + 8, 0, "float");\n    this.pdfiumModule.pdfium.setValue(matrixPtr + 12, imageData.height, "float");\n    this.pdfiumModule.pdfium.setValue(matrixPtr + 16, 0, "float");\n    this.pdfiumModule.pdfium.setValue(matrixPtr + 20, 0, "float");\n    if (!this.pdfiumModule.FPDFPageObj_SetMatrix(imageObjectPtr, matrixPtr)) {\n      this.memoryManager.free(matrixPtr);\n      this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n      this.pdfiumModule.FPDFPageObj_Destroy(imageObjectPtr);\n      this.memoryManager.free(bitmapBufferPtr);\n      return false;\n    }\n    this.memoryManager.free(matrixPtr);\n    const pagePos = this.convertDevicePointToPagePoint(page, {\n      x: rect.origin.x,\n      y: rect.origin.y + imageData.height\n      // shift down by the image height\n    });\n    this.pdfiumModule.FPDFPageObj_Transform(imageObjectPtr, 1, 0, 0, 1, pagePos.x, pagePos.y);\n    if (!this.pdfiumModule.FPDFAnnot_AppendObject(annotationPtr, imageObjectPtr)) {\n      this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n      this.pdfiumModule.FPDFPageObj_Destroy(imageObjectPtr);\n      this.memoryManager.free(bitmapBufferPtr);\n      return false;\n    }\n    this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n    this.memoryManager.free(bitmapBufferPtr);\n    return true;\n  }\n  /**\n   * Save document to array buffer\n   * @param docPtr - pointer to pdf document\n   * @returns array buffer contains the pdf content\n   *\n   * @private\n   */\n  saveDocument(docPtr) {\n    const writerPtr = this.pdfiumModule.PDFiumExt_OpenFileWriter();\n    this.pdfiumModule.PDFiumExt_SaveAsCopy(docPtr, writerPtr);\n    const size = this.pdfiumModule.PDFiumExt_GetFileWriterSize(writerPtr);\n    const dataPtr = this.memoryManager.malloc(size);\n    this.pdfiumModule.PDFiumExt_GetFileWriterData(writerPtr, dataPtr, size);\n    const buffer = new ArrayBuffer(size);\n    const view = new DataView(buffer);\n    for (let i = 0; i < size; i++) {\n      view.setInt8(i, this.pdfiumModule.pdfium.getValue(dataPtr + i, "i8"));\n    }\n    this.memoryManager.free(dataPtr);\n    this.pdfiumModule.PDFiumExt_CloseFileWriter(writerPtr);\n    return buffer;\n  }\n  /**\n   * Read Catalog /Lang via EPDFCatalog_GetLanguage (UTF-16LE \u2192 JS string).\n   * Returns:\n   *   null  -> /Lang not present (getter returned 0) OR doc not open,\n   *   \'\'    -> /Lang exists but is explicitly empty,\n   *   \'en\', \'en-US\', ... -> normal tag.\n   *\n   * Note: EPDFCatalog_GetLanguage lengths are BYTES (incl. trailing NUL).\n   *\n   * @private\n   */\n  readCatalogLanguage(docPtr) {\n    const byteLen = this.pdfiumModule.EPDFCatalog_GetLanguage(docPtr, 0, 0) >>> 0;\n    if (byteLen === 0) return null;\n    if (byteLen === 2) return "";\n    return readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => this.pdfiumModule.EPDFCatalog_GetLanguage(docPtr, buffer, bufferLength),\n      this.pdfiumModule.pdfium.UTF16ToString,\n      byteLen\n    );\n  }\n  /**\n   * Read metadata from pdf document\n   * @param docPtr - pointer to pdf document\n   * @param key - key of metadata field\n   * @returns metadata value\n   *\n   * @private\n   */\n  readMetaText(docPtr, key) {\n    const exists = !!this.pdfiumModule.EPDF_HasMetaText(docPtr, key);\n    if (!exists) return null;\n    const len = this.pdfiumModule.FPDF_GetMetaText(docPtr, key, 0, 0);\n    if (len === 2) return "";\n    return readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => this.pdfiumModule.FPDF_GetMetaText(docPtr, key, buffer, bufferLength),\n      this.pdfiumModule.pdfium.UTF16ToString,\n      len\n    );\n  }\n  /**\n   * Write metadata into the PDF\'s Info dictionary.\n   * If `value` is null or empty string, the key is removed.\n   * @param docPtr - pointer to pdf document\n   * @param key - key of metadata field\n   * @param value - value of metadata field\n   * @returns whether metadata is written to the pdf document\n   *\n   * @private\n   */\n  setMetaText(docPtr, key, value) {\n    if (value == null || value.length === 0) {\n      const ok = this.pdfiumModule.EPDF_SetMetaText(docPtr, key, 0);\n      return !!ok;\n    }\n    const bytes = 2 * (value.length + 1);\n    const ptr = this.memoryManager.malloc(bytes);\n    try {\n      this.pdfiumModule.pdfium.stringToUTF16(value, ptr, bytes);\n      const ok = this.pdfiumModule.EPDF_SetMetaText(docPtr, key, ptr);\n      return !!ok;\n    } finally {\n      this.memoryManager.free(ptr);\n    }\n  }\n  /**\n   * Read the document\'s trapped status via PDFium.\n   * Falls back to `Unknown` on unexpected values.\n   *\n   * @private\n   */\n  getMetaTrapped(docPtr) {\n    const raw = Number(this.pdfiumModule.EPDF_GetMetaTrapped(docPtr));\n    switch (raw) {\n      case PdfTrappedStatus.NotSet:\n      case PdfTrappedStatus.True:\n      case PdfTrappedStatus.False:\n      case PdfTrappedStatus.Unknown:\n        return raw;\n      default:\n        return PdfTrappedStatus.Unknown;\n    }\n  }\n  /**\n   * Write (or clear) the document\'s trapped status via PDFium.\n   * Pass `null`/`undefined` to remove the `/Trapped` key.\n   *\n   * @private\n   */\n  setMetaTrapped(docPtr, status) {\n    const toSet = status == null || status === void 0 ? PdfTrappedStatus.NotSet : status;\n    const valid = toSet === PdfTrappedStatus.NotSet || toSet === PdfTrappedStatus.True || toSet === PdfTrappedStatus.False || toSet === PdfTrappedStatus.Unknown;\n    if (!valid) return false;\n    return !!this.pdfiumModule.EPDF_SetMetaTrapped(docPtr, toSet);\n  }\n  /**\n   * Get the number of keys in the document\'s Info dictionary.\n   * @param docPtr - pointer to pdf document\n   * @param customOnly - if true, only count non-reserved (custom) keys; if false, count all keys.\n   * @returns the number of keys (possibly 0). On error, returns 0.\n   *\n   * @private\n   */\n  getMetaKeyCount(docPtr, customOnly) {\n    return Number(this.pdfiumModule.EPDF_GetMetaKeyCount(docPtr, customOnly)) | 0;\n  }\n  /**\n   * Get the name of the Info dictionary key at |index|.\n   * @param docPtr - pointer to pdf document\n   * @param index - 0-based key index in the order returned by PDFium.\n   * @param customOnly - if true, indexes only over non-reserved (custom) keys; if false, indexes over all keys.\n   * @returns the name of the key, or null if the key is not found.\n   *\n   * @private\n   */\n  getMetaKeyName(docPtr, index, customOnly) {\n    const len = this.pdfiumModule.EPDF_GetMetaKeyName(docPtr, index, customOnly, 0, 0);\n    if (!len) return null;\n    return readString(\n      this.pdfiumModule.pdfium,\n      (buffer, buflen) => this.pdfiumModule.EPDF_GetMetaKeyName(docPtr, index, customOnly, buffer, buflen),\n      this.pdfiumModule.pdfium.UTF8ToString,\n      len\n    );\n  }\n  /**\n   * Read all metadata from the document\'s Info dictionary.\n   * @param docPtr - pointer to pdf document\n   * @param customOnly - if true, only read non-reserved (custom) keys; if false, read all keys.\n   * @returns all metadata\n   *\n   * @private\n   */\n  readAllMeta(docPtr, customOnly = true) {\n    const n = this.getMetaKeyCount(docPtr, customOnly);\n    const out = {};\n    for (let i = 0; i < n; i++) {\n      const key = this.getMetaKeyName(docPtr, i, customOnly);\n      if (!key) continue;\n      out[key] = this.readMetaText(docPtr, key);\n    }\n    return out;\n  }\n  /**\n   * Read bookmarks in the pdf document\n   * @param docPtr - pointer to pdf document\n   * @param rootBookmarkPtr - pointer to root bookmark\n   * @returns bookmarks in the pdf document\n   *\n   * @private\n   */\n  readPdfBookmarks(docPtr, rootBookmarkPtr = 0) {\n    let bookmarkPtr = this.pdfiumModule.FPDFBookmark_GetFirstChild(docPtr, rootBookmarkPtr);\n    const bookmarks = [];\n    while (bookmarkPtr) {\n      const bookmark = this.readPdfBookmark(docPtr, bookmarkPtr);\n      bookmarks.push(bookmark);\n      const nextBookmarkPtr = this.pdfiumModule.FPDFBookmark_GetNextSibling(docPtr, bookmarkPtr);\n      bookmarkPtr = nextBookmarkPtr;\n    }\n    return bookmarks;\n  }\n  /**\n   * Read bookmark in the pdf document\n   * @param docPtr - pointer to pdf document\n   * @param bookmarkPtr - pointer to bookmark object\n   * @returns pdf bookmark object\n   *\n   * @private\n   */\n  readPdfBookmark(docPtr, bookmarkPtr) {\n    const title = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFBookmark_GetTitle(bookmarkPtr, buffer, bufferLength);\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const bookmarks = this.readPdfBookmarks(docPtr, bookmarkPtr);\n    const target = this.readPdfBookmarkTarget(\n      docPtr,\n      () => {\n        return this.pdfiumModule.FPDFBookmark_GetAction(bookmarkPtr);\n      },\n      () => {\n        return this.pdfiumModule.FPDFBookmark_GetDest(docPtr, bookmarkPtr);\n      }\n    );\n    return {\n      title,\n      target,\n      children: bookmarks\n    };\n  }\n  /**\n   * Read text rects in pdf page\n   * @param page - pdf page info\n   * @param docPtr - pointer to pdf document\n   * @param pagePtr - pointer to pdf page\n   * @param textPagePtr - pointer to pdf text page\n   * @returns text rects in the pdf page\n   *\n   * @public\n   */\n  readPageTextRects(page, docPtr, pagePtr, textPagePtr) {\n    const rectsCount = this.pdfiumModule.FPDFText_CountRects(textPagePtr, 0, -1);\n    const textRects = [];\n    for (let i = 0; i < rectsCount; i++) {\n      const topPtr = this.memoryManager.malloc(8);\n      const leftPtr = this.memoryManager.malloc(8);\n      const rightPtr = this.memoryManager.malloc(8);\n      const bottomPtr = this.memoryManager.malloc(8);\n      const isSucceed = this.pdfiumModule.FPDFText_GetRect(\n        textPagePtr,\n        i,\n        leftPtr,\n        topPtr,\n        rightPtr,\n        bottomPtr\n      );\n      if (!isSucceed) {\n        this.memoryManager.free(leftPtr);\n        this.memoryManager.free(topPtr);\n        this.memoryManager.free(rightPtr);\n        this.memoryManager.free(bottomPtr);\n        continue;\n      }\n      const left = this.pdfiumModule.pdfium.getValue(leftPtr, "double");\n      const top = this.pdfiumModule.pdfium.getValue(topPtr, "double");\n      const right = this.pdfiumModule.pdfium.getValue(rightPtr, "double");\n      const bottom = this.pdfiumModule.pdfium.getValue(bottomPtr, "double");\n      this.memoryManager.free(leftPtr);\n      this.memoryManager.free(topPtr);\n      this.memoryManager.free(rightPtr);\n      this.memoryManager.free(bottomPtr);\n      const deviceXPtr = this.memoryManager.malloc(4);\n      const deviceYPtr = this.memoryManager.malloc(4);\n      this.pdfiumModule.FPDF_PageToDevice(\n        pagePtr,\n        0,\n        0,\n        page.size.width,\n        page.size.height,\n        0,\n        left,\n        top,\n        deviceXPtr,\n        deviceYPtr\n      );\n      const x = this.pdfiumModule.pdfium.getValue(deviceXPtr, "i32");\n      const y = this.pdfiumModule.pdfium.getValue(deviceYPtr, "i32");\n      this.memoryManager.free(deviceXPtr);\n      this.memoryManager.free(deviceYPtr);\n      const rect = {\n        origin: {\n          x,\n          y\n        },\n        size: {\n          width: Math.ceil(Math.abs(right - left)),\n          height: Math.ceil(Math.abs(top - bottom))\n        }\n      };\n      const utf16Length = this.pdfiumModule.FPDFText_GetBoundedText(\n        textPagePtr,\n        left,\n        top,\n        right,\n        bottom,\n        0,\n        0\n      );\n      const bytesCount = (utf16Length + 1) * 2;\n      const textBuffer = this.memoryManager.malloc(bytesCount);\n      this.pdfiumModule.FPDFText_GetBoundedText(\n        textPagePtr,\n        left,\n        top,\n        right,\n        bottom,\n        textBuffer,\n        utf16Length\n      );\n      const content = this.pdfiumModule.pdfium.UTF16ToString(textBuffer);\n      this.memoryManager.free(textBuffer);\n      const charIndex = this.pdfiumModule.FPDFText_GetCharIndexAtPos(textPagePtr, left, top, 2, 2);\n      let fontFamily = "";\n      let fontSize = rect.size.height;\n      if (charIndex >= 0) {\n        fontSize = this.pdfiumModule.FPDFText_GetFontSize(textPagePtr, charIndex);\n        const fontNameLength = this.pdfiumModule.FPDFText_GetFontInfo(\n          textPagePtr,\n          charIndex,\n          0,\n          0,\n          0\n        );\n        const bytesCount2 = fontNameLength + 1;\n        const textBufferPtr = this.memoryManager.malloc(bytesCount2);\n        const flagsPtr = this.memoryManager.malloc(4);\n        this.pdfiumModule.FPDFText_GetFontInfo(\n          textPagePtr,\n          charIndex,\n          textBufferPtr,\n          bytesCount2,\n          flagsPtr\n        );\n        fontFamily = this.pdfiumModule.pdfium.UTF8ToString(textBufferPtr);\n        this.memoryManager.free(textBufferPtr);\n        this.memoryManager.free(flagsPtr);\n      }\n      const textRect = {\n        content,\n        rect,\n        font: {\n          family: fontFamily,\n          size: fontSize\n        }\n      };\n      textRects.push(textRect);\n    }\n    return textRects;\n  }\n  /**\n   * Return geometric + logical text layout for one page\n   * (glyph-only implementation, no FPDFText_GetRect).\n   *\n   * @public\n   */\n  getPageGeometry(doc, page) {\n    const label = "getPageGeometry";\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, label, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, label, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const textPagePtr = pageCtx.getTextPage();\n    const glyphCount = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n    const glyphs = [];\n    for (let i = 0; i < glyphCount; i++) {\n      const g = this.readGlyphInfo(page, pageCtx.pagePtr, textPagePtr, i);\n      glyphs.push(g);\n    }\n    const runs = this.buildRunsFromGlyphs(glyphs, textPagePtr);\n    pageCtx.release();\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, label, "End", doc.id);\n    return PdfTaskHelper.resolve({ runs });\n  }\n  /**\n   * Group consecutive glyphs that belong to the same CPDF_TextObject\n   * using FPDFText_GetTextObject(), and calculate rotation from glyph positions.\n   */\n  buildRunsFromGlyphs(glyphs, textPagePtr) {\n    const runs = [];\n    let current = null;\n    let curObjPtr = null;\n    let bounds = null;\n    for (let i = 0; i < glyphs.length; i++) {\n      const g = glyphs[i];\n      const objPtr = this.pdfiumModule.FPDFText_GetTextObject(textPagePtr, i);\n      if (objPtr !== curObjPtr) {\n        curObjPtr = objPtr;\n        current = {\n          rect: {\n            x: g.origin.x,\n            y: g.origin.y,\n            width: g.size.width,\n            height: g.size.height\n          },\n          charStart: i,\n          glyphs: []\n        };\n        bounds = {\n          minX: g.origin.x,\n          minY: g.origin.y,\n          maxX: g.origin.x + g.size.width,\n          maxY: g.origin.y + g.size.height\n        };\n        runs.push(current);\n      }\n      current.glyphs.push({\n        x: g.origin.x,\n        y: g.origin.y,\n        width: g.size.width,\n        height: g.size.height,\n        flags: g.isEmpty ? 2 : g.isSpace ? 1 : 0\n      });\n      if (g.isEmpty) {\n        continue;\n      }\n      const right = g.origin.x + g.size.width;\n      const bottom = g.origin.y + g.size.height;\n      bounds.minX = Math.min(bounds.minX, g.origin.x);\n      bounds.minY = Math.min(bounds.minY, g.origin.y);\n      bounds.maxX = Math.max(bounds.maxX, right);\n      bounds.maxY = Math.max(bounds.maxY, bottom);\n      current.rect.x = bounds.minX;\n      current.rect.y = bounds.minY;\n      current.rect.width = bounds.maxX - bounds.minX;\n      current.rect.height = bounds.maxY - bounds.minY;\n    }\n    return runs;\n  }\n  /**\n   * Extract glyph geometry + metadata for `charIndex`\n   *\n   * Returns device\u2013space coordinates:\n   *   x,y  \u2192 **top-left** corner (integer-pixels)\n   *   w,h  \u2192 width / height (integer-pixels, \u2265 1)\n   *\n   * And two flags:\n   *   isSpace \u2192 true if the glyph\'s Unicode code-point is U+0020\n   */\n  readGlyphInfo(page, pagePtr, textPagePtr, charIndex) {\n    const dx1Ptr = this.memoryManager.malloc(4);\n    const dy1Ptr = this.memoryManager.malloc(4);\n    const dx2Ptr = this.memoryManager.malloc(4);\n    const dy2Ptr = this.memoryManager.malloc(4);\n    const rectPtr = this.memoryManager.malloc(16);\n    let x = 0, y = 0, width = 0, height = 0, isSpace = false;\n    if (this.pdfiumModule.FPDFText_GetLooseCharBox(textPagePtr, charIndex, rectPtr)) {\n      const left = this.pdfiumModule.pdfium.getValue(rectPtr, "float");\n      const top = this.pdfiumModule.pdfium.getValue(rectPtr + 4, "float");\n      const right = this.pdfiumModule.pdfium.getValue(rectPtr + 8, "float");\n      const bottom = this.pdfiumModule.pdfium.getValue(rectPtr + 12, "float");\n      if (left === right || top === bottom) {\n        [rectPtr, dx1Ptr, dy1Ptr, dx2Ptr, dy2Ptr].forEach((p) => this.memoryManager.free(p));\n        return {\n          origin: { x: 0, y: 0 },\n          size: { width: 0, height: 0 },\n          isEmpty: true\n        };\n      }\n      this.pdfiumModule.FPDF_PageToDevice(\n        pagePtr,\n        0,\n        0,\n        page.size.width,\n        page.size.height,\n        /*rotate=*/\n        0,\n        left,\n        top,\n        dx1Ptr,\n        dy1Ptr\n      );\n      this.pdfiumModule.FPDF_PageToDevice(\n        pagePtr,\n        0,\n        0,\n        page.size.width,\n        page.size.height,\n        /*rotate=*/\n        0,\n        right,\n        bottom,\n        dx2Ptr,\n        dy2Ptr\n      );\n      const x1 = this.pdfiumModule.pdfium.getValue(dx1Ptr, "i32");\n      const y1 = this.pdfiumModule.pdfium.getValue(dy1Ptr, "i32");\n      const x2 = this.pdfiumModule.pdfium.getValue(dx2Ptr, "i32");\n      const y2 = this.pdfiumModule.pdfium.getValue(dy2Ptr, "i32");\n      x = Math.min(x1, x2);\n      y = Math.min(y1, y2);\n      width = Math.max(1, Math.abs(x2 - x1));\n      height = Math.max(1, Math.abs(y2 - y1));\n      const uc = this.pdfiumModule.FPDFText_GetUnicode(textPagePtr, charIndex);\n      isSpace = uc === 32;\n    }\n    [rectPtr, dx1Ptr, dy1Ptr, dx2Ptr, dy2Ptr].forEach((p) => this.memoryManager.free(p));\n    return {\n      origin: { x, y },\n      size: { width, height },\n      ...isSpace && { isSpace }\n    };\n  }\n  /**\n   * Geometry-only text extraction\n   * ------------------------------------------\n   * Returns every glyph on the requested page\n   * in the logical order delivered by PDFium.\n   *\n   * The promise resolves to an array of objects:\n   *   {\n   *     idx:     number;            // glyph index on the page (0\u2026n-1)\n   *     origin:  { x: number; y: number };\n   *     size:    { width: number;  height: number };\n   *     angle:   number;            // degrees, counter-clock-wise\n   *     isSpace: boolean;           // true  \u2192 U+0020\n   *   }\n   *\n   * No Unicode is included; front-end decides whether to hydrate it.\n   */\n  getPageGlyphs(doc, page) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getPageGlyphs", doc, page);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "getPageGlyphs", "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "getPageGlyphs", "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const textPagePtr = pageCtx.getTextPage();\n    const total = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n    const glyphs = new Array(total);\n    for (let i = 0; i < total; i++) {\n      const g = this.readGlyphInfo(page, pageCtx.pagePtr, textPagePtr, i);\n      if (g.isEmpty) {\n        continue;\n      }\n      glyphs[i] = { ...g };\n    }\n    pageCtx.release();\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "getPageGlyphs", "End", doc.id);\n    return PdfTaskHelper.resolve(glyphs);\n  }\n  readCharBox(page, pagePtr, textPagePtr, charIndex) {\n    const topPtr = this.memoryManager.malloc(8);\n    const leftPtr = this.memoryManager.malloc(8);\n    const bottomPtr = this.memoryManager.malloc(8);\n    const rightPtr = this.memoryManager.malloc(8);\n    let x = 0;\n    let y = 0;\n    let width = 0;\n    let height = 0;\n    if (this.pdfiumModule.FPDFText_GetCharBox(\n      textPagePtr,\n      charIndex,\n      leftPtr,\n      rightPtr,\n      bottomPtr,\n      topPtr\n    )) {\n      const top = this.pdfiumModule.pdfium.getValue(topPtr, "double");\n      const left = this.pdfiumModule.pdfium.getValue(leftPtr, "double");\n      const bottom = this.pdfiumModule.pdfium.getValue(bottomPtr, "double");\n      const right = this.pdfiumModule.pdfium.getValue(rightPtr, "double");\n      const deviceXPtr = this.memoryManager.malloc(4);\n      const deviceYPtr = this.memoryManager.malloc(4);\n      this.pdfiumModule.FPDF_PageToDevice(\n        pagePtr,\n        0,\n        0,\n        page.size.width,\n        page.size.height,\n        0,\n        left,\n        top,\n        deviceXPtr,\n        deviceYPtr\n      );\n      x = this.pdfiumModule.pdfium.getValue(deviceXPtr, "i32");\n      y = this.pdfiumModule.pdfium.getValue(deviceYPtr, "i32");\n      this.memoryManager.free(deviceXPtr);\n      this.memoryManager.free(deviceYPtr);\n      width = Math.ceil(Math.abs(right - left));\n      height = Math.ceil(Math.abs(top - bottom));\n    }\n    this.memoryManager.free(topPtr);\n    this.memoryManager.free(leftPtr);\n    this.memoryManager.free(bottomPtr);\n    this.memoryManager.free(rightPtr);\n    return {\n      origin: {\n        x,\n        y\n      },\n      size: {\n        width,\n        height\n      }\n    };\n  }\n  /**\n   * Read page annotations\n   *\n   * @param ctx - document context\n   * @param page - page info\n   * @returns annotations on the pdf page\n   *\n   * @private\n   */\n  readPageAnnotations(ctx, page) {\n    return ctx.borrowPage(page.index, (pageCtx) => {\n      const annotationCount = this.pdfiumModule.FPDFPage_GetAnnotCount(pageCtx.pagePtr);\n      const annotations = [];\n      for (let i = 0; i < annotationCount; i++) {\n        pageCtx.withAnnotation(i, (annotPtr) => {\n          const anno = this.readPageAnnotation(ctx.docPtr, page, annotPtr, pageCtx);\n          if (anno) annotations.push(anno);\n        });\n      }\n      return annotations;\n    });\n  }\n  /**\n   * Read page annotations without loading the page (raw approach)\n   *\n   * @param ctx - document context\n   * @param page - page info\n   * @returns annotations on the pdf page\n   *\n   * @private\n   */\n  readPageAnnotationsRaw(ctx, page) {\n    const count = this.pdfiumModule.EPDFPage_GetAnnotCountRaw(ctx.docPtr, page.index);\n    if (count <= 0) return [];\n    const out = [];\n    for (let i = 0; i < count; ++i) {\n      const annotPtr = this.pdfiumModule.EPDFPage_GetAnnotRaw(ctx.docPtr, page.index, i);\n      if (!annotPtr) continue;\n      try {\n        const anno = this.readPageAnnotation(ctx.docPtr, page, annotPtr);\n        if (anno) out.push(anno);\n      } finally {\n        this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n      }\n    }\n    return out;\n  }\n  /**\n   * Get page annotations (public API, returns Task)\n   *\n   * @param doc - pdf document\n   * @param page - page info\n   * @returns task with annotations on the pdf page\n   *\n   * @public\n   */\n  getPageAnnotationsRaw(doc, page) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getPageAnnotationsRaw", doc, page);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `GetPageAnnotationsRaw`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const out = this.readPageAnnotationsRaw(ctx, page);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `GetPageAnnotationsRaw`,\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    this.logger.debug(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      "getPageAnnotationsRaw",\n      `${doc.id}-${page.index}`,\n      out\n    );\n    return PdfTaskHelper.resolve(out);\n  }\n  /**\n   * Read pdf annotation from pdf document\n   *\n   * @param docPtr - pointer to pdf document\n   * @param page - page info\n   * @param annotationPtr - pointer to pdf annotation\n   * @param pageCtx - page context\n   * @returns pdf annotation\n   *\n   * @private\n   */\n  readPageAnnotation(docPtr, page, annotationPtr, pageCtx) {\n    let index = this.getAnnotString(annotationPtr, "NM");\n    if (!index || !isUuidV4(index)) {\n      index = uuidV4();\n      this.setAnnotString(annotationPtr, "NM", index);\n    }\n    const subType = this.pdfiumModule.FPDFAnnot_GetSubtype(\n      annotationPtr\n    );\n    let annotation;\n    switch (subType) {\n      case PdfAnnotationSubtype.TEXT:\n        {\n          annotation = this.readPdfTextAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.FREETEXT:\n        {\n          annotation = this.readPdfFreeTextAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.LINK:\n        {\n          annotation = this.readPdfLinkAnno(page, docPtr, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.WIDGET:\n        if (pageCtx) {\n          return this.readPdfWidgetAnno(page, annotationPtr, pageCtx.getFormHandle(), index);\n        }\n      case PdfAnnotationSubtype.FILEATTACHMENT:\n        {\n          annotation = this.readPdfFileAttachmentAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.INK:\n        {\n          annotation = this.readPdfInkAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.POLYGON:\n        {\n          annotation = this.readPdfPolygonAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.POLYLINE:\n        {\n          annotation = this.readPdfPolylineAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.LINE:\n        {\n          annotation = this.readPdfLineAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.HIGHLIGHT:\n        annotation = this.readPdfHighlightAnno(page, annotationPtr, index);\n        break;\n      case PdfAnnotationSubtype.STAMP:\n        {\n          annotation = this.readPdfStampAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.SQUARE:\n        {\n          annotation = this.readPdfSquareAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.CIRCLE:\n        {\n          annotation = this.readPdfCircleAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.UNDERLINE:\n        {\n          annotation = this.readPdfUnderlineAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.SQUIGGLY:\n        {\n          annotation = this.readPdfSquigglyAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.STRIKEOUT:\n        {\n          annotation = this.readPdfStrikeOutAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.CARET:\n        {\n          annotation = this.readPdfCaretAnno(page, annotationPtr, index);\n        }\n        break;\n      default:\n        {\n          annotation = this.readPdfAnno(page, subType, annotationPtr, index);\n        }\n        break;\n    }\n    return annotation;\n  }\n  /**\n   * Return the colour stored directly in the annotation dictionary\'s `/C` entry.\n   *\n   * Most PDFs created by Acrobat, Microsoft Office, LaTeX, etc. include this entry.\n   * When the key is absent (common in macOS Preview, Chrome, Drawboard) the call\n   * fails and the function returns `undefined`.\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @returns An RGBA tuple (0-255 channels) or `undefined` if no `/C` entry exists\n   *\n   * @private\n   */\n  readAnnotationColor(annotationPtr, colorType = PdfAnnotationColorType.Color) {\n    const rPtr = this.memoryManager.malloc(4);\n    const gPtr = this.memoryManager.malloc(4);\n    const bPtr = this.memoryManager.malloc(4);\n    const ok = this.pdfiumModule.EPDFAnnot_GetColor(annotationPtr, colorType, rPtr, gPtr, bPtr);\n    let colour;\n    if (ok) {\n      colour = {\n        red: this.pdfiumModule.pdfium.getValue(rPtr, "i32") & 255,\n        green: this.pdfiumModule.pdfium.getValue(gPtr, "i32") & 255,\n        blue: this.pdfiumModule.pdfium.getValue(bPtr, "i32") & 255\n      };\n    }\n    this.memoryManager.free(rPtr);\n    this.memoryManager.free(gPtr);\n    this.memoryManager.free(bPtr);\n    return colour;\n  }\n  /**\n   * Get the fill/stroke colour annotation.\n   *\n   * @param annotationPtr - pointer to the annotation whose colour is being set\n   * @param colorType - which colour to get (0 = fill, 1 = stroke)\n   * @returns WebColor with hex color\n   *\n   * @private\n   */\n  getAnnotationColor(annotationPtr, colorType = PdfAnnotationColorType.Color) {\n    const annotationColor = this.readAnnotationColor(annotationPtr, colorType);\n    return annotationColor ? pdfColorToWebColor(annotationColor) : void 0;\n  }\n  /**\n   * Set the fill/stroke colour for a **Highlight / Underline / StrikeOut / Squiggly** markup annotation.\n   *\n   * @param annotationPtr - pointer to the annotation whose colour is being set\n   * @param webAlphaColor - WebAlphaColor with hex color and opacity (0-1)\n   * @param shouldClearAP - whether to clear the /AP entry\n   * @param which - which colour to set (0 = fill, 1 = stroke)\n   * @returns `true` if the operation was successful\n   *\n   * @private\n   */\n  setAnnotationColor(annotationPtr, webColor, colorType = PdfAnnotationColorType.Color) {\n    const pdfColor = webColorToPdfColor(webColor);\n    return this.pdfiumModule.EPDFAnnot_SetColor(\n      annotationPtr,\n      colorType,\n      pdfColor.red & 255,\n      pdfColor.green & 255,\n      pdfColor.blue & 255\n    );\n  }\n  /**\n   * Get the opacity of the annotation.\n   *\n   * @param annotationPtr - pointer to the annotation whose opacity is being set\n   * @returns opacity (0-1)\n   *\n   * @private\n   */\n  getAnnotationOpacity(annotationPtr) {\n    const opacityPtr = this.memoryManager.malloc(4);\n    const ok = this.pdfiumModule.EPDFAnnot_GetOpacity(annotationPtr, opacityPtr);\n    const opacity = ok ? this.pdfiumModule.pdfium.getValue(opacityPtr, "i32") : 255;\n    this.memoryManager.free(opacityPtr);\n    return pdfAlphaToWebOpacity(opacity);\n  }\n  /**\n   * Set the opacity of the annotation.\n   *\n   * @param annotationPtr - pointer to the annotation whose opacity is being set\n   * @param opacity - opacity (0-1)\n   * @returns true on success\n   *\n   * @private\n   */\n  setAnnotationOpacity(annotationPtr, opacity) {\n    const pdfOpacity = webOpacityToPdfAlpha(opacity);\n    return this.pdfiumModule.EPDFAnnot_SetOpacity(annotationPtr, pdfOpacity & 255);\n  }\n  /**\n   * Fetch the `/Q` text-alignment value from a **FreeText** annotation.\n   *\n   * @param annotationPtr pointer returned by `FPDFPage_GetAnnot`\n   * @returns `PdfTextAlignment`\n   */\n  getAnnotationTextAlignment(annotationPtr) {\n    return this.pdfiumModule.EPDFAnnot_GetTextAlignment(annotationPtr);\n  }\n  /**\n   * Write the `/Q` text-alignment value into a **FreeText** annotation\n   * and clear the existing appearance stream so it can be regenerated.\n   *\n   * @param annotationPtr pointer returned by `FPDFPage_GetAnnot`\n   * @param alignment     `PdfTextAlignment`\n   * @returns `true` on success\n   */\n  setAnnotationTextAlignment(annotationPtr, alignment) {\n    return !!this.pdfiumModule.EPDFAnnot_SetTextAlignment(annotationPtr, alignment);\n  }\n  /**\n   * Fetch the `/EPDF:VerticalAlignment` vertical-alignment value from a **FreeText** annotation.\n   *\n   * @param annotationPtr pointer returned by `FPDFPage_GetAnnot`\n   * @returns `PdfVerticalAlignment`\n   */\n  getAnnotationVerticalAlignment(annotationPtr) {\n    return this.pdfiumModule.EPDFAnnot_GetVerticalAlignment(annotationPtr);\n  }\n  /**\n   * Write the `/EPDF:VerticalAlignment` vertical-alignment value into a **FreeText** annotation\n   * and clear the existing appearance stream so it can be regenerated.\n   *\n   * @param annotationPtr pointer returned by `FPDFPage_GetAnnot`\n   * @param alignment     `PdfVerticalAlignment`\n   * @returns `true` on success\n   */\n  setAnnotationVerticalAlignment(annotationPtr, alignment) {\n    return !!this.pdfiumModule.EPDFAnnot_SetVerticalAlignment(annotationPtr, alignment);\n  }\n  /**\n   * Return the **default appearance** (font, size, colour) declared in the\n   * `/DA` string of a **FreeText** annotation.\n   *\n   * @param annotationPtr  pointer to `FPDF_ANNOTATION`\n   * @returns `{ font, fontSize, color }` or `undefined` when PDFium returns false\n   *\n   * NOTE \u2013 `font` is the raw `FPDF_STANDARD_FONT` enum value that PDFium uses\n   *        (same range as the C API: 0 = Courier, 12 = ZapfDingbats, \u2026).\n   */\n  getAnnotationDefaultAppearance(annotationPtr) {\n    const fontPtr = this.memoryManager.malloc(4);\n    const sizePtr = this.memoryManager.malloc(4);\n    const rPtr = this.memoryManager.malloc(4);\n    const gPtr = this.memoryManager.malloc(4);\n    const bPtr = this.memoryManager.malloc(4);\n    const ok = !!this.pdfiumModule.EPDFAnnot_GetDefaultAppearance(\n      annotationPtr,\n      fontPtr,\n      sizePtr,\n      rPtr,\n      gPtr,\n      bPtr\n    );\n    if (!ok) {\n      [fontPtr, sizePtr, rPtr, gPtr, bPtr].forEach((p) => this.memoryManager.free(p));\n      return;\n    }\n    const pdf = this.pdfiumModule.pdfium;\n    const font = pdf.getValue(fontPtr, "i32");\n    const fontSize = pdf.getValue(sizePtr, "float");\n    const red = pdf.getValue(rPtr, "i32") & 255;\n    const green = pdf.getValue(gPtr, "i32") & 255;\n    const blue = pdf.getValue(bPtr, "i32") & 255;\n    [fontPtr, sizePtr, rPtr, gPtr, bPtr].forEach((p) => this.memoryManager.free(p));\n    return {\n      fontFamily: font,\n      fontSize,\n      fontColor: pdfColorToWebColor({ red, green, blue })\n    };\n  }\n  /**\n   * Write a **default appearance** (`/DA`) into a FreeText annotation.\n   *\n   * @param annotationPtr pointer to `FPDF_ANNOTATION`\n   * @param font          `FPDF_STANDARD_FONT` enum value\n   * @param fontSize      size in points (\u2265 0)\n   * @param color         CSS-style `#rrggbb` string (alpha ignored)\n   * @returns `true` on success\n   */\n  setAnnotationDefaultAppearance(annotationPtr, font, fontSize, color) {\n    const { red, green, blue } = webColorToPdfColor(color);\n    return !!this.pdfiumModule.EPDFAnnot_SetDefaultAppearance(\n      annotationPtr,\n      font,\n      fontSize,\n      red & 255,\n      green & 255,\n      blue & 255\n    );\n  }\n  /**\n   * Border\u2010style + width helper\n   *\n   * Tries the new PDFium helper `EPDFAnnot_GetBorderStyle()` (patch series\n   * 9 July 2025).\n   *\n   * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n   * @returns `{ ok, style, width }`\n   *          \u2022 `ok`     \u2013 `true` when the call succeeded\n   *          \u2022 `style`  \u2013 `PdfAnnotationBorderStyle` enum\n   *          \u2022 `width`  \u2013 stroke-width in points (defaults to 0 pt)\n   */\n  getBorderStyle(annotationPtr) {\n    const widthPtr = this.memoryManager.malloc(4);\n    let width = 0;\n    let style = PdfAnnotationBorderStyle.UNKNOWN;\n    let ok = false;\n    style = this.pdfiumModule.EPDFAnnot_GetBorderStyle(annotationPtr, widthPtr);\n    width = this.pdfiumModule.pdfium.getValue(widthPtr, "float");\n    ok = style !== PdfAnnotationBorderStyle.UNKNOWN;\n    this.memoryManager.free(widthPtr);\n    return { ok, style, width };\n  }\n  setBorderStyle(annotationPtr, style, width) {\n    return this.pdfiumModule.EPDFAnnot_SetBorderStyle(annotationPtr, style, width);\n  }\n  /**\n   * Get the icon of the annotation\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @returns `PdfAnnotationIcon`\n   */\n  getAnnotationIcon(annotationPtr) {\n    return this.pdfiumModule.EPDFAnnot_GetIcon(annotationPtr);\n  }\n  /**\n   * Set the icon of the annotation\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param icon - `PdfAnnotationIcon`\n   * @returns `true` on success\n   */\n  setAnnotationIcon(annotationPtr, icon) {\n    return this.pdfiumModule.EPDFAnnot_SetIcon(annotationPtr, icon);\n  }\n  /**\n   * Border-effect (\u201Ccloudy\u201D) helper\n   *\n   * Calls the new PDFium function `EPDFAnnot_GetBorderEffect()` (July 2025).\n   *\n   * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n   * @returns `{ ok, intensity }`\n   *          \u2022 `ok`        \u2013 `true` when the annotation *does* have a\n   *                          valid cloudy-border effect\n   *          \u2022 `intensity` \u2013 radius/intensity value (0 when `ok` is false)\n   */\n  getBorderEffect(annotationPtr) {\n    const intensityPtr = this.memoryManager.malloc(4);\n    const ok = !!this.pdfiumModule.EPDFAnnot_GetBorderEffect(annotationPtr, intensityPtr);\n    const intensity = ok ? this.pdfiumModule.pdfium.getValue(intensityPtr, "float") : 0;\n    this.memoryManager.free(intensityPtr);\n    return { ok, intensity };\n  }\n  /**\n   * Rectangle-differences helper ( /RD array on Square / Circle annots )\n   *\n   * Calls `EPDFAnnot_GetRectangleDifferences()` introduced in July 2025.\n   *\n   * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n   * @returns `{ ok, left, top, right, bottom }`\n   *          \u2022 `ok`     \u2013 `true` when the annotation *has* an /RD entry\n   *          \u2022 the four floats are 0 when `ok` is false\n   */\n  getRectangleDifferences(annotationPtr) {\n    const lPtr = this.memoryManager.malloc(4);\n    const tPtr = this.memoryManager.malloc(4);\n    const rPtr = this.memoryManager.malloc(4);\n    const bPtr = this.memoryManager.malloc(4);\n    const ok = !!this.pdfiumModule.EPDFAnnot_GetRectangleDifferences(\n      annotationPtr,\n      lPtr,\n      tPtr,\n      rPtr,\n      bPtr\n    );\n    const pdf = this.pdfiumModule.pdfium;\n    const left = pdf.getValue(lPtr, "float");\n    const top = pdf.getValue(tPtr, "float");\n    const right = pdf.getValue(rPtr, "float");\n    const bottom = pdf.getValue(bPtr, "float");\n    this.memoryManager.free(lPtr);\n    this.memoryManager.free(tPtr);\n    this.memoryManager.free(rPtr);\n    this.memoryManager.free(bPtr);\n    return { ok, left, top, right, bottom };\n  }\n  /**\n   * Get the date of the annotation\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param key - \'M\' for modified date, \'CreationDate\' for creation date\n   * @returns `Date` or `undefined` when PDFium can\'t read the date\n   */\n  getAnnotationDate(annotationPtr, key) {\n    const raw = this.getAnnotString(annotationPtr, key);\n    return raw ? pdfDateToDate(raw) : void 0;\n  }\n  /**\n   * Set the date of the annotation\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param key - \'M\' for modified date, \'CreationDate\' for creation date\n   * @param date - `Date` to set\n   * @returns `true` on success\n   */\n  setAnnotationDate(annotationPtr, key, date) {\n    const raw = dateToPdfDate(date);\n    return this.setAnnotString(annotationPtr, key, raw);\n  }\n  /**\n   * Get the date of the attachment\n   *\n   * @param attachmentPtr - pointer to an `FPDF_ATTACHMENT`\n   * @param key - \'ModDate\' for modified date, \'CreationDate\' for creation date\n   * @returns `Date` or `undefined` when PDFium can\'t read the date\n   */\n  getAttachmentDate(attachmentPtr, key) {\n    const raw = this.getAttachmentString(attachmentPtr, key);\n    return raw ? pdfDateToDate(raw) : void 0;\n  }\n  /**\n   * Set the date of the attachment\n   *\n   * @param attachmentPtr - pointer to an `FPDF_ATTACHMENT`\n   * @param key - \'ModDate\' for modified date, \'CreationDate\' for creation date\n   * @param date - `Date` to set\n   * @returns `true` on success\n   */\n  setAttachmentDate(attachmentPtr, key, date) {\n    const raw = dateToPdfDate(date);\n    return this.setAttachmentString(attachmentPtr, key, raw);\n  }\n  /**\n   * Dash-pattern helper ( /BS \u2192 /D array, dashed borders only )\n   *\n   * Uses the two new PDFium helpers:\n   *   \u2022 `EPDFAnnot_GetBorderDashPatternCount`\n   *   \u2022 `EPDFAnnot_GetBorderDashPattern`\n   *\n   * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n   * @returns `{ ok, pattern }`\n   *          \u2022 `ok`       \u2013 `true` when the annot is dashed *and* the array\n   *                          was retrieved successfully\n   *          \u2022 `pattern`  \u2013 numeric array of dash/space lengths (empty when `ok` is false)\n   */\n  getBorderDashPattern(annotationPtr) {\n    const count = this.pdfiumModule.EPDFAnnot_GetBorderDashPatternCount(annotationPtr);\n    if (count === 0) {\n      return { ok: false, pattern: [] };\n    }\n    const arrPtr = this.memoryManager.malloc(4 * count);\n    const okNative = !!this.pdfiumModule.EPDFAnnot_GetBorderDashPattern(\n      annotationPtr,\n      arrPtr,\n      count\n    );\n    const pattern = [];\n    if (okNative) {\n      const pdf = this.pdfiumModule.pdfium;\n      for (let i = 0; i < count; i++) {\n        pattern.push(pdf.getValue(arrPtr + 4 * i, "float"));\n      }\n    }\n    this.memoryManager.free(arrPtr);\n    return { ok: okNative, pattern };\n  }\n  /**\n   * Write the /BS /D dash pattern array for an annotation border.\n   *\n   * @param annotationPtr Pointer to FPDF_ANNOTATION\n   * @param pattern       Array of dash/space lengths in *points* (e.g. [3, 2])\n   *                      Empty array clears the pattern (solid line).\n   * @returns true on success\n   *\n   * @private\n   */\n  setBorderDashPattern(annotationPtr, pattern) {\n    if (!pattern || pattern.length === 0) {\n      return this.pdfiumModule.EPDFAnnot_SetBorderDashPattern(annotationPtr, 0, 0);\n    }\n    const clean = pattern.map((n) => Number.isFinite(n) && n > 0 ? n : 0).filter((n) => n > 0);\n    if (clean.length === 0) {\n      return this.pdfiumModule.EPDFAnnot_SetBorderDashPattern(annotationPtr, 0, 0);\n    }\n    const bytes = 4 * clean.length;\n    const bufPtr = this.memoryManager.malloc(bytes);\n    for (let i = 0; i < clean.length; i++) {\n      this.pdfiumModule.pdfium.setValue(bufPtr + 4 * i, clean[i], "float");\n    }\n    const ok = !!this.pdfiumModule.EPDFAnnot_SetBorderDashPattern(\n      annotationPtr,\n      bufPtr,\n      clean.length\n    );\n    this.memoryManager.free(bufPtr);\n    return ok;\n  }\n  /**\n   * Return the `/LE` array (start/end line-ending styles) for a LINE / POLYLINE annot.\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @returns `{ start, end }` or `undefined` when PDFium can\'t read them\n   *\n   * @private\n   */\n  getLineEndings(annotationPtr) {\n    const startPtr = this.memoryManager.malloc(4);\n    const endPtr = this.memoryManager.malloc(4);\n    const ok = !!this.pdfiumModule.EPDFAnnot_GetLineEndings(annotationPtr, startPtr, endPtr);\n    if (!ok) {\n      this.memoryManager.free(startPtr);\n      this.memoryManager.free(endPtr);\n      return void 0;\n    }\n    const start = this.pdfiumModule.pdfium.getValue(startPtr, "i32");\n    const end = this.pdfiumModule.pdfium.getValue(endPtr, "i32");\n    this.memoryManager.free(startPtr);\n    this.memoryManager.free(endPtr);\n    return { start, end };\n  }\n  /**\n   * Write the `/LE` array (start/end line-ending styles) for a LINE / POLYLINE annot.\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param start - start line ending style\n   * @param end - end line ending style\n   * @returns `true` on success\n   */\n  setLineEndings(annotationPtr, start, end) {\n    return !!this.pdfiumModule.EPDFAnnot_SetLineEndings(annotationPtr, start, end);\n  }\n  /**\n   * Get the start and end points of a LINE / POLYLINE annot.\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param page - logical page info object (`PdfPageObject`)\n   * @returns `{ start, end }` or `undefined` when PDFium can\'t read them\n   */\n  getLinePoints(page, annotationPtr) {\n    const startPtr = this.memoryManager.malloc(8);\n    const endPtr = this.memoryManager.malloc(8);\n    const ok = this.pdfiumModule.FPDFAnnot_GetLine(annotationPtr, startPtr, endPtr);\n    if (!ok) {\n      this.memoryManager.free(startPtr);\n      this.memoryManager.free(endPtr);\n      return void 0;\n    }\n    const pdf = this.pdfiumModule.pdfium;\n    const sx = pdf.getValue(startPtr + 0, "float");\n    const sy = pdf.getValue(startPtr + 4, "float");\n    const ex = pdf.getValue(endPtr + 0, "float");\n    const ey = pdf.getValue(endPtr + 4, "float");\n    this.memoryManager.free(startPtr);\n    this.memoryManager.free(endPtr);\n    const start = this.convertPagePointToDevicePoint(page, { x: sx, y: sy });\n    const end = this.convertPagePointToDevicePoint(page, { x: ex, y: ey });\n    return { start, end };\n  }\n  /**\n   * Set the two end\u2011points of a **Line** annotation\n   * by writing a new /L array `[ x1 y1 x2 y2 ]`.\n   * @param page - logical page info object (`PdfPageObject`)\n   * @param annotPtr - pointer to the annotation whose line points are needed\n   * @param start - start point\n   * @param end - end point\n   * @returns true on success\n   */\n  setLinePoints(page, annotPtr, start, end) {\n    const p1 = this.convertDevicePointToPagePoint(page, start);\n    const p2 = this.convertDevicePointToPagePoint(page, end);\n    if (!p1 || !p2) return false;\n    const buf = this.memoryManager.malloc(16);\n    const pdf = this.pdfiumModule.pdfium;\n    pdf.setValue(buf + 0, p1.x, "float");\n    pdf.setValue(buf + 4, p1.y, "float");\n    pdf.setValue(buf + 8, p2.x, "float");\n    pdf.setValue(buf + 12, p2.y, "float");\n    const ok = this.pdfiumModule.EPDFAnnot_SetLine(annotPtr, buf, buf + 8);\n    this.memoryManager.free(buf);\n    return !!ok;\n  }\n  /**\n   * Read `/QuadPoints` from any annotation and convert each quadrilateral to\n   * device-space coordinates.\n   *\n   * The four points are returned in natural reading order:\n   *   `p1 \u2192 p2` (top edge) and `p4 \u2192 p3` (bottom edge).\n   * This preserves the true shape for rotated / skewed text, whereas callers\n   * that only need axis-aligned boxes can collapse each quad themselves.\n   *\n   * @param page          - logical page info object (`PdfPageObject`)\n   * @param annotationPtr - pointer to the annotation whose quads are needed\n   * @returns Array of `Rect` objects (`[]` if the annotation has no quads)\n   *\n   * @private\n   */\n  getQuadPointsAnno(page, annotationPtr) {\n    const quadCount = this.pdfiumModule.FPDFAnnot_CountAttachmentPoints(annotationPtr);\n    if (quadCount === 0) return [];\n    const FS_QUADPOINTSF_SIZE = 8 * 4;\n    const quads = [];\n    for (let qi = 0; qi < quadCount; qi++) {\n      const quadPtr = this.memoryManager.malloc(FS_QUADPOINTSF_SIZE);\n      const ok = this.pdfiumModule.FPDFAnnot_GetAttachmentPoints(annotationPtr, qi, quadPtr);\n      if (ok) {\n        const xs = [];\n        const ys = [];\n        for (let i = 0; i < 4; i++) {\n          const base = quadPtr + i * 8;\n          xs.push(this.pdfiumModule.pdfium.getValue(base, "float"));\n          ys.push(this.pdfiumModule.pdfium.getValue(base + 4, "float"));\n        }\n        const p1 = this.convertPagePointToDevicePoint(page, { x: xs[0], y: ys[0] });\n        const p2 = this.convertPagePointToDevicePoint(page, { x: xs[1], y: ys[1] });\n        const p3 = this.convertPagePointToDevicePoint(page, { x: xs[2], y: ys[2] });\n        const p4 = this.convertPagePointToDevicePoint(page, { x: xs[3], y: ys[3] });\n        quads.push({ p1, p2, p3, p4 });\n      }\n      this.memoryManager.free(quadPtr);\n    }\n    return quads.map(quadToRect);\n  }\n  /**\n   * Set the quadrilaterals for a **Highlight / Underline / StrikeOut / Squiggly** markup annotation.\n   *\n   * @param page          - logical page info object (`PdfPageObject`)\n   * @param annotationPtr - pointer to the annotation whose quads are needed\n   * @param rects         - array of `Rect` objects (`[]` if the annotation has no quads)\n   * @returns `true` if the operation was successful\n   *\n   * @private\n   */\n  syncQuadPointsAnno(page, annotPtr, rects) {\n    const FS_QUADPOINTSF_SIZE = 8 * 4;\n    const pdf = this.pdfiumModule.pdfium;\n    const count = this.pdfiumModule.FPDFAnnot_CountAttachmentPoints(annotPtr);\n    const buf = this.memoryManager.malloc(FS_QUADPOINTSF_SIZE);\n    const writeQuad = (r) => {\n      const q = rectToQuad(r);\n      const p1 = this.convertDevicePointToPagePoint(page, q.p1);\n      const p2 = this.convertDevicePointToPagePoint(page, q.p2);\n      const p3 = this.convertDevicePointToPagePoint(page, q.p3);\n      const p4 = this.convertDevicePointToPagePoint(page, q.p4);\n      pdf.setValue(buf + 0, p1.x, "float");\n      pdf.setValue(buf + 4, p1.y, "float");\n      pdf.setValue(buf + 8, p2.x, "float");\n      pdf.setValue(buf + 12, p2.y, "float");\n      pdf.setValue(buf + 16, p4.x, "float");\n      pdf.setValue(buf + 20, p4.y, "float");\n      pdf.setValue(buf + 24, p3.x, "float");\n      pdf.setValue(buf + 28, p3.y, "float");\n    };\n    const min = Math.min(count, rects.length);\n    for (let i = 0; i < min; i++) {\n      writeQuad(rects[i]);\n      if (!this.pdfiumModule.FPDFAnnot_SetAttachmentPoints(annotPtr, i, buf)) {\n        this.memoryManager.free(buf);\n        return false;\n      }\n    }\n    for (let i = count; i < rects.length; i++) {\n      writeQuad(rects[i]);\n      if (!this.pdfiumModule.FPDFAnnot_AppendAttachmentPoints(annotPtr, buf)) {\n        this.memoryManager.free(buf);\n        return false;\n      }\n    }\n    this.memoryManager.free(buf);\n    return true;\n  }\n  /**\n   * Redact text that intersects ANY of the provided **quads** (device-space).\n   * Returns `true` if the page changed. Always regenerates the page stream.\n   */\n  redactTextInRects(doc, page, rects, options) {\n    const { recurseForms = true, drawBlackBoxes = false } = options ?? {};\n    this.logger.debug(\n      "PDFiumEngine",\n      "Engine",\n      "redactTextInQuads",\n      doc.id,\n      page.index,\n      rects.length\n    );\n    const label = "RedactTextInQuads";\n    this.logger.perf("PDFiumEngine", "Engine", label, "Begin", `${doc.id}-${page.index}`);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf("PDFiumEngine", "Engine", label, "End", `${doc.id}-${page.index}`);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const clean = (rects ?? []).filter(\n      (r) => {\n        var _a, _b, _c, _d;\n        return r && Number.isFinite((_a = r.origin) == null ? void 0 : _a.x) && Number.isFinite((_b = r.origin) == null ? void 0 : _b.y) && Number.isFinite((_c = r.size) == null ? void 0 : _c.width) && Number.isFinite((_d = r.size) == null ? void 0 : _d.height) && r.size.width > 0 && r.size.height > 0;\n      }\n    );\n    if (clean.length === 0) {\n      this.logger.perf("PDFiumEngine", "Engine", label, "End", `${doc.id}-${page.index}`);\n      return PdfTaskHelper.resolve(false);\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const { ptr, count } = this.allocFSQuadsBufferFromRects(page, clean);\n    let ok = false;\n    try {\n      ok = !!this.pdfiumModule.EPDFText_RedactInQuads(\n        pageCtx.pagePtr,\n        ptr,\n        count,\n        recurseForms ? true : false,\n        drawBlackBoxes ? true : false\n      );\n    } finally {\n      this.memoryManager.free(ptr);\n    }\n    if (ok) {\n      ok = !!this.pdfiumModule.FPDFPage_GenerateContent(pageCtx.pagePtr);\n    }\n    pageCtx.disposeImmediate();\n    this.logger.perf("PDFiumEngine", "Engine", label, "End", `${doc.id}-${page.index}`);\n    return PdfTaskHelper.resolve(!!ok);\n  }\n  /** Pack device-space Rects into an FS_QUADPOINTSF[] buffer (page space). */\n  allocFSQuadsBufferFromRects(page, rects) {\n    const STRIDE = 32;\n    const count = rects.length;\n    const ptr = this.memoryManager.malloc(STRIDE * count);\n    const pdf = this.pdfiumModule.pdfium;\n    for (let i = 0; i < count; i++) {\n      const r = rects[i];\n      const q = rectToQuad(r);\n      const p1 = this.convertDevicePointToPagePoint(page, q.p1);\n      const p2 = this.convertDevicePointToPagePoint(page, q.p2);\n      const p3 = this.convertDevicePointToPagePoint(page, q.p3);\n      const p4 = this.convertDevicePointToPagePoint(page, q.p4);\n      const base = ptr + i * STRIDE;\n      pdf.setValue(base + 0, p1.x, "float");\n      pdf.setValue(base + 4, p1.y, "float");\n      pdf.setValue(base + 8, p2.x, "float");\n      pdf.setValue(base + 12, p2.y, "float");\n      pdf.setValue(base + 16, p4.x, "float");\n      pdf.setValue(base + 20, p4.y, "float");\n      pdf.setValue(base + 24, p3.x, "float");\n      pdf.setValue(base + 28, p3.y, "float");\n    }\n    return { ptr, count };\n  }\n  /**\n   * Read ink list from annotation\n   * @param page  - logical page info object (`PdfPageObject`)\n   * @param pagePtr - pointer to the page\n   * @param annotationPtr - pointer to the annotation whose ink list is needed\n   * @returns ink list\n   */\n  getInkList(page, annotationPtr) {\n    const inkList = [];\n    const pathCount = this.pdfiumModule.FPDFAnnot_GetInkListCount(annotationPtr);\n    if (pathCount <= 0) return inkList;\n    const pdf = this.pdfiumModule.pdfium;\n    const POINT_STRIDE = 8;\n    for (let i = 0; i < pathCount; i++) {\n      const points = [];\n      const n = this.pdfiumModule.FPDFAnnot_GetInkListPath(annotationPtr, i, 0, 0);\n      if (n > 0) {\n        const buf = this.memoryManager.malloc(n * POINT_STRIDE);\n        this.pdfiumModule.FPDFAnnot_GetInkListPath(annotationPtr, i, buf, n);\n        for (let j = 0; j < n; j++) {\n          const base = buf + j * POINT_STRIDE;\n          const px = pdf.getValue(base + 0, "float");\n          const py = pdf.getValue(base + 4, "float");\n          const d = this.convertPagePointToDevicePoint(page, { x: px, y: py });\n          points.push({ x: d.x, y: d.y });\n        }\n        this.memoryManager.free(buf);\n      }\n      inkList.push({ points });\n    }\n    return inkList;\n  }\n  /**\n   * Add ink list to annotation\n   * @param page  - logical page info object (`PdfPageObject`)\n   * @param pagePtr - pointer to the page\n   * @param annotationPtr - pointer to the annotation whose ink list is needed\n   * @param inkList - ink list array of `PdfInkListObject`\n   * @returns `true` if the operation was successful\n   */\n  setInkList(page, annotationPtr, inkList) {\n    const pdf = this.pdfiumModule.pdfium;\n    const POINT_STRIDE = 8;\n    for (const stroke of inkList) {\n      const n = stroke.points.length;\n      if (n === 0) continue;\n      const buf = this.memoryManager.malloc(n * POINT_STRIDE);\n      for (let i = 0; i < n; i++) {\n        const pDev = stroke.points[i];\n        const pPage = this.convertDevicePointToPagePoint(page, pDev);\n        pdf.setValue(buf + i * POINT_STRIDE + 0, pPage.x, "float");\n        pdf.setValue(buf + i * POINT_STRIDE + 4, pPage.y, "float");\n      }\n      const idx = this.pdfiumModule.FPDFAnnot_AddInkStroke(annotationPtr, buf, n);\n      this.memoryManager.free(buf);\n      if (idx === -1) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Read pdf text annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf text annotation\n   *\n   * @private\n   */\n  readPdfTextAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const annoRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, annoRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const state = this.getAnnotString(annotationPtr, "State");\n    const stateModel = this.getAnnotString(annotationPtr, "StateModel");\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const inReplyToId = this.getInReplyToId(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const icon = this.getAnnotationIcon(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.TEXT,\n      flags,\n      contents,\n      color: color ?? "#FFFF00",\n      opacity,\n      rect,\n      inReplyToId,\n      author,\n      modified,\n      created,\n      state,\n      stateModel,\n      icon\n    };\n  }\n  /**\n   * Read pdf freetext annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf freetext annotation\n   *\n   * @private\n   */\n  readPdfFreeTextAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const annoRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, annoRect);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const defaultStyle = this.getAnnotString(annotationPtr, "DS");\n    const da = this.getAnnotationDefaultAppearance(annotationPtr);\n    const backgroundColor = this.getAnnotationColor(annotationPtr);\n    const textAlign = this.getAnnotationTextAlignment(annotationPtr);\n    const verticalAlign = this.getAnnotationVerticalAlignment(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const richContent = this.getAnnotRichContent(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.FREETEXT,\n      fontFamily: (da == null ? void 0 : da.fontFamily) ?? PdfStandardFont.Unknown,\n      fontSize: (da == null ? void 0 : da.fontSize) ?? 12,\n      fontColor: (da == null ? void 0 : da.fontColor) ?? "#000000",\n      verticalAlign,\n      backgroundColor,\n      flags,\n      opacity,\n      textAlign,\n      defaultStyle,\n      richContent,\n      contents,\n      author,\n      modified,\n      created,\n      rect\n    };\n  }\n  /**\n   * Read pdf link annotation from pdf document\n   * @param page  - pdf page infor\n   * @param docPtr - pointer to pdf document object\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf link annotation\n   *\n   * @private\n   */\n  readPdfLinkAnno(page, docPtr, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const linkPtr = this.pdfiumModule.FPDFAnnot_GetLink(annotationPtr);\n    if (!linkPtr) {\n      return;\n    }\n    const annoRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, annoRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const target = this.readPdfLinkAnnoTarget(\n      docPtr,\n      () => {\n        return this.pdfiumModule.FPDFLink_GetAction(linkPtr);\n      },\n      () => {\n        return this.pdfiumModule.FPDFLink_GetDest(docPtr, linkPtr);\n      }\n    );\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.LINK,\n      flags,\n      target,\n      rect,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf widget annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param formHandle - form handle\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf widget annotation\n   *\n   * @private\n   */\n  readPdfWidgetAnno(page, annotationPtr, formHandle, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const field = this.readPdfWidgetAnnoField(formHandle, annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.WIDGET,\n      flags,\n      rect,\n      field,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf file attachment annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf file attachment annotation\n   *\n   * @private\n   */\n  readPdfFileAttachmentAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.FILEATTACHMENT,\n      flags,\n      rect,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf ink annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf ink annotation\n   *\n   * @private\n   */\n  readPdfInkAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const { width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    const inkList = this.getInkList(page, annotationPtr);\n    const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n    const intent = this.getAnnotIntent(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.INK,\n      ...intent && { intent },\n      contents,\n      blendMode,\n      flags,\n      color: color ?? "#FF0000",\n      opacity,\n      strokeWidth: strokeWidth === 0 ? 1 : strokeWidth,\n      rect,\n      inkList,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf polygon annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf polygon annotation\n   *\n   * @private\n   */\n  readPdfPolygonAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const vertices = this.readPdfAnnoVertices(page, annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const strokeColor = this.getAnnotationColor(annotationPtr);\n    const interiorColor = this.getAnnotationColor(\n      annotationPtr,\n      PdfAnnotationColorType.InteriorColor\n    );\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    let strokeDashArray;\n    if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n      const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n      if (ok) {\n        strokeDashArray = pattern;\n      }\n    }\n    if (vertices.length > 1) {\n      const first = vertices[0];\n      const last = vertices[vertices.length - 1];\n      if (first.x === last.x && first.y === last.y) {\n        vertices.pop();\n      }\n    }\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.POLYGON,\n      contents,\n      flags,\n      strokeColor: strokeColor ?? "#FF0000",\n      color: interiorColor ?? "transparent",\n      opacity,\n      strokeWidth: strokeWidth === 0 ? 1 : strokeWidth,\n      strokeStyle,\n      strokeDashArray,\n      rect,\n      vertices,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf polyline annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf polyline annotation\n   *\n   * @private\n   */\n  readPdfPolylineAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const vertices = this.readPdfAnnoVertices(page, annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const strokeColor = this.getAnnotationColor(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const interiorColor = this.getAnnotationColor(\n      annotationPtr,\n      PdfAnnotationColorType.InteriorColor\n    );\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    let strokeDashArray;\n    if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n      const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n      if (ok) {\n        strokeDashArray = pattern;\n      }\n    }\n    const lineEndings = this.getLineEndings(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.POLYLINE,\n      contents,\n      flags,\n      strokeColor: strokeColor ?? "#FF0000",\n      color: interiorColor ?? "transparent",\n      opacity,\n      strokeWidth: strokeWidth === 0 ? 1 : strokeWidth,\n      strokeStyle,\n      strokeDashArray,\n      lineEndings,\n      rect,\n      vertices,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf line annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf line annotation\n   *\n   * @private\n   */\n  readPdfLineAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const linePoints = this.getLinePoints(page, annotationPtr);\n    const lineEndings = this.getLineEndings(annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const strokeColor = this.getAnnotationColor(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const interiorColor = this.getAnnotationColor(\n      annotationPtr,\n      PdfAnnotationColorType.InteriorColor\n    );\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    let strokeDashArray;\n    if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n      const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n      if (ok) {\n        strokeDashArray = pattern;\n      }\n    }\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.LINE,\n      flags,\n      rect,\n      contents,\n      strokeWidth: strokeWidth === 0 ? 1 : strokeWidth,\n      strokeStyle,\n      strokeDashArray,\n      strokeColor: strokeColor ?? "#FF0000",\n      color: interiorColor ?? "transparent",\n      opacity,\n      linePoints: linePoints || { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } },\n      lineEndings: lineEndings || {\n        start: PdfAnnotationLineEnding.None,\n        end: PdfAnnotationLineEnding.None\n      },\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf highlight annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf highlight annotation\n   *\n   * @private\n   */\n  readPdfHighlightAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      blendMode,\n      type: PdfAnnotationSubtype.HIGHLIGHT,\n      rect,\n      flags,\n      contents,\n      segmentRects,\n      color: color ?? "#FFFF00",\n      opacity,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf underline annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf underline annotation\n   *\n   * @private\n   */\n  readPdfUnderlineAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      blendMode,\n      type: PdfAnnotationSubtype.UNDERLINE,\n      rect,\n      flags,\n      contents,\n      segmentRects,\n      color: color ?? "#FF0000",\n      opacity,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read strikeout annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf strikeout annotation\n   *\n   * @private\n   */\n  readPdfStrikeOutAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      blendMode,\n      type: PdfAnnotationSubtype.STRIKEOUT,\n      flags,\n      rect,\n      contents,\n      segmentRects,\n      color: color ?? "#FF0000",\n      opacity,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf squiggly annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf squiggly annotation\n   *\n   * @private\n   */\n  readPdfSquigglyAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      blendMode,\n      type: PdfAnnotationSubtype.SQUIGGLY,\n      rect,\n      flags,\n      contents,\n      segmentRects,\n      color: color ?? "#FF0000",\n      opacity,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf caret annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf caret annotation\n   *\n   * @private\n   */\n  readPdfCaretAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.CARET,\n      rect,\n      flags,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf stamp annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf stamp annotation\n   *\n   * @private\n   */\n  readPdfStampAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.STAMP,\n      contents,\n      rect,\n      author,\n      modified,\n      created,\n      flags\n    };\n  }\n  /**\n   * Read pdf object in pdf page\n   * @param pageObjectPtr  - pointer to pdf object in page\n   * @returns pdf object in page\n   *\n   * @private\n   */\n  readPdfPageObject(pageObjectPtr) {\n    const type = this.pdfiumModule.FPDFPageObj_GetType(pageObjectPtr);\n    switch (type) {\n      case PdfPageObjectType.PATH:\n        return this.readPathObject(pageObjectPtr);\n      case PdfPageObjectType.IMAGE:\n        return this.readImageObject(pageObjectPtr);\n      case PdfPageObjectType.FORM:\n        return this.readFormObject(pageObjectPtr);\n    }\n  }\n  /**\n   * Read pdf path object\n   * @param pathObjectPtr  - pointer to pdf path object in page\n   * @returns pdf path object\n   *\n   * @private\n   */\n  readPathObject(pathObjectPtr) {\n    const segmentCount = this.pdfiumModule.FPDFPath_CountSegments(pathObjectPtr);\n    const leftPtr = this.memoryManager.malloc(4);\n    const bottomPtr = this.memoryManager.malloc(4);\n    const rightPtr = this.memoryManager.malloc(4);\n    const topPtr = this.memoryManager.malloc(4);\n    this.pdfiumModule.FPDFPageObj_GetBounds(pathObjectPtr, leftPtr, bottomPtr, rightPtr, topPtr);\n    const left = this.pdfiumModule.pdfium.getValue(leftPtr, "float");\n    const bottom = this.pdfiumModule.pdfium.getValue(bottomPtr, "float");\n    const right = this.pdfiumModule.pdfium.getValue(rightPtr, "float");\n    const top = this.pdfiumModule.pdfium.getValue(topPtr, "float");\n    const bounds = { left, bottom, right, top };\n    this.memoryManager.free(leftPtr);\n    this.memoryManager.free(bottomPtr);\n    this.memoryManager.free(rightPtr);\n    this.memoryManager.free(topPtr);\n    const segments = [];\n    for (let i = 0; i < segmentCount; i++) {\n      const segment = this.readPdfSegment(pathObjectPtr, i);\n      segments.push(segment);\n    }\n    const matrix = this.readPdfPageObjectTransformMatrix(pathObjectPtr);\n    return {\n      type: PdfPageObjectType.PATH,\n      bounds,\n      segments,\n      matrix\n    };\n  }\n  /**\n   * Read segment of pdf path object\n   * @param annotationObjectPtr - pointer to pdf path object\n   * @param segmentIndex - index of segment\n   * @returns pdf segment in pdf path\n   *\n   * @private\n   */\n  readPdfSegment(annotationObjectPtr, segmentIndex) {\n    const segmentPtr = this.pdfiumModule.FPDFPath_GetPathSegment(annotationObjectPtr, segmentIndex);\n    const segmentType = this.pdfiumModule.FPDFPathSegment_GetType(segmentPtr);\n    const isClosed = this.pdfiumModule.FPDFPathSegment_GetClose(segmentPtr);\n    const pointXPtr = this.memoryManager.malloc(4);\n    const pointYPtr = this.memoryManager.malloc(4);\n    this.pdfiumModule.FPDFPathSegment_GetPoint(segmentPtr, pointXPtr, pointYPtr);\n    const pointX = this.pdfiumModule.pdfium.getValue(pointXPtr, "float");\n    const pointY = this.pdfiumModule.pdfium.getValue(pointYPtr, "float");\n    this.memoryManager.free(pointXPtr);\n    this.memoryManager.free(pointYPtr);\n    return {\n      type: segmentType,\n      point: { x: pointX, y: pointY },\n      isClosed\n    };\n  }\n  /**\n   * Read pdf image object from pdf document\n   * @param pageObjectPtr  - pointer to pdf image object in page\n   * @returns pdf image object\n   *\n   * @private\n   */\n  readImageObject(imageObjectPtr) {\n    const bitmapPtr = this.pdfiumModule.FPDFImageObj_GetBitmap(imageObjectPtr);\n    const bitmapBufferPtr = this.pdfiumModule.FPDFBitmap_GetBuffer(bitmapPtr);\n    const bitmapWidth = this.pdfiumModule.FPDFBitmap_GetWidth(bitmapPtr);\n    const bitmapHeight = this.pdfiumModule.FPDFBitmap_GetHeight(bitmapPtr);\n    const format = this.pdfiumModule.FPDFBitmap_GetFormat(bitmapPtr);\n    const pixelCount = bitmapWidth * bitmapHeight;\n    const bytesPerPixel = 4;\n    const array = new Uint8ClampedArray(pixelCount * bytesPerPixel);\n    for (let i = 0; i < pixelCount; i++) {\n      switch (format) {\n        case 2:\n          {\n            const blue = this.pdfiumModule.pdfium.getValue(bitmapBufferPtr + i * 3, "i8");\n            const green = this.pdfiumModule.pdfium.getValue(bitmapBufferPtr + i * 3 + 1, "i8");\n            const red = this.pdfiumModule.pdfium.getValue(bitmapBufferPtr + i * 3 + 2, "i8");\n            array[i * bytesPerPixel] = red;\n            array[i * bytesPerPixel + 1] = green;\n            array[i * bytesPerPixel + 2] = blue;\n            array[i * bytesPerPixel + 3] = 100;\n          }\n          break;\n      }\n    }\n    const imageDataLike = {\n      data: array,\n      width: bitmapWidth,\n      height: bitmapHeight\n    };\n    const matrix = this.readPdfPageObjectTransformMatrix(imageObjectPtr);\n    return {\n      type: PdfPageObjectType.IMAGE,\n      imageData: imageDataLike,\n      matrix\n    };\n  }\n  /**\n   * Read form object from pdf document\n   * @param formObjectPtr  - pointer to pdf form object in page\n   * @returns pdf form object\n   *\n   * @private\n   */\n  readFormObject(formObjectPtr) {\n    const objectCount = this.pdfiumModule.FPDFFormObj_CountObjects(formObjectPtr);\n    const objects = [];\n    for (let i = 0; i < objectCount; i++) {\n      const pageObjectPtr = this.pdfiumModule.FPDFFormObj_GetObject(formObjectPtr, i);\n      const pageObj = this.readPdfPageObject(pageObjectPtr);\n      if (pageObj) {\n        objects.push(pageObj);\n      }\n    }\n    const matrix = this.readPdfPageObjectTransformMatrix(formObjectPtr);\n    return {\n      type: PdfPageObjectType.FORM,\n      objects,\n      matrix\n    };\n  }\n  /**\n   * Read pdf object in pdf page\n   * @param pageObjectPtr  - pointer to pdf object in page\n   * @returns pdf object in page\n   *\n   * @private\n   */\n  readPdfPageObjectTransformMatrix(pageObjectPtr) {\n    const matrixPtr = this.memoryManager.malloc(4 * 6);\n    if (this.pdfiumModule.FPDFPageObj_GetMatrix(pageObjectPtr, matrixPtr)) {\n      const a = this.pdfiumModule.pdfium.getValue(matrixPtr, "float");\n      const b = this.pdfiumModule.pdfium.getValue(matrixPtr + 4, "float");\n      const c = this.pdfiumModule.pdfium.getValue(matrixPtr + 8, "float");\n      const d = this.pdfiumModule.pdfium.getValue(matrixPtr + 12, "float");\n      const e = this.pdfiumModule.pdfium.getValue(matrixPtr + 16, "float");\n      const f = this.pdfiumModule.pdfium.getValue(matrixPtr + 20, "float");\n      this.memoryManager.free(matrixPtr);\n      return { a, b, c, d, e, f };\n    }\n    this.memoryManager.free(matrixPtr);\n    return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };\n  }\n  /**\n   * Read contents of a stamp annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns contents of the stamp annotation\n   *\n   * @private\n   */\n  readStampAnnotationContents(annotationPtr) {\n    const contents = [];\n    const objectCount = this.pdfiumModule.FPDFAnnot_GetObjectCount(annotationPtr);\n    for (let i = 0; i < objectCount; i++) {\n      const annotationObjectPtr = this.pdfiumModule.FPDFAnnot_GetObject(annotationPtr, i);\n      const pageObj = this.readPdfPageObject(annotationObjectPtr);\n      if (pageObj) {\n        contents.push(pageObj);\n      }\n    }\n    return contents;\n  }\n  /**\n   * Return the stroke-width declared in the annotation\u2019s /Border or /BS entry.\n   * Falls back to 1 pt when nothing is defined.\n   *\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns stroke-width\n   *\n   * @private\n   */\n  getStrokeWidth(annotationPtr) {\n    const hPtr = this.memoryManager.malloc(4);\n    const vPtr = this.memoryManager.malloc(4);\n    const wPtr = this.memoryManager.malloc(4);\n    const ok = this.pdfiumModule.FPDFAnnot_GetBorder(annotationPtr, hPtr, vPtr, wPtr);\n    const width = ok ? this.pdfiumModule.pdfium.getValue(wPtr, "float") : 1;\n    this.memoryManager.free(hPtr);\n    this.memoryManager.free(vPtr);\n    this.memoryManager.free(wPtr);\n    return width;\n  }\n  /**\n   * Fetches the `/F` flag bit-field from an annotation.\n   *\n   * @param annotationPtr pointer to an `FPDF_ANNOTATION`\n   * @returns `{ raw, flags }`\n   *          \u2022 `raw`   \u2013 the 32-bit integer returned by PDFium\n   *          \u2022 `flags` \u2013 object with individual booleans\n   */\n  getAnnotationFlags(annotationPtr) {\n    const rawFlags = this.pdfiumModule.FPDFAnnot_GetFlags(annotationPtr);\n    return flagsToNames(rawFlags);\n  }\n  setAnnotationFlags(annotationPtr, flags) {\n    const rawFlags = namesToFlags(flags);\n    return this.pdfiumModule.FPDFAnnot_SetFlags(annotationPtr, rawFlags);\n  }\n  /**\n   * Read circle annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf circle annotation\n   *\n   * @private\n   */\n  readPdfCircleAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const interiorColor = this.getAnnotationColor(\n      annotationPtr,\n      PdfAnnotationColorType.InteriorColor\n    );\n    const strokeColor = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    let strokeDashArray;\n    if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n      const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n      if (ok) {\n        strokeDashArray = pattern;\n      }\n    }\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.CIRCLE,\n      flags,\n      color: interiorColor ?? "transparent",\n      opacity,\n      contents,\n      strokeWidth,\n      strokeColor: strokeColor ?? "#FF0000",\n      strokeStyle,\n      rect,\n      author,\n      modified,\n      created,\n      ...strokeDashArray !== void 0 && { strokeDashArray }\n    };\n  }\n  /**\n   * Read square annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf square annotation\n   *\n   * @private\n   */\n  readPdfSquareAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const interiorColor = this.getAnnotationColor(\n      annotationPtr,\n      PdfAnnotationColorType.InteriorColor\n    );\n    const strokeColor = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    let strokeDashArray;\n    if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n      const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n      if (ok) {\n        strokeDashArray = pattern;\n      }\n    }\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.SQUARE,\n      flags,\n      color: interiorColor ?? "transparent",\n      opacity,\n      contents,\n      strokeColor: strokeColor ?? "#FF0000",\n      strokeWidth,\n      strokeStyle,\n      rect,\n      author,\n      modified,\n      created,\n      ...strokeDashArray !== void 0 && { strokeDashArray }\n    };\n  }\n  /**\n   * Read basic info of unsupported pdf annotation\n   * @param page  - pdf page infor\n   * @param type - type of annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf annotation\n   *\n   * @private\n   */\n  readPdfAnno(page, type, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      flags,\n      type,\n      rect,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Resolve `/IRT` \u2192 parent-annotation index on the same page.\n   *\n   * @param pagePtr        - pointer to FPDF_PAGE\n   * @param annotationPtr  - pointer to FPDF_ANNOTATION\n   * @returns index (`0\u2026count-1`) or `undefined` when the annotation is *not* a reply\n   *\n   * @private\n   */\n  getInReplyToId(annotationPtr) {\n    const parentPtr = this.pdfiumModule.FPDFAnnot_GetLinkedAnnot(annotationPtr, "IRT");\n    if (!parentPtr) return;\n    return this.getAnnotString(parentPtr, "NM");\n  }\n  /**\n   * Set the in reply to id of the annotation\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param id - the id of the parent annotation\n   * @returns `true` on success\n   */\n  setInReplyToId(pagePtr, annotationPtr, id) {\n    const parentPtr = this.getAnnotationByName(pagePtr, id);\n    if (!parentPtr) return false;\n    return this.pdfiumModule.EPDFAnnot_SetLinkedAnnot(annotationPtr, "IRT", parentPtr);\n  }\n  /**\n   * Fetch a string value (`/T`, `/M`, `/State`, \u2026) from an annotation.\n   *\n   * @returns decoded UTF-8 string or `undefined` when the key is absent\n   *\n   * @private\n   */\n  getAnnotString(annotationPtr, key) {\n    const len = this.pdfiumModule.FPDFAnnot_GetStringValue(annotationPtr, key, 0, 0);\n    if (len === 0) return;\n    const bytes = (len + 1) * 2;\n    const ptr = this.memoryManager.malloc(bytes);\n    this.pdfiumModule.FPDFAnnot_GetStringValue(annotationPtr, key, ptr, bytes);\n    const value = this.pdfiumModule.pdfium.UTF16ToString(ptr);\n    this.memoryManager.free(ptr);\n    return value || void 0;\n  }\n  /**\n   * Get a string value (`/T`, `/M`, `/State`, \u2026) from an attachment.\n   *\n   * @returns decoded UTF-8 string or `undefined` when the key is absent\n   *\n   * @private\n   */\n  getAttachmentString(attachmentPtr, key) {\n    const len = this.pdfiumModule.FPDFAttachment_GetStringValue(attachmentPtr, key, 0, 0);\n    if (len === 0) return;\n    const bytes = (len + 1) * 2;\n    const ptr = this.memoryManager.malloc(bytes);\n    this.pdfiumModule.FPDFAttachment_GetStringValue(attachmentPtr, key, ptr, bytes);\n    const value = this.pdfiumModule.pdfium.UTF16ToString(ptr);\n    this.memoryManager.free(ptr);\n    return value || void 0;\n  }\n  /**\n   * Get a number value (`/Size`) from an attachment.\n   *\n   * @returns number or `null` when the key is absent\n   *\n   * @private\n   */\n  getAttachmentNumber(attachmentPtr, key) {\n    const outPtr = this.memoryManager.malloc(4);\n    try {\n      const ok = this.pdfiumModule.EPDFAttachment_GetIntegerValue(\n        attachmentPtr,\n        key,\n        // FPDF_BYTESTRING \u2192 ASCII JS string is fine in your glue\n        outPtr\n      );\n      if (!ok) return void 0;\n      return this.pdfiumModule.pdfium.getValue(outPtr, "i32") >>> 0;\n    } finally {\n      this.memoryManager.free(outPtr);\n    }\n  }\n  /**\n   * Get custom data of the annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns custom data of the annotation\n   *\n   * @private\n   */\n  getAnnotCustom(annotationPtr) {\n    const custom = this.getAnnotString(annotationPtr, "EPDFCustom");\n    if (!custom) return;\n    try {\n      return JSON.parse(custom);\n    } catch (error) {\n      console.warn("Failed to parse annotation custom data as JSON:", error);\n      console.warn("Invalid JSON string:", custom);\n      return void 0;\n    }\n  }\n  /**\n   * Sets custom data for an annotation by safely stringifying and storing JSON\n   * @private\n   */\n  setAnnotCustom(annotationPtr, data) {\n    if (data === void 0 || data === null) {\n      return this.setAnnotString(annotationPtr, "EPDFCustom", "");\n    }\n    try {\n      const jsonString = JSON.stringify(data);\n      return this.setAnnotString(annotationPtr, "EPDFCustom", jsonString);\n    } catch (error) {\n      console.warn("Failed to stringify annotation custom data as JSON:", error);\n      console.warn("Invalid data object:", data);\n      return false;\n    }\n  }\n  /**\n   * Fetches the /IT (Intent) name from an annotation as a UTF-8 JS string.\n   *\n   * Mirrors getAnnotString(): calls EPDFAnnot_GetIntent twice (length probe + copy).\n   * Returns `undefined` if no intent present.\n   */\n  getAnnotIntent(annotationPtr) {\n    const len = this.pdfiumModule.EPDFAnnot_GetIntent(annotationPtr, 0, 0);\n    if (len === 0) return;\n    const codeUnits = len + 1;\n    const bytes = codeUnits * 2;\n    const ptr = this.memoryManager.malloc(bytes);\n    this.pdfiumModule.EPDFAnnot_GetIntent(annotationPtr, ptr, bytes);\n    const value = this.pdfiumModule.pdfium.UTF16ToString(ptr);\n    this.memoryManager.free(ptr);\n    return value && value !== "undefined" ? value : void 0;\n  }\n  /**\n   * Write the `/IT` (Intent) name into an annotation dictionary.\n   *\n   * Mirrors EPDFAnnot_SetIntent in PDFium (expects a UTF\u20118 FPDF_BYTESTRING).\n   *\n   * @param annotationPtr Pointer returned by FPDFPage_GetAnnot\n   * @param intent        Name without leading slash, e.g. `"PolygonCloud"`\n   *                      A leading \u201C/\u201D will be stripped for convenience.\n   * @returns             true on success, false otherwise\n   */\n  setAnnotIntent(annotationPtr, intent) {\n    return this.pdfiumModule.EPDFAnnot_SetIntent(annotationPtr, intent);\n  }\n  /**\n   * Returns the rich\u2011content string stored in the annotation\u2019s `/RC` entry.\n   *\n   * Works like `getAnnotIntent()`: first probe for length, then copy.\n   * `undefined` when the annotation has no rich content.\n   */\n  getAnnotRichContent(annotationPtr) {\n    const len = this.pdfiumModule.EPDFAnnot_GetRichContent(annotationPtr, 0, 0);\n    if (len === 0) return;\n    const codeUnits = len + 1;\n    const bytes = codeUnits * 2;\n    const ptr = this.memoryManager.malloc(bytes);\n    this.pdfiumModule.EPDFAnnot_GetRichContent(annotationPtr, ptr, bytes);\n    const value = this.pdfiumModule.pdfium.UTF16ToString(ptr);\n    this.memoryManager.free(ptr);\n    return value || void 0;\n  }\n  /**\n   * Get annotation by name\n   * @param pagePtr - pointer to pdf page object\n   * @param name - name of annotation\n   * @returns pointer to pdf annotation\n   *\n   * @private\n   */\n  getAnnotationByName(pagePtr, name) {\n    return this.withWString(name, (wNamePtr) => {\n      return this.pdfiumModule.EPDFPage_GetAnnotByName(pagePtr, wNamePtr);\n    });\n  }\n  /**\n   * Remove annotation by name\n   * @param pagePtr - pointer to pdf page object\n   * @param name - name of annotation\n   * @returns true on success\n   *\n   * @private\n   */\n  removeAnnotationByName(pagePtr, name) {\n    return this.withWString(name, (wNamePtr) => {\n      return this.pdfiumModule.EPDFPage_RemoveAnnotByName(pagePtr, wNamePtr);\n    });\n  }\n  /**\n   * Set a string value (`/T`, `/M`, `/State`, \u2026) to an annotation.\n   *\n   * @returns `true` if the operation was successful\n   *\n   * @private\n   */\n  setAnnotString(annotationPtr, key, value) {\n    return this.withWString(value, (wValPtr) => {\n      return this.pdfiumModule.FPDFAnnot_SetStringValue(annotationPtr, key, wValPtr);\n    });\n  }\n  /**\n   * Set a string value (`/T`, `/M`, `/State`, \u2026) to an attachment.\n   *\n   * @returns `true` if the operation was successful\n   *\n   * @private\n   */\n  setAttachmentString(attachmentPtr, key, value) {\n    return this.withWString(value, (wValPtr) => {\n      return this.pdfiumModule.FPDFAttachment_SetStringValue(attachmentPtr, key, wValPtr);\n    });\n  }\n  /**\n   * Read vertices of pdf annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns vertices of pdf annotation\n   *\n   * @private\n   */\n  readPdfAnnoVertices(page, annotationPtr) {\n    const vertices = [];\n    const count = this.pdfiumModule.FPDFAnnot_GetVertices(annotationPtr, 0, 0);\n    const pointMemorySize = 8;\n    const pointsPtr = this.memoryManager.malloc(count * pointMemorySize);\n    this.pdfiumModule.FPDFAnnot_GetVertices(annotationPtr, pointsPtr, count);\n    for (let i = 0; i < count; i++) {\n      const pointX = this.pdfiumModule.pdfium.getValue(pointsPtr + i * pointMemorySize, "float");\n      const pointY = this.pdfiumModule.pdfium.getValue(\n        pointsPtr + i * pointMemorySize + 4,\n        "float"\n      );\n      const { x, y } = this.convertPagePointToDevicePoint(page, {\n        x: pointX,\n        y: pointY\n      });\n      const last = vertices[vertices.length - 1];\n      if (!last || last.x !== x || last.y !== y) {\n        vertices.push({ x, y });\n      }\n    }\n    this.memoryManager.free(pointsPtr);\n    return vertices;\n  }\n  /**\n   * Sync the vertices of a polygon or polyline annotation.\n   *\n   * @param page  - pdf page infor\n   * @param annotPtr - pointer to pdf annotation\n   * @param vertices - the vertices to be set\n   * @returns true on success\n   *\n   * @private\n   */\n  setPdfAnnoVertices(page, annotPtr, vertices) {\n    const pdf = this.pdfiumModule.pdfium;\n    const FS_POINTF_SIZE = 8;\n    const buf = this.memoryManager.malloc(FS_POINTF_SIZE * vertices.length);\n    vertices.forEach((v, i) => {\n      const pagePt = this.convertDevicePointToPagePoint(page, v);\n      pdf.setValue(buf + i * FS_POINTF_SIZE + 0, pagePt.x, "float");\n      pdf.setValue(buf + i * FS_POINTF_SIZE + 4, pagePt.y, "float");\n    });\n    const ok = this.pdfiumModule.EPDFAnnot_SetVertices(annotPtr, buf, vertices.length);\n    this.memoryManager.free(buf);\n    return ok;\n  }\n  /**\n   * Read the target of pdf bookmark\n   * @param docPtr - pointer to pdf document object\n   * @param getActionPtr - callback function to retrive the pointer of action\n   * @param getDestinationPtr - callback function to retrive the pointer of destination\n   * @returns target of pdf bookmark\n   *\n   * @private\n   */\n  readPdfBookmarkTarget(docPtr, getActionPtr, getDestinationPtr) {\n    const actionPtr = getActionPtr();\n    if (actionPtr) {\n      const action = this.readPdfAction(docPtr, actionPtr);\n      return {\n        type: "action",\n        action\n      };\n    } else {\n      const destinationPtr = getDestinationPtr();\n      if (destinationPtr) {\n        const destination = this.readPdfDestination(docPtr, destinationPtr);\n        return {\n          type: "destination",\n          destination\n        };\n      }\n    }\n  }\n  /**\n   * Read field of pdf widget annotation\n   * @param formHandle - form handle\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns field of pdf widget annotation\n   *\n   * @private\n   */\n  readPdfWidgetAnnoField(formHandle, annotationPtr) {\n    const flag = this.pdfiumModule.FPDFAnnot_GetFormFieldFlags(\n      formHandle,\n      annotationPtr\n    );\n    const type = this.pdfiumModule.FPDFAnnot_GetFormFieldType(\n      formHandle,\n      annotationPtr\n    );\n    const name = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAnnot_GetFormFieldName(\n          formHandle,\n          annotationPtr,\n          buffer,\n          bufferLength\n        );\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const alternateName = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAnnot_GetFormFieldAlternateName(\n          formHandle,\n          annotationPtr,\n          buffer,\n          bufferLength\n        );\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const value = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAnnot_GetFormFieldValue(\n          formHandle,\n          annotationPtr,\n          buffer,\n          bufferLength\n        );\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const options = [];\n    if (type === PDF_FORM_FIELD_TYPE.COMBOBOX || type === PDF_FORM_FIELD_TYPE.LISTBOX) {\n      const count = this.pdfiumModule.FPDFAnnot_GetOptionCount(formHandle, annotationPtr);\n      for (let i = 0; i < count; i++) {\n        const label = readString(\n          this.pdfiumModule.pdfium,\n          (buffer, bufferLength) => {\n            return this.pdfiumModule.FPDFAnnot_GetOptionLabel(\n              formHandle,\n              annotationPtr,\n              i,\n              buffer,\n              bufferLength\n            );\n          },\n          this.pdfiumModule.pdfium.UTF16ToString\n        );\n        const isSelected = this.pdfiumModule.FPDFAnnot_IsOptionSelected(\n          formHandle,\n          annotationPtr,\n          i\n        );\n        options.push({\n          label,\n          isSelected\n        });\n      }\n    }\n    let isChecked = false;\n    if (type === PDF_FORM_FIELD_TYPE.CHECKBOX || type === PDF_FORM_FIELD_TYPE.RADIOBUTTON) {\n      isChecked = this.pdfiumModule.FPDFAnnot_IsChecked(formHandle, annotationPtr);\n    }\n    return {\n      flag,\n      type,\n      name,\n      alternateName,\n      value,\n      isChecked,\n      options\n    };\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.renderAnnotation}\n   *\n   * @public\n   */\n  renderPageAnnotationRaw(doc, page, annotation, options) {\n    const {\n      scaleFactor = 1,\n      rotation = Rotation.Degree0,\n      dpr = 1,\n      mode = AppearanceMode.Normal\n    } = options ?? {};\n    this.logger.debug(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      "renderPageAnnotation",\n      doc,\n      page,\n      annotation,\n      options\n    );\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `RenderPageAnnotation`,\n      "Begin",\n      `${doc.id}-${page.index}-${annotation.id}`\n    );\n    const task = new Task();\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `RenderPageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}-${annotation.id}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const annotPtr = this.getAnnotationByName(pageCtx.pagePtr, annotation.id);\n    if (!annotPtr) {\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `RenderPageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}-${annotation.id}`\n      );\n      pageCtx.release();\n      return PdfTaskHelper.reject({ code: PdfErrorCode.NotFound, message: "annotation not found" });\n    }\n    const finalScale = Math.max(0.01, scaleFactor * dpr);\n    const rect = toIntRect(annotation.rect);\n    const devRect = toIntRect(transformRect(page.size, rect, rotation, finalScale));\n    const wDev = Math.max(1, devRect.size.width);\n    const hDev = Math.max(1, devRect.size.height);\n    const stride = wDev * 4;\n    const bytes = stride * hDev;\n    const heapPtr = this.memoryManager.malloc(bytes);\n    const bitmapPtr = this.pdfiumModule.FPDFBitmap_CreateEx(\n      wDev,\n      hDev,\n      4,\n      heapPtr,\n      stride\n    );\n    this.pdfiumModule.FPDFBitmap_FillRect(bitmapPtr, 0, 0, wDev, hDev, 0);\n    const M = buildUserToDeviceMatrix(\n      rect,\n      // {origin:{L,B}, size:{W,H}}\n      rotation,\n      wDev,\n      hDev\n    );\n    const mPtr = this.memoryManager.malloc(6 * 4);\n    const mView = new Float32Array(this.pdfiumModule.pdfium.HEAPF32.buffer, mPtr, 6);\n    mView.set([M.a, M.b, M.c, M.d, M.e, M.f]);\n    const FLAGS = 16;\n    let ok = false;\n    try {\n      ok = !!this.pdfiumModule.EPDF_RenderAnnotBitmap(\n        bitmapPtr,\n        pageCtx.pagePtr,\n        annotPtr,\n        mode,\n        mPtr,\n        FLAGS\n      );\n    } finally {\n      this.memoryManager.free(mPtr);\n      this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n      this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n      pageCtx.release();\n    }\n    if (!ok) {\n      this.memoryManager.free(heapPtr);\n      this.logger.perf(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `RenderPageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}-${annotation.id}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.Unknown,\n        message: "EPDF_RenderAnnotBitmap failed"\n      });\n    }\n    const data = this.pdfiumModule.pdfium.HEAPU8.subarray(heapPtr, heapPtr + bytes);\n    const imageDataLike = {\n      data: new Uint8ClampedArray(data),\n      width: wDev,\n      height: hDev\n    };\n    task.resolve(imageDataLike);\n    this.memoryManager.free(heapPtr);\n    return task;\n  }\n  renderRectEncoded(doc, page, rect, options) {\n    const task = new Task();\n    const rotation = (options == null ? void 0 : options.rotation) ?? Rotation.Degree0;\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const scale = Math.max(0.01, (options == null ? void 0 : options.scaleFactor) ?? 1);\n    const dpr = Math.max(1, (options == null ? void 0 : options.dpr) ?? 1);\n    const finalScale = scale * dpr;\n    const baseW = rect.size.width;\n    const baseH = rect.size.height;\n    const swap2 = (rotation & 1) === 1;\n    const wDev = Math.max(1, Math.round((swap2 ? baseH : baseW) * finalScale));\n    const hDev = Math.max(1, Math.round((swap2 ? baseW : baseH) * finalScale));\n    const stride = wDev * 4;\n    const bytes = stride * hDev;\n    const pageCtx = ctx.acquirePage(page.index);\n    const shouldRenderForms = (options == null ? void 0 : options.withForms) ?? false;\n    const formHandle = shouldRenderForms ? pageCtx.getFormHandle() : void 0;\n    const heapPtr = this.memoryManager.malloc(bytes);\n    const bitmapPtr = this.pdfiumModule.FPDFBitmap_CreateEx(\n      wDev,\n      hDev,\n      4,\n      heapPtr,\n      stride\n    );\n    this.pdfiumModule.FPDFBitmap_FillRect(bitmapPtr, 0, 0, wDev, hDev, 4294967295);\n    const M = buildUserToDeviceMatrix(rect, rotation, wDev, hDev);\n    const mPtr = this.memoryManager.malloc(6 * 4);\n    const mView = new Float32Array(this.pdfiumModule.pdfium.HEAPF32.buffer, mPtr, 6);\n    mView.set([M.a, M.b, M.c, M.d, M.e, M.f]);\n    const clipPtr = this.memoryManager.malloc(4 * 4);\n    const clipView = new Float32Array(this.pdfiumModule.pdfium.HEAPF32.buffer, clipPtr, 4);\n    clipView.set([0, 0, wDev, hDev]);\n    let flags = 16;\n    if ((options == null ? void 0 : options.withAnnotations) ?? false) flags |= 1;\n    try {\n      this.pdfiumModule.FPDF_RenderPageBitmapWithMatrix(\n        bitmapPtr,\n        pageCtx.pagePtr,\n        mPtr,\n        clipPtr,\n        flags\n      );\n      if (formHandle !== void 0) {\n        const formParams = computeFormDrawParams(M, rect, page.size, rotation);\n        const { startX, startY, formsWidth, formsHeight, scaleX, scaleY } = formParams;\n        this.pdfiumModule.FPDF_FFLDraw(\n          formHandle,\n          bitmapPtr,\n          pageCtx.pagePtr,\n          startX,\n          startY,\n          formsWidth,\n          formsHeight,\n          rotation,\n          flags\n        );\n      }\n    } finally {\n      pageCtx.release();\n      this.memoryManager.free(mPtr);\n      this.memoryManager.free(clipPtr);\n    }\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `RenderRectEncodedData`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const data = this.pdfiumModule.pdfium.HEAPU8.subarray(heapPtr, heapPtr + bytes);\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `RenderRectEncodedData`,\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `RenderRectEncodedImageData`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const imageDataLike = {\n      data: new Uint8ClampedArray(data),\n      width: wDev,\n      height: hDev\n    };\n    this.logger.perf(\n      LOG_SOURCE$1,\n      LOG_CATEGORY$1,\n      `RenderRectEncodedImageData`,\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    task.resolve(imageDataLike);\n    this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n    this.memoryManager.free(heapPtr);\n    return task;\n  }\n  /**\n   * Read the target of pdf link annotation\n   * @param docPtr - pointer to pdf document object\n   * @param getActionPtr - callback function to retrive the pointer of action\n   * @param getDestinationPtr - callback function to retrive the pointer of destination\n   * @returns target of link\n   *\n   * @private\n   */\n  readPdfLinkAnnoTarget(docPtr, getActionPtr, getDestinationPtr) {\n    const destinationPtr = getDestinationPtr();\n    if (destinationPtr) {\n      const destination = this.readPdfDestination(docPtr, destinationPtr);\n      return {\n        type: "destination",\n        destination\n      };\n    } else {\n      const actionPtr = getActionPtr();\n      if (actionPtr) {\n        const action = this.readPdfAction(docPtr, actionPtr);\n        return {\n          type: "action",\n          action\n        };\n      }\n    }\n  }\n  createLocalDestPtr(docPtr, dest) {\n    var _a, _b;\n    const pagePtr = this.pdfiumModule.FPDF_LoadPage(docPtr, dest.pageIndex);\n    if (!pagePtr) return 0;\n    try {\n      if (dest.zoom.mode === PdfZoomMode.XYZ) {\n        const { x, y, zoom } = dest.zoom.params;\n        return this.pdfiumModule.EPDFDest_CreateXYZ(\n          pagePtr,\n          /*has_left*/\n          true,\n          x,\n          /*has_top*/\n          true,\n          y,\n          /*has_zoom*/\n          true,\n          zoom\n        );\n      }\n      let viewEnum;\n      let params = [];\n      switch (dest.zoom.mode) {\n        case PdfZoomMode.FitPage:\n          viewEnum = PdfZoomMode.FitPage;\n          break;\n        case PdfZoomMode.FitHorizontal:\n          viewEnum = PdfZoomMode.FitHorizontal;\n          params = [((_a = dest.view) == null ? void 0 : _a[0]) ?? 0];\n          break;\n        case PdfZoomMode.FitVertical:\n          viewEnum = PdfZoomMode.FitVertical;\n          params = [((_b = dest.view) == null ? void 0 : _b[0]) ?? 0];\n          break;\n        case PdfZoomMode.FitRectangle:\n          {\n            const v = dest.view ?? [];\n            params = [v[0] ?? 0, v[1] ?? 0, v[2] ?? 0, v[3] ?? 0];\n            viewEnum = PdfZoomMode.FitRectangle;\n          }\n          break;\n        case PdfZoomMode.Unknown:\n        default:\n          return 0;\n      }\n      return this.withFloatArray(\n        params,\n        (ptr, count) => this.pdfiumModule.EPDFDest_CreateView(pagePtr, viewEnum, ptr, count)\n      );\n    } finally {\n      this.pdfiumModule.FPDF_ClosePage(pagePtr);\n    }\n  }\n  applyBookmarkTarget(docPtr, bmPtr, target) {\n    if (target.type === "destination") {\n      const destPtr = this.createLocalDestPtr(docPtr, target.destination);\n      if (!destPtr) return false;\n      const ok = this.pdfiumModule.EPDFBookmark_SetDest(docPtr, bmPtr, destPtr);\n      return !!ok;\n    }\n    const action = target.action;\n    switch (action.type) {\n      case PdfActionType.Goto: {\n        const destPtr = this.createLocalDestPtr(docPtr, action.destination);\n        if (!destPtr) return false;\n        const actPtr = this.pdfiumModule.EPDFAction_CreateGoTo(docPtr, destPtr);\n        if (!actPtr) return false;\n        return !!this.pdfiumModule.EPDFBookmark_SetAction(docPtr, bmPtr, actPtr);\n      }\n      case PdfActionType.URI: {\n        const actPtr = this.pdfiumModule.EPDFAction_CreateURI(docPtr, action.uri);\n        if (!actPtr) return false;\n        return !!this.pdfiumModule.EPDFBookmark_SetAction(docPtr, bmPtr, actPtr);\n      }\n      case PdfActionType.LaunchAppOrOpenFile: {\n        const actPtr = this.withWString(\n          action.path,\n          (wptr) => this.pdfiumModule.EPDFAction_CreateLaunch(docPtr, wptr)\n        );\n        if (!actPtr) return false;\n        return !!this.pdfiumModule.EPDFBookmark_SetAction(docPtr, bmPtr, actPtr);\n      }\n      case PdfActionType.RemoteGoto:\n        return false;\n      case PdfActionType.Unsupported:\n      default:\n        return false;\n    }\n  }\n  /**\n   * Read pdf action from pdf document\n   * @param docPtr - pointer to pdf document object\n   * @param actionPtr - pointer to pdf action object\n   * @returns pdf action object\n   *\n   * @private\n   */\n  readPdfAction(docPtr, actionPtr) {\n    const actionType = this.pdfiumModule.FPDFAction_GetType(actionPtr);\n    let action;\n    switch (actionType) {\n      case PdfActionType.Unsupported:\n        action = {\n          type: PdfActionType.Unsupported\n        };\n        break;\n      case PdfActionType.Goto:\n        {\n          const destinationPtr = this.pdfiumModule.FPDFAction_GetDest(docPtr, actionPtr);\n          if (destinationPtr) {\n            const destination = this.readPdfDestination(docPtr, destinationPtr);\n            action = {\n              type: PdfActionType.Goto,\n              destination\n            };\n          } else {\n            action = {\n              type: PdfActionType.Unsupported\n            };\n          }\n        }\n        break;\n      case PdfActionType.RemoteGoto:\n        {\n          action = {\n            type: PdfActionType.Unsupported\n          };\n        }\n        break;\n      case PdfActionType.URI:\n        {\n          const uri = readString(\n            this.pdfiumModule.pdfium,\n            (buffer, bufferLength) => {\n              return this.pdfiumModule.FPDFAction_GetURIPath(\n                docPtr,\n                actionPtr,\n                buffer,\n                bufferLength\n              );\n            },\n            this.pdfiumModule.pdfium.UTF8ToString\n          );\n          action = {\n            type: PdfActionType.URI,\n            uri\n          };\n        }\n        break;\n      case PdfActionType.LaunchAppOrOpenFile:\n        {\n          const path = readString(\n            this.pdfiumModule.pdfium,\n            (buffer, bufferLength) => {\n              return this.pdfiumModule.FPDFAction_GetFilePath(actionPtr, buffer, bufferLength);\n            },\n            this.pdfiumModule.pdfium.UTF8ToString\n          );\n          action = {\n            type: PdfActionType.LaunchAppOrOpenFile,\n            path\n          };\n        }\n        break;\n    }\n    return action;\n  }\n  /**\n   * Read pdf destination object\n   * @param docPtr - pointer to pdf document object\n   * @param destinationPtr - pointer to pdf destination\n   * @returns pdf destination object\n   *\n   * @private\n   */\n  readPdfDestination(docPtr, destinationPtr) {\n    const pageIndex = this.pdfiumModule.FPDFDest_GetDestPageIndex(docPtr, destinationPtr);\n    const maxParmamsCount = 4;\n    const paramsCountPtr = this.memoryManager.malloc(maxParmamsCount);\n    const paramsPtr = this.memoryManager.malloc(maxParmamsCount * 4);\n    const zoomMode = this.pdfiumModule.FPDFDest_GetView(\n      destinationPtr,\n      paramsCountPtr,\n      paramsPtr\n    );\n    const paramsCount = this.pdfiumModule.pdfium.getValue(paramsCountPtr, "i32");\n    const view = [];\n    for (let i = 0; i < paramsCount; i++) {\n      const paramPtr = paramsPtr + i * 4;\n      view.push(this.pdfiumModule.pdfium.getValue(paramPtr, "float"));\n    }\n    this.memoryManager.free(paramsCountPtr);\n    this.memoryManager.free(paramsPtr);\n    if (zoomMode === PdfZoomMode.XYZ) {\n      const hasXPtr = this.memoryManager.malloc(1);\n      const hasYPtr = this.memoryManager.malloc(1);\n      const hasZPtr = this.memoryManager.malloc(1);\n      const xPtr = this.memoryManager.malloc(4);\n      const yPtr = this.memoryManager.malloc(4);\n      const zPtr = this.memoryManager.malloc(4);\n      const isSucceed = this.pdfiumModule.FPDFDest_GetLocationInPage(\n        destinationPtr,\n        hasXPtr,\n        hasYPtr,\n        hasZPtr,\n        xPtr,\n        yPtr,\n        zPtr\n      );\n      if (isSucceed) {\n        const hasX = this.pdfiumModule.pdfium.getValue(hasXPtr, "i8");\n        const hasY = this.pdfiumModule.pdfium.getValue(hasYPtr, "i8");\n        const hasZ = this.pdfiumModule.pdfium.getValue(hasZPtr, "i8");\n        const x = hasX ? this.pdfiumModule.pdfium.getValue(xPtr, "float") : 0;\n        const y = hasY ? this.pdfiumModule.pdfium.getValue(yPtr, "float") : 0;\n        const zoom = hasZ ? this.pdfiumModule.pdfium.getValue(zPtr, "float") : 0;\n        this.memoryManager.free(hasXPtr);\n        this.memoryManager.free(hasYPtr);\n        this.memoryManager.free(hasZPtr);\n        this.memoryManager.free(xPtr);\n        this.memoryManager.free(yPtr);\n        this.memoryManager.free(zPtr);\n        return {\n          pageIndex,\n          zoom: {\n            mode: zoomMode,\n            params: {\n              x,\n              y,\n              zoom\n            }\n          },\n          view\n        };\n      }\n      this.memoryManager.free(hasXPtr);\n      this.memoryManager.free(hasYPtr);\n      this.memoryManager.free(hasZPtr);\n      this.memoryManager.free(xPtr);\n      this.memoryManager.free(yPtr);\n      this.memoryManager.free(zPtr);\n      return {\n        pageIndex,\n        zoom: {\n          mode: zoomMode,\n          params: {\n            x: 0,\n            y: 0,\n            zoom: 0\n          }\n        },\n        view\n      };\n    }\n    return {\n      pageIndex,\n      zoom: {\n        mode: zoomMode\n      },\n      view\n    };\n  }\n  /**\n   * Read attachmet from pdf document\n   * @param docPtr - pointer to pdf document object\n   * @param index - index of attachment\n   * @returns attachment content\n   *\n   * @private\n   */\n  readPdfAttachment(docPtr, index) {\n    const attachmentPtr = this.pdfiumModule.FPDFDoc_GetAttachment(docPtr, index);\n    const name = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAttachment_GetName(attachmentPtr, buffer, bufferLength);\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const description = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.EPDFAttachment_GetDescription(attachmentPtr, buffer, bufferLength);\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const mimeType = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAttachment_GetSubtype(attachmentPtr, buffer, bufferLength);\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const creationDate = this.getAttachmentDate(attachmentPtr, "CreationDate");\n    const checksum = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAttachment_GetStringValue(\n          attachmentPtr,\n          "Checksum",\n          buffer,\n          bufferLength\n        );\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const size = this.getAttachmentNumber(attachmentPtr, "Size");\n    return {\n      index,\n      name,\n      description,\n      mimeType,\n      size,\n      creationDate,\n      checksum\n    };\n  }\n  /**\n   * Convert coordinate of point from device coordinate to page coordinate\n   * @param page  - pdf page infor\n   * @param position - position of point\n   * @returns converted position\n   *\n   * @private\n   */\n  convertDevicePointToPagePoint(page, position) {\n    const DW = page.size.width;\n    const DH = page.size.height;\n    const r = page.rotation & 3;\n    if (r === 0) {\n      return { x: position.x, y: DH - position.y };\n    }\n    if (r === 1) {\n      return { x: position.y, y: position.x };\n    }\n    if (r === 2) {\n      return { x: DW - position.x, y: position.y };\n    }\n    {\n      return { x: DH - position.y, y: DW - position.x };\n    }\n  }\n  /**\n   * Convert coordinate of point from page coordinate to device coordinate\n   * @param page  - pdf page infor\n   * @param position - position of point\n   * @returns converted position\n   *\n   * @private\n   */\n  convertPagePointToDevicePoint(page, position) {\n    const DW = page.size.width;\n    const DH = page.size.height;\n    const r = page.rotation & 3;\n    if (r === 0) {\n      return { x: position.x, y: DH - position.y };\n    }\n    if (r === 1) {\n      return { x: position.y, y: position.x };\n    }\n    if (r === 2) {\n      return { x: DW - position.x, y: position.y };\n    }\n    {\n      return { x: DW - position.y, y: DH - position.x };\n    }\n  }\n  /**\n   * Convert coordinate of rectangle from page coordinate to device coordinate\n   * @param page  - pdf page infor\n   * @param pagePtr - pointer to pdf page object\n   * @param pageRect - rectangle that needs to be converted\n   * @returns converted rectangle\n   *\n   * @private\n   */\n  convertPageRectToDeviceRect(page, pageRect) {\n    const { x, y } = this.convertPagePointToDevicePoint(page, {\n      x: pageRect.left,\n      y: pageRect.top\n    });\n    const rect = {\n      origin: {\n        x,\n        y\n      },\n      size: {\n        width: Math.abs(pageRect.right - pageRect.left),\n        height: Math.abs(pageRect.top - pageRect.bottom)\n      }\n    };\n    return rect;\n  }\n  /**\n   * Read the appearance stream of annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @param mode - appearance mode\n   * @returns appearance stream\n   *\n   * @private\n   */\n  readPageAnnoAppearanceStreams(annotationPtr) {\n    return {\n      normal: this.readPageAnnoAppearanceStream(annotationPtr, AppearanceMode.Normal),\n      rollover: this.readPageAnnoAppearanceStream(annotationPtr, AppearanceMode.Rollover),\n      down: this.readPageAnnoAppearanceStream(annotationPtr, AppearanceMode.Down)\n    };\n  }\n  /**\n   * Read the appearance stream of annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @param mode - appearance mode\n   * @returns appearance stream\n   *\n   * @private\n   */\n  readPageAnnoAppearanceStream(annotationPtr, mode = AppearanceMode.Normal) {\n    const utf16Length = this.pdfiumModule.FPDFAnnot_GetAP(annotationPtr, mode, 0, 0);\n    const bytesCount = (utf16Length + 1) * 2;\n    const bufferPtr = this.memoryManager.malloc(bytesCount);\n    this.pdfiumModule.FPDFAnnot_GetAP(annotationPtr, mode, bufferPtr, bytesCount);\n    const ap = this.pdfiumModule.pdfium.UTF16ToString(bufferPtr);\n    this.memoryManager.free(bufferPtr);\n    return ap;\n  }\n  /**\n   * Set the appearance stream of annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @param mode - appearance mode\n   * @param apContent - appearance stream content (null to remove)\n   * @returns whether the appearance stream was set successfully\n   *\n   * @private\n   */\n  setPageAnnoAppearanceStream(annotationPtr, mode = AppearanceMode.Normal, apContent) {\n    const bytes = 2 * (apContent.length + 1);\n    const ptr = this.memoryManager.malloc(bytes);\n    try {\n      this.pdfiumModule.pdfium.stringToUTF16(apContent, ptr, bytes);\n      const ok = this.pdfiumModule.FPDFAnnot_SetAP(annotationPtr, mode, ptr);\n      return !!ok;\n    } finally {\n      this.memoryManager.free(ptr);\n    }\n  }\n  /**\n   * Set the rect of specified annotation\n   * @param page - page info that the annotation is belonged to\n   * @param annotationPtr - pointer to annotation object\n   * @param rect - target rectangle\n   * @returns whether the rect is setted\n   *\n   * @private\n   */\n  setPageAnnoRect(page, annotPtr, rect) {\n    const x0d = Math.floor(rect.origin.x);\n    const y0d = Math.floor(rect.origin.y);\n    const x1d = Math.floor(rect.origin.x + rect.size.width);\n    const y1d = Math.floor(rect.origin.y + rect.size.height);\n    const TL = this.convertDevicePointToPagePoint(page, { x: x0d, y: y0d });\n    const TR = this.convertDevicePointToPagePoint(page, { x: x1d, y: y0d });\n    const BR = this.convertDevicePointToPagePoint(page, { x: x1d, y: y1d });\n    const BL = this.convertDevicePointToPagePoint(page, { x: x0d, y: y1d });\n    let left = Math.min(TL.x, TR.x, BR.x, BL.x);\n    let right = Math.max(TL.x, TR.x, BR.x, BL.x);\n    let bottom = Math.min(TL.y, TR.y, BR.y, BL.y);\n    let top = Math.max(TL.y, TR.y, BR.y, BL.y);\n    if (left > right) [left, right] = [right, left];\n    if (bottom > top) [bottom, top] = [top, bottom];\n    const ptr = this.memoryManager.malloc(16);\n    const pdf = this.pdfiumModule.pdfium;\n    pdf.setValue(ptr + 0, left, "float");\n    pdf.setValue(ptr + 4, top, "float");\n    pdf.setValue(ptr + 8, right, "float");\n    pdf.setValue(ptr + 12, bottom, "float");\n    const ok = this.pdfiumModule.FPDFAnnot_SetRect(annotPtr, ptr);\n    this.memoryManager.free(ptr);\n    return !!ok;\n  }\n  /**\n   * Read the rectangle of annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns rectangle of annotation\n   *\n   * @private\n   */\n  readPageAnnoRect(annotationPtr) {\n    const pageRectPtr = this.memoryManager.malloc(4 * 4);\n    const pageRect = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    if (this.pdfiumModule.FPDFAnnot_GetRect(annotationPtr, pageRectPtr)) {\n      pageRect.left = this.pdfiumModule.pdfium.getValue(pageRectPtr, "float");\n      pageRect.top = this.pdfiumModule.pdfium.getValue(pageRectPtr + 4, "float");\n      pageRect.right = this.pdfiumModule.pdfium.getValue(pageRectPtr + 8, "float");\n      pageRect.bottom = this.pdfiumModule.pdfium.getValue(pageRectPtr + 12, "float");\n    }\n    this.memoryManager.free(pageRectPtr);\n    return pageRect;\n  }\n  /**\n   * Get highlight rects for a specific character range (for search highlighting)\n   * @param page - pdf page info\n   * @param pagePtr - pointer to pdf page\n   * @param textPagePtr - pointer to pdf text page\n   * @param startIndex - starting character index\n   * @param charCount - number of characters in the range\n   * @returns array of rectangles for highlighting the specified character range\n   *\n   * @private\n   */\n  getHighlightRects(page, textPagePtr, startIndex, charCount) {\n    const rectsCount = this.pdfiumModule.FPDFText_CountRects(textPagePtr, startIndex, charCount);\n    const highlightRects = [];\n    const l = this.memoryManager.malloc(8);\n    const t = this.memoryManager.malloc(8);\n    const r = this.memoryManager.malloc(8);\n    const b = this.memoryManager.malloc(8);\n    for (let i = 0; i < rectsCount; i++) {\n      const ok = this.pdfiumModule.FPDFText_GetRect(textPagePtr, i, l, t, r, b);\n      if (!ok) continue;\n      const left = this.pdfiumModule.pdfium.getValue(l, "double");\n      const top = this.pdfiumModule.pdfium.getValue(t, "double");\n      const right = this.pdfiumModule.pdfium.getValue(r, "double");\n      const bottom = this.pdfiumModule.pdfium.getValue(b, "double");\n      const p1 = this.convertPagePointToDevicePoint(page, { x: left, y: top });\n      const p2 = this.convertPagePointToDevicePoint(page, { x: right, y: top });\n      const p3 = this.convertPagePointToDevicePoint(page, { x: right, y: bottom });\n      const p4 = this.convertPagePointToDevicePoint(page, { x: left, y: bottom });\n      const xs = [p1.x, p2.x, p3.x, p4.x];\n      const ys = [p1.y, p2.y, p3.y, p4.y];\n      const x = Math.min(...xs);\n      const y = Math.min(...ys);\n      const width = Math.max(...xs) - x;\n      const height = Math.max(...ys) - y;\n      highlightRects.push({\n        origin: { x, y },\n        size: { width: Math.ceil(width), height: Math.ceil(height) }\n      });\n    }\n    this.memoryManager.free(l);\n    this.memoryManager.free(t);\n    this.memoryManager.free(r);\n    this.memoryManager.free(b);\n    return highlightRects;\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.searchAllPages}\n   *\n   * Runs inside the worker.\n   * Emits per-page progress: { page, results }\n   *\n   * @public\n   */\n  searchInPage(doc, page, keyword, flags) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "searchInPage", doc, page, keyword, flags);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `SearchInPage`, "Begin", `${doc.id}-${page.index}`);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `PreparePrintDocument`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "Document is not open"\n      });\n    }\n    const length = 2 * (keyword.length + 1);\n    const keywordPtr = this.memoryManager.malloc(length);\n    this.pdfiumModule.pdfium.stringToUTF16(keyword, keywordPtr, length);\n    try {\n      const results = this.searchAllInPage(ctx, page, keywordPtr, flags);\n      return PdfTaskHelper.resolve(results);\n    } finally {\n      this.memoryManager.free(keywordPtr);\n    }\n  }\n  /**\n   * Get annotations for multiple pages in a single batch.\n   * Emits progress per page for streaming updates.\n   *\n   * @param doc - PDF document\n   * @param pages - Array of pages to process\n   * @returns Task with results keyed by page index, with per-page progress\n   *\n   * @public\n   */\n  getAnnotationsBatch(doc, pages) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "getAnnotationsBatch", doc.id, pages.length);\n    const task = new Task();\n    queueMicrotask(() => {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "GetAnnotationsBatch", "Begin", doc.id);\n      const ctx = this.cache.getContext(doc.id);\n      if (!ctx) {\n        task.reject({ code: PdfErrorCode.DocNotOpen, message: "Document is not open" });\n        return;\n      }\n      const results = {};\n      const total = pages.length;\n      for (let i = 0; i < pages.length; i++) {\n        const page = pages[i];\n        const annotations = this.readPageAnnotationsRaw(ctx, page);\n        results[page.index] = annotations;\n        task.progress({\n          pageIndex: page.index,\n          result: annotations,\n          completed: i + 1,\n          total\n        });\n      }\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "GetAnnotationsBatch", "End", doc.id);\n      task.resolve(results);\n    });\n    return task;\n  }\n  /**\n   * Search across multiple pages in a single batch.\n   * Emits progress per page for streaming updates.\n   *\n   * @param doc - PDF document\n   * @param pages - Array of pages to search\n   * @param keyword - Search keyword\n   * @param flags - Search flags\n   * @returns Task with results keyed by page index, with per-page progress\n   *\n   * @public\n   */\n  searchBatch(doc, pages, keyword, flags) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "searchBatch", doc.id, pages.length, keyword);\n    const task = new Task();\n    queueMicrotask(() => {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "SearchBatch", "Begin", doc.id);\n      const ctx = this.cache.getContext(doc.id);\n      if (!ctx) {\n        task.reject({ code: PdfErrorCode.DocNotOpen, message: "Document is not open" });\n        return;\n      }\n      const length = 2 * (keyword.length + 1);\n      const keywordPtr = this.memoryManager.malloc(length);\n      this.pdfiumModule.pdfium.stringToUTF16(keyword, keywordPtr, length);\n      try {\n        const results = {};\n        const total = pages.length;\n        for (let i = 0; i < pages.length; i++) {\n          const page = pages[i];\n          const pageResults = this.searchAllInPage(ctx, page, keywordPtr, flags);\n          results[page.index] = pageResults;\n          task.progress({\n            pageIndex: page.index,\n            result: pageResults,\n            completed: i + 1,\n            total\n          });\n        }\n        this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, "SearchBatch", "End", doc.id);\n        task.resolve(results);\n      } finally {\n        this.memoryManager.free(keywordPtr);\n      }\n    });\n    return task;\n  }\n  /**\n   * Extract word-aligned context for a search hit.\n   *\n   * @param fullText      full UTF-16 page text (fetch this once per page!)\n   * @param start         index of 1st char that matched\n   * @param count         number of chars in the match\n   * @param windowChars   minimum context chars to keep left & right\n   */\n  buildContext(fullText, start, count, windowChars = 30) {\n    const WORD_BREAK = /[\\s\\u00A0.,;:!?()\\[\\]{}<>/\\\\\\-"\'`"\u201D\\u2013\\u2014]/;\n    const findWordStart = (index) => {\n      while (index > 0 && !WORD_BREAK.test(fullText[index - 1])) index--;\n      return index;\n    };\n    const findWordEnd = (index) => {\n      while (index < fullText.length && !WORD_BREAK.test(fullText[index])) index++;\n      return index;\n    };\n    let left = start;\n    while (left > 0 && WORD_BREAK.test(fullText[left - 1])) left--;\n    let collected = 0;\n    while (left > 0 && collected < windowChars) {\n      left--;\n      if (!WORD_BREAK.test(fullText[left])) collected++;\n    }\n    left = findWordStart(left);\n    let right = start + count;\n    while (right < fullText.length && WORD_BREAK.test(fullText[right])) right++;\n    collected = 0;\n    while (right < fullText.length && collected < windowChars) {\n      if (!WORD_BREAK.test(fullText[right])) collected++;\n      right++;\n    }\n    right = findWordEnd(right);\n    const before = fullText.slice(left, start).replace(/\\s+/g, " ").trimStart();\n    const match = fullText.slice(start, start + count);\n    const after = fullText.slice(start + count, right).replace(/\\s+/g, " ").trimEnd();\n    return {\n      before: this.tidy(before),\n      match: this.tidy(match),\n      after: this.tidy(after),\n      truncatedLeft: left > 0,\n      truncatedRight: right < fullText.length\n    };\n  }\n  /**\n   * Tidy the text to remove any non-printable characters and whitespace\n   * @param s - text to tidy\n   * @returns tidied text\n   *\n   * @private\n   */\n  tidy(s) {\n    return s.replace(/-\\uFFFE\\s*/g, "").replace(/[\\uFFFE\\u00AD\\u200B\\u2060\\uFEFF]/g, "").replace(/\\s+/g, " ");\n  }\n  /**\n   * Search for all occurrences of a keyword on a single page\n   * This method efficiently loads the page only once and finds all matches\n   *\n   * @param docPtr - pointer to pdf document\n   * @param page - pdf page object\n   * @param pageIndex - index of the page\n   * @param keywordPtr - pointer to the search keyword\n   * @param flag - search flags\n   * @returns array of search results on this page\n   *\n   * @private\n   */\n  searchAllInPage(ctx, page, keywordPtr, flag) {\n    return ctx.borrowPage(page.index, (pageCtx) => {\n      const textPagePtr = pageCtx.getTextPage();\n      const total = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n      const bufPtr = this.memoryManager.malloc(2 * (total + 1));\n      this.pdfiumModule.FPDFText_GetText(textPagePtr, 0, total, bufPtr);\n      const fullText = this.pdfiumModule.pdfium.UTF16ToString(bufPtr);\n      this.memoryManager.free(bufPtr);\n      const pageResults = [];\n      const searchHandle = this.pdfiumModule.FPDFText_FindStart(\n        textPagePtr,\n        keywordPtr,\n        flag,\n        0\n        // Start from the beginning of the page\n      );\n      while (this.pdfiumModule.FPDFText_FindNext(searchHandle)) {\n        const charIndex = this.pdfiumModule.FPDFText_GetSchResultIndex(searchHandle);\n        const charCount = this.pdfiumModule.FPDFText_GetSchCount(searchHandle);\n        const rects = this.getHighlightRects(page, textPagePtr, charIndex, charCount);\n        const context = this.buildContext(fullText, charIndex, charCount);\n        pageResults.push({\n          pageIndex: page.index,\n          charIndex,\n          charCount,\n          rects,\n          context\n        });\n      }\n      this.pdfiumModule.FPDFText_FindClose(searchHandle);\n      return pageResults;\n    });\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.preparePrintDocument}\n   *\n   * Prepares a PDF document for printing with specified options.\n   * Creates a new document with selected pages and optionally removes annotations\n   * for optimal printing performance.\n   *\n   * @public\n   */\n  preparePrintDocument(doc, options) {\n    const { includeAnnotations = true, pageRange = null } = options ?? {};\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "preparePrintDocument", doc, options);\n    this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `PreparePrintDocument`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `PreparePrintDocument`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "Document is not open"\n      });\n    }\n    const printDocPtr = this.pdfiumModule.FPDF_CreateNewDocument();\n    if (!printDocPtr) {\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `PreparePrintDocument`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantCreateNewDoc,\n        message: "Cannot create print document"\n      });\n    }\n    try {\n      const sanitizedPageRange = this.sanitizePageRange(pageRange, doc.pageCount);\n      if (!this.pdfiumModule.FPDF_ImportPages(\n        printDocPtr,\n        ctx.docPtr,\n        sanitizedPageRange ?? "",\n        0\n        // Insert at beginning\n      )) {\n        this.pdfiumModule.FPDF_CloseDocument(printDocPtr);\n        this.logger.error(LOG_SOURCE$1, LOG_CATEGORY$1, "Failed to import pages for printing");\n        this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `PreparePrintDocument`, "End", doc.id);\n        return PdfTaskHelper.reject({\n          code: PdfErrorCode.CantImportPages,\n          message: "Failed to import pages for printing"\n        });\n      }\n      if (!includeAnnotations) {\n        const removalResult = this.removeAnnotationsFromPrintDocument(printDocPtr);\n        if (!removalResult.success) {\n          this.pdfiumModule.FPDF_CloseDocument(printDocPtr);\n          this.logger.error(\n            LOG_SOURCE$1,\n            LOG_CATEGORY$1,\n            `Failed to remove annotations: ${removalResult.error}`\n          );\n          this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `PreparePrintDocument`, "End", doc.id);\n          return PdfTaskHelper.reject({\n            code: PdfErrorCode.Unknown,\n            message: `Failed to prepare print document: ${removalResult.error}`\n          });\n        }\n        this.logger.debug(\n          LOG_SOURCE$1,\n          LOG_CATEGORY$1,\n          `Removed ${removalResult.annotationsRemoved} annotations from ${removalResult.pagesProcessed} pages`\n        );\n      }\n      const buffer = this.saveDocument(printDocPtr);\n      this.pdfiumModule.FPDF_CloseDocument(printDocPtr);\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `PreparePrintDocument`, "End", doc.id);\n      return PdfTaskHelper.resolve(buffer);\n    } catch (error) {\n      if (printDocPtr) {\n        this.pdfiumModule.FPDF_CloseDocument(printDocPtr);\n      }\n      this.logger.error(LOG_SOURCE$1, LOG_CATEGORY$1, "preparePrintDocument failed", error);\n      this.logger.perf(LOG_SOURCE$1, LOG_CATEGORY$1, `PreparePrintDocument`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.Unknown,\n        message: error instanceof Error ? error.message : "Failed to prepare print document"\n      });\n    }\n  }\n  /**\n   * Removes all annotations from a print document using fast raw annotation functions.\n   * This method is optimized for performance by avoiding full page loading.\n   *\n   * @param printDocPtr - Pointer to the print document\n   * @returns Result object with success status and statistics\n   *\n   * @private\n   */\n  removeAnnotationsFromPrintDocument(printDocPtr) {\n    let totalAnnotationsRemoved = 0;\n    let pagesProcessed = 0;\n    try {\n      const pageCount = this.pdfiumModule.FPDF_GetPageCount(printDocPtr);\n      for (let pageIndex = 0; pageIndex < pageCount; pageIndex++) {\n        const annotCount = this.pdfiumModule.EPDFPage_GetAnnotCountRaw(printDocPtr, pageIndex);\n        if (annotCount <= 0) {\n          pagesProcessed++;\n          continue;\n        }\n        let annotationsRemovedFromPage = 0;\n        for (let annotIndex = annotCount - 1; annotIndex >= 0; annotIndex--) {\n          const removed = this.pdfiumModule.EPDFPage_RemoveAnnotRaw(\n            printDocPtr,\n            pageIndex,\n            annotIndex\n          );\n          if (removed) {\n            annotationsRemovedFromPage++;\n            totalAnnotationsRemoved++;\n          } else {\n            this.logger.warn(\n              LOG_SOURCE$1,\n              LOG_CATEGORY$1,\n              `Failed to remove annotation ${annotIndex} from page ${pageIndex}`\n            );\n          }\n        }\n        if (annotationsRemovedFromPage > 0) {\n          const pagePtr = this.pdfiumModule.FPDF_LoadPage(printDocPtr, pageIndex);\n          if (pagePtr) {\n            this.pdfiumModule.FPDFPage_GenerateContent(pagePtr);\n            this.pdfiumModule.FPDF_ClosePage(pagePtr);\n          }\n        }\n        pagesProcessed++;\n      }\n      return {\n        success: true,\n        annotationsRemoved: totalAnnotationsRemoved,\n        pagesProcessed\n      };\n    } catch (error) {\n      return {\n        success: false,\n        annotationsRemoved: totalAnnotationsRemoved,\n        pagesProcessed,\n        error: error instanceof Error ? error.message : "Unknown error during annotation removal"\n      };\n    }\n  }\n  /**\n   * Sanitizes and validates a page range string.\n   * Ensures page numbers are within valid bounds and properly formatted.\n   *\n   * @param pageRange - Page range string (e.g., "1,3,5-7") or null for all pages\n   * @param totalPages - Total number of pages in the document\n   * @returns Sanitized page range string or null for all pages\n   *\n   * @private\n   */\n  sanitizePageRange(pageRange, totalPages) {\n    if (!pageRange || pageRange.trim() === "") {\n      return null;\n    }\n    try {\n      const sanitized = [];\n      const parts = pageRange.split(",");\n      for (const part of parts) {\n        const trimmed = part.trim();\n        if (trimmed.includes("-")) {\n          const [startStr, endStr] = trimmed.split("-").map((s) => s.trim());\n          const start = parseInt(startStr, 10);\n          const end = parseInt(endStr, 10);\n          if (isNaN(start) || isNaN(end)) {\n            this.logger.warn(LOG_SOURCE$1, LOG_CATEGORY$1, `Invalid range: ${trimmed}`);\n            continue;\n          }\n          const validStart = Math.max(1, Math.min(start, totalPages));\n          const validEnd = Math.max(1, Math.min(end, totalPages));\n          for (let i = validStart; i <= validEnd; i++) {\n            if (!sanitized.includes(i)) {\n              sanitized.push(i);\n            }\n          }\n        } else {\n          const pageNum = parseInt(trimmed, 10);\n          if (isNaN(pageNum)) {\n            this.logger.warn(LOG_SOURCE$1, LOG_CATEGORY$1, `Invalid page number: ${trimmed}`);\n            continue;\n          }\n          const validPageNum = Math.max(1, Math.min(pageNum, totalPages));\n          if (!sanitized.includes(validPageNum)) {\n            sanitized.push(validPageNum);\n          }\n        }\n      }\n      if (sanitized.length === 0) {\n        this.logger.warn(LOG_SOURCE$1, LOG_CATEGORY$1, "No valid pages in range, using all pages");\n        return null;\n      }\n      sanitized.sort((a, b) => a - b);\n      const optimized = [];\n      let rangeStart = sanitized[0];\n      let rangeEnd = sanitized[0];\n      for (let i = 1; i < sanitized.length; i++) {\n        if (sanitized[i] === rangeEnd + 1) {\n          rangeEnd = sanitized[i];\n        } else {\n          if (rangeStart === rangeEnd) {\n            optimized.push(rangeStart.toString());\n          } else if (rangeEnd - rangeStart === 1) {\n            optimized.push(rangeStart.toString());\n            optimized.push(rangeEnd.toString());\n          } else {\n            optimized.push(`${rangeStart}-${rangeEnd}`);\n          }\n          rangeStart = sanitized[i];\n          rangeEnd = sanitized[i];\n        }\n      }\n      if (rangeStart === rangeEnd) {\n        optimized.push(rangeStart.toString());\n      } else if (rangeEnd - rangeStart === 1) {\n        optimized.push(rangeStart.toString());\n        optimized.push(rangeEnd.toString());\n      } else {\n        optimized.push(`${rangeStart}-${rangeEnd}`);\n      }\n      const result = optimized.join(",");\n      this.logger.debug(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        `Sanitized page range: "${pageRange}" -> "${result}"`\n      );\n      return result;\n    } catch (error) {\n      this.logger.error(LOG_SOURCE$1, LOG_CATEGORY$1, `Error sanitizing page range: ${error}`);\n      return null;\n    }\n  }\n}\nconst LOG_SOURCE = "PdfiumNativeRunner";\nconst LOG_CATEGORY = "Worker";\nclass PdfiumNativeRunner {\n  constructor(logger) {\n    this.native = null;\n    this.activeTasks = /* @__PURE__ */ new Map();\n    this.logger = logger ?? new NoopLogger();\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "PdfiumNativeRunner created");\n  }\n  /**\n   * Initialize PDFium with WASM binary\n   */\n  async prepare(wasmBinary, logger) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "Preparing PDFium...");\n    try {\n      const module = await init({ wasmBinary });\n      this.native = new PdfiumNative(module, { logger: logger ?? this.logger });\n      this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "PDFium initialized successfully");\n    } catch (error) {\n      this.logger.error(LOG_SOURCE, LOG_CATEGORY, "Failed to initialize PDFium:", error);\n      throw error;\n    }\n  }\n  /**\n   * Start listening for messages\n   */\n  listen() {\n    self.onmessage = (evt) => {\n      this.handle(evt);\n    };\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "Listening for messages");\n  }\n  /**\n   * Handle incoming messages\n   */\n  handle(evt) {\n    const request = evt.data;\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "Received message:", request.type);\n    try {\n      switch (request.type) {\n        case "init":\n          this.handleInit(request);\n          break;\n        case "execute":\n          this.handleExecute(request);\n          break;\n        default:\n          this.logger.warn(LOG_SOURCE, LOG_CATEGORY, "Unknown message type:", request.type);\n      }\n    } catch (error) {\n      this.logger.error(LOG_SOURCE, LOG_CATEGORY, "Error handling message:", error);\n      this.respond({\n        id: request.id,\n        type: "error",\n        error: {\n          type: "reject",\n          reason: { code: PdfErrorCode.Unknown, message: String(error) }\n        }\n      });\n    }\n  }\n  /**\n   * Handle initialization request\n   */\n  async handleInit(request) {\n    if (!request.wasmUrl) {\n      this.respond({\n        id: request.id,\n        type: "error",\n        error: {\n          type: "reject",\n          reason: { code: PdfErrorCode.Unknown, message: "Missing wasmUrl" }\n        }\n      });\n      return;\n    }\n    try {\n      const response = await fetch(request.wasmUrl);\n      const wasmBinary = await response.arrayBuffer();\n      await this.prepare(wasmBinary);\n      this.respond({\n        id: request.id,\n        type: "ready"\n      });\n    } catch (error) {\n      this.respond({\n        id: request.id,\n        type: "error",\n        error: {\n          type: "reject",\n          reason: { code: PdfErrorCode.Unknown, message: String(error) }\n        }\n      });\n    }\n  }\n  /**\n   * Handle method execution request\n   */\n  async handleExecute(request) {\n    if (!this.native) {\n      this.respond({\n        id: request.id,\n        type: "error",\n        error: {\n          type: "reject",\n          reason: { code: PdfErrorCode.NotReady, message: "PDFium not initialized" }\n        }\n      });\n      return;\n    }\n    if (!request.method) {\n      this.respond({\n        id: request.id,\n        type: "error",\n        error: {\n          type: "reject",\n          reason: { code: PdfErrorCode.Unknown, message: "Missing method name" }\n        }\n      });\n      return;\n    }\n    const method = request.method;\n    const args = request.args ?? [];\n    if (!(method in this.native) || typeof this.native[method] !== "function") {\n      this.respond({\n        id: request.id,\n        type: "error",\n        error: {\n          type: "reject",\n          reason: { code: PdfErrorCode.NotSupport, message: `Method ${method} not supported` }\n        }\n      });\n      return;\n    }\n    try {\n      this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Executing method: ${method}`);\n      const result = this.native[method](...args);\n      if (result && typeof result === "object" && "wait" in result) {\n        const task = result;\n        this.activeTasks.set(request.id, task);\n        task.onProgress((progress) => {\n          this.respond({\n            id: request.id,\n            type: "progress",\n            progress\n          });\n        });\n        task.wait(\n          (data) => {\n            this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Method ${method} resolved`);\n            this.respond({\n              id: request.id,\n              type: "result",\n              data\n            });\n            this.activeTasks.delete(request.id);\n          },\n          (error) => {\n            this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Method ${method} failed:`, error);\n            this.respond({\n              id: request.id,\n              type: "error",\n              error\n            });\n            this.activeTasks.delete(request.id);\n          }\n        );\n      } else {\n        this.respond({\n          id: request.id,\n          type: "result",\n          data: result\n        });\n      }\n    } catch (error) {\n      this.logger.error(LOG_SOURCE, LOG_CATEGORY, `Error executing ${method}:`, error);\n      this.respond({\n        id: request.id,\n        type: "error",\n        error: {\n          type: "reject",\n          reason: { code: PdfErrorCode.Unknown, message: String(error) }\n        }\n      });\n    }\n  }\n  /**\n   * Send response back to main thread\n   */\n  respond(response) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "Sending response:", response.type);\n    self.postMessage(response);\n  }\n  /**\n   * Ready notification\n   */\n  ready() {\n    this.listen();\n    this.respond({\n      id: "0",\n      type: "ready"\n    });\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "Runner is ready");\n  }\n}\nclass PdfiumEngineRunner extends PdfiumNativeRunner {\n  /**\n   * Create an instance of PdfiumEngineRunner\n   * @param wasmBinary - wasm binary that contains the pdfium wasm file\n   * @param logger - optional logger instance\n   * @param fontFallback - optional font fallback configuration\n   */\n  constructor(wasmBinary, logger, fontFallback) {\n    super(logger);\n    this.wasmBinary = wasmBinary;\n    this.fontFallback = fontFallback;\n  }\n  /**\n   * Initialize runner\n   */\n  async prepare() {\n    const wasmBinary = this.wasmBinary;\n    const wasmModule = await init({ wasmBinary });\n    this.native = new PdfiumNative(wasmModule, {\n      logger: this.logger,\n      fontFallback: this.fontFallback\n    });\n    this.ready();\n  }\n}\nconst fonts$6 = [\n  { file: "NotoSansJP-Thin.otf", weight: 100 },\n  { file: "NotoSansJP-Light.otf", weight: 300 },\n  { file: "NotoSansJP-DemiLight.otf", weight: 350 },\n  { file: "NotoSansJP-Regular.otf", weight: 400 },\n  { file: "NotoSansJP-Medium.otf", weight: 500 },\n  { file: "NotoSansJP-Bold.otf", weight: 700 },\n  { file: "NotoSansJP-Black.otf", weight: 900 }\n];\nconst fonts$5 = [\n  { file: "NotoSansKR-Thin.otf", weight: 100 },\n  { file: "NotoSansKR-Light.otf", weight: 300 },\n  { file: "NotoSansKR-DemiLight.otf", weight: 350 },\n  { file: "NotoSansKR-Regular.otf", weight: 400 },\n  { file: "NotoSansKR-Medium.otf", weight: 500 },\n  { file: "NotoSansKR-Bold.otf", weight: 700 },\n  { file: "NotoSansKR-Black.otf", weight: 900 }\n];\nconst fonts$4 = [\n  { file: "NotoSansHans-Light.otf", weight: 300 },\n  { file: "NotoSansHans-DemiLight.otf", weight: 350 },\n  { file: "NotoSansHans-Regular.otf", weight: 400 },\n  { file: "NotoSansHans-Medium.otf", weight: 500 },\n  { file: "NotoSansHans-Bold.otf", weight: 700 }\n];\nconst fonts$3 = [\n  { file: "NotoSansHant-Thin.otf", weight: 100 },\n  { file: "NotoSansHant-Light.otf", weight: 300 },\n  { file: "NotoSansHant-DemiLight.otf", weight: 350 },\n  { file: "NotoSansHant-Regular.otf", weight: 400 },\n  { file: "NotoSansHant-Medium.otf", weight: 500 },\n  { file: "NotoSansHant-Bold.otf", weight: 700 },\n  { file: "NotoSansHant-Black.otf", weight: 900 }\n];\nconst fonts$2 = [\n  { file: "NotoNaskhArabic-Regular.ttf", weight: 400 },\n  { file: "NotoNaskhArabic-Bold.ttf", weight: 700 }\n];\nconst fonts$1 = [\n  { file: "NotoSansHebrew-Regular.ttf", weight: 400 },\n  { file: "NotoSansHebrew-Bold.ttf", weight: 700 }\n];\nconst fonts = [\n  // Thin (100)\n  { file: "NotoSans-Thin.ttf", weight: 100 },\n  { file: "NotoSans-ThinItalic.ttf", weight: 100, italic: true },\n  // ExtraLight (200)\n  { file: "NotoSans-ExtraLight.ttf", weight: 200 },\n  { file: "NotoSans-ExtraLightItalic.ttf", weight: 200, italic: true },\n  // Light (300)\n  { file: "NotoSans-Light.ttf", weight: 300 },\n  { file: "NotoSans-LightItalic.ttf", weight: 300, italic: true },\n  // Regular (400)\n  { file: "NotoSans-Regular.ttf", weight: 400 },\n  { file: "NotoSans-Italic.ttf", weight: 400, italic: true },\n  // Medium (500)\n  { file: "NotoSans-Medium.ttf", weight: 500 },\n  { file: "NotoSans-MediumItalic.ttf", weight: 500, italic: true },\n  // SemiBold (600)\n  { file: "NotoSans-SemiBold.ttf", weight: 600 },\n  { file: "NotoSans-SemiBoldItalic.ttf", weight: 600, italic: true },\n  // Bold (700)\n  { file: "NotoSans-Bold.ttf", weight: 700 },\n  { file: "NotoSans-BoldItalic.ttf", weight: 700, italic: true },\n  // ExtraBold (800)\n  { file: "NotoSans-ExtraBold.ttf", weight: 800 },\n  { file: "NotoSans-ExtraBoldItalic.ttf", weight: 800, italic: true },\n  // Black (900)\n  { file: "NotoSans-Black.ttf", weight: 900 },\n  { file: "NotoSans-BlackItalic.ttf", weight: 900, italic: true }\n];\nfunction buildCdnUrls(version = "latest") {\n  return {\n    jp: `https://cdn.jsdelivr.net/npm/@embedpdf/fonts-jp@${version}/fonts`,\n    kr: `https://cdn.jsdelivr.net/npm/@embedpdf/fonts-kr@${version}/fonts`,\n    sc: `https://cdn.jsdelivr.net/npm/@embedpdf/fonts-sc@${version}/fonts`,\n    tc: `https://cdn.jsdelivr.net/npm/@embedpdf/fonts-tc@${version}/fonts`,\n    arabic: `https://cdn.jsdelivr.net/npm/@embedpdf/fonts-arabic@${version}/fonts`,\n    hebrew: `https://cdn.jsdelivr.net/npm/@embedpdf/fonts-hebrew@${version}/fonts`,\n    latin: `https://cdn.jsdelivr.net/npm/@embedpdf/fonts-latin@${version}/fonts`\n  };\n}\nfunction toFontVariants(fonts2, baseUrl) {\n  return fonts2.map((f) => ({\n    url: `${baseUrl}/${f.file}`,\n    weight: f.weight,\n    italic: f.italic\n  }));\n}\nfunction buildCdnFontConfig(urls) {\n  return {\n    fonts: {\n      [FontCharset.SHIFTJIS]: toFontVariants(fonts$6, urls.jp),\n      [FontCharset.HANGEUL]: toFontVariants(fonts$5, urls.kr),\n      [FontCharset.GB2312]: toFontVariants(fonts$4, urls.sc),\n      [FontCharset.CHINESEBIG5]: toFontVariants(fonts$3, urls.tc),\n      [FontCharset.ARABIC]: toFontVariants(fonts$2, urls.arabic),\n      [FontCharset.HEBREW]: toFontVariants(fonts$1, urls.hebrew),\n      [FontCharset.CYRILLIC]: toFontVariants(fonts, urls.latin),\n      [FontCharset.GREEK]: toFontVariants(fonts, urls.latin),\n      [FontCharset.VIETNAMESE]: toFontVariants(fonts, urls.latin)\n    }\n  };\n}\nconst FONT_CDN_URLS = buildCdnUrls("latest");\nconst cdnFontConfig = buildCdnFontConfig(FONT_CDN_URLS);\nlet runner = null;\nself.onmessage = async (event) => {\n  const { type, wasmUrl, logger: serializedLogger, fontFallback } = event.data;\n  if (type === "wasmInit" && wasmUrl && !runner) {\n    try {\n      const response = await fetch(wasmUrl);\n      const wasmBinary = await response.arrayBuffer();\n      const logger = serializedLogger ? deserializeLogger(serializedLogger) : void 0;\n      const effectiveFontFallback = fontFallback === null ? void 0 : fontFallback ?? cdnFontConfig;\n      runner = new PdfiumEngineRunner(wasmBinary, logger, effectiveFontFallback);\n      await runner.prepare();\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      self.postMessage({ type: "wasmError", error: message });\n    }\n  }\n};\n'], { type: "application/javascript" })), { type: "module" }), u4 = new l2(d4, { wasmUrl: t2, logger: a3, fontFallback: s4 }), c4 = URL.createObjectURL(new Blob(['async function encodeImage(imageData, imageType, quality) {\n  if (typeof OffscreenCanvas === "undefined") {\n    throw new Error("OffscreenCanvas is not available in this worker environment");\n  }\n  const { data, width, height } = imageData;\n  const imgData = new ImageData(new Uint8ClampedArray(data), width, height);\n  const canvas = new OffscreenCanvas(width, height);\n  const ctx = canvas.getContext("2d");\n  if (!ctx) {\n    throw new Error("Failed to get 2D context from OffscreenCanvas");\n  }\n  ctx.putImageData(imgData, 0, 0);\n  return canvas.convertToBlob({ type: imageType, quality });\n}\nself.onmessage = async (event) => {\n  const request = event.data;\n  if (request.type !== "encode") {\n    return;\n  }\n  try {\n    const { imageData, imageType, quality } = request.data;\n    const blob = await encodeImage(imageData, imageType, quality);\n    const response = {\n      id: request.id,\n      type: "result",\n      data: blob\n    };\n    self.postMessage(response);\n  } catch (error) {\n    const response = {\n      id: request.id,\n      type: "error",\n      data: {\n        message: error instanceof Error ? error.message : String(error)\n      }\n    };\n    self.postMessage(response);\n  }\n};\n'], { type: "application/javascript" })), m3 = new p2(i3 ?? 2, c4, a3);
    return new h(u4, { imageConverter: p(m3), logger: a3 });
  }
  var i, s2, d2, l2, u2, c2, p2;
  var init_worker_engine_BwJuk6Jt = __esm({
    "node_modules/@embedpdf/snippet/dist/worker-engine-BwJuk6Jt.js"() {
      init_browser_awZxztMA_K_rXQQYD();
      init_embedpdf_Ob4AJbqq();
      i = "RemoteExecutor";
      s2 = "Worker";
      d2 = class n {
        constructor(e3, d4) {
          this.worker = e3, this.pendingRequests = /* @__PURE__ */ new Map(), this.requestCounter = 0, this.handleMessage = (n3) => {
            const e4 = n3.data;
            if ("ready" === e4.type) return this.logger.debug(i, s2, "Worker is ready"), void this.readyTask.resolve(true);
            const r2 = this.pendingRequests.get(e4.id);
            if (r2) switch (e4.type) {
              case "result":
                this.logger.debug(i, s2, `Received result for ${e4.id}`), r2.resolve(e4.data), this.pendingRequests.delete(e4.id);
                break;
              case "error":
                this.logger.debug(i, s2, `Received error for ${e4.id}:`, e4.error), e4.error ? r2.fail(e4.error) : r2.reject({ code: Ht.Unknown, message: "Unknown error" }), this.pendingRequests.delete(e4.id);
                break;
              case "progress":
                this.logger.debug(i, s2, `Received progress for ${e4.id}`), r2.progress(e4.progress);
            }
            else this.logger.warn(i, s2, `Received response for unknown request: ${e4.id}`);
          }, this.logger = d4.logger ?? new at(), this.worker.addEventListener("message", this.handleMessage), this.readyTask = new gt(), this.pendingRequests.set(n.READY_TASK_ID, this.readyTask), this.worker.postMessage({ id: n.READY_TASK_ID, type: "wasmInit", wasmUrl: d4.wasmUrl, logger: d4.logger ? pn(d4.logger) : void 0, fontFallback: d4.fontFallback }), this.logger.debug(i, s2, "RemoteExecutor created");
        }
        generateId() {
          return `req-${Date.now()}-${this.requestCounter++}`;
        }
        send(n3, e3) {
          const r2 = this.generateId(), a3 = new gt(), d4 = { id: r2, type: "execute", method: n3, args: e3 };
          return this.readyTask.wait(() => {
            this.pendingRequests.set(r2, a3), this.logger.debug(i, s2, `Sending ${n3} request:`, r2), this.worker.postMessage(d4);
          }, (e4) => {
            this.logger.error(i, s2, `Worker init failed, rejecting ${n3}:`, e4), a3.reject({ code: Ht.Initialization, message: "Worker initialization failed" });
          }), a3;
        }
        destroy() {
          this.worker.removeEventListener("message", this.handleMessage), this.pendingRequests.forEach((e3, t2) => {
            t2 !== n.READY_TASK_ID && (e3.abort("Worker destroyed"), this.logger.debug(i, s2, `Aborted pending request: ${t2}`));
          }), this.pendingRequests.clear(), this.worker.terminate(), this.logger.debug(i, s2, "RemoteExecutor destroyed");
        }
        openDocumentBuffer(n3, e3) {
          return this.send("openDocumentBuffer", [n3, e3]);
        }
        getMetadata(n3) {
          return this.send("getMetadata", [n3]);
        }
        setMetadata(n3, e3) {
          return this.send("setMetadata", [n3, e3]);
        }
        getDocPermissions(n3) {
          return this.send("getDocPermissions", [n3]);
        }
        getDocUserPermissions(n3) {
          return this.send("getDocUserPermissions", [n3]);
        }
        getSignatures(n3) {
          return this.send("getSignatures", [n3]);
        }
        getBookmarks(n3) {
          return this.send("getBookmarks", [n3]);
        }
        setBookmarks(n3, e3) {
          return this.send("setBookmarks", [n3, e3]);
        }
        deleteBookmarks(n3) {
          return this.send("deleteBookmarks", [n3]);
        }
        renderPageRaw(n3, e3, t2) {
          return this.send("renderPageRaw", [n3, e3, t2]);
        }
        renderPageRect(n3, e3, t2, r2) {
          return this.send("renderPageRect", [n3, e3, t2, r2]);
        }
        renderThumbnailRaw(n3, e3, t2) {
          return this.send("renderThumbnailRaw", [n3, e3, t2]);
        }
        renderPageAnnotationRaw(n3, e3, t2, r2) {
          return this.send("renderPageAnnotationRaw", [n3, e3, t2, r2]);
        }
        getPageAnnotationsRaw(n3, e3) {
          return this.send("getPageAnnotationsRaw", [n3, e3]);
        }
        getPageAnnotations(n3, e3) {
          return this.send("getPageAnnotations", [n3, e3]);
        }
        createPageAnnotation(n3, e3, t2, r2) {
          return this.send("createPageAnnotation", [n3, e3, t2, r2]);
        }
        updatePageAnnotation(n3, e3, t2) {
          return this.send("updatePageAnnotation", [n3, e3, t2]);
        }
        removePageAnnotation(n3, e3, t2) {
          return this.send("removePageAnnotation", [n3, e3, t2]);
        }
        getPageTextRects(n3, e3) {
          return this.send("getPageTextRects", [n3, e3]);
        }
        searchInPage(n3, e3, t2, r2) {
          return this.send("searchInPage", [n3, e3, t2, r2]);
        }
        getAnnotationsBatch(n3, e3) {
          return this.send("getAnnotationsBatch", [n3, e3]);
        }
        searchBatch(n3, e3, t2, r2) {
          return this.send("searchBatch", [n3, e3, t2, r2]);
        }
        getAttachments(n3) {
          return this.send("getAttachments", [n3]);
        }
        addAttachment(n3, e3) {
          return this.send("addAttachment", [n3, e3]);
        }
        removeAttachment(n3, e3) {
          return this.send("removeAttachment", [n3, e3]);
        }
        readAttachmentContent(n3, e3) {
          return this.send("readAttachmentContent", [n3, e3]);
        }
        setFormFieldValue(n3, e3, t2, r2) {
          return this.send("setFormFieldValue", [n3, e3, t2, r2]);
        }
        flattenPage(n3, e3, t2) {
          return this.send("flattenPage", [n3, e3, t2]);
        }
        extractPages(n3, e3) {
          return this.send("extractPages", [n3, e3]);
        }
        extractText(n3, e3) {
          return this.send("extractText", [n3, e3]);
        }
        redactTextInRects(n3, e3, t2, r2) {
          return this.send("redactTextInRects", [n3, e3, t2, r2]);
        }
        getTextSlices(n3, e3) {
          return this.send("getTextSlices", [n3, e3]);
        }
        getPageGlyphs(n3, e3) {
          return this.send("getPageGlyphs", [n3, e3]);
        }
        getPageGeometry(n3, e3) {
          return this.send("getPageGeometry", [n3, e3]);
        }
        merge(n3) {
          return this.send("merge", [n3]);
        }
        mergePages(n3) {
          return this.send("mergePages", [n3]);
        }
        preparePrintDocument(n3, e3) {
          return this.send("preparePrintDocument", [n3, e3]);
        }
        saveAsCopy(n3) {
          return this.send("saveAsCopy", [n3]);
        }
        closeDocument(n3) {
          return this.send("closeDocument", [n3]);
        }
        closeAllDocuments() {
          return this.send("closeAllDocuments", []);
        }
      };
      d2.READY_TASK_ID = "0";
      l2 = d2;
      u2 = "ImageEncoderPool";
      c2 = "Encoder";
      p2 = class {
        constructor(n3 = 2, e3, t2) {
          this.poolSize = n3, this.workerUrl = e3, this.workers = [], this.pendingTasks = /* @__PURE__ */ new Map(), this.nextWorkerId = 0, this.requestCounter = 0, this.logger = t2 ?? new at(), this.initialize();
        }
        initialize() {
          this.logger.debug(u2, c2, `Creating worker pool with ${this.poolSize} workers`);
          for (let n3 = 0; n3 < this.poolSize; n3++) try {
            const e3 = new Worker(this.workerUrl, { type: "module" });
            e3.onmessage = this.handleWorkerMessage.bind(this), e3.onerror = this.handleWorkerError.bind(this), this.workers.push(e3), this.logger.debug(u2, c2, `Worker ${n3} created successfully`);
          } catch (e3) {
            this.logger.error(u2, c2, `Failed to create worker ${n3}:`, e3);
          }
        }
        handleWorkerMessage(n3) {
          const e3 = n3.data, t2 = this.pendingTasks.get(e3.id);
          if (t2) if (this.pendingTasks.delete(e3.id), "result" === e3.type) t2.resolve(e3.data);
          else {
            const n4 = e3.data;
            t2.reject(new Error(n4.message));
          }
          else this.logger.warn(u2, c2, `Received response for unknown task: ${e3.id}`);
        }
        handleWorkerError(n3) {
          this.logger.error(u2, c2, "Worker error:", n3.message);
        }
        getNextWorker() {
          if (0 === this.workers.length) return null;
          const n3 = this.workers[this.nextWorkerId];
          return this.nextWorkerId = (this.nextWorkerId + 1) % this.workers.length, n3;
        }
        encode(n3, e3 = "image/webp", t2) {
          return new Promise((r2, o3) => {
            const a3 = this.getNextWorker();
            if (!a3) return void o3(new Error("No workers available in the pool"));
            const i3 = `encode-${Date.now()}-${this.requestCounter++}`;
            this.pendingTasks.set(i3, { resolve: r2, reject: o3 });
            const s4 = { id: i3, type: "encode", data: { imageData: { data: n3.data, width: n3.width, height: n3.height }, imageType: e3, quality: t2 } };
            this.logger.debug(u2, c2, `Sending encoding request ${i3} (${n3.width}x${n3.height})`), a3.postMessage(s4, [n3.data.buffer]);
          });
        }
        destroy() {
          this.logger.debug(u2, c2, "Destroying worker pool"), this.pendingTasks.forEach((n3, e3) => {
            n3.reject(new Error("Worker pool destroyed")), this.logger.debug(u2, c2, `Rejected pending task: ${e3}`);
          }), this.pendingTasks.clear(), this.workers.forEach((n3, e3) => {
            n3.terminate(), this.logger.debug(u2, c2, `Worker ${e3} terminated`);
          }), this.workers = [];
        }
        get activeWorkers() {
          return this.workers.length;
        }
        get pendingTasksCount() {
          return this.pendingTasks.size;
        }
      };
    }
  });

  // node_modules/@embedpdf/snippet/dist/direct-engine-Db2HQG7S.js
  var direct_engine_Db2HQG7S_exports = {};
  __export(direct_engine_Db2HQG7S_exports, {
    createPdfiumEngine: () => ie
  });
  async function N(e3) {
    return (async function(e4) {
      const t2 = { pdfium: e4 };
      for (const n3 in L) {
        const r2 = n3, o3 = L[r2][0], a3 = L[r2][1];
        t2[r2] = e4.cwrap(n3, a3, o3);
      }
      return t2;
    })(await B(e3));
  }
  function V(e3, t2, n3, r2 = 100) {
    let o3 = e3.wasmExports.malloc(r2);
    for (let t3 = 0; t3 < r2; t3++) e3.HEAP8[o3 + t3] = 0;
    const a3 = t2(o3, r2);
    let i3;
    if (a3 > r2) {
      e3.wasmExports.free(o3), o3 = e3.wasmExports.malloc(a3);
      for (let t3 = 0; t3 < a3; t3++) e3.HEAP8[o3 + t3] = 0;
      t2(o3, a3), i3 = n3(o3);
    } else i3 = n3(o3);
    return e3.wasmExports.free(o3), i3;
  }
  function U(e3, t2) {
    const n3 = t2(0, 0), r2 = e3.wasmExports.malloc(n3);
    t2(r2, n3);
    const o3 = new ArrayBuffer(n3), a3 = new DataView(o3);
    for (let t3 = 0; t3 < n3; t3++) a3.setInt8(t3, e3.getValue(r2 + t3, "i8"));
    return e3.wasmExports.free(r2), o3;
  }
  function W(e3) {
    if (!e3 || e3.length > 127) return false;
    if ($.has(e3)) return false;
    if ("/" === e3[0]) return false;
    for (let t2 = 0; t2 < e3.length; t2++) {
      const n3 = e3.charCodeAt(t2);
      if (n3 < 32 || n3 > 126) return false;
    }
    return true;
  }
  async function ie(e3, t2) {
    const n3 = await fetch(e3), r2 = await n3.arrayBuffer(), o3 = await N({ wasmBinary: r2 }), a3 = new ae(o3, { logger: null == t2 ? void 0 : t2.logger, fontFallback: null == t2 ? void 0 : t2.fontFallback });
    return new h(a3, { imageConverter: l, logger: null == t2 ? void 0 : t2.logger });
  }
  var import_meta, j, B, L, $, z, H, X, K, Y, J, q, Q, Z, ee, te, ne, re, oe, ae;
  var init_direct_engine_Db2HQG7S = __esm({
    "node_modules/@embedpdf/snippet/dist/direct-engine-Db2HQG7S.js"() {
      init_embedpdf_Ob4AJbqq();
      init_browser_awZxztMA_K_rXQQYD();
      import_meta = {};
      B = (j = import_meta.url, async function(e3 = {}) {
        var t2, n3, r2, o3 = e3, a3 = new Promise((e4, t3) => {
          n3 = e4, r2 = t3;
        });
        ["_EPDF_GetMetaKeyCount", "_EPDF_GetMetaKeyName", "_EPDF_GetMetaTrapped", "_EPDF_GetPageRotationByIndex", "_EPDF_HasMetaText", "_EPDF_PNG_EncodeRGBA", "_EPDF_RenderAnnotBitmap", "_EPDF_SetMetaText", "_EPDF_SetMetaTrapped", "_EPDFAction_CreateGoTo", "_EPDFAction_CreateGoToNamed", "_EPDFAction_CreateLaunch", "_EPDFAction_CreateRemoteGoToByName", "_EPDFAction_CreateRemoteGoToDest", "_EPDFAction_CreateURI", "_EPDFAnnot_ClearColor", "_EPDFAnnot_GenerateAppearance", "_EPDFAnnot_GenerateAppearanceWithBlend", "_EPDFAnnot_GetBlendMode", "_EPDFAnnot_GetBorderDashPattern", "_EPDFAnnot_GetBorderDashPatternCount", "_EPDFAnnot_GetBorderEffect", "_EPDFAnnot_GetBorderStyle", "_EPDFAnnot_GetColor", "_EPDFAnnot_GetDefaultAppearance", "_EPDFAnnot_GetIcon", "_EPDFAnnot_GetIntent", "_EPDFAnnot_GetLineEndings", "_EPDFAnnot_GetOpacity", "_EPDFAnnot_GetRectangleDifferences", "_EPDFAnnot_GetRichContent", "_EPDFAnnot_GetTextAlignment", "_EPDFAnnot_GetVerticalAlignment", "_EPDFAnnot_SetBorderDashPattern", "_EPDFAnnot_SetBorderStyle", "_EPDFAnnot_SetColor", "_EPDFAnnot_SetDefaultAppearance", "_EPDFAnnot_SetIcon", "_EPDFAnnot_SetIntent", "_EPDFAnnot_SetLine", "_EPDFAnnot_SetLineEndings", "_EPDFAnnot_SetLinkedAnnot", "_EPDFAnnot_SetOpacity", "_EPDFAnnot_SetTextAlignment", "_EPDFAnnot_SetVerticalAlignment", "_EPDFAnnot_SetVertices", "_EPDFAnnot_UpdateAppearanceToRect", "_EPDFAttachment_GetDescription", "_EPDFAttachment_GetIntegerValue", "_EPDFAttachment_SetDescription", "_EPDFAttachment_SetSubtype", "_EPDFBookmark_AppendChild", "_EPDFBookmark_Clear", "_EPDFBookmark_ClearTarget", "_EPDFBookmark_Create", "_EPDFBookmark_Delete", "_EPDFBookmark_InsertAfter", "_EPDFBookmark_SetAction", "_EPDFBookmark_SetDest", "_EPDFBookmark_SetTitle", "_EPDFCatalog_GetLanguage", "_EPDFDest_CreateRemoteView", "_EPDFDest_CreateRemoteXYZ", "_EPDFDest_CreateView", "_EPDFDest_CreateXYZ", "_EPDFNamedDest_Remove", "_EPDFNamedDest_SetDest", "_EPDFPage_CreateAnnot", "_EPDFPage_GetAnnotByName", "_EPDFPage_GetAnnotCountRaw", "_EPDFPage_GetAnnotRaw", "_EPDFPage_RemoveAnnotByName", "_EPDFPage_RemoveAnnotRaw", "_EPDFText_RedactInQuads", "_EPDFText_RedactInRect", "_FORM_CanRedo", "_FORM_CanUndo", "_FORM_DoDocumentAAction", "_FORM_DoDocumentJSAction", "_FORM_DoDocumentOpenAction", "_FORM_DoPageAAction", "_FORM_ForceToKillFocus", "_FORM_GetFocusedAnnot", "_FORM_GetFocusedText", "_FORM_GetSelectedText", "_FORM_IsIndexSelected", "_FORM_OnAfterLoadPage", "_FORM_OnBeforeClosePage", "_FORM_OnChar", "_FORM_OnFocus", "_FORM_OnKeyDown", "_FORM_OnKeyUp", "_FORM_OnLButtonDoubleClick", "_FORM_OnLButtonDown", "_FORM_OnLButtonUp", "_FORM_OnMouseMove", "_FORM_OnMouseWheel", "_FORM_OnRButtonDown", "_FORM_OnRButtonUp", "_FORM_Redo", "_FORM_ReplaceAndKeepSelection", "_FORM_ReplaceSelection", "_FORM_SelectAllText", "_FORM_SetFocusedAnnot", "_FORM_SetIndexSelected", "_FORM_Undo", "_FPDF_AddInstalledFont", "_FPDF_CloseDocument", "_FPDF_ClosePage", "_FPDF_CloseXObject", "_FPDF_CopyViewerPreferences", "_FPDF_CountNamedDests", "_FPDF_CreateClipPath", "_FPDF_CreateNewDocument", "_FPDF_DestroyClipPath", "_FPDF_DestroyLibrary", "_FPDF_DeviceToPage", "_FPDF_DocumentHasValidCrossReferenceTable", "_FPDF_FFLDraw", "_FPDF_FreeDefaultSystemFontInfo", "_FPDF_GetDefaultSystemFontInfo", "_FPDF_GetDefaultTTFMap", "_FPDF_GetDefaultTTFMapCount", "_FPDF_GetDefaultTTFMapEntry", "_FPDF_GetDocPermissions", "_FPDF_GetDocUserPermissions", "_FPDF_GetFileIdentifier", "_FPDF_GetFileVersion", "_FPDF_GetFormType", "_FPDF_GetLastError", "_FPDF_GetMetaText", "_FPDF_GetNamedDest", "_FPDF_GetNamedDestByName", "_FPDF_GetPageAAction", "_FPDF_GetPageBoundingBox", "_FPDF_GetPageCount", "_FPDF_GetPageHeight", "_FPDF_GetPageHeightF", "_FPDF_GetPageLabel", "_FPDF_GetPageSizeByIndex", "_FPDF_GetPageSizeByIndexF", "_FPDF_GetPageWidth", "_FPDF_GetPageWidthF", "_FPDF_GetSecurityHandlerRevision", "_FPDF_GetSignatureCount", "_FPDF_GetSignatureObject", "_FPDF_GetTrailerEnds", "_FPDF_GetXFAPacketContent", "_FPDF_GetXFAPacketCount", "_FPDF_GetXFAPacketName", "_FPDF_ImportNPagesToOne", "_FPDF_ImportPages", "_FPDF_ImportPagesByIndex", "_FPDF_InitLibrary", "_FPDF_InitLibraryWithConfig", "_FPDF_LoadCustomDocument", "_FPDF_LoadDocument", "_FPDF_LoadMemDocument", "_FPDF_LoadMemDocument64", "_FPDF_LoadPage", "_FPDF_LoadXFA", "_FPDF_MovePages", "_FPDF_NewFormObjectFromXObject", "_FPDF_NewXObjectFromPage", "_FPDF_PageToDevice", "_FPDF_RemoveFormFieldHighlight", "_FPDF_RenderPage_Close", "_FPDF_RenderPage_Continue", "_FPDF_RenderPageBitmap", "_FPDF_RenderPageBitmap_Start", "_FPDF_RenderPageBitmapWithColorScheme_Start", "_FPDF_RenderPageBitmapWithMatrix", "_FPDF_SaveAsCopy", "_FPDF_SaveWithVersion", "_FPDF_SetFormFieldHighlightAlpha", "_FPDF_SetFormFieldHighlightColor", "_FPDF_SetSandBoxPolicy", "_FPDF_SetSystemFontInfo", "_FPDF_StructElement_Attr_CountChildren", "_FPDF_StructElement_Attr_GetBlobValue", "_FPDF_StructElement_Attr_GetBooleanValue", "_FPDF_StructElement_Attr_GetChildAtIndex", "_FPDF_StructElement_Attr_GetCount", "_FPDF_StructElement_Attr_GetName", "_FPDF_StructElement_Attr_GetNumberValue", "_FPDF_StructElement_Attr_GetStringValue", "_FPDF_StructElement_Attr_GetType", "_FPDF_StructElement_Attr_GetValue", "_FPDF_StructElement_CountChildren", "_FPDF_StructElement_GetActualText", "_FPDF_StructElement_GetAltText", "_FPDF_StructElement_GetAttributeAtIndex", "_FPDF_StructElement_GetAttributeCount", "_FPDF_StructElement_GetChildAtIndex", "_FPDF_StructElement_GetChildMarkedContentID", "_FPDF_StructElement_GetID", "_FPDF_StructElement_GetLang", "_FPDF_StructElement_GetMarkedContentID", "_FPDF_StructElement_GetMarkedContentIdAtIndex", "_FPDF_StructElement_GetMarkedContentIdCount", "_FPDF_StructElement_GetObjType", "_FPDF_StructElement_GetParent", "_FPDF_StructElement_GetStringAttribute", "_FPDF_StructElement_GetTitle", "_FPDF_StructElement_GetType", "_FPDF_StructTree_Close", "_FPDF_StructTree_CountChildren", "_FPDF_StructTree_GetChildAtIndex", "_FPDF_StructTree_GetForPage", "_FPDF_VIEWERREF_GetDuplex", "_FPDF_VIEWERREF_GetName", "_FPDF_VIEWERREF_GetNumCopies", "_FPDF_VIEWERREF_GetPrintPageRange", "_FPDF_VIEWERREF_GetPrintPageRangeCount", "_FPDF_VIEWERREF_GetPrintPageRangeElement", "_FPDF_VIEWERREF_GetPrintScaling", "_FPDFAction_GetDest", "_FPDFAction_GetFilePath", "_FPDFAction_GetType", "_FPDFAction_GetURIPath", "_FPDFAnnot_AddFileAttachment", "_FPDFAnnot_AddInkStroke", "_FPDFAnnot_AppendAttachmentPoints", "_FPDFAnnot_AppendObject", "_FPDFAnnot_CountAttachmentPoints", "_FPDFAnnot_GetAP", "_FPDFAnnot_GetAttachmentPoints", "_FPDFAnnot_GetBorder", "_FPDFAnnot_GetColor", "_FPDFAnnot_GetFileAttachment", "_FPDFAnnot_GetFlags", "_FPDFAnnot_GetFocusableSubtypes", "_FPDFAnnot_GetFocusableSubtypesCount", "_FPDFAnnot_GetFontColor", "_FPDFAnnot_GetFontSize", "_FPDFAnnot_GetFormAdditionalActionJavaScript", "_FPDFAnnot_GetFormControlCount", "_FPDFAnnot_GetFormControlIndex", "_FPDFAnnot_GetFormFieldAlternateName", "_FPDFAnnot_GetFormFieldAtPoint", "_FPDFAnnot_GetFormFieldExportValue", "_FPDFAnnot_GetFormFieldFlags", "_FPDFAnnot_GetFormFieldName", "_FPDFAnnot_GetFormFieldType", "_FPDFAnnot_GetFormFieldValue", "_FPDFAnnot_GetInkListCount", "_FPDFAnnot_GetInkListPath", "_FPDFAnnot_GetLine", "_FPDFAnnot_GetLink", "_FPDFAnnot_GetLinkedAnnot", "_FPDFAnnot_GetNumberValue", "_FPDFAnnot_GetObject", "_FPDFAnnot_GetObjectCount", "_FPDFAnnot_GetOptionCount", "_FPDFAnnot_GetOptionLabel", "_FPDFAnnot_GetRect", "_FPDFAnnot_GetStringValue", "_FPDFAnnot_GetSubtype", "_FPDFAnnot_GetValueType", "_FPDFAnnot_GetVertices", "_FPDFAnnot_HasAttachmentPoints", "_FPDFAnnot_HasKey", "_FPDFAnnot_IsChecked", "_FPDFAnnot_IsObjectSupportedSubtype", "_FPDFAnnot_IsOptionSelected", "_FPDFAnnot_IsSupportedSubtype", "_FPDFAnnot_RemoveInkList", "_FPDFAnnot_RemoveObject", "_FPDFAnnot_SetAP", "_FPDFAnnot_SetAttachmentPoints", "_FPDFAnnot_SetBorder", "_FPDFAnnot_SetColor", "_FPDFAnnot_SetFlags", "_FPDFAnnot_SetFocusableSubtypes", "_FPDFAnnot_SetFontColor", "_FPDFAnnot_SetFormFieldFlags", "_FPDFAnnot_SetRect", "_FPDFAnnot_SetStringValue", "_FPDFAnnot_SetURI", "_FPDFAnnot_UpdateObject", "_FPDFAttachment_GetFile", "_FPDFAttachment_GetName", "_FPDFAttachment_GetStringValue", "_FPDFAttachment_GetSubtype", "_FPDFAttachment_GetValueType", "_FPDFAttachment_HasKey", "_FPDFAttachment_SetFile", "_FPDFAttachment_SetStringValue", "_FPDFAvail_Create", "_FPDFAvail_Destroy", "_FPDFAvail_GetDocument", "_FPDFAvail_GetFirstPageNum", "_FPDFAvail_IsDocAvail", "_FPDFAvail_IsFormAvail", "_FPDFAvail_IsLinearized", "_FPDFAvail_IsPageAvail", "_FPDFBitmap_Create", "_FPDFBitmap_CreateEx", "_FPDFBitmap_Destroy", "_FPDFBitmap_FillRect", "_FPDFBitmap_GetBuffer", "_FPDFBitmap_GetFormat", "_FPDFBitmap_GetHeight", "_FPDFBitmap_GetStride", "_FPDFBitmap_GetWidth", "_FPDFBookmark_Find", "_FPDFBookmark_GetAction", "_FPDFBookmark_GetCount", "_FPDFBookmark_GetDest", "_FPDFBookmark_GetFirstChild", "_FPDFBookmark_GetNextSibling", "_FPDFBookmark_GetTitle", "_FPDFCatalog_IsTagged", "_FPDFCatalog_SetLanguage", "_FPDFClipPath_CountPaths", "_FPDFClipPath_CountPathSegments", "_FPDFClipPath_GetPathSegment", "_FPDFDest_GetDestPageIndex", "_FPDFDest_GetLocationInPage", "_FPDFDest_GetView", "_FPDFDoc_AddAttachment", "_FPDFDoc_CloseJavaScriptAction", "_FPDFDoc_DeleteAttachment", "_FPDFDOC_ExitFormFillEnvironment", "_FPDFDoc_GetAttachment", "_FPDFDoc_GetAttachmentCount", "_FPDFDoc_GetJavaScriptAction", "_FPDFDoc_GetJavaScriptActionCount", "_FPDFDoc_GetPageMode", "_FPDFDOC_InitFormFillEnvironment", "_FPDFFont_Close", "_FPDFFont_GetAscent", "_FPDFFont_GetBaseFontName", "_FPDFFont_GetDescent", "_FPDFFont_GetFamilyName", "_FPDFFont_GetFlags", "_FPDFFont_GetFontData", "_FPDFFont_GetGlyphPath", "_FPDFFont_GetGlyphWidth", "_FPDFFont_GetIsEmbedded", "_FPDFFont_GetItalicAngle", "_FPDFFont_GetWeight", "_FPDFFormObj_CountObjects", "_FPDFFormObj_GetObject", "_FPDFFormObj_RemoveObject", "_FPDFGlyphPath_CountGlyphSegments", "_FPDFGlyphPath_GetGlyphPathSegment", "_FPDFImageObj_GetBitmap", "_FPDFImageObj_GetIccProfileDataDecoded", "_FPDFImageObj_GetImageDataDecoded", "_FPDFImageObj_GetImageDataRaw", "_FPDFImageObj_GetImageFilter", "_FPDFImageObj_GetImageFilterCount", "_FPDFImageObj_GetImageMetadata", "_FPDFImageObj_GetImagePixelSize", "_FPDFImageObj_GetRenderedBitmap", "_FPDFImageObj_LoadJpegFile", "_FPDFImageObj_LoadJpegFileInline", "_FPDFImageObj_SetBitmap", "_FPDFImageObj_SetMatrix", "_FPDFJavaScriptAction_GetName", "_FPDFJavaScriptAction_GetScript", "_FPDFLink_CloseWebLinks", "_FPDFLink_CountQuadPoints", "_FPDFLink_CountRects", "_FPDFLink_CountWebLinks", "_FPDFLink_Enumerate", "_FPDFLink_GetAction", "_FPDFLink_GetAnnot", "_FPDFLink_GetAnnotRect", "_FPDFLink_GetDest", "_FPDFLink_GetLinkAtPoint", "_FPDFLink_GetLinkZOrderAtPoint", "_FPDFLink_GetQuadPoints", "_FPDFLink_GetRect", "_FPDFLink_GetTextRange", "_FPDFLink_GetURL", "_FPDFLink_LoadWebLinks", "_FPDFPage_CloseAnnot", "_FPDFPage_CountObjects", "_FPDFPage_CreateAnnot", "_FPDFPage_Delete", "_FPDFPage_Flatten", "_FPDFPage_FormFieldZOrderAtPoint", "_FPDFPage_GenerateContent", "_FPDFPage_GetAnnot", "_FPDFPage_GetAnnotCount", "_FPDFPage_GetAnnotIndex", "_FPDFPage_GetArtBox", "_FPDFPage_GetBleedBox", "_FPDFPage_GetCropBox", "_FPDFPage_GetDecodedThumbnailData", "_FPDFPage_GetMediaBox", "_FPDFPage_GetObject", "_FPDFPage_GetRawThumbnailData", "_FPDFPage_GetRotation", "_FPDFPage_GetThumbnailAsBitmap", "_FPDFPage_GetTrimBox", "_FPDFPage_HasFormFieldAtPoint", "_FPDFPage_HasTransparency", "_FPDFPage_InsertClipPath", "_FPDFPage_InsertObject", "_FPDFPage_InsertObjectAtIndex", "_FPDFPage_New", "_FPDFPage_RemoveAnnot", "_FPDFPage_RemoveObject", "_FPDFPage_SetArtBox", "_FPDFPage_SetBleedBox", "_FPDFPage_SetCropBox", "_FPDFPage_SetMediaBox", "_FPDFPage_SetRotation", "_FPDFPage_SetTrimBox", "_FPDFPage_TransformAnnots", "_FPDFPage_TransFormWithClip", "_FPDFPageObj_AddMark", "_FPDFPageObj_CountMarks", "_FPDFPageObj_CreateNewPath", "_FPDFPageObj_CreateNewRect", "_FPDFPageObj_CreateTextObj", "_FPDFPageObj_Destroy", "_FPDFPageObj_GetBounds", "_FPDFPageObj_GetClipPath", "_FPDFPageObj_GetDashArray", "_FPDFPageObj_GetDashCount", "_FPDFPageObj_GetDashPhase", "_FPDFPageObj_GetFillColor", "_FPDFPageObj_GetIsActive", "_FPDFPageObj_GetLineCap", "_FPDFPageObj_GetLineJoin", "_FPDFPageObj_GetMark", "_FPDFPageObj_GetMarkedContentID", "_FPDFPageObj_GetMatrix", "_FPDFPageObj_GetRotatedBounds", "_FPDFPageObj_GetStrokeColor", "_FPDFPageObj_GetStrokeWidth", "_FPDFPageObj_GetType", "_FPDFPageObj_HasTransparency", "_FPDFPageObj_NewImageObj", "_FPDFPageObj_NewTextObj", "_FPDFPageObj_RemoveMark", "_FPDFPageObj_SetBlendMode", "_FPDFPageObj_SetDashArray", "_FPDFPageObj_SetDashPhase", "_FPDFPageObj_SetFillColor", "_FPDFPageObj_SetIsActive", "_FPDFPageObj_SetLineCap", "_FPDFPageObj_SetLineJoin", "_FPDFPageObj_SetMatrix", "_FPDFPageObj_SetStrokeColor", "_FPDFPageObj_SetStrokeWidth", "_FPDFPageObj_Transform", "_FPDFPageObj_TransformClipPath", "_FPDFPageObj_TransformF", "_FPDFPageObjMark_CountParams", "_FPDFPageObjMark_GetName", "_FPDFPageObjMark_GetParamBlobValue", "_FPDFPageObjMark_GetParamIntValue", "_FPDFPageObjMark_GetParamKey", "_FPDFPageObjMark_GetParamStringValue", "_FPDFPageObjMark_GetParamValueType", "_FPDFPageObjMark_RemoveParam", "_FPDFPageObjMark_SetBlobParam", "_FPDFPageObjMark_SetIntParam", "_FPDFPageObjMark_SetStringParam", "_FPDFPath_BezierTo", "_FPDFPath_Close", "_FPDFPath_CountSegments", "_FPDFPath_GetDrawMode", "_FPDFPath_GetPathSegment", "_FPDFPath_LineTo", "_FPDFPath_MoveTo", "_FPDFPath_SetDrawMode", "_FPDFPathSegment_GetClose", "_FPDFPathSegment_GetPoint", "_FPDFPathSegment_GetType", "_FPDFSignatureObj_GetByteRange", "_FPDFSignatureObj_GetContents", "_FPDFSignatureObj_GetDocMDPPermission", "_FPDFSignatureObj_GetReason", "_FPDFSignatureObj_GetSubFilter", "_FPDFSignatureObj_GetTime", "_FPDFText_ClosePage", "_FPDFText_CountChars", "_FPDFText_CountRects", "_FPDFText_FindClose", "_FPDFText_FindNext", "_FPDFText_FindPrev", "_FPDFText_FindStart", "_FPDFText_GetBoundedText", "_FPDFText_GetCharAngle", "_FPDFText_GetCharBox", "_FPDFText_GetCharIndexAtPos", "_FPDFText_GetCharIndexFromTextIndex", "_FPDFText_GetCharOrigin", "_FPDFText_GetFillColor", "_FPDFText_GetFontInfo", "_FPDFText_GetFontSize", "_FPDFText_GetFontWeight", "_FPDFText_GetLooseCharBox", "_FPDFText_GetMatrix", "_FPDFText_GetRect", "_FPDFText_GetSchCount", "_FPDFText_GetSchResultIndex", "_FPDFText_GetStrokeColor", "_FPDFText_GetText", "_FPDFText_GetTextIndexFromCharIndex", "_FPDFText_GetTextObject", "_FPDFText_GetUnicode", "_FPDFText_HasUnicodeMapError", "_FPDFText_IsGenerated", "_FPDFText_IsHyphen", "_FPDFText_LoadCidType2Font", "_FPDFText_LoadFont", "_FPDFText_LoadPage", "_FPDFText_LoadStandardFont", "_FPDFText_SetCharcodes", "_FPDFText_SetText", "_FPDFTextObj_GetFont", "_FPDFTextObj_GetFontSize", "_FPDFTextObj_GetRenderedBitmap", "_FPDFTextObj_GetText", "_FPDFTextObj_GetTextRenderMode", "_FPDFTextObj_SetTextRenderMode", "_PDFiumExt_CloseFileWriter", "_PDFiumExt_CloseFormFillInfo", "_PDFiumExt_ExitFormFillEnvironment", "_PDFiumExt_GetFileWriterData", "_PDFiumExt_GetFileWriterSize", "_PDFiumExt_Init", "_PDFiumExt_InitFormFillEnvironment", "_PDFiumExt_OpenFileWriter", "_PDFiumExt_OpenFormFillInfo", "_PDFiumExt_SaveAsCopy", "_malloc", "_free", "_memory", "___indirect_function_table", "onRuntimeInitialized"].forEach((e4) => {
          Object.getOwnPropertyDescriptor(a3, e4) || Object.defineProperty(a3, e4, { get: () => z3("You are getting " + e4 + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"), set: () => z3("You are setting " + e4 + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js") });
        });
        var i3 = "object" == typeof window, s4 = "function" == typeof importScripts;
        "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node && process.type;
        var u4, F2, m3 = !i3 && !s4, l4 = Object.assign({}, o3), d4 = "./this.program", _2 = "";
        if (m3) {
          if ("object" == typeof window || "function" == typeof importScripts) throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
          F2 = (e4) => {
            if ("function" == typeof readbuffer) return new Uint8Array(readbuffer(e4));
            let t3 = read(e4, "binary");
            return C2("object" == typeof t3), t3;
          }, u4 = (e4) => new Promise((t3, n4) => {
            setTimeout(() => t3(F2(e4)));
          }), globalThis.clearTimeout ??= (e4) => {
          }, globalThis.setTimeout ??= (e4) => "function" == typeof e4 ? e4() : z3(), "undefined" != typeof print && (globalThis.console ??= {}, console.log = print, console.warn = console.error = globalThis.printErr ?? print);
        } else {
          if (!i3 && !s4) throw new Error("environment detection error");
          if (s4 ? _2 = self.location.href : "undefined" != typeof document && document.currentScript && (_2 = document.currentScript.src), j && (_2 = j), _2 = _2.startsWith("blob:") ? "" : _2.substr(0, _2.replace(/[?#].*/, "").lastIndexOf("/") + 1), "object" != typeof window && "function" != typeof importScripts) throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
          s4 && (F2 = (e4) => {
            var t3 = new XMLHttpRequest();
            return t3.open("GET", e4, false), t3.responseType = "arraybuffer", t3.send(null), new Uint8Array(t3.response);
          }), u4 = (e4) => (C2(!J3(e4), "readAsync does not work with file:// URLs"), fetch(e4, { credentials: "same-origin" }).then((e5) => e5.ok ? e5.arrayBuffer() : Promise.reject(new Error(e5.status + " : " + e5.url))));
        }
        var c4, P2 = o3.print || console.log.bind(console), g3 = o3.printErr || console.error.bind(console);
        Object.assign(o3, l4), l4 = null, c4 = "fetchSettings", Object.getOwnPropertyDescriptor(o3, c4) && z3(`\`Module.${c4}\` was supplied but \`${c4}\` not included in INCOMING_MODULE_JS_API`), o3.arguments && o3.arguments, te3("arguments", "arguments_"), o3.thisProgram && (d4 = o3.thisProgram), te3("thisProgram", "thisProgram"), C2(void 0 === o3.memoryInitializerPrefixURL, "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead"), C2(void 0 === o3.pthreadMainPrefixURL, "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead"), C2(void 0 === o3.cdInitializerPrefixURL, "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead"), C2(void 0 === o3.filePackagePrefixURL, "Module.filePackagePrefixURL option was removed, use Module.locateFile instead"), C2(void 0 === o3.read, "Module.read option was removed"), C2(void 0 === o3.readAsync, "Module.readAsync option was removed (modify readAsync in JS)"), C2(void 0 === o3.readBinary, "Module.readBinary option was removed (modify readBinary in JS)"), C2(void 0 === o3.setWindowTitle, "Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)"), C2(void 0 === o3.TOTAL_MEMORY, "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY"), te3("asm", "wasmExports"), te3("readAsync", "readAsync"), te3("readBinary", "readBinary"), te3("setWindowTitle", "setWindowTitle");
        var h3, D2 = o3.wasmBinary;
        te3("wasmBinary", "wasmBinary"), "object" != typeof WebAssembly && g3("no native wasm support detected");
        var b2, f2, p4, A2, E2, M2, y2, G2, S2 = false;
        function C2(e4, t3) {
          e4 || z3("Assertion failed" + (t3 ? ": " + t3 : ""));
        }
        function T2() {
          var e4 = h3.buffer;
          o3.HEAP8 = b2 = new Int8Array(e4), o3.HEAP16 = p4 = new Int16Array(e4), o3.HEAPU8 = f2 = new Uint8Array(e4), o3.HEAPU16 = A2 = new Uint16Array(e4), o3.HEAP32 = E2 = new Int32Array(e4), o3.HEAPU32 = M2 = new Uint32Array(e4), o3.HEAPF32 = y2 = new Float32Array(e4), o3.HEAPF64 = G2 = new Float64Array(e4);
        }
        function x2() {
          if (!S2) {
            var e4 = it2();
            0 == e4 && (e4 += 4);
            var t3 = M2[e4 >> 2], n4 = M2[e4 + 4 >> 2];
            34821223 == t3 && 2310721022 == n4 || z3(`Stack overflow! Stack cookie has been overwritten at ${se2(e4)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${se2(n4)} ${se2(t3)}`), 1668509029 != M2[0] && z3("Runtime error: The application has corrupted its heap memory area (address zero)!");
          }
        }
        C2(!o3.STACK_SIZE, "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time"), C2("undefined" != typeof Int32Array && "undefined" != typeof Float64Array && null != Int32Array.prototype.subarray && null != Int32Array.prototype.set, "JS engine does not provide full typed array support"), C2(!o3.wasmMemory, "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally"), C2(!o3.INITIAL_MEMORY, "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
        var v2 = [], O2 = [], k2 = [], w2 = false;
        function R2(e4) {
          v2.unshift(e4);
        }
        function I2(e4) {
          k2.unshift(e4);
        }
        C2(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), C2(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), C2(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"), C2(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
        var B3 = 0, L3 = null, N3 = null, V3 = {};
        function U3(e4) {
          for (var t3 = e4; ; ) {
            if (!V3[e4]) return e4;
            e4 = t3 + Math.random();
          }
        }
        function $3(e4) {
          B3++, o3.monitorRunDependencies?.(B3), e4 ? (C2(!V3[e4]), V3[e4] = 1, null === L3 && "undefined" != typeof setInterval && (L3 = setInterval(() => {
            if (S2) return clearInterval(L3), void (L3 = null);
            var e5 = false;
            for (var t3 in V3) e5 || (e5 = true, g3("still waiting on run dependencies:")), g3(`dependency: ${t3}`);
            e5 && g3("(end of list)");
          }, 1e4))) : g3("warning: run dependency added without ID");
        }
        function W3(e4) {
          if (B3--, o3.monitorRunDependencies?.(B3), e4 ? (C2(V3[e4]), delete V3[e4]) : g3("warning: run dependency removed without ID"), 0 == B3 && (null !== L3 && (clearInterval(L3), L3 = null), N3)) {
            var t3 = N3;
            N3 = null, t3();
          }
        }
        function z3(e4) {
          o3.onAbort?.(e4), g3(e4 = "Aborted(" + e4 + ")"), S2 = true;
          var t3 = new WebAssembly.RuntimeError(e4);
          throw r2(t3), t3;
        }
        var H3, X3, K3, Y3 = (e4) => e4.startsWith("data:application/octet-stream;base64,"), J3 = (e4) => e4.startsWith("file://");
        function q3(e4, t3) {
          return (...n4) => {
            C2(w2, `native function \`${e4}\` called before runtime initialization`);
            var r3 = Qe2[e4];
            return C2(r3, `exported native function \`${e4}\` not found`), C2(n4.length <= t3, `native function \`${e4}\` called with ${n4.length} args but expects ${t3}`), r3(...n4);
          };
        }
        function Q3() {
          if (o3.locateFile) {
            var e4 = "pdfium.wasm";
            return Y3(e4) ? e4 : (t3 = e4, o3.locateFile ? o3.locateFile(t3, _2) : _2 + t3);
          }
          var t3;
          return m3 ? "pdfium.wasm" : new URL("pdfium.wasm", import_meta.url).href;
        }
        function Z3(e4) {
          if (e4 == H3 && D2) return new Uint8Array(D2);
          if (F2) return F2(e4);
          throw "both async and sync fetching of the wasm failed";
        }
        function ee3(e4, t3, n4) {
          return (function(e5) {
            return D2 ? Promise.resolve().then(() => Z3(e5)) : u4(e5).then((e6) => new Uint8Array(e6), () => Z3(e5));
          })(e4).then((e5) => WebAssembly.instantiate(e5, t3)).then(n4, (e5) => {
            g3(`failed to asynchronously prepare wasm: ${e5}`), J3(H3) && g3(`warning: Loading from a file URI (${H3}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`), z3(e5);
          });
        }
        if ((() => {
          var e4 = new Int16Array(1), t3 = new Int8Array(e4.buffer);
          if (e4[0] = 25459, 115 !== t3[0] || 99 !== t3[1]) throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
        })(), o3.ENVIRONMENT) throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
        function te3(e4, t3, n4 = true) {
          Object.getOwnPropertyDescriptor(o3, e4) || Object.defineProperty(o3, e4, { configurable: true, get() {
            z3(`\`Module.${e4}\` has been replaced by \`${t3}\`` + (n4 ? " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)" : ""));
          } });
        }
        function ne3(e4) {
          return "FS_createPath" === e4 || "FS_createDataFile" === e4 || "FS_createPreloadedFile" === e4 || "FS_unlink" === e4 || "addRunDependency" === e4 || "FS_createLazyFile" === e4 || "FS_createDevice" === e4 || "removeRunDependency" === e4;
        }
        function re3(e4, t3) {
          "undefined" == typeof globalThis || Object.getOwnPropertyDescriptor(globalThis, e4) || Object.defineProperty(globalThis, e4, { configurable: true, get() {
            t3();
          } });
        }
        function oe3(e4, t3) {
          re3(e4, () => {
            me2(`\`${e4}\` is not longer defined by emscripten. ${t3}`);
          });
        }
        function ae3(e4) {
          Object.getOwnPropertyDescriptor(o3, e4) || Object.defineProperty(o3, e4, { configurable: true, get() {
            var t3 = `'${e4}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;
            ne3(e4) && (t3 += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you"), z3(t3);
          } });
        }
        oe3("buffer", "Please use HEAP8.buffer or wasmMemory.buffer"), oe3("asm", "Please use wasmExports instead");
        var ie3 = (e4) => {
          e4.forEach((e5) => e5(o3));
        };
        o3.noExitRuntime;
        var se2 = (e4) => (C2("number" == typeof e4), "0x" + (e4 >>>= 0).toString(16).padStart(8, "0")), ue2 = (e4) => st2(e4), Fe2 = () => Ft2(), me2 = (e4) => {
          me2.shown ||= {}, me2.shown[e4] || (me2.shown[e4] = 1, g3(e4));
        }, le2 = "undefined" != typeof TextDecoder ? new TextDecoder() : void 0, de2 = (e4, t3 = 0, n4 = NaN) => {
          for (var r3 = t3 + n4, o4 = t3; e4[o4] && !(o4 >= r3); ) ++o4;
          if (o4 - t3 > 16 && e4.buffer && le2) return le2.decode(e4.subarray(t3, o4));
          for (var a4 = ""; t3 < o4; ) {
            var i4 = e4[t3++];
            if (128 & i4) {
              var s5 = 63 & e4[t3++];
              if (192 != (224 & i4)) {
                var u5 = 63 & e4[t3++];
                if (224 == (240 & i4) ? i4 = (15 & i4) << 12 | s5 << 6 | u5 : (240 != (248 & i4) && me2("Invalid UTF-8 leading byte " + se2(i4) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!"), i4 = (7 & i4) << 18 | s5 << 12 | u5 << 6 | 63 & e4[t3++]), i4 < 65536) a4 += String.fromCharCode(i4);
                else {
                  var F3 = i4 - 65536;
                  a4 += String.fromCharCode(55296 | F3 >> 10, 56320 | 1023 & F3);
                }
              } else a4 += String.fromCharCode((31 & i4) << 6 | s5);
            } else a4 += String.fromCharCode(i4);
          }
          return a4;
        }, _e2 = (e4, t3) => (C2("number" == typeof e4, `UTF8ToString expects a number (got ${typeof e4})`), e4 ? de2(f2, e4, t3) : "");
        function ce2() {
          C2(null != ke2.varargs);
          var e4 = E2[+ke2.varargs >> 2];
          return ke2.varargs += 4, e4;
        }
        var Pe2 = ce2, ge2 = { isAbs: (e4) => "/" === e4.charAt(0), splitPath: (e4) => /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(e4).slice(1), normalizeArray: (e4, t3) => {
          for (var n4 = 0, r3 = e4.length - 1; r3 >= 0; r3--) {
            var o4 = e4[r3];
            "." === o4 ? e4.splice(r3, 1) : ".." === o4 ? (e4.splice(r3, 1), n4++) : n4 && (e4.splice(r3, 1), n4--);
          }
          if (t3) for (; n4; n4--) e4.unshift("..");
          return e4;
        }, normalize: (e4) => {
          var t3 = ge2.isAbs(e4), n4 = "/" === e4.substr(-1);
          return (e4 = ge2.normalizeArray(e4.split("/").filter((e5) => !!e5), !t3).join("/")) || t3 || (e4 = "."), e4 && n4 && (e4 += "/"), (t3 ? "/" : "") + e4;
        }, dirname: (e4) => {
          var t3 = ge2.splitPath(e4), n4 = t3[0], r3 = t3[1];
          return n4 || r3 ? (r3 && (r3 = r3.substr(0, r3.length - 1)), n4 + r3) : ".";
        }, basename: (e4) => {
          if ("/" === e4) return "/";
          var t3 = (e4 = (e4 = ge2.normalize(e4)).replace(/\/$/, "")).lastIndexOf("/");
          return -1 === t3 ? e4 : e4.substr(t3 + 1);
        }, join: (...e4) => ge2.normalize(e4.join("/")), join2: (e4, t3) => ge2.normalize(e4 + "/" + t3) }, he2 = (e4) => (he2 = (() => {
          if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) return (e5) => crypto.getRandomValues(e5);
          z3("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };");
        })())(e4), De2 = { resolve: (...e4) => {
          for (var t3 = "", n4 = false, r3 = e4.length - 1; r3 >= -1 && !n4; r3--) {
            var o4 = r3 >= 0 ? e4[r3] : Oe2.cwd();
            if ("string" != typeof o4) throw new TypeError("Arguments to path.resolve must be strings");
            if (!o4) return "";
            t3 = o4 + "/" + t3, n4 = ge2.isAbs(o4);
          }
          return (n4 ? "/" : "") + (t3 = ge2.normalizeArray(t3.split("/").filter((e5) => !!e5), !n4).join("/")) || ".";
        }, relative: (e4, t3) => {
          function n4(e5) {
            for (var t4 = 0; t4 < e5.length && "" === e5[t4]; t4++) ;
            for (var n5 = e5.length - 1; n5 >= 0 && "" === e5[n5]; n5--) ;
            return t4 > n5 ? [] : e5.slice(t4, n5 - t4 + 1);
          }
          e4 = De2.resolve(e4).substr(1), t3 = De2.resolve(t3).substr(1);
          for (var r3 = n4(e4.split("/")), o4 = n4(t3.split("/")), a4 = Math.min(r3.length, o4.length), i4 = a4, s5 = 0; s5 < a4; s5++) if (r3[s5] !== o4[s5]) {
            i4 = s5;
            break;
          }
          var u5 = [];
          for (s5 = i4; s5 < r3.length; s5++) u5.push("..");
          return (u5 = u5.concat(o4.slice(i4))).join("/");
        } }, be2 = [], fe2 = (e4) => {
          for (var t3 = 0, n4 = 0; n4 < e4.length; ++n4) {
            var r3 = e4.charCodeAt(n4);
            r3 <= 127 ? t3++ : r3 <= 2047 ? t3 += 2 : r3 >= 55296 && r3 <= 57343 ? (t3 += 4, ++n4) : t3 += 3;
          }
          return t3;
        }, pe2 = (e4, t3, n4, r3) => {
          if (C2("string" == typeof e4, `stringToUTF8Array expects a string (got ${typeof e4})`), !(r3 > 0)) return 0;
          for (var o4 = n4, a4 = n4 + r3 - 1, i4 = 0; i4 < e4.length; ++i4) {
            var s5 = e4.charCodeAt(i4);
            if (s5 >= 55296 && s5 <= 57343 && (s5 = 65536 + ((1023 & s5) << 10) | 1023 & e4.charCodeAt(++i4)), s5 <= 127) {
              if (n4 >= a4) break;
              t3[n4++] = s5;
            } else if (s5 <= 2047) {
              if (n4 + 1 >= a4) break;
              t3[n4++] = 192 | s5 >> 6, t3[n4++] = 128 | 63 & s5;
            } else if (s5 <= 65535) {
              if (n4 + 2 >= a4) break;
              t3[n4++] = 224 | s5 >> 12, t3[n4++] = 128 | s5 >> 6 & 63, t3[n4++] = 128 | 63 & s5;
            } else {
              if (n4 + 3 >= a4) break;
              s5 > 1114111 && me2("Invalid Unicode code point " + se2(s5) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF)."), t3[n4++] = 240 | s5 >> 18, t3[n4++] = 128 | s5 >> 12 & 63, t3[n4++] = 128 | s5 >> 6 & 63, t3[n4++] = 128 | 63 & s5;
            }
          }
          return t3[n4] = 0, n4 - o4;
        };
        function Ae2(e4, t3, n4) {
          var r3 = fe2(e4) + 1, o4 = new Array(r3), a4 = pe2(e4, o4, 0, o4.length);
          return o4.length = a4, o4;
        }
        var Ee2, Me2, ye2 = { ttys: [], init() {
        }, shutdown() {
        }, register(e4, t3) {
          ye2.ttys[e4] = { input: [], output: [], ops: t3 }, Oe2.registerDevice(e4, ye2.stream_ops);
        }, stream_ops: { open(e4) {
          var t3 = ye2.ttys[e4.node.rdev];
          if (!t3) throw new Oe2.ErrnoError(43);
          e4.tty = t3, e4.seekable = false;
        }, close(e4) {
          e4.tty.ops.fsync(e4.tty);
        }, fsync(e4) {
          e4.tty.ops.fsync(e4.tty);
        }, read(e4, t3, n4, r3, o4) {
          if (!e4.tty || !e4.tty.ops.get_char) throw new Oe2.ErrnoError(60);
          for (var a4 = 0, i4 = 0; i4 < r3; i4++) {
            var s5;
            try {
              s5 = e4.tty.ops.get_char(e4.tty);
            } catch (e5) {
              throw new Oe2.ErrnoError(29);
            }
            if (void 0 === s5 && 0 === a4) throw new Oe2.ErrnoError(6);
            if (null == s5) break;
            a4++, t3[n4 + i4] = s5;
          }
          return a4 && (e4.node.timestamp = Date.now()), a4;
        }, write(e4, t3, n4, r3, o4) {
          if (!e4.tty || !e4.tty.ops.put_char) throw new Oe2.ErrnoError(60);
          try {
            for (var a4 = 0; a4 < r3; a4++) e4.tty.ops.put_char(e4.tty, t3[n4 + a4]);
          } catch (e5) {
            throw new Oe2.ErrnoError(29);
          }
          return r3 && (e4.node.timestamp = Date.now()), a4;
        } }, default_tty_ops: { get_char: (e4) => (() => {
          if (!be2.length) {
            var e5 = null;
            if ("undefined" != typeof window && "function" == typeof window.prompt ? null !== (e5 = window.prompt("Input: ")) && (e5 += "\n") : "function" == typeof readline && (e5 = readline()) && (e5 += "\n"), !e5) return null;
            be2 = Ae2(e5);
          }
          return be2.shift();
        })(), put_char(e4, t3) {
          null === t3 || 10 === t3 ? (P2(de2(e4.output)), e4.output = []) : 0 != t3 && e4.output.push(t3);
        }, fsync(e4) {
          e4.output && e4.output.length > 0 && (P2(de2(e4.output)), e4.output = []);
        }, ioctl_tcgets: (e4) => ({ c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }), ioctl_tcsets: (e4, t3, n4) => 0, ioctl_tiocgwinsz: (e4) => [24, 80] }, default_tty1_ops: { put_char(e4, t3) {
          null === t3 || 10 === t3 ? (g3(de2(e4.output)), e4.output = []) : 0 != t3 && e4.output.push(t3);
        }, fsync(e4) {
          e4.output && e4.output.length > 0 && (g3(de2(e4.output)), e4.output = []);
        } } }, Ge2 = (e4, t3) => (C2(t3, "alignment argument is required"), Math.ceil(e4 / t3) * t3), Se2 = (e4) => {
          e4 = Ge2(e4, 65536);
          var t3 = nt2(65536, e4);
          return t3 && ((e5, t4) => {
            f2.fill(0, e5, e5 + t4);
          })(t3, e4), t3;
        }, Ce2 = { ops_table: null, mount: (e4) => Ce2.createNode(null, "/", 16895, 0), createNode(e4, t3, n4, r3) {
          if (Oe2.isBlkdev(n4) || Oe2.isFIFO(n4)) throw new Oe2.ErrnoError(63);
          Ce2.ops_table ||= { dir: { node: { getattr: Ce2.node_ops.getattr, setattr: Ce2.node_ops.setattr, lookup: Ce2.node_ops.lookup, mknod: Ce2.node_ops.mknod, rename: Ce2.node_ops.rename, unlink: Ce2.node_ops.unlink, rmdir: Ce2.node_ops.rmdir, readdir: Ce2.node_ops.readdir, symlink: Ce2.node_ops.symlink }, stream: { llseek: Ce2.stream_ops.llseek } }, file: { node: { getattr: Ce2.node_ops.getattr, setattr: Ce2.node_ops.setattr }, stream: { llseek: Ce2.stream_ops.llseek, read: Ce2.stream_ops.read, write: Ce2.stream_ops.write, allocate: Ce2.stream_ops.allocate, mmap: Ce2.stream_ops.mmap, msync: Ce2.stream_ops.msync } }, link: { node: { getattr: Ce2.node_ops.getattr, setattr: Ce2.node_ops.setattr, readlink: Ce2.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: Ce2.node_ops.getattr, setattr: Ce2.node_ops.setattr }, stream: Oe2.chrdev_stream_ops } };
          var o4 = Oe2.createNode(e4, t3, n4, r3);
          return Oe2.isDir(o4.mode) ? (o4.node_ops = Ce2.ops_table.dir.node, o4.stream_ops = Ce2.ops_table.dir.stream, o4.contents = {}) : Oe2.isFile(o4.mode) ? (o4.node_ops = Ce2.ops_table.file.node, o4.stream_ops = Ce2.ops_table.file.stream, o4.usedBytes = 0, o4.contents = null) : Oe2.isLink(o4.mode) ? (o4.node_ops = Ce2.ops_table.link.node, o4.stream_ops = Ce2.ops_table.link.stream) : Oe2.isChrdev(o4.mode) && (o4.node_ops = Ce2.ops_table.chrdev.node, o4.stream_ops = Ce2.ops_table.chrdev.stream), o4.timestamp = Date.now(), e4 && (e4.contents[t3] = o4, e4.timestamp = o4.timestamp), o4;
        }, getFileDataAsTypedArray: (e4) => e4.contents ? e4.contents.subarray ? e4.contents.subarray(0, e4.usedBytes) : new Uint8Array(e4.contents) : new Uint8Array(0), expandFileStorage(e4, t3) {
          var n4 = e4.contents ? e4.contents.length : 0;
          if (!(n4 >= t3)) {
            t3 = Math.max(t3, n4 * (n4 < 1048576 ? 2 : 1.125) >>> 0), 0 != n4 && (t3 = Math.max(t3, 256));
            var r3 = e4.contents;
            e4.contents = new Uint8Array(t3), e4.usedBytes > 0 && e4.contents.set(r3.subarray(0, e4.usedBytes), 0);
          }
        }, resizeFileStorage(e4, t3) {
          if (e4.usedBytes != t3) if (0 == t3) e4.contents = null, e4.usedBytes = 0;
          else {
            var n4 = e4.contents;
            e4.contents = new Uint8Array(t3), n4 && e4.contents.set(n4.subarray(0, Math.min(t3, e4.usedBytes))), e4.usedBytes = t3;
          }
        }, node_ops: { getattr(e4) {
          var t3 = {};
          return t3.dev = Oe2.isChrdev(e4.mode) ? e4.id : 1, t3.ino = e4.id, t3.mode = e4.mode, t3.nlink = 1, t3.uid = 0, t3.gid = 0, t3.rdev = e4.rdev, Oe2.isDir(e4.mode) ? t3.size = 4096 : Oe2.isFile(e4.mode) ? t3.size = e4.usedBytes : Oe2.isLink(e4.mode) ? t3.size = e4.link.length : t3.size = 0, t3.atime = new Date(e4.timestamp), t3.mtime = new Date(e4.timestamp), t3.ctime = new Date(e4.timestamp), t3.blksize = 4096, t3.blocks = Math.ceil(t3.size / t3.blksize), t3;
        }, setattr(e4, t3) {
          void 0 !== t3.mode && (e4.mode = t3.mode), void 0 !== t3.timestamp && (e4.timestamp = t3.timestamp), void 0 !== t3.size && Ce2.resizeFileStorage(e4, t3.size);
        }, lookup(e4, t3) {
          throw Oe2.genericErrors[44];
        }, mknod: (e4, t3, n4, r3) => Ce2.createNode(e4, t3, n4, r3), rename(e4, t3, n4) {
          if (Oe2.isDir(e4.mode)) {
            var r3;
            try {
              r3 = Oe2.lookupNode(t3, n4);
            } catch (e5) {
            }
            if (r3) for (var o4 in r3.contents) throw new Oe2.ErrnoError(55);
          }
          delete e4.parent.contents[e4.name], e4.parent.timestamp = Date.now(), e4.name = n4, t3.contents[n4] = e4, t3.timestamp = e4.parent.timestamp;
        }, unlink(e4, t3) {
          delete e4.contents[t3], e4.timestamp = Date.now();
        }, rmdir(e4, t3) {
          var n4 = Oe2.lookupNode(e4, t3);
          for (var r3 in n4.contents) throw new Oe2.ErrnoError(55);
          delete e4.contents[t3], e4.timestamp = Date.now();
        }, readdir(e4) {
          var t3 = [".", ".."];
          for (var n4 of Object.keys(e4.contents)) t3.push(n4);
          return t3;
        }, symlink(e4, t3, n4) {
          var r3 = Ce2.createNode(e4, t3, 41471, 0);
          return r3.link = n4, r3;
        }, readlink(e4) {
          if (!Oe2.isLink(e4.mode)) throw new Oe2.ErrnoError(28);
          return e4.link;
        } }, stream_ops: { read(e4, t3, n4, r3, o4) {
          var a4 = e4.node.contents;
          if (o4 >= e4.node.usedBytes) return 0;
          var i4 = Math.min(e4.node.usedBytes - o4, r3);
          if (C2(i4 >= 0), i4 > 8 && a4.subarray) t3.set(a4.subarray(o4, o4 + i4), n4);
          else for (var s5 = 0; s5 < i4; s5++) t3[n4 + s5] = a4[o4 + s5];
          return i4;
        }, write(e4, t3, n4, r3, o4, a4) {
          if (C2(!(t3 instanceof ArrayBuffer)), t3.buffer === b2.buffer && (a4 = false), !r3) return 0;
          var i4 = e4.node;
          if (i4.timestamp = Date.now(), t3.subarray && (!i4.contents || i4.contents.subarray)) {
            if (a4) return C2(0 === o4, "canOwn must imply no weird position inside the file"), i4.contents = t3.subarray(n4, n4 + r3), i4.usedBytes = r3, r3;
            if (0 === i4.usedBytes && 0 === o4) return i4.contents = t3.slice(n4, n4 + r3), i4.usedBytes = r3, r3;
            if (o4 + r3 <= i4.usedBytes) return i4.contents.set(t3.subarray(n4, n4 + r3), o4), r3;
          }
          if (Ce2.expandFileStorage(i4, o4 + r3), i4.contents.subarray && t3.subarray) i4.contents.set(t3.subarray(n4, n4 + r3), o4);
          else for (var s5 = 0; s5 < r3; s5++) i4.contents[o4 + s5] = t3[n4 + s5];
          return i4.usedBytes = Math.max(i4.usedBytes, o4 + r3), r3;
        }, llseek(e4, t3, n4) {
          var r3 = t3;
          if (1 === n4 ? r3 += e4.position : 2 === n4 && Oe2.isFile(e4.node.mode) && (r3 += e4.node.usedBytes), r3 < 0) throw new Oe2.ErrnoError(28);
          return r3;
        }, allocate(e4, t3, n4) {
          Ce2.expandFileStorage(e4.node, t3 + n4), e4.node.usedBytes = Math.max(e4.node.usedBytes, t3 + n4);
        }, mmap(e4, t3, n4, r3, o4) {
          if (!Oe2.isFile(e4.node.mode)) throw new Oe2.ErrnoError(43);
          var a4, i4, s5 = e4.node.contents;
          if (2 & o4 || !s5 || s5.buffer !== b2.buffer) {
            if (i4 = true, !(a4 = Se2(t3))) throw new Oe2.ErrnoError(48);
            s5 && ((n4 > 0 || n4 + t3 < s5.length) && (s5 = s5.subarray ? s5.subarray(n4, n4 + t3) : Array.prototype.slice.call(s5, n4, n4 + t3)), b2.set(s5, a4));
          } else i4 = false, a4 = s5.byteOffset;
          return { ptr: a4, allocated: i4 };
        }, msync: (e4, t3, n4, r3, o4) => (Ce2.stream_ops.write(e4, t3, 0, r3, n4, false), 0) } }, Te2 = o3.preloadPlugins || [], xe2 = (e4, t3) => {
          var n4 = 0;
          return e4 && (n4 |= 365), t3 && (n4 |= 146), n4;
        }, ve2 = { EPERM: 63, ENOENT: 44, ESRCH: 71, EINTR: 27, EIO: 29, ENXIO: 60, E2BIG: 1, ENOEXEC: 45, EBADF: 8, ECHILD: 12, EAGAIN: 6, EWOULDBLOCK: 6, ENOMEM: 48, EACCES: 2, EFAULT: 21, ENOTBLK: 105, EBUSY: 10, EEXIST: 20, EXDEV: 75, ENODEV: 43, ENOTDIR: 54, EISDIR: 31, EINVAL: 28, ENFILE: 41, EMFILE: 33, ENOTTY: 59, ETXTBSY: 74, EFBIG: 22, ENOSPC: 51, ESPIPE: 70, EROFS: 69, EMLINK: 34, EPIPE: 64, EDOM: 18, ERANGE: 68, ENOMSG: 49, EIDRM: 24, ECHRNG: 106, EL2NSYNC: 156, EL3HLT: 107, EL3RST: 108, ELNRNG: 109, EUNATCH: 110, ENOCSI: 111, EL2HLT: 112, EDEADLK: 16, ENOLCK: 46, EBADE: 113, EBADR: 114, EXFULL: 115, ENOANO: 104, EBADRQC: 103, EBADSLT: 102, EDEADLOCK: 16, EBFONT: 101, ENOSTR: 100, ENODATA: 116, ETIME: 117, ENOSR: 118, ENONET: 119, ENOPKG: 120, EREMOTE: 121, ENOLINK: 47, EADV: 122, ESRMNT: 123, ECOMM: 124, EPROTO: 65, EMULTIHOP: 36, EDOTDOT: 125, EBADMSG: 9, ENOTUNIQ: 126, EBADFD: 127, EREMCHG: 128, ELIBACC: 129, ELIBBAD: 130, ELIBSCN: 131, ELIBMAX: 132, ELIBEXEC: 133, ENOSYS: 52, ENOTEMPTY: 55, ENAMETOOLONG: 37, ELOOP: 32, EOPNOTSUPP: 138, EPFNOSUPPORT: 139, ECONNRESET: 15, ENOBUFS: 42, EAFNOSUPPORT: 5, EPROTOTYPE: 67, ENOTSOCK: 57, ENOPROTOOPT: 50, ESHUTDOWN: 140, ECONNREFUSED: 14, EADDRINUSE: 3, ECONNABORTED: 13, ENETUNREACH: 40, ENETDOWN: 38, ETIMEDOUT: 73, EHOSTDOWN: 142, EHOSTUNREACH: 23, EINPROGRESS: 26, EALREADY: 7, EDESTADDRREQ: 17, EMSGSIZE: 35, EPROTONOSUPPORT: 66, ESOCKTNOSUPPORT: 137, EADDRNOTAVAIL: 4, ENETRESET: 39, EISCONN: 30, ENOTCONN: 53, ETOOMANYREFS: 141, EUSERS: 136, EDQUOT: 19, ESTALE: 72, ENOTSUP: 138, ENOMEDIUM: 148, EILSEQ: 25, EOVERFLOW: 61, ECANCELED: 11, ENOTRECOVERABLE: 56, EOWNERDEAD: 62, ESTRPIPE: 135 }, Oe2 = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: class extends Error {
          constructor(e4) {
            for (var t3 in super(w2 ? ((e5) => _e2(rt2(e5)))(e4) : ""), this.name = "ErrnoError", this.errno = e4, ve2) if (ve2[t3] === e4) {
              this.code = t3;
              break;
            }
          }
        }, genericErrors: {}, filesystems: null, syncFSRequests: 0, readFiles: {}, FSStream: class {
          constructor() {
            this.shared = {};
          }
          get object() {
            return this.node;
          }
          set object(e4) {
            this.node = e4;
          }
          get isRead() {
            return 1 != (2097155 & this.flags);
          }
          get isWrite() {
            return !!(2097155 & this.flags);
          }
          get isAppend() {
            return 1024 & this.flags;
          }
          get flags() {
            return this.shared.flags;
          }
          set flags(e4) {
            this.shared.flags = e4;
          }
          get position() {
            return this.shared.position;
          }
          set position(e4) {
            this.shared.position = e4;
          }
        }, FSNode: class {
          constructor(e4, t3, n4, r3) {
            e4 || (e4 = this), this.parent = e4, this.mount = e4.mount, this.mounted = null, this.id = Oe2.nextInode++, this.name = t3, this.mode = n4, this.node_ops = {}, this.stream_ops = {}, this.rdev = r3, this.readMode = 365, this.writeMode = 146;
          }
          get read() {
            return (this.mode & this.readMode) === this.readMode;
          }
          set read(e4) {
            e4 ? this.mode |= this.readMode : this.mode &= ~this.readMode;
          }
          get write() {
            return (this.mode & this.writeMode) === this.writeMode;
          }
          set write(e4) {
            e4 ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
          }
          get isFolder() {
            return Oe2.isDir(this.mode);
          }
          get isDevice() {
            return Oe2.isChrdev(this.mode);
          }
        }, lookupPath(e4, t3 = {}) {
          if (!(e4 = De2.resolve(e4))) return { path: "", node: null };
          if ((t3 = Object.assign({ follow_mount: true, recurse_count: 0 }, t3)).recurse_count > 8) throw new Oe2.ErrnoError(32);
          for (var n4 = e4.split("/").filter((e5) => !!e5), r3 = Oe2.root, o4 = "/", a4 = 0; a4 < n4.length; a4++) {
            var i4 = a4 === n4.length - 1;
            if (i4 && t3.parent) break;
            if (r3 = Oe2.lookupNode(r3, n4[a4]), o4 = ge2.join2(o4, n4[a4]), Oe2.isMountpoint(r3) && (!i4 || i4 && t3.follow_mount) && (r3 = r3.mounted.root), !i4 || t3.follow) for (var s5 = 0; Oe2.isLink(r3.mode); ) {
              var u5 = Oe2.readlink(o4);
              if (o4 = De2.resolve(ge2.dirname(o4), u5), r3 = Oe2.lookupPath(o4, { recurse_count: t3.recurse_count + 1 }).node, s5++ > 40) throw new Oe2.ErrnoError(32);
            }
          }
          return { path: o4, node: r3 };
        }, getPath(e4) {
          for (var t3; ; ) {
            if (Oe2.isRoot(e4)) {
              var n4 = e4.mount.mountpoint;
              return t3 ? "/" !== n4[n4.length - 1] ? `${n4}/${t3}` : n4 + t3 : n4;
            }
            t3 = t3 ? `${e4.name}/${t3}` : e4.name, e4 = e4.parent;
          }
        }, hashName(e4, t3) {
          for (var n4 = 0, r3 = 0; r3 < t3.length; r3++) n4 = (n4 << 5) - n4 + t3.charCodeAt(r3) | 0;
          return (e4 + n4 >>> 0) % Oe2.nameTable.length;
        }, hashAddNode(e4) {
          var t3 = Oe2.hashName(e4.parent.id, e4.name);
          e4.name_next = Oe2.nameTable[t3], Oe2.nameTable[t3] = e4;
        }, hashRemoveNode(e4) {
          var t3 = Oe2.hashName(e4.parent.id, e4.name);
          if (Oe2.nameTable[t3] === e4) Oe2.nameTable[t3] = e4.name_next;
          else for (var n4 = Oe2.nameTable[t3]; n4; ) {
            if (n4.name_next === e4) {
              n4.name_next = e4.name_next;
              break;
            }
            n4 = n4.name_next;
          }
        }, lookupNode(e4, t3) {
          var n4 = Oe2.mayLookup(e4);
          if (n4) throw new Oe2.ErrnoError(n4);
          for (var r3 = Oe2.hashName(e4.id, t3), o4 = Oe2.nameTable[r3]; o4; o4 = o4.name_next) {
            var a4 = o4.name;
            if (o4.parent.id === e4.id && a4 === t3) return o4;
          }
          return Oe2.lookup(e4, t3);
        }, createNode(e4, t3, n4, r3) {
          C2("object" == typeof e4);
          var o4 = new Oe2.FSNode(e4, t3, n4, r3);
          return Oe2.hashAddNode(o4), o4;
        }, destroyNode(e4) {
          Oe2.hashRemoveNode(e4);
        }, isRoot: (e4) => e4 === e4.parent, isMountpoint: (e4) => !!e4.mounted, isFile: (e4) => 32768 == (61440 & e4), isDir: (e4) => 16384 == (61440 & e4), isLink: (e4) => 40960 == (61440 & e4), isChrdev: (e4) => 8192 == (61440 & e4), isBlkdev: (e4) => 24576 == (61440 & e4), isFIFO: (e4) => 4096 == (61440 & e4), isSocket: (e4) => !(49152 & ~e4), flagsToPermissionString(e4) {
          var t3 = ["r", "w", "rw"][3 & e4];
          return 512 & e4 && (t3 += "w"), t3;
        }, nodePermissions: (e4, t3) => Oe2.ignorePermissions || (!t3.includes("r") || 292 & e4.mode) && (!t3.includes("w") || 146 & e4.mode) && (!t3.includes("x") || 73 & e4.mode) ? 0 : 2, mayLookup(e4) {
          if (!Oe2.isDir(e4.mode)) return 54;
          var t3 = Oe2.nodePermissions(e4, "x");
          return t3 || (e4.node_ops.lookup ? 0 : 2);
        }, mayCreate(e4, t3) {
          try {
            return Oe2.lookupNode(e4, t3), 20;
          } catch (e5) {
          }
          return Oe2.nodePermissions(e4, "wx");
        }, mayDelete(e4, t3, n4) {
          var r3;
          try {
            r3 = Oe2.lookupNode(e4, t3);
          } catch (e5) {
            return e5.errno;
          }
          var o4 = Oe2.nodePermissions(e4, "wx");
          if (o4) return o4;
          if (n4) {
            if (!Oe2.isDir(r3.mode)) return 54;
            if (Oe2.isRoot(r3) || Oe2.getPath(r3) === Oe2.cwd()) return 10;
          } else if (Oe2.isDir(r3.mode)) return 31;
          return 0;
        }, mayOpen: (e4, t3) => e4 ? Oe2.isLink(e4.mode) ? 32 : Oe2.isDir(e4.mode) && ("r" !== Oe2.flagsToPermissionString(t3) || 512 & t3) ? 31 : Oe2.nodePermissions(e4, Oe2.flagsToPermissionString(t3)) : 44, MAX_OPEN_FDS: 4096, nextfd() {
          for (var e4 = 0; e4 <= Oe2.MAX_OPEN_FDS; e4++) if (!Oe2.streams[e4]) return e4;
          throw new Oe2.ErrnoError(33);
        }, getStreamChecked(e4) {
          var t3 = Oe2.getStream(e4);
          if (!t3) throw new Oe2.ErrnoError(8);
          return t3;
        }, getStream: (e4) => Oe2.streams[e4], createStream: (e4, t3 = -1) => (C2(t3 >= -1), e4 = Object.assign(new Oe2.FSStream(), e4), -1 == t3 && (t3 = Oe2.nextfd()), e4.fd = t3, Oe2.streams[t3] = e4, e4), closeStream(e4) {
          Oe2.streams[e4] = null;
        }, dupStream(e4, t3 = -1) {
          var n4 = Oe2.createStream(e4, t3);
          return n4.stream_ops?.dup?.(n4), n4;
        }, chrdev_stream_ops: { open(e4) {
          var t3 = Oe2.getDevice(e4.node.rdev);
          e4.stream_ops = t3.stream_ops, e4.stream_ops.open?.(e4);
        }, llseek() {
          throw new Oe2.ErrnoError(70);
        } }, major: (e4) => e4 >> 8, minor: (e4) => 255 & e4, makedev: (e4, t3) => e4 << 8 | t3, registerDevice(e4, t3) {
          Oe2.devices[e4] = { stream_ops: t3 };
        }, getDevice: (e4) => Oe2.devices[e4], getMounts(e4) {
          for (var t3 = [], n4 = [e4]; n4.length; ) {
            var r3 = n4.pop();
            t3.push(r3), n4.push(...r3.mounts);
          }
          return t3;
        }, syncfs(e4, t3) {
          "function" == typeof e4 && (t3 = e4, e4 = false), Oe2.syncFSRequests++, Oe2.syncFSRequests > 1 && g3(`warning: ${Oe2.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
          var n4 = Oe2.getMounts(Oe2.root.mount), r3 = 0;
          function o4(e5) {
            return C2(Oe2.syncFSRequests > 0), Oe2.syncFSRequests--, t3(e5);
          }
          function a4(e5) {
            if (e5) return a4.errored ? void 0 : (a4.errored = true, o4(e5));
            ++r3 >= n4.length && o4(null);
          }
          n4.forEach((t4) => {
            if (!t4.type.syncfs) return a4(null);
            t4.type.syncfs(t4, e4, a4);
          });
        }, mount(e4, t3, n4) {
          if ("string" == typeof e4) throw e4;
          var r3, o4 = "/" === n4, a4 = !n4;
          if (o4 && Oe2.root) throw new Oe2.ErrnoError(10);
          if (!o4 && !a4) {
            var i4 = Oe2.lookupPath(n4, { follow_mount: false });
            if (n4 = i4.path, r3 = i4.node, Oe2.isMountpoint(r3)) throw new Oe2.ErrnoError(10);
            if (!Oe2.isDir(r3.mode)) throw new Oe2.ErrnoError(54);
          }
          var s5 = { type: e4, opts: t3, mountpoint: n4, mounts: [] }, u5 = e4.mount(s5);
          return u5.mount = s5, s5.root = u5, o4 ? Oe2.root = u5 : r3 && (r3.mounted = s5, r3.mount && r3.mount.mounts.push(s5)), u5;
        }, unmount(e4) {
          var t3 = Oe2.lookupPath(e4, { follow_mount: false });
          if (!Oe2.isMountpoint(t3.node)) throw new Oe2.ErrnoError(28);
          var n4 = t3.node, r3 = n4.mounted, o4 = Oe2.getMounts(r3);
          Object.keys(Oe2.nameTable).forEach((e5) => {
            for (var t4 = Oe2.nameTable[e5]; t4; ) {
              var n5 = t4.name_next;
              o4.includes(t4.mount) && Oe2.destroyNode(t4), t4 = n5;
            }
          }), n4.mounted = null;
          var a4 = n4.mount.mounts.indexOf(r3);
          C2(-1 !== a4), n4.mount.mounts.splice(a4, 1);
        }, lookup: (e4, t3) => e4.node_ops.lookup(e4, t3), mknod(e4, t3, n4) {
          var r3 = Oe2.lookupPath(e4, { parent: true }).node, o4 = ge2.basename(e4);
          if (!o4 || "." === o4 || ".." === o4) throw new Oe2.ErrnoError(28);
          var a4 = Oe2.mayCreate(r3, o4);
          if (a4) throw new Oe2.ErrnoError(a4);
          if (!r3.node_ops.mknod) throw new Oe2.ErrnoError(63);
          return r3.node_ops.mknod(r3, o4, t3, n4);
        }, create: (e4, t3) => (t3 = void 0 !== t3 ? t3 : 438, t3 &= 4095, t3 |= 32768, Oe2.mknod(e4, t3, 0)), mkdir: (e4, t3) => (t3 = void 0 !== t3 ? t3 : 511, t3 &= 1023, t3 |= 16384, Oe2.mknod(e4, t3, 0)), mkdirTree(e4, t3) {
          for (var n4 = e4.split("/"), r3 = "", o4 = 0; o4 < n4.length; ++o4) if (n4[o4]) {
            r3 += "/" + n4[o4];
            try {
              Oe2.mkdir(r3, t3);
            } catch (e5) {
              if (20 != e5.errno) throw e5;
            }
          }
        }, mkdev: (e4, t3, n4) => (void 0 === n4 && (n4 = t3, t3 = 438), t3 |= 8192, Oe2.mknod(e4, t3, n4)), symlink(e4, t3) {
          if (!De2.resolve(e4)) throw new Oe2.ErrnoError(44);
          var n4 = Oe2.lookupPath(t3, { parent: true }).node;
          if (!n4) throw new Oe2.ErrnoError(44);
          var r3 = ge2.basename(t3), o4 = Oe2.mayCreate(n4, r3);
          if (o4) throw new Oe2.ErrnoError(o4);
          if (!n4.node_ops.symlink) throw new Oe2.ErrnoError(63);
          return n4.node_ops.symlink(n4, r3, e4);
        }, rename(e4, t3) {
          var n4, r3, o4 = ge2.dirname(e4), a4 = ge2.dirname(t3), i4 = ge2.basename(e4), s5 = ge2.basename(t3);
          if (n4 = Oe2.lookupPath(e4, { parent: true }).node, r3 = Oe2.lookupPath(t3, { parent: true }).node, !n4 || !r3) throw new Oe2.ErrnoError(44);
          if (n4.mount !== r3.mount) throw new Oe2.ErrnoError(75);
          var u5, F3 = Oe2.lookupNode(n4, i4), m4 = De2.relative(e4, a4);
          if ("." !== m4.charAt(0)) throw new Oe2.ErrnoError(28);
          if ("." !== (m4 = De2.relative(t3, o4)).charAt(0)) throw new Oe2.ErrnoError(55);
          try {
            u5 = Oe2.lookupNode(r3, s5);
          } catch (e5) {
          }
          if (F3 !== u5) {
            var l5 = Oe2.isDir(F3.mode), d5 = Oe2.mayDelete(n4, i4, l5);
            if (d5) throw new Oe2.ErrnoError(d5);
            if (d5 = u5 ? Oe2.mayDelete(r3, s5, l5) : Oe2.mayCreate(r3, s5)) throw new Oe2.ErrnoError(d5);
            if (!n4.node_ops.rename) throw new Oe2.ErrnoError(63);
            if (Oe2.isMountpoint(F3) || u5 && Oe2.isMountpoint(u5)) throw new Oe2.ErrnoError(10);
            if (r3 !== n4 && (d5 = Oe2.nodePermissions(n4, "w"))) throw new Oe2.ErrnoError(d5);
            Oe2.hashRemoveNode(F3);
            try {
              n4.node_ops.rename(F3, r3, s5), F3.parent = r3;
            } catch (e5) {
              throw e5;
            } finally {
              Oe2.hashAddNode(F3);
            }
          }
        }, rmdir(e4) {
          var t3 = Oe2.lookupPath(e4, { parent: true }).node, n4 = ge2.basename(e4), r3 = Oe2.lookupNode(t3, n4), o4 = Oe2.mayDelete(t3, n4, true);
          if (o4) throw new Oe2.ErrnoError(o4);
          if (!t3.node_ops.rmdir) throw new Oe2.ErrnoError(63);
          if (Oe2.isMountpoint(r3)) throw new Oe2.ErrnoError(10);
          t3.node_ops.rmdir(t3, n4), Oe2.destroyNode(r3);
        }, readdir(e4) {
          var t3 = Oe2.lookupPath(e4, { follow: true }).node;
          if (!t3.node_ops.readdir) throw new Oe2.ErrnoError(54);
          return t3.node_ops.readdir(t3);
        }, unlink(e4) {
          var t3 = Oe2.lookupPath(e4, { parent: true }).node;
          if (!t3) throw new Oe2.ErrnoError(44);
          var n4 = ge2.basename(e4), r3 = Oe2.lookupNode(t3, n4), o4 = Oe2.mayDelete(t3, n4, false);
          if (o4) throw new Oe2.ErrnoError(o4);
          if (!t3.node_ops.unlink) throw new Oe2.ErrnoError(63);
          if (Oe2.isMountpoint(r3)) throw new Oe2.ErrnoError(10);
          t3.node_ops.unlink(t3, n4), Oe2.destroyNode(r3);
        }, readlink(e4) {
          var t3 = Oe2.lookupPath(e4).node;
          if (!t3) throw new Oe2.ErrnoError(44);
          if (!t3.node_ops.readlink) throw new Oe2.ErrnoError(28);
          return De2.resolve(Oe2.getPath(t3.parent), t3.node_ops.readlink(t3));
        }, stat(e4, t3) {
          var n4 = Oe2.lookupPath(e4, { follow: !t3 }).node;
          if (!n4) throw new Oe2.ErrnoError(44);
          if (!n4.node_ops.getattr) throw new Oe2.ErrnoError(63);
          return n4.node_ops.getattr(n4);
        }, lstat: (e4) => Oe2.stat(e4, true), chmod(e4, t3, n4) {
          var r3;
          if (!(r3 = "string" == typeof e4 ? Oe2.lookupPath(e4, { follow: !n4 }).node : e4).node_ops.setattr) throw new Oe2.ErrnoError(63);
          r3.node_ops.setattr(r3, { mode: 4095 & t3 | -4096 & r3.mode, timestamp: Date.now() });
        }, lchmod(e4, t3) {
          Oe2.chmod(e4, t3, true);
        }, fchmod(e4, t3) {
          var n4 = Oe2.getStreamChecked(e4);
          Oe2.chmod(n4.node, t3);
        }, chown(e4, t3, n4, r3) {
          var o4;
          if (!(o4 = "string" == typeof e4 ? Oe2.lookupPath(e4, { follow: !r3 }).node : e4).node_ops.setattr) throw new Oe2.ErrnoError(63);
          o4.node_ops.setattr(o4, { timestamp: Date.now() });
        }, lchown(e4, t3, n4) {
          Oe2.chown(e4, t3, n4, true);
        }, fchown(e4, t3, n4) {
          var r3 = Oe2.getStreamChecked(e4);
          Oe2.chown(r3.node, t3, n4);
        }, truncate(e4, t3) {
          if (t3 < 0) throw new Oe2.ErrnoError(28);
          var n4;
          if (!(n4 = "string" == typeof e4 ? Oe2.lookupPath(e4, { follow: true }).node : e4).node_ops.setattr) throw new Oe2.ErrnoError(63);
          if (Oe2.isDir(n4.mode)) throw new Oe2.ErrnoError(31);
          if (!Oe2.isFile(n4.mode)) throw new Oe2.ErrnoError(28);
          var r3 = Oe2.nodePermissions(n4, "w");
          if (r3) throw new Oe2.ErrnoError(r3);
          n4.node_ops.setattr(n4, { size: t3, timestamp: Date.now() });
        }, ftruncate(e4, t3) {
          var n4 = Oe2.getStreamChecked(e4);
          if (!(2097155 & n4.flags)) throw new Oe2.ErrnoError(28);
          Oe2.truncate(n4.node, t3);
        }, utime(e4, t3, n4) {
          var r3 = Oe2.lookupPath(e4, { follow: true }).node;
          r3.node_ops.setattr(r3, { timestamp: Math.max(t3, n4) });
        }, open(e4, t3, n4) {
          if ("" === e4) throw new Oe2.ErrnoError(44);
          var r3;
          if (n4 = 64 & (t3 = "string" == typeof t3 ? ((e5) => {
            var t4 = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }[e5];
            if (void 0 === t4) throw new Error(`Unknown file open mode: ${e5}`);
            return t4;
          })(t3) : t3) ? 4095 & (n4 = void 0 === n4 ? 438 : n4) | 32768 : 0, "object" == typeof e4) r3 = e4;
          else {
            e4 = ge2.normalize(e4);
            try {
              r3 = Oe2.lookupPath(e4, { follow: !(131072 & t3) }).node;
            } catch (e5) {
            }
          }
          var a4 = false;
          if (64 & t3) if (r3) {
            if (128 & t3) throw new Oe2.ErrnoError(20);
          } else r3 = Oe2.mknod(e4, n4, 0), a4 = true;
          if (!r3) throw new Oe2.ErrnoError(44);
          if (Oe2.isChrdev(r3.mode) && (t3 &= -513), 65536 & t3 && !Oe2.isDir(r3.mode)) throw new Oe2.ErrnoError(54);
          if (!a4) {
            var i4 = Oe2.mayOpen(r3, t3);
            if (i4) throw new Oe2.ErrnoError(i4);
          }
          512 & t3 && !a4 && Oe2.truncate(r3, 0), t3 &= -131713;
          var s5 = Oe2.createStream({ node: r3, path: Oe2.getPath(r3), flags: t3, seekable: true, position: 0, stream_ops: r3.stream_ops, ungotten: [], error: false });
          return s5.stream_ops.open && s5.stream_ops.open(s5), !o3.logReadFiles || 1 & t3 || e4 in Oe2.readFiles || (Oe2.readFiles[e4] = 1), s5;
        }, close(e4) {
          if (Oe2.isClosed(e4)) throw new Oe2.ErrnoError(8);
          e4.getdents && (e4.getdents = null);
          try {
            e4.stream_ops.close && e4.stream_ops.close(e4);
          } catch (e5) {
            throw e5;
          } finally {
            Oe2.closeStream(e4.fd);
          }
          e4.fd = null;
        }, isClosed: (e4) => null === e4.fd, llseek(e4, t3, n4) {
          if (Oe2.isClosed(e4)) throw new Oe2.ErrnoError(8);
          if (!e4.seekable || !e4.stream_ops.llseek) throw new Oe2.ErrnoError(70);
          if (0 != n4 && 1 != n4 && 2 != n4) throw new Oe2.ErrnoError(28);
          return e4.position = e4.stream_ops.llseek(e4, t3, n4), e4.ungotten = [], e4.position;
        }, read(e4, t3, n4, r3, o4) {
          if (C2(n4 >= 0), r3 < 0 || o4 < 0) throw new Oe2.ErrnoError(28);
          if (Oe2.isClosed(e4)) throw new Oe2.ErrnoError(8);
          if (1 == (2097155 & e4.flags)) throw new Oe2.ErrnoError(8);
          if (Oe2.isDir(e4.node.mode)) throw new Oe2.ErrnoError(31);
          if (!e4.stream_ops.read) throw new Oe2.ErrnoError(28);
          var a4 = void 0 !== o4;
          if (a4) {
            if (!e4.seekable) throw new Oe2.ErrnoError(70);
          } else o4 = e4.position;
          var i4 = e4.stream_ops.read(e4, t3, n4, r3, o4);
          return a4 || (e4.position += i4), i4;
        }, write(e4, t3, n4, r3, o4, a4) {
          if (C2(n4 >= 0), r3 < 0 || o4 < 0) throw new Oe2.ErrnoError(28);
          if (Oe2.isClosed(e4)) throw new Oe2.ErrnoError(8);
          if (!(2097155 & e4.flags)) throw new Oe2.ErrnoError(8);
          if (Oe2.isDir(e4.node.mode)) throw new Oe2.ErrnoError(31);
          if (!e4.stream_ops.write) throw new Oe2.ErrnoError(28);
          e4.seekable && 1024 & e4.flags && Oe2.llseek(e4, 0, 2);
          var i4 = void 0 !== o4;
          if (i4) {
            if (!e4.seekable) throw new Oe2.ErrnoError(70);
          } else o4 = e4.position;
          var s5 = e4.stream_ops.write(e4, t3, n4, r3, o4, a4);
          return i4 || (e4.position += s5), s5;
        }, allocate(e4, t3, n4) {
          if (Oe2.isClosed(e4)) throw new Oe2.ErrnoError(8);
          if (t3 < 0 || n4 <= 0) throw new Oe2.ErrnoError(28);
          if (!(2097155 & e4.flags)) throw new Oe2.ErrnoError(8);
          if (!Oe2.isFile(e4.node.mode) && !Oe2.isDir(e4.node.mode)) throw new Oe2.ErrnoError(43);
          if (!e4.stream_ops.allocate) throw new Oe2.ErrnoError(138);
          e4.stream_ops.allocate(e4, t3, n4);
        }, mmap(e4, t3, n4, r3, o4) {
          if (2 & r3 && !(2 & o4) && 2 != (2097155 & e4.flags)) throw new Oe2.ErrnoError(2);
          if (1 == (2097155 & e4.flags)) throw new Oe2.ErrnoError(2);
          if (!e4.stream_ops.mmap) throw new Oe2.ErrnoError(43);
          if (!t3) throw new Oe2.ErrnoError(28);
          return e4.stream_ops.mmap(e4, t3, n4, r3, o4);
        }, msync: (e4, t3, n4, r3, o4) => (C2(n4 >= 0), e4.stream_ops.msync ? e4.stream_ops.msync(e4, t3, n4, r3, o4) : 0), ioctl(e4, t3, n4) {
          if (!e4.stream_ops.ioctl) throw new Oe2.ErrnoError(59);
          return e4.stream_ops.ioctl(e4, t3, n4);
        }, readFile(e4, t3 = {}) {
          if (t3.flags = t3.flags || 0, t3.encoding = t3.encoding || "binary", "utf8" !== t3.encoding && "binary" !== t3.encoding) throw new Error(`Invalid encoding type "${t3.encoding}"`);
          var n4, r3 = Oe2.open(e4, t3.flags), o4 = Oe2.stat(e4).size, a4 = new Uint8Array(o4);
          return Oe2.read(r3, a4, 0, o4, 0), "utf8" === t3.encoding ? n4 = de2(a4) : "binary" === t3.encoding && (n4 = a4), Oe2.close(r3), n4;
        }, writeFile(e4, t3, n4 = {}) {
          n4.flags = n4.flags || 577;
          var r3 = Oe2.open(e4, n4.flags, n4.mode);
          if ("string" == typeof t3) {
            var o4 = new Uint8Array(fe2(t3) + 1), a4 = pe2(t3, o4, 0, o4.length);
            Oe2.write(r3, o4, 0, a4, void 0, n4.canOwn);
          } else {
            if (!ArrayBuffer.isView(t3)) throw new Error("Unsupported data type");
            Oe2.write(r3, t3, 0, t3.byteLength, void 0, n4.canOwn);
          }
          Oe2.close(r3);
        }, cwd: () => Oe2.currentPath, chdir(e4) {
          var t3 = Oe2.lookupPath(e4, { follow: true });
          if (null === t3.node) throw new Oe2.ErrnoError(44);
          if (!Oe2.isDir(t3.node.mode)) throw new Oe2.ErrnoError(54);
          var n4 = Oe2.nodePermissions(t3.node, "x");
          if (n4) throw new Oe2.ErrnoError(n4);
          Oe2.currentPath = t3.path;
        }, createDefaultDirectories() {
          Oe2.mkdir("/tmp"), Oe2.mkdir("/home"), Oe2.mkdir("/home/web_user");
        }, createDefaultDevices() {
          Oe2.mkdir("/dev"), Oe2.registerDevice(Oe2.makedev(1, 3), { read: () => 0, write: (e5, t4, n5, r3, o4) => r3 }), Oe2.mkdev("/dev/null", Oe2.makedev(1, 3)), ye2.register(Oe2.makedev(5, 0), ye2.default_tty_ops), ye2.register(Oe2.makedev(6, 0), ye2.default_tty1_ops), Oe2.mkdev("/dev/tty", Oe2.makedev(5, 0)), Oe2.mkdev("/dev/tty1", Oe2.makedev(6, 0));
          var e4 = new Uint8Array(1024), t3 = 0, n4 = () => (0 === t3 && (t3 = he2(e4).byteLength), e4[--t3]);
          Oe2.createDevice("/dev", "random", n4), Oe2.createDevice("/dev", "urandom", n4), Oe2.mkdir("/dev/shm"), Oe2.mkdir("/dev/shm/tmp");
        }, createSpecialDirectories() {
          Oe2.mkdir("/proc");
          var e4 = Oe2.mkdir("/proc/self");
          Oe2.mkdir("/proc/self/fd"), Oe2.mount({ mount() {
            var t3 = Oe2.createNode(e4, "fd", 16895, 73);
            return t3.node_ops = { lookup(e5, t4) {
              var n4 = +t4, r3 = Oe2.getStreamChecked(n4), o4 = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => r3.path } };
              return o4.parent = o4, o4;
            } }, t3;
          } }, {}, "/proc/self/fd");
        }, createStandardStreams(e4, t3, n4) {
          e4 ? Oe2.createDevice("/dev", "stdin", e4) : Oe2.symlink("/dev/tty", "/dev/stdin"), t3 ? Oe2.createDevice("/dev", "stdout", null, t3) : Oe2.symlink("/dev/tty", "/dev/stdout"), n4 ? Oe2.createDevice("/dev", "stderr", null, n4) : Oe2.symlink("/dev/tty1", "/dev/stderr");
          var r3 = Oe2.open("/dev/stdin", 0), o4 = Oe2.open("/dev/stdout", 1), a4 = Oe2.open("/dev/stderr", 1);
          C2(0 === r3.fd, `invalid handle for stdin (${r3.fd})`), C2(1 === o4.fd, `invalid handle for stdout (${o4.fd})`), C2(2 === a4.fd, `invalid handle for stderr (${a4.fd})`);
        }, staticInit() {
          [44].forEach((e4) => {
            Oe2.genericErrors[e4] = new Oe2.ErrnoError(e4), Oe2.genericErrors[e4].stack = "<generic error, no stack>";
          }), Oe2.nameTable = new Array(4096), Oe2.mount(Ce2, {}, "/"), Oe2.createDefaultDirectories(), Oe2.createDefaultDevices(), Oe2.createSpecialDirectories(), Oe2.filesystems = { MEMFS: Ce2 };
        }, init(e4, t3, n4) {
          C2(!Oe2.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)"), Oe2.initialized = true, e4 ??= o3.stdin, t3 ??= o3.stdout, n4 ??= o3.stderr, Oe2.createStandardStreams(e4, t3, n4);
        }, quit() {
          Oe2.initialized = false, tt2(0);
          for (var e4 = 0; e4 < Oe2.streams.length; e4++) {
            var t3 = Oe2.streams[e4];
            t3 && Oe2.close(t3);
          }
        }, findObject(e4, t3) {
          var n4 = Oe2.analyzePath(e4, t3);
          return n4.exists ? n4.object : null;
        }, analyzePath(e4, t3) {
          try {
            e4 = (r3 = Oe2.lookupPath(e4, { follow: !t3 })).path;
          } catch (e5) {
          }
          var n4 = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
          try {
            var r3 = Oe2.lookupPath(e4, { parent: true });
            n4.parentExists = true, n4.parentPath = r3.path, n4.parentObject = r3.node, n4.name = ge2.basename(e4), r3 = Oe2.lookupPath(e4, { follow: !t3 }), n4.exists = true, n4.path = r3.path, n4.object = r3.node, n4.name = r3.node.name, n4.isRoot = "/" === r3.path;
          } catch (e5) {
            n4.error = e5.errno;
          }
          return n4;
        }, createPath(e4, t3, n4, r3) {
          e4 = "string" == typeof e4 ? e4 : Oe2.getPath(e4);
          for (var o4 = t3.split("/").reverse(); o4.length; ) {
            var a4 = o4.pop();
            if (a4) {
              var i4 = ge2.join2(e4, a4);
              try {
                Oe2.mkdir(i4);
              } catch (e5) {
              }
              e4 = i4;
            }
          }
          return i4;
        }, createFile(e4, t3, n4, r3, o4) {
          var a4 = ge2.join2("string" == typeof e4 ? e4 : Oe2.getPath(e4), t3), i4 = xe2(r3, o4);
          return Oe2.create(a4, i4);
        }, createDataFile(e4, t3, n4, r3, o4, a4) {
          var i4 = t3;
          e4 && (e4 = "string" == typeof e4 ? e4 : Oe2.getPath(e4), i4 = t3 ? ge2.join2(e4, t3) : e4);
          var s5 = xe2(r3, o4), u5 = Oe2.create(i4, s5);
          if (n4) {
            if ("string" == typeof n4) {
              for (var F3 = new Array(n4.length), m4 = 0, l5 = n4.length; m4 < l5; ++m4) F3[m4] = n4.charCodeAt(m4);
              n4 = F3;
            }
            Oe2.chmod(u5, 146 | s5);
            var d5 = Oe2.open(u5, 577);
            Oe2.write(d5, n4, 0, n4.length, 0, a4), Oe2.close(d5), Oe2.chmod(u5, s5);
          }
        }, createDevice(e4, t3, n4, r3) {
          var o4 = ge2.join2("string" == typeof e4 ? e4 : Oe2.getPath(e4), t3), a4 = xe2(!!n4, !!r3);
          Oe2.createDevice.major ??= 64;
          var i4 = Oe2.makedev(Oe2.createDevice.major++, 0);
          return Oe2.registerDevice(i4, { open(e5) {
            e5.seekable = false;
          }, close(e5) {
            r3?.buffer?.length && r3(10);
          }, read(e5, t4, r4, o5, a5) {
            for (var i5 = 0, s5 = 0; s5 < o5; s5++) {
              var u5;
              try {
                u5 = n4();
              } catch (e6) {
                throw new Oe2.ErrnoError(29);
              }
              if (void 0 === u5 && 0 === i5) throw new Oe2.ErrnoError(6);
              if (null == u5) break;
              i5++, t4[r4 + s5] = u5;
            }
            return i5 && (e5.node.timestamp = Date.now()), i5;
          }, write(e5, t4, n5, o5, a5) {
            for (var i5 = 0; i5 < o5; i5++) try {
              r3(t4[n5 + i5]);
            } catch (e6) {
              throw new Oe2.ErrnoError(29);
            }
            return o5 && (e5.node.timestamp = Date.now()), i5;
          } }), Oe2.mkdev(o4, a4, i4);
        }, forceLoadFile(e4) {
          if (e4.isDevice || e4.isFolder || e4.link || e4.contents) return true;
          if ("undefined" != typeof XMLHttpRequest) throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
          try {
            e4.contents = F2(e4.url), e4.usedBytes = e4.contents.length;
          } catch (e5) {
            throw new Oe2.ErrnoError(29);
          }
        }, createLazyFile(e4, t3, n4, r3, o4) {
          class a4 {
            constructor() {
              this.lengthKnown = false, this.chunks = [];
            }
            get(e5) {
              if (!(e5 > this.length - 1 || e5 < 0)) {
                var t4 = e5 % this.chunkSize, n5 = e5 / this.chunkSize | 0;
                return this.getter(n5)[t4];
              }
            }
            setDataGetter(e5) {
              this.getter = e5;
            }
            cacheLength() {
              var e5 = new XMLHttpRequest();
              if (e5.open("HEAD", n4, false), e5.send(null), !(e5.status >= 200 && e5.status < 300 || 304 === e5.status)) throw new Error("Couldn't load " + n4 + ". Status: " + e5.status);
              var t4, r4 = Number(e5.getResponseHeader("Content-length")), o5 = (t4 = e5.getResponseHeader("Accept-Ranges")) && "bytes" === t4, a5 = (t4 = e5.getResponseHeader("Content-Encoding")) && "gzip" === t4, i5 = 1048576;
              o5 || (i5 = r4);
              var s5 = this;
              s5.setDataGetter((e6) => {
                var t5 = e6 * i5, o6 = (e6 + 1) * i5 - 1;
                if (o6 = Math.min(o6, r4 - 1), void 0 === s5.chunks[e6] && (s5.chunks[e6] = ((e7, t6) => {
                  if (e7 > t6) throw new Error("invalid range (" + e7 + ", " + t6 + ") or no bytes requested!");
                  if (t6 > r4 - 1) throw new Error("only " + r4 + " bytes available! programmer error!");
                  var o7 = new XMLHttpRequest();
                  if (o7.open("GET", n4, false), r4 !== i5 && o7.setRequestHeader("Range", "bytes=" + e7 + "-" + t6), o7.responseType = "arraybuffer", o7.overrideMimeType && o7.overrideMimeType("text/plain; charset=x-user-defined"), o7.send(null), !(o7.status >= 200 && o7.status < 300 || 304 === o7.status)) throw new Error("Couldn't load " + n4 + ". Status: " + o7.status);
                  return void 0 !== o7.response ? new Uint8Array(o7.response || []) : Ae2(o7.responseText || "");
                })(t5, o6)), void 0 === s5.chunks[e6]) throw new Error("doXHR failed!");
                return s5.chunks[e6];
              }), !a5 && r4 || (i5 = r4 = 1, r4 = this.getter(0).length, i5 = r4, P2("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = r4, this._chunkSize = i5, this.lengthKnown = true;
            }
            get length() {
              return this.lengthKnown || this.cacheLength(), this._length;
            }
            get chunkSize() {
              return this.lengthKnown || this.cacheLength(), this._chunkSize;
            }
          }
          if ("undefined" != typeof XMLHttpRequest) {
            if (!s4) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
            var i4 = { isDevice: false, contents: new a4() };
          } else i4 = { isDevice: false, url: n4 };
          var u5 = Oe2.createFile(e4, t3, i4, r3, o4);
          i4.contents ? u5.contents = i4.contents : i4.url && (u5.contents = null, u5.url = i4.url), Object.defineProperties(u5, { usedBytes: { get: function() {
            return this.contents.length;
          } } });
          var F3 = {};
          function m4(e5, t4, n5, r4, o5) {
            var a5 = e5.node.contents;
            if (o5 >= a5.length) return 0;
            var i5 = Math.min(a5.length - o5, r4);
            if (C2(i5 >= 0), a5.slice) for (var s5 = 0; s5 < i5; s5++) t4[n5 + s5] = a5[o5 + s5];
            else for (s5 = 0; s5 < i5; s5++) t4[n5 + s5] = a5.get(o5 + s5);
            return i5;
          }
          return Object.keys(u5.stream_ops).forEach((e5) => {
            var t4 = u5.stream_ops[e5];
            F3[e5] = (...e6) => (Oe2.forceLoadFile(u5), t4(...e6));
          }), F3.read = (e5, t4, n5, r4, o5) => (Oe2.forceLoadFile(u5), m4(e5, t4, n5, r4, o5)), F3.mmap = (e5, t4, n5, r4, o5) => {
            Oe2.forceLoadFile(u5);
            var a5 = Se2(t4);
            if (!a5) throw new Oe2.ErrnoError(48);
            return m4(e5, b2, a5, t4, n5), { ptr: a5, allocated: true };
          }, u5.stream_ops = F3, u5;
        }, absolutePath() {
          z3("FS.absolutePath has been removed; use PATH_FS.resolve instead");
        }, createFolder() {
          z3("FS.createFolder has been removed; use FS.mkdir instead");
        }, createLink() {
          z3("FS.createLink has been removed; use FS.symlink instead");
        }, joinPath() {
          z3("FS.joinPath has been removed; use PATH.join instead");
        }, mmapAlloc() {
          z3("FS.mmapAlloc has been replaced by the top level function mmapAlloc");
        }, standardizePath() {
          z3("FS.standardizePath has been removed; use PATH.normalize instead");
        } }, ke2 = { DEFAULT_POLLMASK: 5, calculateAt(e4, t3, n4) {
          if (ge2.isAbs(t3)) return t3;
          var r3;
          if (r3 = -100 === e4 ? Oe2.cwd() : ke2.getStreamFromFD(e4).path, 0 == t3.length) {
            if (!n4) throw new Oe2.ErrnoError(44);
            return r3;
          }
          return ge2.join2(r3, t3);
        }, doStat(e4, t3, n4) {
          var r3 = e4(t3);
          E2[n4 >> 2] = r3.dev, E2[n4 + 4 >> 2] = r3.mode, M2[n4 + 8 >> 2] = r3.nlink, E2[n4 + 12 >> 2] = r3.uid, E2[n4 + 16 >> 2] = r3.gid, E2[n4 + 20 >> 2] = r3.rdev, K3 = [r3.size >>> 0, (X3 = r3.size, +Math.abs(X3) >= 1 ? X3 > 0 ? +Math.floor(X3 / 4294967296) >>> 0 : ~~+Math.ceil((X3 - +(~~X3 >>> 0)) / 4294967296) >>> 0 : 0)], E2[n4 + 24 >> 2] = K3[0], E2[n4 + 28 >> 2] = K3[1], E2[n4 + 32 >> 2] = 4096, E2[n4 + 36 >> 2] = r3.blocks;
          var o4 = r3.atime.getTime(), a4 = r3.mtime.getTime(), i4 = r3.ctime.getTime();
          return K3 = [Math.floor(o4 / 1e3) >>> 0, (X3 = Math.floor(o4 / 1e3), +Math.abs(X3) >= 1 ? X3 > 0 ? +Math.floor(X3 / 4294967296) >>> 0 : ~~+Math.ceil((X3 - +(~~X3 >>> 0)) / 4294967296) >>> 0 : 0)], E2[n4 + 40 >> 2] = K3[0], E2[n4 + 44 >> 2] = K3[1], M2[n4 + 48 >> 2] = o4 % 1e3 * 1e3 * 1e3, K3 = [Math.floor(a4 / 1e3) >>> 0, (X3 = Math.floor(a4 / 1e3), +Math.abs(X3) >= 1 ? X3 > 0 ? +Math.floor(X3 / 4294967296) >>> 0 : ~~+Math.ceil((X3 - +(~~X3 >>> 0)) / 4294967296) >>> 0 : 0)], E2[n4 + 56 >> 2] = K3[0], E2[n4 + 60 >> 2] = K3[1], M2[n4 + 64 >> 2] = a4 % 1e3 * 1e3 * 1e3, K3 = [Math.floor(i4 / 1e3) >>> 0, (X3 = Math.floor(i4 / 1e3), +Math.abs(X3) >= 1 ? X3 > 0 ? +Math.floor(X3 / 4294967296) >>> 0 : ~~+Math.ceil((X3 - +(~~X3 >>> 0)) / 4294967296) >>> 0 : 0)], E2[n4 + 72 >> 2] = K3[0], E2[n4 + 76 >> 2] = K3[1], M2[n4 + 80 >> 2] = i4 % 1e3 * 1e3 * 1e3, K3 = [r3.ino >>> 0, (X3 = r3.ino, +Math.abs(X3) >= 1 ? X3 > 0 ? +Math.floor(X3 / 4294967296) >>> 0 : ~~+Math.ceil((X3 - +(~~X3 >>> 0)) / 4294967296) >>> 0 : 0)], E2[n4 + 88 >> 2] = K3[0], E2[n4 + 92 >> 2] = K3[1], 0;
        }, doMsync(e4, t3, n4, r3, o4) {
          if (!Oe2.isFile(t3.node.mode)) throw new Oe2.ErrnoError(43);
          if (2 & r3) return 0;
          var a4 = f2.slice(e4, e4 + n4);
          Oe2.msync(t3, a4, o4, n4, r3);
        }, getStreamFromFD: (e4) => Oe2.getStreamChecked(e4), varargs: void 0, getStr: (e4) => _e2(e4) }, we2 = (e4, t3) => (C2(e4 == e4 >>> 0 || e4 == (0 | e4)), C2(t3 === (0 | t3)), t3 + 2097152 >>> 0 < 4194305 - !!e4 ? (e4 >>> 0) + 4294967296 * t3 : NaN), Re2 = (e4, t3, n4) => (C2("number" == typeof n4, "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"), pe2(e4, f2, t3, n4)), Ie2 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], je2 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Be2 = (e4) => {
          var t3 = h3.buffer, n4 = (e4 - t3.byteLength + 65535) / 65536 | 0;
          try {
            return h3.grow(n4), T2(), 1;
          } catch (n5) {
            g3(`growMemory: Attempted to grow heap from ${t3.byteLength} bytes to ${e4} bytes, but got error: ${n5}`);
          }
        }, Le2 = {}, Ne2 = () => {
          if (!Ne2.strings) {
            var e4 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: d4 || "./this.program" };
            for (var t3 in Le2) void 0 === Le2[t3] ? delete e4[t3] : e4[t3] = Le2[t3];
            var n4 = [];
            for (var t3 in e4) n4.push(`${t3}=${e4[t3]}`);
            Ne2.strings = n4;
          }
          return Ne2.strings;
        }, Ve2 = [], Ue2 = (e4) => {
          var t3 = Ve2[e4];
          return t3 || (e4 >= Ve2.length && (Ve2.length = e4 + 1), Ve2[e4] = t3 = Ee2.get(e4)), C2(Ee2.get(e4) == t3, "JavaScript-side Wasm function table mirror is out of date!"), t3;
        }, $e2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, We2 = (e4, t3) => {
          C2(e4 < 16384), e4 < 128 ? t3.push(e4) : t3.push(e4 % 128 | 128, e4 >> 7);
        }, ze2 = (e4, t3) => {
          if (C2(!t3.includes("j"), "i64 not permitted in function signatures when WASM_BIGINT is disabled"), "function" == typeof WebAssembly.Function) return new WebAssembly.Function(((e5) => {
            C2(!e5.includes("j"), "i64 not permitted in function signatures when WASM_BIGINT is disabled");
            for (var t4 = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" }, n5 = { parameters: [], results: "v" == e5[0] ? [] : [t4[e5[0]]] }, r4 = 1; r4 < e5.length; ++r4) C2(e5[r4] in t4, "invalid signature char: " + e5[r4]), n5.parameters.push(t4[e5[r4]]);
            return n5;
          })(t3), e4);
          var n4 = [1];
          ((e5, t4) => {
            var n5 = e5.slice(0, 1), r4 = e5.slice(1), o5 = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
            t4.push(96), We2(r4.length, t4);
            for (var a4 = 0; a4 < r4.length; ++a4) C2(r4[a4] in o5, "invalid signature char: " + r4[a4]), t4.push(o5[r4[a4]]);
            "v" == n5 ? t4.push(0) : t4.push(1, o5[n5]);
          })(t3, n4);
          var r3 = [0, 97, 115, 109, 1, 0, 0, 0, 1];
          We2(n4.length, r3), r3.push(...n4), r3.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
          var o4 = new WebAssembly.Module(new Uint8Array(r3));
          return new WebAssembly.Instance(o4, { e: { f: e4 } }).exports.f;
        }, He2 = (e4) => (Me2 || (Me2 = /* @__PURE__ */ new WeakMap(), ((e5, t3) => {
          if (Me2) for (var n4 = e5; n4 < e5 + t3; n4++) {
            var r3 = Ue2(n4);
            r3 && Me2.set(r3, n4);
          }
        })(0, Ee2.length)), Me2.get(e4) || 0), Xe2 = [], Ke2 = (e4, t3) => {
          Ee2.set(e4, t3), Ve2[e4] = Ee2.get(e4);
        }, Ye2 = (e4) => ut2(e4), Je2 = (e4, t3, n4, r3, a4) => {
          var i4 = { string: (e5) => {
            var t4 = 0;
            return null != e5 && 0 !== e5 && (t4 = ((e6) => {
              var t5 = fe2(e6) + 1, n5 = Ye2(t5);
              return Re2(e6, n5, t5), n5;
            })(e5)), t4;
          }, array: (e5) => {
            var t4, n5, r4 = Ye2(e5.length);
            return n5 = r4, C2((t4 = e5).length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)"), b2.set(t4, n5), r4;
          } }, s5 = ((e5) => {
            var t4 = o3["_" + e5];
            return C2(t4, "Cannot call unknown function " + e5 + ", make sure it is exported"), t4;
          })(e4), u5 = [], F3 = 0;
          if (C2("array" !== t3, 'Return type should not be "array".'), r3) for (var m4 = 0; m4 < r3.length; m4++) {
            var l5 = i4[n4[m4]];
            l5 ? (0 === F3 && (F3 = Fe2()), u5[m4] = l5(r3[m4])) : u5[m4] = r3[m4];
          }
          var d5 = s5(...u5);
          return d5 = (function(e5) {
            return 0 !== F3 && ue2(F3), (function(e6) {
              return "string" === t3 ? _e2(e6) : "boolean" === t3 ? Boolean(e6) : e6;
            })(e5);
          })(d5);
        };
        Oe2.createPreloadedFile = (e4, t3, n4, r3, o4, a4, i4, s5, F3, m4) => {
          var l5 = t3 ? De2.resolve(ge2.join2(e4, t3)) : e4, d5 = U3(`cp ${l5}`);
          function _3(n5) {
            function u5(n6) {
              m4?.(), s5 || ((e5, t4, n7, r4, o5, a5) => {
                Oe2.createDataFile(e5, t4, n7, r4, o5, a5);
              })(e4, t3, n6, r3, o4, F3), a4?.(), W3(d5);
            }
            ((e5, t4, n6, r4) => {
              "undefined" != typeof Browser && Browser.init();
              var o5 = false;
              return Te2.forEach((a5) => {
                o5 || a5.canHandle(t4) && (a5.handle(e5, t4, n6, r4), o5 = true);
              }), o5;
            })(n5, l5, u5, () => {
              i4?.(), W3(d5);
            }) || u5(n5);
          }
          $3(d5), "string" == typeof n4 ? ((e5, t4, n5) => {
            var r4 = U3(`al ${e5}`);
            u4(e5).then((n6) => {
              C2(n6, `Loading data file "${e5}" failed (no arrayBuffer).`), t4(new Uint8Array(n6)), r4 && W3(r4);
            }, (t5) => {
              if (!n5) throw `Loading data file "${e5}" failed.`;
              n5();
            }), r4 && $3(r4);
          })(n4, _3, i4) : _3(n4);
        }, Oe2.staticInit();
        var qe2 = { __assert_fail: (e4, t3, n4, r3) => {
          z3(`Assertion failed: ${_e2(e4)}, at: ` + [t3 ? _e2(t3) : "unknown filename", n4, r3 ? _e2(r3) : "unknown function"]);
        }, __syscall_fcntl64: function(e4, t3, n4) {
          ke2.varargs = n4;
          try {
            var r3 = ke2.getStreamFromFD(e4);
            switch (t3) {
              case 0:
                if ((o4 = ce2()) < 0) return -28;
                for (; Oe2.streams[o4]; ) o4++;
                return Oe2.dupStream(r3, o4).fd;
              case 1:
              case 2:
              case 13:
              case 14:
                return 0;
              case 3:
                return r3.flags;
              case 4:
                var o4 = ce2();
                return r3.flags |= o4, 0;
              case 12:
                return o4 = Pe2(), p4[o4 + 0 >> 1] = 2, 0;
            }
            return -28;
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return -e5.errno;
          }
        }, __syscall_fstat64: function(e4, t3) {
          try {
            var n4 = ke2.getStreamFromFD(e4);
            return ke2.doStat(Oe2.stat, n4.path, t3);
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return -e5.errno;
          }
        }, __syscall_ftruncate64: function(e4, t3, n4) {
          var r3 = we2(t3, n4);
          try {
            return isNaN(r3) ? 61 : (Oe2.ftruncate(e4, r3), 0);
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return -e5.errno;
          }
        }, __syscall_getdents64: function(e4, t3, n4) {
          try {
            var r3 = ke2.getStreamFromFD(e4);
            r3.getdents ||= Oe2.readdir(r3.path);
            for (var o4 = 280, a4 = 0, i4 = Oe2.llseek(r3, 0, 1), s5 = Math.floor(i4 / o4); s5 < r3.getdents.length && a4 + o4 <= n4; ) {
              var u5, F3, m4 = r3.getdents[s5];
              if ("." === m4) u5 = r3.node.id, F3 = 4;
              else if (".." === m4) u5 = Oe2.lookupPath(r3.path, { parent: true }).node.id, F3 = 4;
              else {
                var l5 = Oe2.lookupNode(r3.node, m4);
                u5 = l5.id, F3 = Oe2.isChrdev(l5.mode) ? 2 : Oe2.isDir(l5.mode) ? 4 : Oe2.isLink(l5.mode) ? 10 : 8;
              }
              C2(u5), K3 = [u5 >>> 0, (X3 = u5, +Math.abs(X3) >= 1 ? X3 > 0 ? +Math.floor(X3 / 4294967296) >>> 0 : ~~+Math.ceil((X3 - +(~~X3 >>> 0)) / 4294967296) >>> 0 : 0)], E2[t3 + a4 >> 2] = K3[0], E2[t3 + a4 + 4 >> 2] = K3[1], K3 = [(s5 + 1) * o4 >>> 0, (X3 = (s5 + 1) * o4, +Math.abs(X3) >= 1 ? X3 > 0 ? +Math.floor(X3 / 4294967296) >>> 0 : ~~+Math.ceil((X3 - +(~~X3 >>> 0)) / 4294967296) >>> 0 : 0)], E2[t3 + a4 + 8 >> 2] = K3[0], E2[t3 + a4 + 12 >> 2] = K3[1], p4[t3 + a4 + 16 >> 1] = 280, b2[t3 + a4 + 18] = F3, Re2(m4, t3 + a4 + 19, 256), a4 += o4, s5 += 1;
            }
            return Oe2.llseek(r3, s5 * o4, 0), a4;
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return -e5.errno;
          }
        }, __syscall_ioctl: function(e4, t3, n4) {
          ke2.varargs = n4;
          try {
            var r3 = ke2.getStreamFromFD(e4);
            switch (t3) {
              case 21509:
              case 21510:
              case 21511:
              case 21512:
              case 21524:
              case 21515:
                return r3.tty ? 0 : -59;
              case 21505:
                if (!r3.tty) return -59;
                if (r3.tty.ops.ioctl_tcgets) {
                  var o4 = r3.tty.ops.ioctl_tcgets(r3), a4 = Pe2();
                  E2[a4 >> 2] = o4.c_iflag || 0, E2[a4 + 4 >> 2] = o4.c_oflag || 0, E2[a4 + 8 >> 2] = o4.c_cflag || 0, E2[a4 + 12 >> 2] = o4.c_lflag || 0;
                  for (var i4 = 0; i4 < 32; i4++) b2[a4 + i4 + 17] = o4.c_cc[i4] || 0;
                  return 0;
                }
                return 0;
              case 21506:
              case 21507:
              case 21508:
                if (!r3.tty) return -59;
                if (r3.tty.ops.ioctl_tcsets) {
                  a4 = Pe2();
                  var s5 = E2[a4 >> 2], u5 = E2[a4 + 4 >> 2], F3 = E2[a4 + 8 >> 2], m4 = E2[a4 + 12 >> 2], l5 = [];
                  for (i4 = 0; i4 < 32; i4++) l5.push(b2[a4 + i4 + 17]);
                  return r3.tty.ops.ioctl_tcsets(r3.tty, t3, { c_iflag: s5, c_oflag: u5, c_cflag: F3, c_lflag: m4, c_cc: l5 });
                }
                return 0;
              case 21519:
                return r3.tty ? (a4 = Pe2(), E2[a4 >> 2] = 0, 0) : -59;
              case 21520:
                return r3.tty ? -28 : -59;
              case 21531:
                return a4 = Pe2(), Oe2.ioctl(r3, t3, a4);
              case 21523:
                if (!r3.tty) return -59;
                if (r3.tty.ops.ioctl_tiocgwinsz) {
                  var d5 = r3.tty.ops.ioctl_tiocgwinsz(r3.tty);
                  a4 = Pe2(), p4[a4 >> 1] = d5[0], p4[a4 + 2 >> 1] = d5[1];
                }
                return 0;
              default:
                return -28;
            }
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return -e5.errno;
          }
        }, __syscall_lstat64: function(e4, t3) {
          try {
            return e4 = ke2.getStr(e4), ke2.doStat(Oe2.lstat, e4, t3);
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return -e5.errno;
          }
        }, __syscall_newfstatat: function(e4, t3, n4, r3) {
          try {
            t3 = ke2.getStr(t3);
            var o4 = 256 & r3, a4 = 4096 & r3;
            return C2(!(r3 &= -6401), `unknown flags in __syscall_newfstatat: ${r3}`), t3 = ke2.calculateAt(e4, t3, a4), ke2.doStat(o4 ? Oe2.lstat : Oe2.stat, t3, n4);
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return -e5.errno;
          }
        }, __syscall_openat: function(e4, t3, n4, r3) {
          ke2.varargs = r3;
          try {
            t3 = ke2.getStr(t3), t3 = ke2.calculateAt(e4, t3);
            var o4 = r3 ? ce2() : 0;
            return Oe2.open(t3, n4, o4).fd;
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return -e5.errno;
          }
        }, __syscall_rmdir: function(e4) {
          try {
            return e4 = ke2.getStr(e4), Oe2.rmdir(e4), 0;
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return -e5.errno;
          }
        }, __syscall_stat64: function(e4, t3) {
          try {
            return e4 = ke2.getStr(e4), ke2.doStat(Oe2.stat, e4, t3);
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return -e5.errno;
          }
        }, __syscall_unlinkat: function(e4, t3, n4) {
          try {
            return t3 = ke2.getStr(t3), t3 = ke2.calculateAt(e4, t3), 0 === n4 ? Oe2.unlink(t3) : 512 === n4 ? Oe2.rmdir(t3) : z3("Invalid flags passed to unlinkat"), 0;
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return -e5.errno;
          }
        }, _abort_js: () => {
          z3("native code called abort()");
        }, _emscripten_memcpy_js: (e4, t3, n4) => f2.copyWithin(e4, t3, t3 + n4), _emscripten_throw_longjmp: () => {
          throw 1 / 0;
        }, _gmtime_js: function(e4, t3, n4) {
          var r3 = we2(e4, t3), o4 = new Date(1e3 * r3);
          E2[n4 >> 2] = o4.getUTCSeconds(), E2[n4 + 4 >> 2] = o4.getUTCMinutes(), E2[n4 + 8 >> 2] = o4.getUTCHours(), E2[n4 + 12 >> 2] = o4.getUTCDate(), E2[n4 + 16 >> 2] = o4.getUTCMonth(), E2[n4 + 20 >> 2] = o4.getUTCFullYear() - 1900, E2[n4 + 24 >> 2] = o4.getUTCDay();
          var a4 = Date.UTC(o4.getUTCFullYear(), 0, 1, 0, 0, 0, 0), i4 = (o4.getTime() - a4) / 864e5 | 0;
          E2[n4 + 28 >> 2] = i4;
        }, _localtime_js: function(e4, t3, n4) {
          var r3 = we2(e4, t3), o4 = new Date(1e3 * r3);
          E2[n4 >> 2] = o4.getSeconds(), E2[n4 + 4 >> 2] = o4.getMinutes(), E2[n4 + 8 >> 2] = o4.getHours(), E2[n4 + 12 >> 2] = o4.getDate(), E2[n4 + 16 >> 2] = o4.getMonth(), E2[n4 + 20 >> 2] = o4.getFullYear() - 1900, E2[n4 + 24 >> 2] = o4.getDay();
          var a4 = 0 | ((e5) => {
            var t4;
            return ((t4 = e5.getFullYear()) % 4 != 0 || t4 % 100 == 0 && t4 % 400 != 0 ? je2 : Ie2)[e5.getMonth()] + e5.getDate() - 1;
          })(o4);
          E2[n4 + 28 >> 2] = a4, E2[n4 + 36 >> 2] = -60 * o4.getTimezoneOffset();
          var i4 = new Date(o4.getFullYear(), 0, 1), s5 = new Date(o4.getFullYear(), 6, 1).getTimezoneOffset(), u5 = i4.getTimezoneOffset(), F3 = 0 | (s5 != u5 && o4.getTimezoneOffset() == Math.min(u5, s5));
          E2[n4 + 32 >> 2] = F3;
        }, _tzset_js: (e4, t3, n4, r3) => {
          var o4 = (/* @__PURE__ */ new Date()).getFullYear(), a4 = new Date(o4, 0, 1), i4 = new Date(o4, 6, 1), s5 = a4.getTimezoneOffset(), u5 = i4.getTimezoneOffset(), F3 = Math.max(s5, u5);
          M2[e4 >> 2] = 60 * F3, E2[t3 >> 2] = Number(s5 != u5);
          var m4 = (e5) => {
            var t4 = e5 >= 0 ? "-" : "+", n5 = Math.abs(e5);
            return `UTC${t4}${String(Math.floor(n5 / 60)).padStart(2, "0")}${String(n5 % 60).padStart(2, "0")}`;
          }, l5 = m4(s5), d5 = m4(u5);
          C2(l5), C2(d5), C2(fe2(l5) <= 16, `timezone name truncated to fit in TZNAME_MAX (${l5})`), C2(fe2(d5) <= 16, `timezone name truncated to fit in TZNAME_MAX (${d5})`), u5 < s5 ? (Re2(l5, n4, 17), Re2(d5, r3, 17)) : (Re2(l5, r3, 17), Re2(d5, n4, 17));
        }, emscripten_date_now: () => Date.now(), emscripten_resize_heap: (e4) => {
          var t3 = f2.length;
          C2((e4 >>>= 0) > t3);
          var n4 = 2147483648;
          if (e4 > n4) return g3(`Cannot enlarge memory, requested ${e4} bytes, but the limit is 2147483648 bytes!`), false;
          for (var r3 = 1; r3 <= 4; r3 *= 2) {
            var o4 = t3 * (1 + 0.2 / r3);
            o4 = Math.min(o4, e4 + 100663296);
            var a4 = Math.min(n4, Ge2(Math.max(e4, o4), 65536));
            if (Be2(a4)) return true;
          }
          return g3(`Failed to grow the heap from ${t3} bytes to ${a4} bytes, not enough memory!`), false;
        }, environ_get: (e4, t3) => {
          var n4 = 0;
          return Ne2().forEach((r3, o4) => {
            var a4 = t3 + n4;
            M2[e4 + 4 * o4 >> 2] = a4, ((e5, t4) => {
              for (var n5 = 0; n5 < e5.length; ++n5) C2(e5.charCodeAt(n5) === (255 & e5.charCodeAt(n5))), b2[t4++] = e5.charCodeAt(n5);
              b2[t4] = 0;
            })(r3, a4), n4 += r3.length + 1;
          }), 0;
        }, environ_sizes_get: (e4, t3) => {
          var n4 = Ne2();
          M2[e4 >> 2] = n4.length;
          var r3 = 0;
          return n4.forEach((e5) => r3 += e5.length + 1), M2[t3 >> 2] = r3, 0;
        }, fd_close: function(e4) {
          try {
            var t3 = ke2.getStreamFromFD(e4);
            return Oe2.close(t3), 0;
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return e5.errno;
          }
        }, fd_read: function(e4, t3, n4, r3) {
          try {
            var o4 = ((e5, t4, n5, r4) => {
              for (var o5 = 0, a4 = 0; a4 < n5; a4++) {
                var i4 = M2[t4 >> 2], s5 = M2[t4 + 4 >> 2];
                t4 += 8;
                var u5 = Oe2.read(e5, b2, i4, s5, r4);
                if (u5 < 0) return -1;
                if (o5 += u5, u5 < s5) break;
              }
              return o5;
            })(ke2.getStreamFromFD(e4), t3, n4);
            return M2[r3 >> 2] = o4, 0;
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return e5.errno;
          }
        }, fd_seek: function(e4, t3, n4, r3, o4) {
          var a4 = we2(t3, n4);
          try {
            if (isNaN(a4)) return 61;
            var i4 = ke2.getStreamFromFD(e4);
            return Oe2.llseek(i4, a4, r3), K3 = [i4.position >>> 0, (X3 = i4.position, +Math.abs(X3) >= 1 ? X3 > 0 ? +Math.floor(X3 / 4294967296) >>> 0 : ~~+Math.ceil((X3 - +(~~X3 >>> 0)) / 4294967296) >>> 0 : 0)], E2[o4 >> 2] = K3[0], E2[o4 + 4 >> 2] = K3[1], i4.getdents && 0 === a4 && 0 === r3 && (i4.getdents = null), 0;
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return e5.errno;
          }
        }, fd_sync: function(e4) {
          try {
            var t3 = ke2.getStreamFromFD(e4);
            return t3.stream_ops?.fsync ? t3.stream_ops.fsync(t3) : 0;
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return e5.errno;
          }
        }, fd_write: function(e4, t3, n4, r3) {
          try {
            var o4 = ((e5, t4, n5, r4) => {
              for (var o5 = 0, a4 = 0; a4 < n5; a4++) {
                var i4 = M2[t4 >> 2], s5 = M2[t4 + 4 >> 2];
                t4 += 8;
                var u5 = Oe2.write(e5, b2, i4, s5, r4);
                if (u5 < 0) return -1;
                if (o5 += u5, u5 < s5) break;
              }
              return o5;
            })(ke2.getStreamFromFD(e4), t3, n4);
            return M2[r3 >> 2] = o4, 0;
          } catch (e5) {
            if (void 0 === Oe2 || "ErrnoError" !== e5.name) throw e5;
            return e5.errno;
          }
        }, invoke_ii: function(e4, t3) {
          var n4 = Fe2();
          try {
            return Ue2(e4)(t3);
          } catch (e5) {
            if (ue2(n4), e5 !== e5 + 0) throw e5;
            ot2(1, 0);
          }
        }, invoke_iii: function(e4, t3, n4) {
          var r3 = Fe2();
          try {
            return Ue2(e4)(t3, n4);
          } catch (e5) {
            if (ue2(r3), e5 !== e5 + 0) throw e5;
            ot2(1, 0);
          }
        }, invoke_iiii: function(e4, t3, n4, r3) {
          var o4 = Fe2();
          try {
            return Ue2(e4)(t3, n4, r3);
          } catch (e5) {
            if (ue2(o4), e5 !== e5 + 0) throw e5;
            ot2(1, 0);
          }
        }, invoke_iiiii: function(e4, t3, n4, r3, o4) {
          var a4 = Fe2();
          try {
            return Ue2(e4)(t3, n4, r3, o4);
          } catch (e5) {
            if (ue2(a4), e5 !== e5 + 0) throw e5;
            ot2(1, 0);
          }
        }, invoke_v: function(e4) {
          var t3 = Fe2();
          try {
            Ue2(e4)();
          } catch (e5) {
            if (ue2(t3), e5 !== e5 + 0) throw e5;
            ot2(1, 0);
          }
        }, invoke_vii: function(e4, t3, n4) {
          var r3 = Fe2();
          try {
            Ue2(e4)(t3, n4);
          } catch (e5) {
            if (ue2(r3), e5 !== e5 + 0) throw e5;
            ot2(1, 0);
          }
        }, invoke_viii: function(e4, t3, n4, r3) {
          var o4 = Fe2();
          try {
            Ue2(e4)(t3, n4, r3);
          } catch (e5) {
            if (ue2(o4), e5 !== e5 + 0) throw e5;
            ot2(1, 0);
          }
        }, invoke_viiii: function(e4, t3, n4, r3, o4) {
          var a4 = Fe2();
          try {
            Ue2(e4)(t3, n4, r3, o4);
          } catch (e5) {
            if (ue2(a4), e5 !== e5 + 0) throw e5;
            ot2(1, 0);
          }
        }, invoke_viiiiiiiii: function(e4, t3, n4, r3, o4, a4, i4, s5, u5, F3) {
          var m4 = Fe2();
          try {
            Ue2(e4)(t3, n4, r3, o4, a4, i4, s5, u5, F3);
          } catch (e5) {
            if (ue2(m4), e5 !== e5 + 0) throw e5;
            ot2(1, 0);
          }
        } }, Qe2 = (function() {
          var e4 = { env: qe2, wasi_snapshot_preview1: qe2 };
          function t3(e5, t4) {
            var n5;
            return Qe2 = e5.exports, o3.wasmExports = Qe2, C2(h3 = Qe2.memory, "memory not found in wasm exports"), T2(), C2(Ee2 = Qe2.__indirect_function_table, "table not found in wasm exports"), n5 = Qe2.__wasm_call_ctors, O2.unshift(n5), W3("wasm-instantiate"), Qe2;
          }
          $3("wasm-instantiate");
          var n4, a4, i4, s5, u5 = o3;
          if (o3.instantiateWasm) try {
            return o3.instantiateWasm(e4, t3);
          } catch (e5) {
            g3(`Module.instantiateWasm callback failed with error: ${e5}`), r2(e5);
          }
          return H3 ??= Q3(), (n4 = D2, a4 = H3, i4 = e4, s5 = function(e5) {
            C2(o3 === u5, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?"), u5 = null, t3(e5.instance);
          }, n4 || "function" != typeof WebAssembly.instantiateStreaming || Y3(a4) || "function" != typeof fetch ? ee3(a4, i4, s5) : fetch(a4, { credentials: "same-origin" }).then((e5) => WebAssembly.instantiateStreaming(e5, i4).then(s5, function(e6) {
            return g3(`wasm streaming compile failed: ${e6}`), g3("falling back to ArrayBuffer instantiation"), ee3(a4, i4, s5);
          }))).catch(r2), {};
        })();
        o3._PDFiumExt_Init = q3("PDFiumExt_Init", 0), o3._FPDF_InitLibraryWithConfig = q3("FPDF_InitLibraryWithConfig", 1), o3._PDFiumExt_OpenFileWriter = q3("PDFiumExt_OpenFileWriter", 0), o3._PDFiumExt_GetFileWriterSize = q3("PDFiumExt_GetFileWriterSize", 1), o3._PDFiumExt_GetFileWriterData = q3("PDFiumExt_GetFileWriterData", 3), o3._PDFiumExt_CloseFileWriter = q3("PDFiumExt_CloseFileWriter", 1), o3._PDFiumExt_SaveAsCopy = q3("PDFiumExt_SaveAsCopy", 2), o3._FPDF_SaveAsCopy = q3("FPDF_SaveAsCopy", 3), o3._PDFiumExt_OpenFormFillInfo = q3("PDFiumExt_OpenFormFillInfo", 0), o3._PDFiumExt_CloseFormFillInfo = q3("PDFiumExt_CloseFormFillInfo", 1), o3._PDFiumExt_InitFormFillEnvironment = q3("PDFiumExt_InitFormFillEnvironment", 2), o3._FPDFDOC_InitFormFillEnvironment = q3("FPDFDOC_InitFormFillEnvironment", 2), o3._PDFiumExt_ExitFormFillEnvironment = q3("PDFiumExt_ExitFormFillEnvironment", 1), o3._FPDFDOC_ExitFormFillEnvironment = q3("FPDFDOC_ExitFormFillEnvironment", 1), o3._EPDFNamedDest_SetDest = q3("EPDFNamedDest_SetDest", 3), o3._EPDFNamedDest_Remove = q3("EPDFNamedDest_Remove", 2), o3._EPDFDest_CreateView = q3("EPDFDest_CreateView", 4), o3._EPDFDest_CreateXYZ = q3("EPDFDest_CreateXYZ", 7), o3._EPDFDest_CreateRemoteView = q3("EPDFDest_CreateRemoteView", 5), o3._EPDFDest_CreateRemoteXYZ = q3("EPDFDest_CreateRemoteXYZ", 8), o3._EPDFAction_CreateGoTo = q3("EPDFAction_CreateGoTo", 2), o3._EPDFAction_CreateGoToNamed = q3("EPDFAction_CreateGoToNamed", 2), o3._EPDFAction_CreateLaunch = q3("EPDFAction_CreateLaunch", 2), o3._EPDFAction_CreateRemoteGoToByName = q3("EPDFAction_CreateRemoteGoToByName", 3), o3._EPDFAction_CreateRemoteGoToDest = q3("EPDFAction_CreateRemoteGoToDest", 3), o3._EPDFAction_CreateURI = q3("EPDFAction_CreateURI", 2), o3._EPDFBookmark_Create = q3("EPDFBookmark_Create", 2), o3._EPDFBookmark_Delete = q3("EPDFBookmark_Delete", 2), o3._EPDFBookmark_AppendChild = q3("EPDFBookmark_AppendChild", 3), o3._EPDFBookmark_InsertAfter = q3("EPDFBookmark_InsertAfter", 4), o3._EPDFBookmark_Clear = q3("EPDFBookmark_Clear", 1), o3._EPDFBookmark_SetTitle = q3("EPDFBookmark_SetTitle", 2), o3._EPDFBookmark_SetDest = q3("EPDFBookmark_SetDest", 3), o3._EPDFBookmark_SetAction = q3("EPDFBookmark_SetAction", 3), o3._EPDFBookmark_ClearTarget = q3("EPDFBookmark_ClearTarget", 1), o3._EPDF_PNG_EncodeRGBA = q3("EPDF_PNG_EncodeRGBA", 6), o3._FPDFAnnot_IsSupportedSubtype = q3("FPDFAnnot_IsSupportedSubtype", 1), o3._FPDFPage_CreateAnnot = q3("FPDFPage_CreateAnnot", 2), o3._FPDFPage_GetAnnotCount = q3("FPDFPage_GetAnnotCount", 1), o3._FPDFPage_GetAnnot = q3("FPDFPage_GetAnnot", 2), o3._FPDFPage_GetAnnotIndex = q3("FPDFPage_GetAnnotIndex", 2), o3._FPDFPage_CloseAnnot = q3("FPDFPage_CloseAnnot", 1), o3._FPDFPage_RemoveAnnot = q3("FPDFPage_RemoveAnnot", 2), o3._FPDFAnnot_GetSubtype = q3("FPDFAnnot_GetSubtype", 1), o3._FPDFAnnot_IsObjectSupportedSubtype = q3("FPDFAnnot_IsObjectSupportedSubtype", 1), o3._FPDFAnnot_UpdateObject = q3("FPDFAnnot_UpdateObject", 2), o3._FPDFAnnot_AddInkStroke = q3("FPDFAnnot_AddInkStroke", 3), o3._FPDFAnnot_RemoveInkList = q3("FPDFAnnot_RemoveInkList", 1), o3._FPDFAnnot_AppendObject = q3("FPDFAnnot_AppendObject", 2), o3._FPDFAnnot_GetObjectCount = q3("FPDFAnnot_GetObjectCount", 1), o3._FPDFAnnot_GetObject = q3("FPDFAnnot_GetObject", 2), o3._FPDFAnnot_RemoveObject = q3("FPDFAnnot_RemoveObject", 2), o3._FPDFAnnot_SetColor = q3("FPDFAnnot_SetColor", 6), o3._FPDFAnnot_GetColor = q3("FPDFAnnot_GetColor", 6), o3._FPDFAnnot_HasAttachmentPoints = q3("FPDFAnnot_HasAttachmentPoints", 1), o3._FPDFAnnot_SetAttachmentPoints = q3("FPDFAnnot_SetAttachmentPoints", 3), o3._FPDFAnnot_AppendAttachmentPoints = q3("FPDFAnnot_AppendAttachmentPoints", 2), o3._FPDFAnnot_CountAttachmentPoints = q3("FPDFAnnot_CountAttachmentPoints", 1), o3._FPDFAnnot_GetAttachmentPoints = q3("FPDFAnnot_GetAttachmentPoints", 3), o3._FPDFAnnot_SetRect = q3("FPDFAnnot_SetRect", 2), o3._FPDFAnnot_GetRect = q3("FPDFAnnot_GetRect", 2), o3._FPDFAnnot_GetVertices = q3("FPDFAnnot_GetVertices", 3), o3._FPDFAnnot_GetInkListCount = q3("FPDFAnnot_GetInkListCount", 1), o3._FPDFAnnot_GetInkListPath = q3("FPDFAnnot_GetInkListPath", 4), o3._FPDFAnnot_GetLine = q3("FPDFAnnot_GetLine", 3), o3._FPDFAnnot_SetBorder = q3("FPDFAnnot_SetBorder", 4), o3._FPDFAnnot_GetBorder = q3("FPDFAnnot_GetBorder", 4), o3._FPDFAnnot_HasKey = q3("FPDFAnnot_HasKey", 2), o3._FPDFAnnot_GetValueType = q3("FPDFAnnot_GetValueType", 2), o3._FPDFAnnot_SetStringValue = q3("FPDFAnnot_SetStringValue", 3), o3._FPDFAnnot_GetStringValue = q3("FPDFAnnot_GetStringValue", 4), o3._FPDFAnnot_GetNumberValue = q3("FPDFAnnot_GetNumberValue", 3), o3._FPDFAnnot_SetAP = q3("FPDFAnnot_SetAP", 3), o3._FPDFAnnot_GetAP = q3("FPDFAnnot_GetAP", 4), o3._FPDFAnnot_GetLinkedAnnot = q3("FPDFAnnot_GetLinkedAnnot", 2), o3._FPDFAnnot_GetFlags = q3("FPDFAnnot_GetFlags", 1), o3._FPDFAnnot_SetFlags = q3("FPDFAnnot_SetFlags", 2), o3._FPDFAnnot_GetFormFieldFlags = q3("FPDFAnnot_GetFormFieldFlags", 2), o3._FPDFAnnot_SetFormFieldFlags = q3("FPDFAnnot_SetFormFieldFlags", 3), o3._FPDFAnnot_GetFormFieldAtPoint = q3("FPDFAnnot_GetFormFieldAtPoint", 3), o3._FPDFAnnot_GetFormFieldName = q3("FPDFAnnot_GetFormFieldName", 4), o3._FPDFAnnot_GetFormFieldType = q3("FPDFAnnot_GetFormFieldType", 2), o3._FPDFAnnot_GetFormAdditionalActionJavaScript = q3("FPDFAnnot_GetFormAdditionalActionJavaScript", 5), o3._FPDFAnnot_GetFormFieldAlternateName = q3("FPDFAnnot_GetFormFieldAlternateName", 4), o3._FPDFAnnot_GetFormFieldValue = q3("FPDFAnnot_GetFormFieldValue", 4), o3._FPDFAnnot_GetOptionCount = q3("FPDFAnnot_GetOptionCount", 2), o3._FPDFAnnot_GetOptionLabel = q3("FPDFAnnot_GetOptionLabel", 5), o3._FPDFAnnot_IsOptionSelected = q3("FPDFAnnot_IsOptionSelected", 3), o3._FPDFAnnot_GetFontSize = q3("FPDFAnnot_GetFontSize", 3), o3._FPDFAnnot_SetFontColor = q3("FPDFAnnot_SetFontColor", 5), o3._FPDFAnnot_GetFontColor = q3("FPDFAnnot_GetFontColor", 5), o3._FPDFAnnot_IsChecked = q3("FPDFAnnot_IsChecked", 2), o3._FPDFAnnot_SetFocusableSubtypes = q3("FPDFAnnot_SetFocusableSubtypes", 3), o3._FPDFAnnot_GetFocusableSubtypesCount = q3("FPDFAnnot_GetFocusableSubtypesCount", 1), o3._FPDFAnnot_GetFocusableSubtypes = q3("FPDFAnnot_GetFocusableSubtypes", 3), o3._FPDFAnnot_GetLink = q3("FPDFAnnot_GetLink", 1), o3._FPDFAnnot_GetFormControlCount = q3("FPDFAnnot_GetFormControlCount", 2), o3._FPDFAnnot_GetFormControlIndex = q3("FPDFAnnot_GetFormControlIndex", 2), o3._FPDFAnnot_GetFormFieldExportValue = q3("FPDFAnnot_GetFormFieldExportValue", 4), o3._FPDFAnnot_SetURI = q3("FPDFAnnot_SetURI", 2), o3._FPDFAnnot_GetFileAttachment = q3("FPDFAnnot_GetFileAttachment", 1), o3._FPDFAnnot_AddFileAttachment = q3("FPDFAnnot_AddFileAttachment", 2), o3._EPDFAnnot_SetColor = q3("EPDFAnnot_SetColor", 5), o3._EPDFAnnot_GetColor = q3("EPDFAnnot_GetColor", 5), o3._EPDFAnnot_ClearColor = q3("EPDFAnnot_ClearColor", 2), o3._EPDFAnnot_SetOpacity = q3("EPDFAnnot_SetOpacity", 2), o3._EPDFAnnot_GetOpacity = q3("EPDFAnnot_GetOpacity", 2), o3._EPDFAnnot_GetBorderEffect = q3("EPDFAnnot_GetBorderEffect", 2), o3._EPDFAnnot_GetRectangleDifferences = q3("EPDFAnnot_GetRectangleDifferences", 5), o3._EPDFAnnot_GetBorderDashPatternCount = q3("EPDFAnnot_GetBorderDashPatternCount", 1), o3._EPDFAnnot_GetBorderDashPattern = q3("EPDFAnnot_GetBorderDashPattern", 3), o3._EPDFAnnot_SetBorderDashPattern = q3("EPDFAnnot_SetBorderDashPattern", 3), o3._EPDFAnnot_GetBorderStyle = q3("EPDFAnnot_GetBorderStyle", 2), o3._EPDFAnnot_SetBorderStyle = q3("EPDFAnnot_SetBorderStyle", 3), o3._EPDFAnnot_GenerateAppearance = q3("EPDFAnnot_GenerateAppearance", 1), o3._EPDFAnnot_GenerateAppearanceWithBlend = q3("EPDFAnnot_GenerateAppearanceWithBlend", 2), o3._EPDFAnnot_GetBlendMode = q3("EPDFAnnot_GetBlendMode", 1), o3._EPDFAnnot_SetIntent = q3("EPDFAnnot_SetIntent", 2), o3._EPDFAnnot_GetIntent = q3("EPDFAnnot_GetIntent", 3), o3._EPDFAnnot_GetRichContent = q3("EPDFAnnot_GetRichContent", 3), o3._EPDFAnnot_SetLineEndings = q3("EPDFAnnot_SetLineEndings", 3), o3._EPDFAnnot_GetLineEndings = q3("EPDFAnnot_GetLineEndings", 3), o3._EPDFAnnot_SetVertices = q3("EPDFAnnot_SetVertices", 3), o3._EPDFAnnot_SetLine = q3("EPDFAnnot_SetLine", 3), o3._EPDFAnnot_SetDefaultAppearance = q3("EPDFAnnot_SetDefaultAppearance", 6), o3._EPDFAnnot_GetDefaultAppearance = q3("EPDFAnnot_GetDefaultAppearance", 6), o3._EPDFAnnot_SetTextAlignment = q3("EPDFAnnot_SetTextAlignment", 2), o3._EPDFAnnot_GetTextAlignment = q3("EPDFAnnot_GetTextAlignment", 1), o3._EPDFAnnot_SetVerticalAlignment = q3("EPDFAnnot_SetVerticalAlignment", 2), o3._EPDFAnnot_GetVerticalAlignment = q3("EPDFAnnot_GetVerticalAlignment", 1), o3._EPDFPage_GetAnnotByName = q3("EPDFPage_GetAnnotByName", 2), o3._EPDFPage_RemoveAnnotByName = q3("EPDFPage_RemoveAnnotByName", 2), o3._EPDFAnnot_SetLinkedAnnot = q3("EPDFAnnot_SetLinkedAnnot", 3), o3._EPDFPage_GetAnnotCountRaw = q3("EPDFPage_GetAnnotCountRaw", 2), o3._EPDFPage_GetAnnotRaw = q3("EPDFPage_GetAnnotRaw", 3), o3._EPDFPage_RemoveAnnotRaw = q3("EPDFPage_RemoveAnnotRaw", 3), o3._EPDFAnnot_SetIcon = q3("EPDFAnnot_SetIcon", 2), o3._EPDFAnnot_GetIcon = q3("EPDFAnnot_GetIcon", 1), o3._EPDFAnnot_UpdateAppearanceToRect = q3("EPDFAnnot_UpdateAppearanceToRect", 2), o3._EPDFPage_CreateAnnot = q3("EPDFPage_CreateAnnot", 2), o3._FPDFDoc_GetAttachmentCount = q3("FPDFDoc_GetAttachmentCount", 1), o3._FPDFDoc_AddAttachment = q3("FPDFDoc_AddAttachment", 2), o3._FPDFDoc_GetAttachment = q3("FPDFDoc_GetAttachment", 2), o3._FPDFDoc_DeleteAttachment = q3("FPDFDoc_DeleteAttachment", 2), o3._FPDFAttachment_GetName = q3("FPDFAttachment_GetName", 3), o3._FPDFAttachment_HasKey = q3("FPDFAttachment_HasKey", 2), o3._FPDFAttachment_GetValueType = q3("FPDFAttachment_GetValueType", 2), o3._FPDFAttachment_SetStringValue = q3("FPDFAttachment_SetStringValue", 3), o3._FPDFAttachment_GetStringValue = q3("FPDFAttachment_GetStringValue", 4), o3._FPDFAttachment_SetFile = q3("FPDFAttachment_SetFile", 4), o3._FPDFAttachment_GetFile = q3("FPDFAttachment_GetFile", 4), o3._FPDFAttachment_GetSubtype = q3("FPDFAttachment_GetSubtype", 3), o3._EPDFAttachment_SetSubtype = q3("EPDFAttachment_SetSubtype", 2), o3._EPDFAttachment_SetDescription = q3("EPDFAttachment_SetDescription", 2), o3._EPDFAttachment_GetDescription = q3("EPDFAttachment_GetDescription", 3), o3._EPDFAttachment_GetIntegerValue = q3("EPDFAttachment_GetIntegerValue", 3), o3._FPDFCatalog_IsTagged = q3("FPDFCatalog_IsTagged", 1), o3._FPDFCatalog_SetLanguage = q3("FPDFCatalog_SetLanguage", 2), o3._EPDFCatalog_GetLanguage = q3("EPDFCatalog_GetLanguage", 3), o3._FPDFAvail_Create = q3("FPDFAvail_Create", 2), o3._FPDFAvail_Destroy = q3("FPDFAvail_Destroy", 1), o3._FPDFAvail_IsDocAvail = q3("FPDFAvail_IsDocAvail", 2), o3._FPDFAvail_GetDocument = q3("FPDFAvail_GetDocument", 2), o3._FPDFAvail_GetFirstPageNum = q3("FPDFAvail_GetFirstPageNum", 1), o3._FPDFAvail_IsPageAvail = q3("FPDFAvail_IsPageAvail", 3), o3._FPDFAvail_IsFormAvail = q3("FPDFAvail_IsFormAvail", 2), o3._FPDFAvail_IsLinearized = q3("FPDFAvail_IsLinearized", 1), o3._FPDFBookmark_GetFirstChild = q3("FPDFBookmark_GetFirstChild", 2), o3._FPDFBookmark_GetNextSibling = q3("FPDFBookmark_GetNextSibling", 2), o3._FPDFBookmark_GetTitle = q3("FPDFBookmark_GetTitle", 3), o3._FPDFBookmark_GetCount = q3("FPDFBookmark_GetCount", 1), o3._FPDFBookmark_Find = q3("FPDFBookmark_Find", 2), o3._FPDFBookmark_GetDest = q3("FPDFBookmark_GetDest", 2), o3._FPDFBookmark_GetAction = q3("FPDFBookmark_GetAction", 1), o3._FPDFAction_GetType = q3("FPDFAction_GetType", 1), o3._FPDFAction_GetDest = q3("FPDFAction_GetDest", 2), o3._FPDFAction_GetFilePath = q3("FPDFAction_GetFilePath", 3), o3._FPDFAction_GetURIPath = q3("FPDFAction_GetURIPath", 4), o3._FPDFDest_GetDestPageIndex = q3("FPDFDest_GetDestPageIndex", 2), o3._FPDFDest_GetView = q3("FPDFDest_GetView", 3), o3._FPDFDest_GetLocationInPage = q3("FPDFDest_GetLocationInPage", 7), o3._FPDFLink_GetLinkAtPoint = q3("FPDFLink_GetLinkAtPoint", 3), o3._FPDFLink_GetLinkZOrderAtPoint = q3("FPDFLink_GetLinkZOrderAtPoint", 3), o3._FPDFLink_GetDest = q3("FPDFLink_GetDest", 2), o3._FPDFLink_GetAction = q3("FPDFLink_GetAction", 1), o3._FPDFLink_Enumerate = q3("FPDFLink_Enumerate", 3), o3._FPDFLink_GetAnnot = q3("FPDFLink_GetAnnot", 2), o3._FPDFLink_GetAnnotRect = q3("FPDFLink_GetAnnotRect", 2), o3._FPDFLink_CountQuadPoints = q3("FPDFLink_CountQuadPoints", 1), o3._FPDFLink_GetQuadPoints = q3("FPDFLink_GetQuadPoints", 3), o3._FPDF_GetPageAAction = q3("FPDF_GetPageAAction", 2), o3._FPDF_GetFileIdentifier = q3("FPDF_GetFileIdentifier", 4), o3._FPDF_GetMetaText = q3("FPDF_GetMetaText", 4), o3._FPDF_GetPageLabel = q3("FPDF_GetPageLabel", 4), o3._EPDF_SetMetaText = q3("EPDF_SetMetaText", 3), o3._EPDF_HasMetaText = q3("EPDF_HasMetaText", 2), o3._EPDF_GetMetaTrapped = q3("EPDF_GetMetaTrapped", 1), o3._EPDF_SetMetaTrapped = q3("EPDF_SetMetaTrapped", 2), o3._EPDF_GetMetaKeyCount = q3("EPDF_GetMetaKeyCount", 2), o3._EPDF_GetMetaKeyName = q3("EPDF_GetMetaKeyName", 5), o3._FPDFPageObj_NewImageObj = q3("FPDFPageObj_NewImageObj", 1), o3._FPDFImageObj_LoadJpegFile = q3("FPDFImageObj_LoadJpegFile", 4), o3._FPDFImageObj_LoadJpegFileInline = q3("FPDFImageObj_LoadJpegFileInline", 4), o3._FPDFImageObj_SetMatrix = q3("FPDFImageObj_SetMatrix", 7), o3._FPDFImageObj_SetBitmap = q3("FPDFImageObj_SetBitmap", 4), o3._FPDFImageObj_GetBitmap = q3("FPDFImageObj_GetBitmap", 1), o3._FPDFImageObj_GetRenderedBitmap = q3("FPDFImageObj_GetRenderedBitmap", 3), o3._FPDFImageObj_GetImageDataDecoded = q3("FPDFImageObj_GetImageDataDecoded", 3), o3._FPDFImageObj_GetImageDataRaw = q3("FPDFImageObj_GetImageDataRaw", 3), o3._FPDFImageObj_GetImageFilterCount = q3("FPDFImageObj_GetImageFilterCount", 1), o3._FPDFImageObj_GetImageFilter = q3("FPDFImageObj_GetImageFilter", 4), o3._FPDFImageObj_GetImageMetadata = q3("FPDFImageObj_GetImageMetadata", 3), o3._FPDFImageObj_GetImagePixelSize = q3("FPDFImageObj_GetImagePixelSize", 3), o3._FPDFImageObj_GetIccProfileDataDecoded = q3("FPDFImageObj_GetIccProfileDataDecoded", 5), o3._FPDF_CreateNewDocument = q3("FPDF_CreateNewDocument", 0), o3._FPDFPage_Delete = q3("FPDFPage_Delete", 2), o3._FPDF_MovePages = q3("FPDF_MovePages", 4), o3._FPDFPage_New = q3("FPDFPage_New", 4), o3._FPDFPage_GetRotation = q3("FPDFPage_GetRotation", 1), o3._FPDFPage_InsertObject = q3("FPDFPage_InsertObject", 2), o3._FPDFPage_InsertObjectAtIndex = q3("FPDFPage_InsertObjectAtIndex", 3), o3._FPDFPage_RemoveObject = q3("FPDFPage_RemoveObject", 2), o3._FPDFPage_CountObjects = q3("FPDFPage_CountObjects", 1), o3._FPDFPage_GetObject = q3("FPDFPage_GetObject", 2), o3._FPDFPage_HasTransparency = q3("FPDFPage_HasTransparency", 1), o3._FPDFPageObj_Destroy = q3("FPDFPageObj_Destroy", 1), o3._FPDFPageObj_GetMarkedContentID = q3("FPDFPageObj_GetMarkedContentID", 1), o3._FPDFPageObj_CountMarks = q3("FPDFPageObj_CountMarks", 1), o3._FPDFPageObj_GetMark = q3("FPDFPageObj_GetMark", 2), o3._FPDFPageObj_AddMark = q3("FPDFPageObj_AddMark", 2), o3._FPDFPageObj_RemoveMark = q3("FPDFPageObj_RemoveMark", 2), o3._FPDFPageObjMark_GetName = q3("FPDFPageObjMark_GetName", 4), o3._FPDFPageObjMark_CountParams = q3("FPDFPageObjMark_CountParams", 1), o3._FPDFPageObjMark_GetParamKey = q3("FPDFPageObjMark_GetParamKey", 5), o3._FPDFPageObjMark_GetParamValueType = q3("FPDFPageObjMark_GetParamValueType", 2), o3._FPDFPageObjMark_GetParamIntValue = q3("FPDFPageObjMark_GetParamIntValue", 3), o3._FPDFPageObjMark_GetParamStringValue = q3("FPDFPageObjMark_GetParamStringValue", 5), o3._FPDFPageObjMark_GetParamBlobValue = q3("FPDFPageObjMark_GetParamBlobValue", 5), o3._FPDFPageObj_HasTransparency = q3("FPDFPageObj_HasTransparency", 1), o3._FPDFPageObjMark_SetIntParam = q3("FPDFPageObjMark_SetIntParam", 5), o3._FPDFPageObjMark_SetStringParam = q3("FPDFPageObjMark_SetStringParam", 5), o3._FPDFPageObjMark_SetBlobParam = q3("FPDFPageObjMark_SetBlobParam", 6), o3._FPDFPageObjMark_RemoveParam = q3("FPDFPageObjMark_RemoveParam", 3), o3._FPDFPageObj_GetType = q3("FPDFPageObj_GetType", 1), o3._FPDFPageObj_GetIsActive = q3("FPDFPageObj_GetIsActive", 2), o3._FPDFPageObj_SetIsActive = q3("FPDFPageObj_SetIsActive", 2), o3._FPDFPage_GenerateContent = q3("FPDFPage_GenerateContent", 1), o3._FPDFPageObj_Transform = q3("FPDFPageObj_Transform", 7), o3._FPDFPageObj_TransformF = q3("FPDFPageObj_TransformF", 2), o3._FPDFPageObj_GetMatrix = q3("FPDFPageObj_GetMatrix", 2), o3._FPDFPageObj_SetMatrix = q3("FPDFPageObj_SetMatrix", 2), o3._FPDFPageObj_SetBlendMode = q3("FPDFPageObj_SetBlendMode", 2), o3._FPDFPage_TransformAnnots = q3("FPDFPage_TransformAnnots", 7), o3._FPDFPage_SetRotation = q3("FPDFPage_SetRotation", 2), o3._FPDFPageObj_SetFillColor = q3("FPDFPageObj_SetFillColor", 5), o3._FPDFPageObj_GetFillColor = q3("FPDFPageObj_GetFillColor", 5), o3._FPDFPageObj_GetBounds = q3("FPDFPageObj_GetBounds", 5), o3._FPDFPageObj_GetRotatedBounds = q3("FPDFPageObj_GetRotatedBounds", 2), o3._FPDFPageObj_SetStrokeColor = q3("FPDFPageObj_SetStrokeColor", 5), o3._FPDFPageObj_GetStrokeColor = q3("FPDFPageObj_GetStrokeColor", 5), o3._FPDFPageObj_SetStrokeWidth = q3("FPDFPageObj_SetStrokeWidth", 2), o3._FPDFPageObj_GetStrokeWidth = q3("FPDFPageObj_GetStrokeWidth", 2), o3._FPDFPageObj_GetLineJoin = q3("FPDFPageObj_GetLineJoin", 1), o3._FPDFPageObj_SetLineJoin = q3("FPDFPageObj_SetLineJoin", 2), o3._FPDFPageObj_GetLineCap = q3("FPDFPageObj_GetLineCap", 1), o3._FPDFPageObj_SetLineCap = q3("FPDFPageObj_SetLineCap", 2), o3._FPDFPageObj_GetDashPhase = q3("FPDFPageObj_GetDashPhase", 2), o3._FPDFPageObj_SetDashPhase = q3("FPDFPageObj_SetDashPhase", 2), o3._FPDFPageObj_GetDashCount = q3("FPDFPageObj_GetDashCount", 1), o3._FPDFPageObj_GetDashArray = q3("FPDFPageObj_GetDashArray", 3), o3._FPDFPageObj_SetDashArray = q3("FPDFPageObj_SetDashArray", 4), o3._FPDFFormObj_CountObjects = q3("FPDFFormObj_CountObjects", 1), o3._FPDFFormObj_GetObject = q3("FPDFFormObj_GetObject", 2), o3._FPDFFormObj_RemoveObject = q3("FPDFFormObj_RemoveObject", 2), o3._FPDFPageObj_CreateNewPath = q3("FPDFPageObj_CreateNewPath", 2), o3._FPDFPageObj_CreateNewRect = q3("FPDFPageObj_CreateNewRect", 4), o3._FPDFPath_CountSegments = q3("FPDFPath_CountSegments", 1), o3._FPDFPath_GetPathSegment = q3("FPDFPath_GetPathSegment", 2), o3._FPDFPath_MoveTo = q3("FPDFPath_MoveTo", 3), o3._FPDFPath_LineTo = q3("FPDFPath_LineTo", 3), o3._FPDFPath_BezierTo = q3("FPDFPath_BezierTo", 7), o3._FPDFPath_Close = q3("FPDFPath_Close", 1), o3._FPDFPath_SetDrawMode = q3("FPDFPath_SetDrawMode", 3), o3._FPDFPath_GetDrawMode = q3("FPDFPath_GetDrawMode", 3), o3._FPDFPathSegment_GetPoint = q3("FPDFPathSegment_GetPoint", 3), o3._FPDFPathSegment_GetType = q3("FPDFPathSegment_GetType", 1), o3._FPDFPathSegment_GetClose = q3("FPDFPathSegment_GetClose", 1), o3._FPDFPageObj_NewTextObj = q3("FPDFPageObj_NewTextObj", 3), o3._FPDFText_SetText = q3("FPDFText_SetText", 2), o3._FPDFText_SetCharcodes = q3("FPDFText_SetCharcodes", 3), o3._FPDFText_LoadFont = q3("FPDFText_LoadFont", 5), o3._FPDFText_LoadStandardFont = q3("FPDFText_LoadStandardFont", 2), o3._FPDFText_LoadCidType2Font = q3("FPDFText_LoadCidType2Font", 6), o3._FPDFTextObj_GetFontSize = q3("FPDFTextObj_GetFontSize", 2), o3._FPDFTextObj_GetText = q3("FPDFTextObj_GetText", 4), o3._FPDFTextObj_GetRenderedBitmap = q3("FPDFTextObj_GetRenderedBitmap", 4), o3._FPDFFont_Close = q3("FPDFFont_Close", 1), o3._FPDFPageObj_CreateTextObj = q3("FPDFPageObj_CreateTextObj", 3), o3._FPDFTextObj_GetTextRenderMode = q3("FPDFTextObj_GetTextRenderMode", 1), o3._FPDFTextObj_SetTextRenderMode = q3("FPDFTextObj_SetTextRenderMode", 2), o3._FPDFTextObj_GetFont = q3("FPDFTextObj_GetFont", 1), o3._FPDFFont_GetBaseFontName = q3("FPDFFont_GetBaseFontName", 3), o3._FPDFFont_GetFamilyName = q3("FPDFFont_GetFamilyName", 3), o3._FPDFFont_GetFontData = q3("FPDFFont_GetFontData", 4), o3._FPDFFont_GetIsEmbedded = q3("FPDFFont_GetIsEmbedded", 1), o3._FPDFFont_GetFlags = q3("FPDFFont_GetFlags", 1), o3._FPDFFont_GetWeight = q3("FPDFFont_GetWeight", 1), o3._FPDFFont_GetItalicAngle = q3("FPDFFont_GetItalicAngle", 2), o3._FPDFFont_GetAscent = q3("FPDFFont_GetAscent", 3), o3._FPDFFont_GetDescent = q3("FPDFFont_GetDescent", 3), o3._FPDFFont_GetGlyphWidth = q3("FPDFFont_GetGlyphWidth", 4), o3._FPDFFont_GetGlyphPath = q3("FPDFFont_GetGlyphPath", 3), o3._FPDFGlyphPath_CountGlyphSegments = q3("FPDFGlyphPath_CountGlyphSegments", 1), o3._FPDFGlyphPath_GetGlyphPathSegment = q3("FPDFGlyphPath_GetGlyphPathSegment", 2), o3._EPDFText_RedactInRect = q3("EPDFText_RedactInRect", 4), o3._EPDFText_RedactInQuads = q3("EPDFText_RedactInQuads", 5), o3._FPDFDoc_GetPageMode = q3("FPDFDoc_GetPageMode", 1), o3._FPDFPage_Flatten = q3("FPDFPage_Flatten", 2), o3._FPDFPage_HasFormFieldAtPoint = q3("FPDFPage_HasFormFieldAtPoint", 4), o3._FPDFPage_FormFieldZOrderAtPoint = q3("FPDFPage_FormFieldZOrderAtPoint", 4), o3._malloc = q3("malloc", 1), o3._free = q3("free", 1), o3._FORM_OnMouseMove = q3("FORM_OnMouseMove", 5), o3._FORM_OnMouseWheel = q3("FORM_OnMouseWheel", 6), o3._FORM_OnFocus = q3("FORM_OnFocus", 5), o3._FORM_OnLButtonDown = q3("FORM_OnLButtonDown", 5), o3._FORM_OnLButtonUp = q3("FORM_OnLButtonUp", 5), o3._FORM_OnLButtonDoubleClick = q3("FORM_OnLButtonDoubleClick", 5), o3._FORM_OnRButtonDown = q3("FORM_OnRButtonDown", 5), o3._FORM_OnRButtonUp = q3("FORM_OnRButtonUp", 5), o3._FORM_OnKeyDown = q3("FORM_OnKeyDown", 4), o3._FORM_OnKeyUp = q3("FORM_OnKeyUp", 4), o3._FORM_OnChar = q3("FORM_OnChar", 4), o3._FORM_GetFocusedText = q3("FORM_GetFocusedText", 4), o3._FORM_GetSelectedText = q3("FORM_GetSelectedText", 4), o3._FORM_ReplaceAndKeepSelection = q3("FORM_ReplaceAndKeepSelection", 3), o3._FORM_ReplaceSelection = q3("FORM_ReplaceSelection", 3), o3._FORM_SelectAllText = q3("FORM_SelectAllText", 2), o3._FORM_CanUndo = q3("FORM_CanUndo", 2), o3._FORM_CanRedo = q3("FORM_CanRedo", 2), o3._FORM_Undo = q3("FORM_Undo", 2), o3._FORM_Redo = q3("FORM_Redo", 2), o3._FORM_ForceToKillFocus = q3("FORM_ForceToKillFocus", 1), o3._FORM_GetFocusedAnnot = q3("FORM_GetFocusedAnnot", 3), o3._FORM_SetFocusedAnnot = q3("FORM_SetFocusedAnnot", 2), o3._FPDF_FFLDraw = q3("FPDF_FFLDraw", 9), o3._FPDF_SetFormFieldHighlightColor = q3("FPDF_SetFormFieldHighlightColor", 3), o3._FPDF_SetFormFieldHighlightAlpha = q3("FPDF_SetFormFieldHighlightAlpha", 2), o3._FPDF_RemoveFormFieldHighlight = q3("FPDF_RemoveFormFieldHighlight", 1), o3._FORM_OnAfterLoadPage = q3("FORM_OnAfterLoadPage", 2), o3._FORM_OnBeforeClosePage = q3("FORM_OnBeforeClosePage", 2), o3._FORM_DoDocumentJSAction = q3("FORM_DoDocumentJSAction", 1), o3._FORM_DoDocumentOpenAction = q3("FORM_DoDocumentOpenAction", 1), o3._FORM_DoDocumentAAction = q3("FORM_DoDocumentAAction", 2), o3._FORM_DoPageAAction = q3("FORM_DoPageAAction", 3), o3._FORM_SetIndexSelected = q3("FORM_SetIndexSelected", 4), o3._FORM_IsIndexSelected = q3("FORM_IsIndexSelected", 3), o3._FPDFDoc_GetJavaScriptActionCount = q3("FPDFDoc_GetJavaScriptActionCount", 1), o3._FPDFDoc_GetJavaScriptAction = q3("FPDFDoc_GetJavaScriptAction", 2), o3._FPDFDoc_CloseJavaScriptAction = q3("FPDFDoc_CloseJavaScriptAction", 1), o3._FPDFJavaScriptAction_GetName = q3("FPDFJavaScriptAction_GetName", 3), o3._FPDFJavaScriptAction_GetScript = q3("FPDFJavaScriptAction_GetScript", 3), o3._FPDF_ImportPagesByIndex = q3("FPDF_ImportPagesByIndex", 5), o3._FPDF_ImportPages = q3("FPDF_ImportPages", 4), o3._FPDF_ImportNPagesToOne = q3("FPDF_ImportNPagesToOne", 5), o3._FPDF_NewXObjectFromPage = q3("FPDF_NewXObjectFromPage", 3), o3._FPDF_CloseXObject = q3("FPDF_CloseXObject", 1), o3._FPDF_NewFormObjectFromXObject = q3("FPDF_NewFormObjectFromXObject", 1), o3._FPDF_CopyViewerPreferences = q3("FPDF_CopyViewerPreferences", 2), o3._FPDF_RenderPageBitmapWithColorScheme_Start = q3("FPDF_RenderPageBitmapWithColorScheme_Start", 10), o3._FPDF_RenderPageBitmap_Start = q3("FPDF_RenderPageBitmap_Start", 9), o3._FPDF_RenderPage_Continue = q3("FPDF_RenderPage_Continue", 2), o3._FPDF_RenderPage_Close = q3("FPDF_RenderPage_Close", 1), o3._FPDF_SaveWithVersion = q3("FPDF_SaveWithVersion", 4), o3._FPDFText_GetCharIndexFromTextIndex = q3("FPDFText_GetCharIndexFromTextIndex", 2), o3._FPDFText_GetTextIndexFromCharIndex = q3("FPDFText_GetTextIndexFromCharIndex", 2), o3._FPDF_GetSignatureCount = q3("FPDF_GetSignatureCount", 1), o3._FPDF_GetSignatureObject = q3("FPDF_GetSignatureObject", 2), o3._FPDFSignatureObj_GetContents = q3("FPDFSignatureObj_GetContents", 3), o3._FPDFSignatureObj_GetByteRange = q3("FPDFSignatureObj_GetByteRange", 3), o3._FPDFSignatureObj_GetSubFilter = q3("FPDFSignatureObj_GetSubFilter", 3), o3._FPDFSignatureObj_GetReason = q3("FPDFSignatureObj_GetReason", 3), o3._FPDFSignatureObj_GetTime = q3("FPDFSignatureObj_GetTime", 3), o3._FPDFSignatureObj_GetDocMDPPermission = q3("FPDFSignatureObj_GetDocMDPPermission", 1), o3._FPDF_StructTree_GetForPage = q3("FPDF_StructTree_GetForPage", 1), o3._FPDF_StructTree_Close = q3("FPDF_StructTree_Close", 1), o3._FPDF_StructTree_CountChildren = q3("FPDF_StructTree_CountChildren", 1), o3._FPDF_StructTree_GetChildAtIndex = q3("FPDF_StructTree_GetChildAtIndex", 2), o3._FPDF_StructElement_GetAltText = q3("FPDF_StructElement_GetAltText", 3), o3._FPDF_StructElement_GetActualText = q3("FPDF_StructElement_GetActualText", 3), o3._FPDF_StructElement_GetID = q3("FPDF_StructElement_GetID", 3), o3._FPDF_StructElement_GetLang = q3("FPDF_StructElement_GetLang", 3), o3._FPDF_StructElement_GetAttributeCount = q3("FPDF_StructElement_GetAttributeCount", 1), o3._FPDF_StructElement_GetAttributeAtIndex = q3("FPDF_StructElement_GetAttributeAtIndex", 2), o3._FPDF_StructElement_GetStringAttribute = q3("FPDF_StructElement_GetStringAttribute", 4), o3._FPDF_StructElement_GetMarkedContentID = q3("FPDF_StructElement_GetMarkedContentID", 1), o3._FPDF_StructElement_GetType = q3("FPDF_StructElement_GetType", 3), o3._FPDF_StructElement_GetObjType = q3("FPDF_StructElement_GetObjType", 3), o3._FPDF_StructElement_GetTitle = q3("FPDF_StructElement_GetTitle", 3), o3._FPDF_StructElement_CountChildren = q3("FPDF_StructElement_CountChildren", 1), o3._FPDF_StructElement_GetChildAtIndex = q3("FPDF_StructElement_GetChildAtIndex", 2), o3._FPDF_StructElement_GetChildMarkedContentID = q3("FPDF_StructElement_GetChildMarkedContentID", 2), o3._FPDF_StructElement_GetParent = q3("FPDF_StructElement_GetParent", 1), o3._FPDF_StructElement_Attr_GetCount = q3("FPDF_StructElement_Attr_GetCount", 1), o3._FPDF_StructElement_Attr_GetName = q3("FPDF_StructElement_Attr_GetName", 5), o3._FPDF_StructElement_Attr_GetValue = q3("FPDF_StructElement_Attr_GetValue", 2), o3._FPDF_StructElement_Attr_GetType = q3("FPDF_StructElement_Attr_GetType", 1), o3._FPDF_StructElement_Attr_GetBooleanValue = q3("FPDF_StructElement_Attr_GetBooleanValue", 2), o3._FPDF_StructElement_Attr_GetNumberValue = q3("FPDF_StructElement_Attr_GetNumberValue", 2), o3._FPDF_StructElement_Attr_GetStringValue = q3("FPDF_StructElement_Attr_GetStringValue", 4), o3._FPDF_StructElement_Attr_GetBlobValue = q3("FPDF_StructElement_Attr_GetBlobValue", 4), o3._FPDF_StructElement_Attr_CountChildren = q3("FPDF_StructElement_Attr_CountChildren", 1), o3._FPDF_StructElement_Attr_GetChildAtIndex = q3("FPDF_StructElement_Attr_GetChildAtIndex", 2), o3._FPDF_StructElement_GetMarkedContentIdCount = q3("FPDF_StructElement_GetMarkedContentIdCount", 1), o3._FPDF_StructElement_GetMarkedContentIdAtIndex = q3("FPDF_StructElement_GetMarkedContentIdAtIndex", 2), o3._FPDF_AddInstalledFont = q3("FPDF_AddInstalledFont", 3), o3._FPDF_SetSystemFontInfo = q3("FPDF_SetSystemFontInfo", 1), o3._FPDF_GetDefaultTTFMap = q3("FPDF_GetDefaultTTFMap", 0), o3._FPDF_GetDefaultTTFMapCount = q3("FPDF_GetDefaultTTFMapCount", 0), o3._FPDF_GetDefaultTTFMapEntry = q3("FPDF_GetDefaultTTFMapEntry", 1), o3._FPDF_GetDefaultSystemFontInfo = q3("FPDF_GetDefaultSystemFontInfo", 0), o3._FPDF_FreeDefaultSystemFontInfo = q3("FPDF_FreeDefaultSystemFontInfo", 1), o3._FPDFText_LoadPage = q3("FPDFText_LoadPage", 1), o3._FPDFText_ClosePage = q3("FPDFText_ClosePage", 1), o3._FPDFText_CountChars = q3("FPDFText_CountChars", 1), o3._FPDFText_GetUnicode = q3("FPDFText_GetUnicode", 2), o3._FPDFText_GetTextObject = q3("FPDFText_GetTextObject", 2), o3._FPDFText_IsGenerated = q3("FPDFText_IsGenerated", 2), o3._FPDFText_IsHyphen = q3("FPDFText_IsHyphen", 2), o3._FPDFText_HasUnicodeMapError = q3("FPDFText_HasUnicodeMapError", 2), o3._FPDFText_GetFontSize = q3("FPDFText_GetFontSize", 2), o3._FPDFText_GetFontInfo = q3("FPDFText_GetFontInfo", 5), o3._FPDFText_GetFontWeight = q3("FPDFText_GetFontWeight", 2), o3._FPDFText_GetFillColor = q3("FPDFText_GetFillColor", 6), o3._FPDFText_GetStrokeColor = q3("FPDFText_GetStrokeColor", 6), o3._FPDFText_GetCharAngle = q3("FPDFText_GetCharAngle", 2), o3._FPDFText_GetCharBox = q3("FPDFText_GetCharBox", 6), o3._FPDFText_GetLooseCharBox = q3("FPDFText_GetLooseCharBox", 3), o3._FPDFText_GetMatrix = q3("FPDFText_GetMatrix", 3), o3._FPDFText_GetCharOrigin = q3("FPDFText_GetCharOrigin", 4), o3._FPDFText_GetCharIndexAtPos = q3("FPDFText_GetCharIndexAtPos", 5), o3._FPDFText_GetText = q3("FPDFText_GetText", 4), o3._FPDFText_CountRects = q3("FPDFText_CountRects", 3), o3._FPDFText_GetRect = q3("FPDFText_GetRect", 6), o3._FPDFText_GetBoundedText = q3("FPDFText_GetBoundedText", 7), o3._FPDFText_FindStart = q3("FPDFText_FindStart", 4), o3._FPDFText_FindNext = q3("FPDFText_FindNext", 1), o3._FPDFText_FindPrev = q3("FPDFText_FindPrev", 1), o3._FPDFText_GetSchResultIndex = q3("FPDFText_GetSchResultIndex", 1), o3._FPDFText_GetSchCount = q3("FPDFText_GetSchCount", 1), o3._FPDFText_FindClose = q3("FPDFText_FindClose", 1), o3._FPDFLink_LoadWebLinks = q3("FPDFLink_LoadWebLinks", 1), o3._FPDFLink_CountWebLinks = q3("FPDFLink_CountWebLinks", 1), o3._FPDFLink_GetURL = q3("FPDFLink_GetURL", 4), o3._FPDFLink_CountRects = q3("FPDFLink_CountRects", 2), o3._FPDFLink_GetRect = q3("FPDFLink_GetRect", 7), o3._FPDFLink_GetTextRange = q3("FPDFLink_GetTextRange", 4), o3._FPDFLink_CloseWebLinks = q3("FPDFLink_CloseWebLinks", 1), o3._FPDFPage_GetDecodedThumbnailData = q3("FPDFPage_GetDecodedThumbnailData", 3), o3._FPDFPage_GetRawThumbnailData = q3("FPDFPage_GetRawThumbnailData", 3), o3._FPDFPage_GetThumbnailAsBitmap = q3("FPDFPage_GetThumbnailAsBitmap", 1), o3._FPDFPage_SetMediaBox = q3("FPDFPage_SetMediaBox", 5), o3._FPDFPage_SetCropBox = q3("FPDFPage_SetCropBox", 5), o3._FPDFPage_SetBleedBox = q3("FPDFPage_SetBleedBox", 5), o3._FPDFPage_SetTrimBox = q3("FPDFPage_SetTrimBox", 5), o3._FPDFPage_SetArtBox = q3("FPDFPage_SetArtBox", 5), o3._FPDFPage_GetMediaBox = q3("FPDFPage_GetMediaBox", 5), o3._FPDFPage_GetCropBox = q3("FPDFPage_GetCropBox", 5), o3._FPDFPage_GetBleedBox = q3("FPDFPage_GetBleedBox", 5), o3._FPDFPage_GetTrimBox = q3("FPDFPage_GetTrimBox", 5), o3._FPDFPage_GetArtBox = q3("FPDFPage_GetArtBox", 5), o3._FPDFPage_TransFormWithClip = q3("FPDFPage_TransFormWithClip", 3), o3._FPDFPageObj_TransformClipPath = q3("FPDFPageObj_TransformClipPath", 7), o3._FPDFPageObj_GetClipPath = q3("FPDFPageObj_GetClipPath", 1), o3._FPDFClipPath_CountPaths = q3("FPDFClipPath_CountPaths", 1), o3._FPDFClipPath_CountPathSegments = q3("FPDFClipPath_CountPathSegments", 2), o3._FPDFClipPath_GetPathSegment = q3("FPDFClipPath_GetPathSegment", 3), o3._FPDF_CreateClipPath = q3("FPDF_CreateClipPath", 4), o3._FPDF_DestroyClipPath = q3("FPDF_DestroyClipPath", 1), o3._FPDFPage_InsertClipPath = q3("FPDFPage_InsertClipPath", 2), o3._FPDF_InitLibrary = q3("FPDF_InitLibrary", 0), o3._FPDF_DestroyLibrary = q3("FPDF_DestroyLibrary", 0), o3._FPDF_SetSandBoxPolicy = q3("FPDF_SetSandBoxPolicy", 2), o3._FPDF_LoadDocument = q3("FPDF_LoadDocument", 2), o3._FPDF_GetFormType = q3("FPDF_GetFormType", 1), o3._FPDF_LoadXFA = q3("FPDF_LoadXFA", 1), o3._FPDF_LoadMemDocument = q3("FPDF_LoadMemDocument", 3), o3._FPDF_LoadMemDocument64 = q3("FPDF_LoadMemDocument64", 3), o3._FPDF_LoadCustomDocument = q3("FPDF_LoadCustomDocument", 2), o3._FPDF_GetFileVersion = q3("FPDF_GetFileVersion", 2), o3._FPDF_DocumentHasValidCrossReferenceTable = q3("FPDF_DocumentHasValidCrossReferenceTable", 1), o3._FPDF_GetDocPermissions = q3("FPDF_GetDocPermissions", 1), o3._FPDF_GetDocUserPermissions = q3("FPDF_GetDocUserPermissions", 1), o3._FPDF_GetSecurityHandlerRevision = q3("FPDF_GetSecurityHandlerRevision", 1), o3._FPDF_GetPageCount = q3("FPDF_GetPageCount", 1), o3._FPDF_LoadPage = q3("FPDF_LoadPage", 2), o3._FPDF_GetPageWidthF = q3("FPDF_GetPageWidthF", 1), o3._FPDF_GetPageWidth = q3("FPDF_GetPageWidth", 1), o3._FPDF_GetPageHeightF = q3("FPDF_GetPageHeightF", 1), o3._FPDF_GetPageHeight = q3("FPDF_GetPageHeight", 1), o3._FPDF_GetPageBoundingBox = q3("FPDF_GetPageBoundingBox", 2), o3._FPDF_RenderPageBitmap = q3("FPDF_RenderPageBitmap", 8), o3._FPDF_RenderPageBitmapWithMatrix = q3("FPDF_RenderPageBitmapWithMatrix", 5), o3._EPDF_RenderAnnotBitmap = q3("EPDF_RenderAnnotBitmap", 6), o3._FPDF_ClosePage = q3("FPDF_ClosePage", 1), o3._FPDF_CloseDocument = q3("FPDF_CloseDocument", 1), o3._FPDF_GetLastError = q3("FPDF_GetLastError", 0), o3._FPDF_DeviceToPage = q3("FPDF_DeviceToPage", 10), o3._FPDF_PageToDevice = q3("FPDF_PageToDevice", 10), o3._FPDFBitmap_Create = q3("FPDFBitmap_Create", 3), o3._FPDFBitmap_CreateEx = q3("FPDFBitmap_CreateEx", 5), o3._FPDFBitmap_GetFormat = q3("FPDFBitmap_GetFormat", 1), o3._FPDFBitmap_FillRect = q3("FPDFBitmap_FillRect", 6), o3._FPDFBitmap_GetBuffer = q3("FPDFBitmap_GetBuffer", 1), o3._FPDFBitmap_GetWidth = q3("FPDFBitmap_GetWidth", 1), o3._FPDFBitmap_GetHeight = q3("FPDFBitmap_GetHeight", 1), o3._FPDFBitmap_GetStride = q3("FPDFBitmap_GetStride", 1), o3._FPDFBitmap_Destroy = q3("FPDFBitmap_Destroy", 1), o3._FPDF_GetPageSizeByIndexF = q3("FPDF_GetPageSizeByIndexF", 3), o3._EPDF_GetPageRotationByIndex = q3("EPDF_GetPageRotationByIndex", 2), o3._FPDF_GetPageSizeByIndex = q3("FPDF_GetPageSizeByIndex", 4), o3._FPDF_VIEWERREF_GetPrintScaling = q3("FPDF_VIEWERREF_GetPrintScaling", 1), o3._FPDF_VIEWERREF_GetNumCopies = q3("FPDF_VIEWERREF_GetNumCopies", 1), o3._FPDF_VIEWERREF_GetPrintPageRange = q3("FPDF_VIEWERREF_GetPrintPageRange", 1), o3._FPDF_VIEWERREF_GetPrintPageRangeCount = q3("FPDF_VIEWERREF_GetPrintPageRangeCount", 1), o3._FPDF_VIEWERREF_GetPrintPageRangeElement = q3("FPDF_VIEWERREF_GetPrintPageRangeElement", 2), o3._FPDF_VIEWERREF_GetDuplex = q3("FPDF_VIEWERREF_GetDuplex", 1), o3._FPDF_VIEWERREF_GetName = q3("FPDF_VIEWERREF_GetName", 4), o3._FPDF_CountNamedDests = q3("FPDF_CountNamedDests", 1), o3._FPDF_GetNamedDestByName = q3("FPDF_GetNamedDestByName", 2), o3._FPDF_GetNamedDest = q3("FPDF_GetNamedDest", 4), o3._FPDF_GetXFAPacketCount = q3("FPDF_GetXFAPacketCount", 1), o3._FPDF_GetXFAPacketName = q3("FPDF_GetXFAPacketName", 4), o3._FPDF_GetXFAPacketContent = q3("FPDF_GetXFAPacketContent", 5), o3._FPDF_GetTrailerEnds = q3("FPDF_GetTrailerEnds", 3);
        var Ze2, et2, tt2 = q3("fflush", 1), nt2 = q3("emscripten_builtin_memalign", 2), rt2 = q3("strerror", 1), ot2 = q3("setThrew", 2), at2 = () => (at2 = Qe2.emscripten_stack_init)(), it2 = () => (it2 = Qe2.emscripten_stack_get_end)(), st2 = (e4) => (st2 = Qe2._emscripten_stack_restore)(e4), ut2 = (e4) => (ut2 = Qe2._emscripten_stack_alloc)(e4), Ft2 = () => (Ft2 = Qe2.emscripten_stack_get_current)();
        function mt2() {
          var e4;
          at2(), C2(!(3 & (e4 = it2()))), 0 == e4 && (e4 += 4), M2[e4 >> 2] = 34821223, M2[e4 + 4 >> 2] = 2310721022, M2[0] = 1668509029;
        }
        function lt2() {
          var e4;
          function t3() {
            Ze2 || (Ze2 = 1, o3.calledRun = 1, S2 || (C2(!w2), w2 = true, x2(), o3.noFSInit || Oe2.initialized || Oe2.init(), Oe2.ignorePermissions = false, ie3(O2), n3(o3), o3.onRuntimeInitialized?.(), C2(!o3._main, 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]'), (function() {
              x2();
              var e5 = o3.postRun;
              e5 && ("function" == typeof e5 && (e5 = [e5]), e5.forEach(I2)), ie3(k2);
            })()));
          }
          B3 > 0 || (mt2(), !et2 && (et2 = 1, (e4 = o3.preRun) && ("function" == typeof e4 && (e4 = [e4]), e4.forEach(R2)), ie3(v2), B3 > 0) || (o3.setStatus ? (o3.setStatus("Running..."), setTimeout(() => {
            setTimeout(() => o3.setStatus(""), 1), t3();
          }, 1)) : t3(), x2()));
        }
        if (o3.dynCall_ji = q3("dynCall_ji", 2), o3.dynCall_jij = q3("dynCall_jij", 4), o3.dynCall_iiij = q3("dynCall_iiij", 5), o3.dynCall_iij = q3("dynCall_iij", 4), o3.dynCall_j = q3("dynCall_j", 1), o3.dynCall_jji = q3("dynCall_jji", 4), o3.dynCall_iji = q3("dynCall_iji", 4), o3.dynCall_viijii = q3("dynCall_viijii", 7), o3.dynCall_iiji = q3("dynCall_iiji", 5), o3.dynCall_jiji = q3("dynCall_jiji", 5), o3.dynCall_iiiiij = q3("dynCall_iiiiij", 7), o3.dynCall_iiiiijj = q3("dynCall_iiiiijj", 9), o3.dynCall_iiiiiijj = q3("dynCall_iiiiiijj", 10), o3.dynCall_viji = q3("dynCall_viji", 5), o3.wasmExports = Qe2, o3.ccall = Je2, o3.cwrap = (e4, t3, n4, r3) => (...r4) => Je2(e4, t3, n4, r4), o3.addFunction = (e4, t3) => {
          C2(void 0 !== e4);
          var n4 = He2(e4);
          if (n4) return n4;
          var r3 = (() => {
            if (Xe2.length) return Xe2.pop();
            try {
              Ee2.grow(1);
            } catch (e5) {
              if (!(e5 instanceof RangeError)) throw e5;
              throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            return Ee2.length - 1;
          })();
          try {
            Ke2(r3, e4);
          } catch (n5) {
            if (!(n5 instanceof TypeError)) throw n5;
            C2(void 0 !== t3, "Missing signature argument to addFunction: " + e4);
            var o4 = ze2(e4, t3);
            Ke2(r3, o4);
          }
          return Me2.set(e4, r3), r3;
        }, o3.removeFunction = (e4) => {
          Me2.delete(Ue2(e4)), Ke2(e4, null), Xe2.push(e4);
        }, o3.setValue = function(e4, t3, n4 = "i8") {
          switch (n4.endsWith("*") && (n4 = "*"), n4) {
            case "i1":
            case "i8":
              b2[e4] = t3;
              break;
            case "i16":
              p4[e4 >> 1] = t3;
              break;
            case "i32":
              E2[e4 >> 2] = t3;
              break;
            case "i64":
              z3("to do setValue(i64) use WASM_BIGINT");
            case "float":
              y2[e4 >> 2] = t3;
              break;
            case "double":
              G2[e4 >> 3] = t3;
              break;
            case "*":
              M2[e4 >> 2] = t3;
              break;
            default:
              z3(`invalid type for setValue: ${n4}`);
          }
        }, o3.getValue = function(e4, t3 = "i8") {
          switch (t3.endsWith("*") && (t3 = "*"), t3) {
            case "i1":
            case "i8":
              return b2[e4];
            case "i16":
              return p4[e4 >> 1];
            case "i32":
              return E2[e4 >> 2];
            case "i64":
              z3("to do getValue(i64) use WASM_BIGINT");
            case "float":
              return y2[e4 >> 2];
            case "double":
              return G2[e4 >> 3];
            case "*":
              return M2[e4 >> 2];
            default:
              z3(`invalid type for getValue: ${t3}`);
          }
        }, o3.UTF8ToString = _e2, o3.stringToUTF8 = Re2, o3.UTF16ToString = (e4, t3) => {
          C2(e4 % 2 == 0, "Pointer passed to UTF16ToString must be aligned to two bytes!");
          for (var n4 = e4, r3 = n4 >> 1, o4 = r3 + t3 / 2; !(r3 >= o4) && A2[r3]; ) ++r3;
          if ((n4 = r3 << 1) - e4 > 32 && $e2) return $e2.decode(f2.subarray(e4, n4));
          for (var a4 = "", i4 = 0; !(i4 >= t3 / 2); ++i4) {
            var s5 = p4[e4 + 2 * i4 >> 1];
            if (0 == s5) break;
            a4 += String.fromCharCode(s5);
          }
          return a4;
        }, o3.stringToUTF16 = (e4, t3, n4) => {
          if (C2(t3 % 2 == 0, "Pointer passed to stringToUTF16 must be aligned to two bytes!"), C2("number" == typeof n4, "stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"), n4 ??= 2147483647, n4 < 2) return 0;
          for (var r3 = t3, o4 = (n4 -= 2) < 2 * e4.length ? n4 / 2 : e4.length, a4 = 0; a4 < o4; ++a4) {
            var i4 = e4.charCodeAt(a4);
            p4[t3 >> 1] = i4, t3 += 2;
          }
          return p4[t3 >> 1] = 0, t3 - r3;
        }, ["writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromI64", "readI53FromU64", "convertI32PairToI53", "convertU32PairToI53", "getTempRet0", "setTempRet0", "exitJS", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "emscriptenLog", "readEmAsmArgs", "jstoi_q", "listenOnce", "autoResumeAudioContext", "dynCallLegacy", "getDynCaller", "dynCall", "handleException", "keepRuntimeAlive", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "asmjsMangle", "HandleAllocator", "getNativeTypeSize", "STACK_SIZE", "STACK_ALIGN", "POINTER_SIZE", "ASSERTIONS", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "intArrayToString", "AsciiToString", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "stringToNewUTF8", "registerKeyEventCallback", "maybeCStringToJsString", "findEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "jsStackTrace", "getCallstack", "convertPCtoSourceLocation", "checkWasiClock", "wasiRightsToMuslOFlags", "wasiOFlagsToMuslOFlags", "createDyncallWrapper", "safeSetTimeout", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "registerPostMainLoop", "registerPreMainLoop", "getPromise", "makePromise", "idsToPromises", "makePromiseCallback", "ExceptionInfo", "findMatchingCatch", "Browser_asyncPrepareDataCounter", "safeRequestAnimationFrame", "arraySum", "addDays", "getSocketFromFD", "getSocketAddress", "FS_unlink", "FS_mkdirTree", "_setNetworkCallback", "heapObjectForWebGLType", "toTypedArrayIndex", "webgl_enable_ANGLE_instanced_arrays", "webgl_enable_OES_vertex_array_object", "webgl_enable_WEBGL_draw_buffers", "webgl_enable_WEBGL_multi_draw", "webgl_enable_EXT_polygon_offset_clamp", "webgl_enable_EXT_clip_control", "webgl_enable_WEBGL_polygon_mode", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "colorChannelsInGlTextureFormat", "emscriptenWebGLGetTexPixelData", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "__glGetActiveAttribOrUniform", "writeGLArray", "registerWebGlEventCallback", "runAndAbortIfError", "ALLOC_NORMAL", "ALLOC_STACK", "allocate", "writeStringToMemory", "writeAsciiToMemory", "setErrNo", "demangle", "stackTrace"].forEach(function(e4) {
          re3(e4, () => {
            var t3 = `\`${e4}\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`, n4 = e4;
            n4.startsWith("_") || (n4 = "$" + e4), t3 += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${n4}')`, ne3(e4) && (t3 += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you"), me2(t3);
          }), ae3(e4);
        }), ["run", "addOnPreRun", "addOnInit", "addOnPreMain", "addOnExit", "addOnPostRun", "addRunDependency", "removeRunDependency", "out", "err", "callMain", "abort", "wasmMemory", "writeStackCookie", "checkStackCookie", "convertI32PairToI53Checked", "stackSave", "stackRestore", "stackAlloc", "ptrToString", "zeroMemory", "getHeapMax", "growMemory", "ENV", "ERRNO_CODES", "strError", "DNS", "Protocols", "Sockets", "initRandomFill", "randomFill", "timers", "warnOnce", "readEmAsmArgsArray", "jstoi_s", "getExecutableName", "asyncLoad", "alignMemory", "mmapAlloc", "wasmTable", "noExitRuntime", "getCFunc", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "freeTableIndexes", "functionsInTableMap", "getEmptyTableSlot", "updateTableMap", "getFunctionAddress", "PATH", "PATH_FS", "UTF8Decoder", "UTF8ArrayToString", "stringToUTF8Array", "lengthBytesUTF8", "intArrayFromString", "stringToAscii", "UTF16Decoder", "stringToUTF8OnStack", "writeArrayToMemory", "JSEvents", "specialHTMLTargets", "findCanvasEventTarget", "currentFullscreenStrategy", "restoreOldWindowedStyle", "UNWIND_CACHE", "ExitStatus", "getEnvStrings", "doReadv", "doWritev", "promiseMap", "uncaughtExceptionCount", "exceptionLast", "exceptionCaught", "Browser", "getPreloadedImageData__data", "wget", "MONTH_DAYS_REGULAR", "MONTH_DAYS_LEAP", "MONTH_DAYS_REGULAR_CUMULATIVE", "MONTH_DAYS_LEAP_CUMULATIVE", "isLeapYear", "ydayFromDate", "SYSCALLS", "preloadPlugins", "FS_createPreloadedFile", "FS_modeStringToFlags", "FS_getMode", "FS_stdin_getChar_buffer", "FS_stdin_getChar", "FS_createPath", "FS_createDevice", "FS_readFile", "FS", "FS_createDataFile", "FS_createLazyFile", "MEMFS", "TTY", "PIPEFS", "SOCKFS", "tempFixedLengthArray", "miniTempWebGLFloatBuffers", "miniTempWebGLIntBuffers", "GL", "AL", "GLUT", "EGL", "GLEW", "IDBStore", "SDL", "SDL_gfx", "allocateUTF8", "allocateUTF8OnStack", "print", "printErr"].forEach(ae3), N3 = function e4() {
          Ze2 || lt2(), Ze2 || (N3 = e4);
        }, o3.preInit) for ("function" == typeof o3.preInit && (o3.preInit = [o3.preInit]); o3.preInit.length > 0; ) o3.preInit.pop()();
        lt2(), t2 = a3;
        for (const t3 of Object.keys(o3)) t3 in e3 || Object.defineProperty(e3, t3, { configurable: true, get() {
          z3(`Access to module property ('${t3}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`);
        } });
        return t2;
      });
      L = { EPDF_GetMetaKeyCount: [["number", "boolean"], "number"], EPDF_GetMetaKeyName: [["number", "number", "boolean", "number", "number"], "number"], EPDF_GetMetaTrapped: [["number"], "number"], EPDF_GetPageRotationByIndex: [["number", "number"], "number"], EPDF_HasMetaText: [["number", "string"], "boolean"], EPDF_PNG_EncodeRGBA: [["number", "number", "number", "number", "number", "number"], "number"], EPDF_RenderAnnotBitmap: [["number", "number", "number", "number", "number", "number"], "boolean"], EPDF_SetMetaText: [["number", "string", "number"], "boolean"], EPDF_SetMetaTrapped: [["number", "number"], "boolean"], EPDFAction_CreateGoTo: [["number", "number"], "number"], EPDFAction_CreateGoToNamed: [["number", "string"], "number"], EPDFAction_CreateLaunch: [["number", "number"], "number"], EPDFAction_CreateRemoteGoToByName: [["number", "number", "number"], "number"], EPDFAction_CreateRemoteGoToDest: [["number", "number", "number"], "number"], EPDFAction_CreateURI: [["number", "string"], "number"], EPDFAnnot_ClearColor: [["number", "number"], "boolean"], EPDFAnnot_GenerateAppearance: [["number"], "boolean"], EPDFAnnot_GenerateAppearanceWithBlend: [["number", "number"], "boolean"], EPDFAnnot_GetBlendMode: [["number"], "number"], EPDFAnnot_GetBorderDashPattern: [["number", "number", "number"], "boolean"], EPDFAnnot_GetBorderDashPatternCount: [["number"], "number"], EPDFAnnot_GetBorderEffect: [["number", "number"], "boolean"], EPDFAnnot_GetBorderStyle: [["number", "number"], "number"], EPDFAnnot_GetColor: [["number", "number", "number", "number", "number"], "boolean"], EPDFAnnot_GetDefaultAppearance: [["number", "number", "number", "number", "number", "number"], "boolean"], EPDFAnnot_GetIcon: [["number"], "number"], EPDFAnnot_GetIntent: [["number", "number", "number"], "number"], EPDFAnnot_GetLineEndings: [["number", "number", "number"], "boolean"], EPDFAnnot_GetOpacity: [["number", "number"], "boolean"], EPDFAnnot_GetRectangleDifferences: [["number", "number", "number", "number", "number"], "boolean"], EPDFAnnot_GetRichContent: [["number", "number", "number"], "number"], EPDFAnnot_GetTextAlignment: [["number"], "number"], EPDFAnnot_GetVerticalAlignment: [["number"], "number"], EPDFAnnot_SetBorderDashPattern: [["number", "number", "number"], "boolean"], EPDFAnnot_SetBorderStyle: [["number", "number", "number"], "boolean"], EPDFAnnot_SetColor: [["number", "number", "number", "number", "number"], "boolean"], EPDFAnnot_SetDefaultAppearance: [["number", "number", "number", "number", "number", "number"], "boolean"], EPDFAnnot_SetIcon: [["number", "number"], "boolean"], EPDFAnnot_SetIntent: [["number", "string"], "boolean"], EPDFAnnot_SetLine: [["number", "number", "number"], "boolean"], EPDFAnnot_SetLineEndings: [["number", "number", "number"], "boolean"], EPDFAnnot_SetLinkedAnnot: [["number", "string", "number"], "boolean"], EPDFAnnot_SetOpacity: [["number", "number"], "boolean"], EPDFAnnot_SetTextAlignment: [["number", "number"], "boolean"], EPDFAnnot_SetVerticalAlignment: [["number", "number"], "boolean"], EPDFAnnot_SetVertices: [["number", "number", "number"], "boolean"], EPDFAnnot_UpdateAppearanceToRect: [["number", "number"], "boolean"], EPDFAttachment_GetDescription: [["number", "number", "number"], "number"], EPDFAttachment_GetIntegerValue: [["number", "string", "number"], "boolean"], EPDFAttachment_SetDescription: [["number", "number"], "boolean"], EPDFAttachment_SetSubtype: [["number", "string"], "boolean"], EPDFBookmark_AppendChild: [["number", "number", "number"], "number"], EPDFBookmark_Clear: [["number"], "boolean"], EPDFBookmark_ClearTarget: [["number"], "boolean"], EPDFBookmark_Create: [["number", "number"], "number"], EPDFBookmark_Delete: [["number", "number"], "boolean"], EPDFBookmark_InsertAfter: [["number", "number", "number", "number"], "number"], EPDFBookmark_SetAction: [["number", "number", "number"], "boolean"], EPDFBookmark_SetDest: [["number", "number", "number"], "boolean"], EPDFBookmark_SetTitle: [["number", "number"], "boolean"], EPDFCatalog_GetLanguage: [["number", "number", "number"], "number"], EPDFDest_CreateRemoteView: [["number", "number", "number", "number", "number"], "number"], EPDFDest_CreateRemoteXYZ: [["number", "number", "boolean", "number", "boolean", "number", "boolean", "number"], "number"], EPDFDest_CreateView: [["number", "number", "number", "number"], "number"], EPDFDest_CreateXYZ: [["number", "boolean", "number", "boolean", "number", "boolean", "number"], "number"], EPDFNamedDest_Remove: [["number", "string"], "boolean"], EPDFNamedDest_SetDest: [["number", "string", "number"], "boolean"], EPDFPage_CreateAnnot: [["number", "number"], "number"], EPDFPage_GetAnnotByName: [["number", "number"], "number"], EPDFPage_GetAnnotCountRaw: [["number", "number"], "number"], EPDFPage_GetAnnotRaw: [["number", "number", "number"], "number"], EPDFPage_RemoveAnnotByName: [["number", "number"], "boolean"], EPDFPage_RemoveAnnotRaw: [["number", "number", "number"], "boolean"], EPDFText_RedactInQuads: [["number", "number", "number", "boolean", "boolean"], "boolean"], EPDFText_RedactInRect: [["number", "number", "boolean", "boolean"], "boolean"], FORM_CanRedo: [["number", "number"], "boolean"], FORM_CanUndo: [["number", "number"], "boolean"], FORM_DoDocumentAAction: [["number", "number"], null], FORM_DoDocumentJSAction: [["number"], null], FORM_DoDocumentOpenAction: [["number"], null], FORM_DoPageAAction: [["number", "number", "number"], null], FORM_ForceToKillFocus: [["number"], "boolean"], FORM_GetFocusedAnnot: [["number", "number", "number"], "boolean"], FORM_GetFocusedText: [["number", "number", "number", "number"], "number"], FORM_GetSelectedText: [["number", "number", "number", "number"], "number"], FORM_IsIndexSelected: [["number", "number", "number"], "boolean"], FORM_OnAfterLoadPage: [["number", "number"], null], FORM_OnBeforeClosePage: [["number", "number"], null], FORM_OnChar: [["number", "number", "number", "number"], "boolean"], FORM_OnFocus: [["number", "number", "number", "number", "number"], "boolean"], FORM_OnKeyDown: [["number", "number", "number", "number"], "boolean"], FORM_OnKeyUp: [["number", "number", "number", "number"], "boolean"], FORM_OnLButtonDoubleClick: [["number", "number", "number", "number", "number"], "boolean"], FORM_OnLButtonDown: [["number", "number", "number", "number", "number"], "boolean"], FORM_OnLButtonUp: [["number", "number", "number", "number", "number"], "boolean"], FORM_OnMouseMove: [["number", "number", "number", "number", "number"], "boolean"], FORM_OnMouseWheel: [["number", "number", "number", "number", "number", "number"], "boolean"], FORM_OnRButtonDown: [["number", "number", "number", "number", "number"], "boolean"], FORM_OnRButtonUp: [["number", "number", "number", "number", "number"], "boolean"], FORM_Redo: [["number", "number"], "boolean"], FORM_ReplaceAndKeepSelection: [["number", "number", "number"], null], FORM_ReplaceSelection: [["number", "number", "number"], null], FORM_SelectAllText: [["number", "number"], "boolean"], FORM_SetFocusedAnnot: [["number", "number"], "boolean"], FORM_SetIndexSelected: [["number", "number", "number", "boolean"], "boolean"], FORM_Undo: [["number", "number"], "boolean"], FPDF_AddInstalledFont: [["number", "number", "number"], null], FPDF_CloseDocument: [["number"], null], FPDF_ClosePage: [["number"], null], FPDF_CloseXObject: [["number"], null], FPDF_CopyViewerPreferences: [["number", "number"], "boolean"], FPDF_CountNamedDests: [["number"], "number"], FPDF_CreateClipPath: [["number", "number", "number", "number"], "number"], FPDF_CreateNewDocument: [[], "number"], FPDF_DestroyClipPath: [["number"], null], FPDF_DestroyLibrary: [[], null], FPDF_DeviceToPage: [["number", "number", "number", "number", "number", "number", "number", "number", "number", "number"], "boolean"], FPDF_DocumentHasValidCrossReferenceTable: [["number"], "boolean"], FPDF_FFLDraw: [["number", "number", "number", "number", "number", "number", "number", "number", "number"], null], FPDF_FreeDefaultSystemFontInfo: [["number"], null], FPDF_GetDefaultSystemFontInfo: [[], "number"], FPDF_GetDefaultTTFMap: [[], "number"], FPDF_GetDefaultTTFMapCount: [[], "number"], FPDF_GetDefaultTTFMapEntry: [["number"], "number"], FPDF_GetDocPermissions: [["number"], "number"], FPDF_GetDocUserPermissions: [["number"], "number"], FPDF_GetFileIdentifier: [["number", "number", "number", "number"], "number"], FPDF_GetFileVersion: [["number", "number"], "boolean"], FPDF_GetFormType: [["number"], "number"], FPDF_GetLastError: [[], "number"], FPDF_GetMetaText: [["number", "string", "number", "number"], "number"], FPDF_GetNamedDest: [["number", "number", "number", "number"], "number"], FPDF_GetNamedDestByName: [["number", "string"], "number"], FPDF_GetPageAAction: [["number", "number"], "number"], FPDF_GetPageBoundingBox: [["number", "number"], "boolean"], FPDF_GetPageCount: [["number"], "number"], FPDF_GetPageHeight: [["number"], "number"], FPDF_GetPageHeightF: [["number"], "number"], FPDF_GetPageLabel: [["number", "number", "number", "number"], "number"], FPDF_GetPageSizeByIndex: [["number", "number", "number", "number"], "number"], FPDF_GetPageSizeByIndexF: [["number", "number", "number"], "boolean"], FPDF_GetPageWidth: [["number"], "number"], FPDF_GetPageWidthF: [["number"], "number"], FPDF_GetSecurityHandlerRevision: [["number"], "number"], FPDF_GetSignatureCount: [["number"], "number"], FPDF_GetSignatureObject: [["number", "number"], "number"], FPDF_GetTrailerEnds: [["number", "number", "number"], "number"], FPDF_GetXFAPacketContent: [["number", "number", "number", "number", "number"], "boolean"], FPDF_GetXFAPacketCount: [["number"], "number"], FPDF_GetXFAPacketName: [["number", "number", "number", "number"], "number"], FPDF_ImportNPagesToOne: [["number", "number", "number", "number", "number"], "number"], FPDF_ImportPages: [["number", "number", "string", "number"], "boolean"], FPDF_ImportPagesByIndex: [["number", "number", "number", "number", "number"], "boolean"], FPDF_InitLibrary: [[], null], FPDF_InitLibraryWithConfig: [["number"], null], FPDF_LoadCustomDocument: [["number", "string"], "number"], FPDF_LoadDocument: [["number", "string"], "number"], FPDF_LoadMemDocument: [["number", "number", "string"], "number"], FPDF_LoadMemDocument64: [["number", "number", "string"], "number"], FPDF_LoadPage: [["number", "number"], "number"], FPDF_LoadXFA: [["number"], "boolean"], FPDF_MovePages: [["number", "number", "number", "number"], "boolean"], FPDF_NewFormObjectFromXObject: [["number"], "number"], FPDF_NewXObjectFromPage: [["number", "number", "number"], "number"], FPDF_PageToDevice: [["number", "number", "number", "number", "number", "number", "number", "number", "number", "number"], "boolean"], FPDF_RemoveFormFieldHighlight: [["number"], null], FPDF_RenderPage_Close: [["number"], null], FPDF_RenderPage_Continue: [["number", "number"], "number"], FPDF_RenderPageBitmap: [["number", "number", "number", "number", "number", "number", "number", "number"], null], FPDF_RenderPageBitmap_Start: [["number", "number", "number", "number", "number", "number", "number", "number", "number"], "number"], FPDF_RenderPageBitmapWithColorScheme_Start: [["number", "number", "number", "number", "number", "number", "number", "number", "number", "number"], "number"], FPDF_RenderPageBitmapWithMatrix: [["number", "number", "number", "number", "number"], null], FPDF_SaveAsCopy: [["number", "number", "number"], "boolean"], FPDF_SaveWithVersion: [["number", "number", "number", "number"], "boolean"], FPDF_SetFormFieldHighlightAlpha: [["number", "number"], null], FPDF_SetFormFieldHighlightColor: [["number", "number", "number"], null], FPDF_SetSandBoxPolicy: [["number", "boolean"], null], FPDF_SetSystemFontInfo: [["number"], null], FPDF_StructElement_Attr_CountChildren: [["number"], "number"], FPDF_StructElement_Attr_GetBlobValue: [["number", "number", "number", "number"], "boolean"], FPDF_StructElement_Attr_GetBooleanValue: [["number", "number"], "boolean"], FPDF_StructElement_Attr_GetChildAtIndex: [["number", "number"], "number"], FPDF_StructElement_Attr_GetCount: [["number"], "number"], FPDF_StructElement_Attr_GetName: [["number", "number", "number", "number", "number"], "boolean"], FPDF_StructElement_Attr_GetNumberValue: [["number", "number"], "boolean"], FPDF_StructElement_Attr_GetStringValue: [["number", "number", "number", "number"], "boolean"], FPDF_StructElement_Attr_GetType: [["number"], "number"], FPDF_StructElement_Attr_GetValue: [["number", "string"], "number"], FPDF_StructElement_CountChildren: [["number"], "number"], FPDF_StructElement_GetActualText: [["number", "number", "number"], "number"], FPDF_StructElement_GetAltText: [["number", "number", "number"], "number"], FPDF_StructElement_GetAttributeAtIndex: [["number", "number"], "number"], FPDF_StructElement_GetAttributeCount: [["number"], "number"], FPDF_StructElement_GetChildAtIndex: [["number", "number"], "number"], FPDF_StructElement_GetChildMarkedContentID: [["number", "number"], "number"], FPDF_StructElement_GetID: [["number", "number", "number"], "number"], FPDF_StructElement_GetLang: [["number", "number", "number"], "number"], FPDF_StructElement_GetMarkedContentID: [["number"], "number"], FPDF_StructElement_GetMarkedContentIdAtIndex: [["number", "number"], "number"], FPDF_StructElement_GetMarkedContentIdCount: [["number"], "number"], FPDF_StructElement_GetObjType: [["number", "number", "number"], "number"], FPDF_StructElement_GetParent: [["number"], "number"], FPDF_StructElement_GetStringAttribute: [["number", "string", "number", "number"], "number"], FPDF_StructElement_GetTitle: [["number", "number", "number"], "number"], FPDF_StructElement_GetType: [["number", "number", "number"], "number"], FPDF_StructTree_Close: [["number"], null], FPDF_StructTree_CountChildren: [["number"], "number"], FPDF_StructTree_GetChildAtIndex: [["number", "number"], "number"], FPDF_StructTree_GetForPage: [["number"], "number"], FPDF_VIEWERREF_GetDuplex: [["number"], "number"], FPDF_VIEWERREF_GetName: [["number", "string", "number", "number"], "number"], FPDF_VIEWERREF_GetNumCopies: [["number"], "number"], FPDF_VIEWERREF_GetPrintPageRange: [["number"], "number"], FPDF_VIEWERREF_GetPrintPageRangeCount: [["number"], "number"], FPDF_VIEWERREF_GetPrintPageRangeElement: [["number", "number"], "number"], FPDF_VIEWERREF_GetPrintScaling: [["number"], "boolean"], FPDFAction_GetDest: [["number", "number"], "number"], FPDFAction_GetFilePath: [["number", "number", "number"], "number"], FPDFAction_GetType: [["number"], "number"], FPDFAction_GetURIPath: [["number", "number", "number", "number"], "number"], FPDFAnnot_AddFileAttachment: [["number", "number"], "number"], FPDFAnnot_AddInkStroke: [["number", "number", "number"], "number"], FPDFAnnot_AppendAttachmentPoints: [["number", "number"], "boolean"], FPDFAnnot_AppendObject: [["number", "number"], "boolean"], FPDFAnnot_CountAttachmentPoints: [["number"], "number"], FPDFAnnot_GetAP: [["number", "number", "number", "number"], "number"], FPDFAnnot_GetAttachmentPoints: [["number", "number", "number"], "boolean"], FPDFAnnot_GetBorder: [["number", "number", "number", "number"], "boolean"], FPDFAnnot_GetColor: [["number", "number", "number", "number", "number", "number"], "boolean"], FPDFAnnot_GetFileAttachment: [["number"], "number"], FPDFAnnot_GetFlags: [["number"], "number"], FPDFAnnot_GetFocusableSubtypes: [["number", "number", "number"], "boolean"], FPDFAnnot_GetFocusableSubtypesCount: [["number"], "number"], FPDFAnnot_GetFontColor: [["number", "number", "number", "number", "number"], "boolean"], FPDFAnnot_GetFontSize: [["number", "number", "number"], "boolean"], FPDFAnnot_GetFormAdditionalActionJavaScript: [["number", "number", "number", "number", "number"], "number"], FPDFAnnot_GetFormControlCount: [["number", "number"], "number"], FPDFAnnot_GetFormControlIndex: [["number", "number"], "number"], FPDFAnnot_GetFormFieldAlternateName: [["number", "number", "number", "number"], "number"], FPDFAnnot_GetFormFieldAtPoint: [["number", "number", "number"], "number"], FPDFAnnot_GetFormFieldExportValue: [["number", "number", "number", "number"], "number"], FPDFAnnot_GetFormFieldFlags: [["number", "number"], "number"], FPDFAnnot_GetFormFieldName: [["number", "number", "number", "number"], "number"], FPDFAnnot_GetFormFieldType: [["number", "number"], "number"], FPDFAnnot_GetFormFieldValue: [["number", "number", "number", "number"], "number"], FPDFAnnot_GetInkListCount: [["number"], "number"], FPDFAnnot_GetInkListPath: [["number", "number", "number", "number"], "number"], FPDFAnnot_GetLine: [["number", "number", "number"], "boolean"], FPDFAnnot_GetLink: [["number"], "number"], FPDFAnnot_GetLinkedAnnot: [["number", "string"], "number"], FPDFAnnot_GetNumberValue: [["number", "string", "number"], "boolean"], FPDFAnnot_GetObject: [["number", "number"], "number"], FPDFAnnot_GetObjectCount: [["number"], "number"], FPDFAnnot_GetOptionCount: [["number", "number"], "number"], FPDFAnnot_GetOptionLabel: [["number", "number", "number", "number", "number"], "number"], FPDFAnnot_GetRect: [["number", "number"], "boolean"], FPDFAnnot_GetStringValue: [["number", "string", "number", "number"], "number"], FPDFAnnot_GetSubtype: [["number"], "number"], FPDFAnnot_GetValueType: [["number", "string"], "number"], FPDFAnnot_GetVertices: [["number", "number", "number"], "number"], FPDFAnnot_HasAttachmentPoints: [["number"], "boolean"], FPDFAnnot_HasKey: [["number", "string"], "boolean"], FPDFAnnot_IsChecked: [["number", "number"], "boolean"], FPDFAnnot_IsObjectSupportedSubtype: [["number"], "boolean"], FPDFAnnot_IsOptionSelected: [["number", "number", "number"], "boolean"], FPDFAnnot_IsSupportedSubtype: [["number"], "boolean"], FPDFAnnot_RemoveInkList: [["number"], "boolean"], FPDFAnnot_RemoveObject: [["number", "number"], "boolean"], FPDFAnnot_SetAP: [["number", "number", "number"], "boolean"], FPDFAnnot_SetAttachmentPoints: [["number", "number", "number"], "boolean"], FPDFAnnot_SetBorder: [["number", "number", "number", "number"], "boolean"], FPDFAnnot_SetColor: [["number", "number", "number", "number", "number", "number"], "boolean"], FPDFAnnot_SetFlags: [["number", "number"], "boolean"], FPDFAnnot_SetFocusableSubtypes: [["number", "number", "number"], "boolean"], FPDFAnnot_SetFontColor: [["number", "number", "number", "number", "number"], "boolean"], FPDFAnnot_SetFormFieldFlags: [["number", "number", "number"], "boolean"], FPDFAnnot_SetRect: [["number", "number"], "boolean"], FPDFAnnot_SetStringValue: [["number", "string", "number"], "boolean"], FPDFAnnot_SetURI: [["number", "number"], "boolean"], FPDFAnnot_UpdateObject: [["number", "number"], "boolean"], FPDFAttachment_GetFile: [["number", "number", "number", "number"], "boolean"], FPDFAttachment_GetName: [["number", "number", "number"], "number"], FPDFAttachment_GetStringValue: [["number", "string", "number", "number"], "number"], FPDFAttachment_GetSubtype: [["number", "number", "number"], "number"], FPDFAttachment_GetValueType: [["number", "string"], "number"], FPDFAttachment_HasKey: [["number", "string"], "boolean"], FPDFAttachment_SetFile: [["number", "number", "number", "number"], "boolean"], FPDFAttachment_SetStringValue: [["number", "string", "number"], "boolean"], FPDFAvail_Create: [["number", "number"], "number"], FPDFAvail_Destroy: [["number"], null], FPDFAvail_GetDocument: [["number", "string"], "number"], FPDFAvail_GetFirstPageNum: [["number"], "number"], FPDFAvail_IsDocAvail: [["number", "number"], "number"], FPDFAvail_IsFormAvail: [["number", "number"], "number"], FPDFAvail_IsLinearized: [["number"], "number"], FPDFAvail_IsPageAvail: [["number", "number", "number"], "number"], FPDFBitmap_Create: [["number", "number", "number"], "number"], FPDFBitmap_CreateEx: [["number", "number", "number", "number", "number"], "number"], FPDFBitmap_Destroy: [["number"], null], FPDFBitmap_FillRect: [["number", "number", "number", "number", "number", "number"], "boolean"], FPDFBitmap_GetBuffer: [["number"], "number"], FPDFBitmap_GetFormat: [["number"], "number"], FPDFBitmap_GetHeight: [["number"], "number"], FPDFBitmap_GetStride: [["number"], "number"], FPDFBitmap_GetWidth: [["number"], "number"], FPDFBookmark_Find: [["number", "number"], "number"], FPDFBookmark_GetAction: [["number"], "number"], FPDFBookmark_GetCount: [["number"], "number"], FPDFBookmark_GetDest: [["number", "number"], "number"], FPDFBookmark_GetFirstChild: [["number", "number"], "number"], FPDFBookmark_GetNextSibling: [["number", "number"], "number"], FPDFBookmark_GetTitle: [["number", "number", "number"], "number"], FPDFCatalog_IsTagged: [["number"], "boolean"], FPDFCatalog_SetLanguage: [["number", "string"], "boolean"], FPDFClipPath_CountPaths: [["number"], "number"], FPDFClipPath_CountPathSegments: [["number", "number"], "number"], FPDFClipPath_GetPathSegment: [["number", "number", "number"], "number"], FPDFDest_GetDestPageIndex: [["number", "number"], "number"], FPDFDest_GetLocationInPage: [["number", "number", "number", "number", "number", "number", "number"], "boolean"], FPDFDest_GetView: [["number", "number", "number"], "number"], FPDFDoc_AddAttachment: [["number", "number"], "number"], FPDFDoc_CloseJavaScriptAction: [["number"], null], FPDFDoc_DeleteAttachment: [["number", "number"], "boolean"], FPDFDOC_ExitFormFillEnvironment: [["number"], null], FPDFDoc_GetAttachment: [["number", "number"], "number"], FPDFDoc_GetAttachmentCount: [["number"], "number"], FPDFDoc_GetJavaScriptAction: [["number", "number"], "number"], FPDFDoc_GetJavaScriptActionCount: [["number"], "number"], FPDFDoc_GetPageMode: [["number"], "number"], FPDFDOC_InitFormFillEnvironment: [["number", "number"], "number"], FPDFFont_Close: [["number"], null], FPDFFont_GetAscent: [["number", "number", "number"], "boolean"], FPDFFont_GetBaseFontName: [["number", "number", "number"], "number"], FPDFFont_GetDescent: [["number", "number", "number"], "boolean"], FPDFFont_GetFamilyName: [["number", "number", "number"], "number"], FPDFFont_GetFlags: [["number"], "number"], FPDFFont_GetFontData: [["number", "number", "number", "number"], "boolean"], FPDFFont_GetGlyphPath: [["number", "number", "number"], "number"], FPDFFont_GetGlyphWidth: [["number", "number", "number", "number"], "boolean"], FPDFFont_GetIsEmbedded: [["number"], "number"], FPDFFont_GetItalicAngle: [["number", "number"], "boolean"], FPDFFont_GetWeight: [["number"], "number"], FPDFFormObj_CountObjects: [["number"], "number"], FPDFFormObj_GetObject: [["number", "number"], "number"], FPDFFormObj_RemoveObject: [["number", "number"], "boolean"], FPDFGlyphPath_CountGlyphSegments: [["number"], "number"], FPDFGlyphPath_GetGlyphPathSegment: [["number", "number"], "number"], FPDFImageObj_GetBitmap: [["number"], "number"], FPDFImageObj_GetIccProfileDataDecoded: [["number", "number", "number", "number", "number"], "boolean"], FPDFImageObj_GetImageDataDecoded: [["number", "number", "number"], "number"], FPDFImageObj_GetImageDataRaw: [["number", "number", "number"], "number"], FPDFImageObj_GetImageFilter: [["number", "number", "number", "number"], "number"], FPDFImageObj_GetImageFilterCount: [["number"], "number"], FPDFImageObj_GetImageMetadata: [["number", "number", "number"], "boolean"], FPDFImageObj_GetImagePixelSize: [["number", "number", "number"], "boolean"], FPDFImageObj_GetRenderedBitmap: [["number", "number", "number"], "number"], FPDFImageObj_LoadJpegFile: [["number", "number", "number", "number"], "boolean"], FPDFImageObj_LoadJpegFileInline: [["number", "number", "number", "number"], "boolean"], FPDFImageObj_SetBitmap: [["number", "number", "number", "number"], "boolean"], FPDFImageObj_SetMatrix: [["number", "number", "number", "number", "number", "number", "number"], "boolean"], FPDFJavaScriptAction_GetName: [["number", "number", "number"], "number"], FPDFJavaScriptAction_GetScript: [["number", "number", "number"], "number"], FPDFLink_CloseWebLinks: [["number"], null], FPDFLink_CountQuadPoints: [["number"], "number"], FPDFLink_CountRects: [["number", "number"], "number"], FPDFLink_CountWebLinks: [["number"], "number"], FPDFLink_Enumerate: [["number", "number", "number"], "boolean"], FPDFLink_GetAction: [["number"], "number"], FPDFLink_GetAnnot: [["number", "number"], "number"], FPDFLink_GetAnnotRect: [["number", "number"], "boolean"], FPDFLink_GetDest: [["number", "number"], "number"], FPDFLink_GetLinkAtPoint: [["number", "number", "number"], "number"], FPDFLink_GetLinkZOrderAtPoint: [["number", "number", "number"], "number"], FPDFLink_GetQuadPoints: [["number", "number", "number"], "boolean"], FPDFLink_GetRect: [["number", "number", "number", "number", "number", "number", "number"], "boolean"], FPDFLink_GetTextRange: [["number", "number", "number", "number"], "boolean"], FPDFLink_GetURL: [["number", "number", "number", "number"], "number"], FPDFLink_LoadWebLinks: [["number"], "number"], FPDFPage_CloseAnnot: [["number"], null], FPDFPage_CountObjects: [["number"], "number"], FPDFPage_CreateAnnot: [["number", "number"], "number"], FPDFPage_Delete: [["number", "number"], null], FPDFPage_Flatten: [["number", "number"], "number"], FPDFPage_FormFieldZOrderAtPoint: [["number", "number", "number", "number"], "number"], FPDFPage_GenerateContent: [["number"], "boolean"], FPDFPage_GetAnnot: [["number", "number"], "number"], FPDFPage_GetAnnotCount: [["number"], "number"], FPDFPage_GetAnnotIndex: [["number", "number"], "number"], FPDFPage_GetArtBox: [["number", "number", "number", "number", "number"], "boolean"], FPDFPage_GetBleedBox: [["number", "number", "number", "number", "number"], "boolean"], FPDFPage_GetCropBox: [["number", "number", "number", "number", "number"], "boolean"], FPDFPage_GetDecodedThumbnailData: [["number", "number", "number"], "number"], FPDFPage_GetMediaBox: [["number", "number", "number", "number", "number"], "boolean"], FPDFPage_GetObject: [["number", "number"], "number"], FPDFPage_GetRawThumbnailData: [["number", "number", "number"], "number"], FPDFPage_GetRotation: [["number"], "number"], FPDFPage_GetThumbnailAsBitmap: [["number"], "number"], FPDFPage_GetTrimBox: [["number", "number", "number", "number", "number"], "boolean"], FPDFPage_HasFormFieldAtPoint: [["number", "number", "number", "number"], "number"], FPDFPage_HasTransparency: [["number"], "boolean"], FPDFPage_InsertClipPath: [["number", "number"], null], FPDFPage_InsertObject: [["number", "number"], null], FPDFPage_InsertObjectAtIndex: [["number", "number", "number"], "boolean"], FPDFPage_New: [["number", "number", "number", "number"], "number"], FPDFPage_RemoveAnnot: [["number", "number"], "boolean"], FPDFPage_RemoveObject: [["number", "number"], "boolean"], FPDFPage_SetArtBox: [["number", "number", "number", "number", "number"], null], FPDFPage_SetBleedBox: [["number", "number", "number", "number", "number"], null], FPDFPage_SetCropBox: [["number", "number", "number", "number", "number"], null], FPDFPage_SetMediaBox: [["number", "number", "number", "number", "number"], null], FPDFPage_SetRotation: [["number", "number"], null], FPDFPage_SetTrimBox: [["number", "number", "number", "number", "number"], null], FPDFPage_TransformAnnots: [["number", "number", "number", "number", "number", "number", "number"], null], FPDFPage_TransFormWithClip: [["number", "number", "number"], "boolean"], FPDFPageObj_AddMark: [["number", "string"], "number"], FPDFPageObj_CountMarks: [["number"], "number"], FPDFPageObj_CreateNewPath: [["number", "number"], "number"], FPDFPageObj_CreateNewRect: [["number", "number", "number", "number"], "number"], FPDFPageObj_CreateTextObj: [["number", "number", "number"], "number"], FPDFPageObj_Destroy: [["number"], null], FPDFPageObj_GetBounds: [["number", "number", "number", "number", "number"], "boolean"], FPDFPageObj_GetClipPath: [["number"], "number"], FPDFPageObj_GetDashArray: [["number", "number", "number"], "boolean"], FPDFPageObj_GetDashCount: [["number"], "number"], FPDFPageObj_GetDashPhase: [["number", "number"], "boolean"], FPDFPageObj_GetFillColor: [["number", "number", "number", "number", "number"], "boolean"], FPDFPageObj_GetIsActive: [["number", "number"], "boolean"], FPDFPageObj_GetLineCap: [["number"], "number"], FPDFPageObj_GetLineJoin: [["number"], "number"], FPDFPageObj_GetMark: [["number", "number"], "number"], FPDFPageObj_GetMarkedContentID: [["number"], "number"], FPDFPageObj_GetMatrix: [["number", "number"], "boolean"], FPDFPageObj_GetRotatedBounds: [["number", "number"], "boolean"], FPDFPageObj_GetStrokeColor: [["number", "number", "number", "number", "number"], "boolean"], FPDFPageObj_GetStrokeWidth: [["number", "number"], "boolean"], FPDFPageObj_GetType: [["number"], "number"], FPDFPageObj_HasTransparency: [["number"], "boolean"], FPDFPageObj_NewImageObj: [["number"], "number"], FPDFPageObj_NewTextObj: [["number", "string", "number"], "number"], FPDFPageObj_RemoveMark: [["number", "number"], "boolean"], FPDFPageObj_SetBlendMode: [["number", "string"], null], FPDFPageObj_SetDashArray: [["number", "number", "number", "number"], "boolean"], FPDFPageObj_SetDashPhase: [["number", "number"], "boolean"], FPDFPageObj_SetFillColor: [["number", "number", "number", "number", "number"], "boolean"], FPDFPageObj_SetIsActive: [["number", "boolean"], "boolean"], FPDFPageObj_SetLineCap: [["number", "number"], "boolean"], FPDFPageObj_SetLineJoin: [["number", "number"], "boolean"], FPDFPageObj_SetMatrix: [["number", "number"], "boolean"], FPDFPageObj_SetStrokeColor: [["number", "number", "number", "number", "number"], "boolean"], FPDFPageObj_SetStrokeWidth: [["number", "number"], "boolean"], FPDFPageObj_Transform: [["number", "number", "number", "number", "number", "number", "number"], null], FPDFPageObj_TransformClipPath: [["number", "number", "number", "number", "number", "number", "number"], null], FPDFPageObj_TransformF: [["number", "number"], "boolean"], FPDFPageObjMark_CountParams: [["number"], "number"], FPDFPageObjMark_GetName: [["number", "number", "number", "number"], "boolean"], FPDFPageObjMark_GetParamBlobValue: [["number", "string", "number", "number", "number"], "boolean"], FPDFPageObjMark_GetParamIntValue: [["number", "string", "number"], "boolean"], FPDFPageObjMark_GetParamKey: [["number", "number", "number", "number", "number"], "boolean"], FPDFPageObjMark_GetParamStringValue: [["number", "string", "number", "number", "number"], "boolean"], FPDFPageObjMark_GetParamValueType: [["number", "string"], "number"], FPDFPageObjMark_RemoveParam: [["number", "number", "string"], "boolean"], FPDFPageObjMark_SetBlobParam: [["number", "number", "number", "string", "number", "number"], "boolean"], FPDFPageObjMark_SetIntParam: [["number", "number", "number", "string", "number"], "boolean"], FPDFPageObjMark_SetStringParam: [["number", "number", "number", "string", "string"], "boolean"], FPDFPath_BezierTo: [["number", "number", "number", "number", "number", "number", "number"], "boolean"], FPDFPath_Close: [["number"], "boolean"], FPDFPath_CountSegments: [["number"], "number"], FPDFPath_GetDrawMode: [["number", "number", "number"], "boolean"], FPDFPath_GetPathSegment: [["number", "number"], "number"], FPDFPath_LineTo: [["number", "number", "number"], "boolean"], FPDFPath_MoveTo: [["number", "number", "number"], "boolean"], FPDFPath_SetDrawMode: [["number", "number", "boolean"], "boolean"], FPDFPathSegment_GetClose: [["number"], "boolean"], FPDFPathSegment_GetPoint: [["number", "number", "number"], "boolean"], FPDFPathSegment_GetType: [["number"], "number"], FPDFSignatureObj_GetByteRange: [["number", "number", "number"], "number"], FPDFSignatureObj_GetContents: [["number", "number", "number"], "number"], FPDFSignatureObj_GetDocMDPPermission: [["number"], "number"], FPDFSignatureObj_GetReason: [["number", "number", "number"], "number"], FPDFSignatureObj_GetSubFilter: [["number", "number", "number"], "number"], FPDFSignatureObj_GetTime: [["number", "number", "number"], "number"], FPDFText_ClosePage: [["number"], null], FPDFText_CountChars: [["number"], "number"], FPDFText_CountRects: [["number", "number", "number"], "number"], FPDFText_FindClose: [["number"], null], FPDFText_FindNext: [["number"], "boolean"], FPDFText_FindPrev: [["number"], "boolean"], FPDFText_FindStart: [["number", "number", "number", "number"], "number"], FPDFText_GetBoundedText: [["number", "number", "number", "number", "number", "number", "number"], "number"], FPDFText_GetCharAngle: [["number", "number"], "number"], FPDFText_GetCharBox: [["number", "number", "number", "number", "number", "number"], "boolean"], FPDFText_GetCharIndexAtPos: [["number", "number", "number", "number", "number"], "number"], FPDFText_GetCharIndexFromTextIndex: [["number", "number"], "number"], FPDFText_GetCharOrigin: [["number", "number", "number", "number"], "boolean"], FPDFText_GetFillColor: [["number", "number", "number", "number", "number", "number"], "boolean"], FPDFText_GetFontInfo: [["number", "number", "number", "number", "number"], "number"], FPDFText_GetFontSize: [["number", "number"], "number"], FPDFText_GetFontWeight: [["number", "number"], "number"], FPDFText_GetLooseCharBox: [["number", "number", "number"], "boolean"], FPDFText_GetMatrix: [["number", "number", "number"], "boolean"], FPDFText_GetRect: [["number", "number", "number", "number", "number", "number"], "boolean"], FPDFText_GetSchCount: [["number"], "number"], FPDFText_GetSchResultIndex: [["number"], "number"], FPDFText_GetStrokeColor: [["number", "number", "number", "number", "number", "number"], "boolean"], FPDFText_GetText: [["number", "number", "number", "number"], "number"], FPDFText_GetTextIndexFromCharIndex: [["number", "number"], "number"], FPDFText_GetTextObject: [["number", "number"], "number"], FPDFText_GetUnicode: [["number", "number"], "number"], FPDFText_HasUnicodeMapError: [["number", "number"], "number"], FPDFText_IsGenerated: [["number", "number"], "number"], FPDFText_IsHyphen: [["number", "number"], "number"], FPDFText_LoadCidType2Font: [["number", "number", "number", "string", "number", "number"], "number"], FPDFText_LoadFont: [["number", "number", "number", "number", "boolean"], "number"], FPDFText_LoadPage: [["number"], "number"], FPDFText_LoadStandardFont: [["number", "string"], "number"], FPDFText_SetCharcodes: [["number", "number", "number"], "boolean"], FPDFText_SetText: [["number", "number"], "boolean"], FPDFTextObj_GetFont: [["number"], "number"], FPDFTextObj_GetFontSize: [["number", "number"], "boolean"], FPDFTextObj_GetRenderedBitmap: [["number", "number", "number", "number"], "number"], FPDFTextObj_GetText: [["number", "number", "number", "number"], "number"], FPDFTextObj_GetTextRenderMode: [["number"], "number"], FPDFTextObj_SetTextRenderMode: [["number", "number"], "boolean"], PDFiumExt_CloseFileWriter: [["number"], null], PDFiumExt_CloseFormFillInfo: [["number"], null], PDFiumExt_ExitFormFillEnvironment: [["number"], null], PDFiumExt_GetFileWriterData: [["number", "number", "number"], "number"], PDFiumExt_GetFileWriterSize: [["number"], "number"], PDFiumExt_Init: [[], null], PDFiumExt_InitFormFillEnvironment: [["number", "number"], "number"], PDFiumExt_OpenFileWriter: [[], "number"], PDFiumExt_OpenFormFillInfo: [[], "number"], PDFiumExt_SaveAsCopy: [["number", "number"], "number"] };
      $ = /* @__PURE__ */ new Set(["Title", "Author", "Subject", "Keywords", "Producer", "Creator", "CreationDate", "ModDate", "Trapped"]);
      z = { pageTtl: 5e3, maxPagesPerDocument: 10 };
      H = class {
        constructor(e3, t2, n3 = {}) {
          this.pdfium = e3, this.memoryManager = t2, this.docs = /* @__PURE__ */ new Map(), this.config = { ...z, ...n3 };
        }
        setDocument(e3, t2, n3) {
          let r2 = this.docs.get(e3);
          r2 || (r2 = new X(t2, n3, this.pdfium, this.memoryManager, this.config), this.docs.set(e3, r2));
        }
        getContext(e3) {
          return this.docs.get(e3);
        }
        closeDocument(e3) {
          const t2 = this.docs.get(e3);
          return !!t2 && (t2.dispose(), this.docs.delete(e3), true);
        }
        closeAllDocuments() {
          for (const e3 of this.docs.values()) e3.dispose();
          this.docs.clear();
        }
        updateConfig(e3) {
          Object.assign(this.config, e3);
          for (const e4 of this.docs.values()) e4.updateConfig(this.config);
        }
        getCacheStats() {
          const e3 = {};
          let t2 = 0;
          for (const [n3, r2] of this.docs.entries()) {
            const o3 = r2.getCacheSize();
            e3[n3] = o3, t2 += o3;
          }
          return { documents: this.docs.size, totalPages: t2, pagesByDocument: e3 };
        }
      };
      X = class {
        constructor(e3, t2, n3, r2, o3) {
          this.filePtr = e3, this.docPtr = t2, this.memoryManager = r2, this.pageCache = new K(n3, t2, o3);
        }
        acquirePage(e3) {
          return this.pageCache.acquire(e3);
        }
        borrowPage(e3, t2) {
          return this.pageCache.borrowPage(e3, t2);
        }
        updateConfig(e3) {
          this.pageCache.updateConfig(e3);
        }
        getCacheSize() {
          return this.pageCache.size();
        }
        dispose() {
          this.pageCache.forceReleaseAll(), this.pageCache.pdf.FPDF_CloseDocument(this.docPtr), this.memoryManager.free(this.filePtr);
        }
      };
      K = class {
        constructor(e3, t2, n3) {
          this.pdf = e3, this.docPtr = t2, this.cache = /* @__PURE__ */ new Map(), this.accessOrder = [], this.config = n3;
        }
        acquire(e3) {
          let t2 = this.cache.get(e3);
          if (!t2) {
            this.evictIfNeeded();
            const n3 = this.pdf.FPDF_LoadPage(this.docPtr, e3);
            t2 = new Y(this.pdf, this.docPtr, e3, n3, this.config.pageTtl, () => {
              this.cache.delete(e3), this.removeFromAccessOrder(e3);
            }), this.cache.set(e3, t2);
          }
          return this.updateAccessOrder(e3), t2.clearExpiryTimer(), t2.bumpRefCount(), t2;
        }
        borrowPage(e3, t2) {
          const n3 = this.cache.has(e3), r2 = this.acquire(e3);
          try {
            return t2(r2);
          } finally {
            n3 ? r2.release() : r2.disposeImmediate();
          }
        }
        forceReleaseAll() {
          for (const e3 of this.cache.values()) e3.disposeImmediate();
          this.cache.clear(), this.accessOrder.length = 0;
        }
        updateConfig(e3) {
          this.config = e3;
          for (const t2 of this.cache.values()) t2.updateTtl(e3.pageTtl);
          this.evictIfNeeded();
        }
        size() {
          return this.cache.size;
        }
        evictIfNeeded() {
          for (; this.cache.size >= this.config.maxPagesPerDocument; ) {
            const e3 = this.accessOrder[0];
            if (void 0 === e3) break;
            {
              const t2 = this.cache.get(e3);
              if (t2) {
                if (0 !== t2.getRefCount()) break;
                t2.disposeImmediate();
              } else this.removeFromAccessOrder(e3);
            }
          }
        }
        updateAccessOrder(e3) {
          this.removeFromAccessOrder(e3), this.accessOrder.push(e3);
        }
        removeFromAccessOrder(e3) {
          const t2 = this.accessOrder.indexOf(e3);
          t2 > -1 && this.accessOrder.splice(t2, 1);
        }
      };
      Y = class {
        constructor(e3, t2, n3, r2, o3, a3) {
          this.pdf = e3, this.docPtr = t2, this.pageIdx = n3, this.pagePtr = r2, this.onFinalDispose = a3, this.refCount = 0, this.disposed = false, this.ttl = o3;
        }
        bumpRefCount() {
          if (this.disposed) throw new Error("Context already disposed");
          this.refCount++;
        }
        getRefCount() {
          return this.refCount;
        }
        clearExpiryTimer() {
          this.expiryTimer && (clearTimeout(this.expiryTimer), this.expiryTimer = void 0);
        }
        updateTtl(e3) {
          this.ttl = e3, this.expiryTimer && 0 === this.refCount && (this.clearExpiryTimer(), this.expiryTimer = setTimeout(() => this.disposeImmediate(), this.ttl));
        }
        release() {
          this.disposed || (this.refCount--, 0 === this.refCount && (this.expiryTimer = setTimeout(() => this.disposeImmediate(), this.ttl)));
        }
        disposeImmediate() {
          this.disposed || (this.disposed = true, this.clearExpiryTimer(), void 0 !== this.textPagePtr && this.pdf.FPDFText_ClosePage(this.textPagePtr), void 0 !== this.formHandle && (this.pdf.FORM_OnBeforeClosePage(this.pagePtr, this.formHandle), this.pdf.PDFiumExt_ExitFormFillEnvironment(this.formHandle)), void 0 !== this.formInfoPtr && this.pdf.PDFiumExt_CloseFormFillInfo(this.formInfoPtr), this.pdf.FPDF_ClosePage(this.pagePtr), this.onFinalDispose());
        }
        getTextPage() {
          return this.ensureAlive(), void 0 === this.textPagePtr && (this.textPagePtr = this.pdf.FPDFText_LoadPage(this.pagePtr)), this.textPagePtr;
        }
        getFormHandle() {
          return this.ensureAlive(), void 0 === this.formHandle && (this.formInfoPtr = this.pdf.PDFiumExt_OpenFormFillInfo(), this.formHandle = this.pdf.PDFiumExt_InitFormFillEnvironment(this.docPtr, this.formInfoPtr), this.pdf.FORM_OnAfterLoadPage(this.pagePtr, this.formHandle)), this.formHandle;
        }
        withAnnotation(e3, t2) {
          this.ensureAlive();
          const n3 = this.pdf.FPDFPage_GetAnnot(this.pagePtr, e3);
          try {
            return t2(n3);
          } finally {
            this.pdf.FPDFPage_CloseAnnot(n3);
          }
        }
        ensureAlive() {
          if (this.disposed) throw new Error("PageContext already disposed");
        }
      };
      J = { MAX_TOTAL_MEMORY: 2147483648 };
      q = "PDFiumEngine";
      Q = "MemoryManager";
      Z = class {
        constructor(e3, t2) {
          this.pdfiumModule = e3, this.logger = t2, this.allocations = /* @__PURE__ */ new Map(), this.totalAllocated = 0;
        }
        malloc(e3) {
          if (this.totalAllocated + e3 > J.MAX_TOTAL_MEMORY) throw new Error(`Total memory usage would exceed limit: ${this.totalAllocated + e3} > ${J.MAX_TOTAL_MEMORY}`);
          const t2 = this.pdfiumModule.pdfium.wasmExports.malloc(e3);
          if (!t2) throw new Error(`Failed to allocate ${e3} bytes`);
          const n3 = { ptr: t2, size: e3, timestamp: Date.now(), stack: this.logger.isEnabled("debug") ? new Error().stack : void 0 };
          return this.allocations.set(t2, n3), this.totalAllocated += e3, t2;
        }
        free(e3) {
          const t2 = this.allocations.get(e3);
          t2 ? (this.totalAllocated -= t2.size, this.allocations.delete(e3)) : this.logger.warn(q, Q, `Freeing untracked pointer: ${e3}`), this.pdfiumModule.pdfium.wasmExports.free(e3);
        }
        getStats() {
          return { totalAllocated: this.totalAllocated, allocationCount: this.allocations.size, allocations: this.logger.isEnabled("debug") ? Array.from(this.allocations.values()) : [] };
        }
        checkLeaks() {
          if (this.allocations.size > 0) {
            this.logger.warn(q, Q, `Potential memory leak: ${this.allocations.size} unfreed allocations`);
            for (const [e3, t2] of this.allocations) this.logger.warn(q, Q, `  - ${e3}: ${t2.size} bytes`, t2.stack);
          }
        }
      };
      ee = "pdfium";
      te = "font-fallback";
      ne = class {
        constructor(t2, n3 = new at()) {
          this.fontHandles = /* @__PURE__ */ new Map(), this.fontCache = /* @__PURE__ */ new Map(), this.nextHandleId = 1, this.module = null, this.enabled = false, this.structPtr = 0, this.releaseFnPtr = 0, this.enumFontsFnPtr = 0, this.mapFontFnPtr = 0, this.getFontFnPtr = 0, this.getFontDataFnPtr = 0, this.getFaceNameFnPtr = 0, this.getFontCharsetFnPtr = 0, this.deleteFontFnPtr = 0, this.fontConfig = t2, this.logger = n3;
        }
        initialize(e3) {
          if (this.enabled) return void this.logger.warn(ee, te, "Font fallback already initialized");
          this.module = e3;
          const t2 = e3.pdfium;
          if ("function" == typeof t2.addFunction) try {
            if (this.structPtr = t2.wasmExports.malloc(36), !this.structPtr) throw new Error("Failed to allocate FPDF_SYSFONTINFO struct");
            for (let e4 = 0; e4 < 36; e4++) t2.setValue(this.structPtr + e4, 0, "i8");
            this.releaseFnPtr = t2.addFunction((e4) => {
            }, "vi"), this.enumFontsFnPtr = t2.addFunction((e4, t3) => {
            }, "vii"), this.mapFontFnPtr = t2.addFunction((e4, n3, r2, o3, a3, i3, s4) => {
              const u4 = i3 ? t2.UTF8ToString(i3) : "", F2 = this.mapFont(n3, r2, o3, a3, u4);
              return s4 && t2.setValue(s4, 0, "i32"), F2;
            }, "iiiiiiii"), this.getFontFnPtr = t2.addFunction((e4, n3) => {
              const r2 = n3 ? t2.UTF8ToString(n3) : "";
              return this.mapFont(400, 0, 0, 0, r2);
            }, "iii"), this.getFontDataFnPtr = t2.addFunction((e4, t3, n3, r2, o3) => this.getFontData(t3, n3, r2, o3), "iiiiii"), this.getFaceNameFnPtr = t2.addFunction((e4, t3, n3, r2) => 0, "iiiii"), this.getFontCharsetFnPtr = t2.addFunction((e4, t3) => {
              const n3 = this.fontHandles.get(t3);
              return (null == n3 ? void 0 : n3.charset) ?? 0;
            }, "iii"), this.deleteFontFnPtr = t2.addFunction((e4, t3) => {
              this.deleteFont(t3);
            }, "vii"), t2.setValue(this.structPtr + 0, 1, "i32"), t2.setValue(this.structPtr + 4, this.releaseFnPtr, "i32"), t2.setValue(this.structPtr + 8, this.enumFontsFnPtr, "i32"), t2.setValue(this.structPtr + 12, this.mapFontFnPtr, "i32"), t2.setValue(this.structPtr + 16, this.getFontFnPtr, "i32"), t2.setValue(this.structPtr + 20, this.getFontDataFnPtr, "i32"), t2.setValue(this.structPtr + 24, this.getFaceNameFnPtr, "i32"), t2.setValue(this.structPtr + 28, this.getFontCharsetFnPtr, "i32"), t2.setValue(this.structPtr + 32, this.deleteFontFnPtr, "i32"), e3.FPDF_SetSystemFontInfo(this.structPtr), this.enabled = true, this.logger.info(ee, te, "Font fallback system initialized (pure TypeScript)", Object.keys(this.fontConfig.fonts));
          } catch (e4) {
            throw this.logger.error(ee, te, "Failed to initialize font fallback", e4), this.cleanup(), e4;
          }
          else this.logger.error(ee, te, "addFunction not available. Make sure WASM is compiled with -sALLOW_TABLE_GROWTH");
        }
        disable() {
          this.enabled && this.module && (this.module.FPDF_SetSystemFontInfo(0), this.cleanup(), this.enabled = false, this.logger.debug(ee, te, "Font fallback system disabled"));
        }
        cleanup() {
          if (!this.module) return;
          const e3 = this.module.pdfium;
          this.structPtr && (e3.wasmExports.free(this.structPtr), this.structPtr = 0);
          const t2 = (t3) => {
            if (t3 && "function" == typeof e3.removeFunction) try {
              e3.removeFunction(t3);
            } catch {
            }
          };
          t2(this.releaseFnPtr), t2(this.enumFontsFnPtr), t2(this.mapFontFnPtr), t2(this.getFontFnPtr), t2(this.getFontDataFnPtr), t2(this.getFaceNameFnPtr), t2(this.getFontCharsetFnPtr), t2(this.deleteFontFnPtr), this.releaseFnPtr = 0, this.enumFontsFnPtr = 0, this.mapFontFnPtr = 0, this.getFontFnPtr = 0, this.getFontDataFnPtr = 0, this.getFaceNameFnPtr = 0, this.getFontCharsetFnPtr = 0, this.deleteFontFnPtr = 0;
        }
        isEnabled() {
          return this.enabled;
        }
        getStats() {
          return { handleCount: this.fontHandles.size, cacheSize: this.fontCache.size, cachedUrls: Array.from(this.fontCache.keys()) };
        }
        async preloadFonts(e3) {
          const t2 = e3.map((e4) => this.getFontUrlForCharset(e4)).filter((e4) => null !== e4), n3 = [...new Set(t2)];
          await Promise.all(n3.map(async (e4) => {
            if (!this.fontCache.has(e4)) try {
              const t3 = await this.fetchFontAsync(e4);
              t3 && (this.fontCache.set(e4, t3), this.logger.debug(ee, te, `Pre-loaded font: ${e4}`));
            } catch (t3) {
              this.logger.warn(ee, te, `Failed to pre-load font: ${e4}`, t3);
            }
          }));
        }
        mapFont(e3, t2, n3, r2, o3) {
          const a3 = 0 !== t2;
          this.logger.debug(ee, te, "MapFont called", { weight: e3, italic: a3, charset: n3, pitchFamily: r2, face: o3 });
          const i3 = this.findBestFontMatch(n3, e3, a3);
          if (!i3) return this.logger.debug(ee, te, `No font configured for charset ${n3}`), 0;
          const s4 = { id: this.nextHandleId++, charset: n3, weight: e3, italic: a3, url: i3.url, data: null };
          return this.fontHandles.set(s4.id, s4), this.logger.debug(ee, te, `Created font handle ${s4.id} for ${i3.url} (requested: weight=${e3}, italic=${a3}, matched: weight=${i3.matchedWeight}, italic=${i3.matchedItalic})`), s4.id;
        }
        getFontData(e3, t2, n3, r2) {
          const o3 = this.fontHandles.get(e3);
          if (!o3) return this.logger.warn(ee, te, `Unknown font handle: ${e3}`), 0;
          if (o3.data || (this.fontCache.has(o3.url) ? o3.data = this.fontCache.get(o3.url) : (o3.data = this.fetchFontSync(o3.url), o3.data && this.fontCache.set(o3.url, o3.data))), !o3.data) return this.logger.warn(ee, te, `Failed to load font: ${o3.url}`), 0;
          const a3 = o3.data;
          if (0 !== t2) return this.logger.debug(ee, te, `Table ${t2} requested - returning 0 to request whole file`), 0;
          if (0 === n3 || r2 < a3.length) return a3.length;
          if (this.module) {
            this.module.pdfium.HEAPU8.set(a3, n3), this.logger.debug(ee, te, `Copied ${a3.length} bytes to buffer for handle ${e3}`);
          }
          return a3.length;
        }
        deleteFont(e3) {
          this.fontHandles.get(e3) && (this.logger.debug(ee, te, `Deleting font handle ${e3}`), this.fontHandles.delete(e3));
        }
        findBestFontMatch(e3, t2, n3) {
          const { fonts: r2, defaultFont: o3, baseUrl: a3 } = this.fontConfig, i3 = r2[e3] ?? o3;
          if (!i3) return null;
          const s4 = this.normalizeToVariants(i3);
          if (0 === s4.length) return null;
          const u4 = this.selectBestVariant(s4, t2, n3);
          let F2 = u4.url;
          return !a3 || F2.startsWith("http://") || F2.startsWith("https://") || F2.startsWith("/") || (F2 = `${a3}/${F2}`), { url: F2, matchedWeight: u4.weight ?? 400, matchedItalic: u4.italic ?? false };
        }
        normalizeToVariants(e3) {
          return "string" == typeof e3 ? [{ url: e3, weight: 400, italic: false }] : Array.isArray(e3) ? e3.map((e4) => ({ url: e4.url, weight: e4.weight ?? 400, italic: e4.italic ?? false })) : [{ url: e3.url, weight: e3.weight ?? 400, italic: e3.italic ?? false }];
        }
        selectBestVariant(e3, t2, n3) {
          if (1 === e3.length) return e3[0];
          const r2 = e3.filter((e4) => (e4.italic ?? false) === n3), o3 = r2.length > 0 ? r2 : e3;
          let a3 = o3[0], i3 = Math.abs((a3.weight ?? 400) - t2);
          for (const e4 of o3) {
            const n4 = e4.weight ?? 400, r3 = Math.abs(n4 - t2);
            if (r3 < i3) a3 = e4, i3 = r3;
            else if (r3 === i3) {
              const r4 = a3.weight ?? 400;
              t2 >= 500 ? n4 > r4 && (a3 = e4) : n4 < r4 && (a3 = e4);
            }
          }
          return a3;
        }
        getFontUrlForCharset(e3) {
          const t2 = this.findBestFontMatch(e3, 400, false);
          return (null == t2 ? void 0 : t2.url) ?? null;
        }
        fetchFontSync(e3) {
          if (this.logger.debug(ee, te, `Fetching font synchronously: ${e3}`), this.fontConfig.fontLoader) try {
            const t2 = this.fontConfig.fontLoader(e3);
            return t2 ? this.logger.info(ee, te, `Loaded font via custom loader: ${e3} (${t2.length} bytes)`) : this.logger.warn(ee, te, `Custom font loader returned null for: ${e3}`), t2;
          } catch (t2) {
            return this.logger.error(ee, te, `Error in custom font loader: ${e3}`, t2), null;
          }
          try {
            const t2 = new XMLHttpRequest();
            if (t2.open("GET", e3, false), t2.responseType = "arraybuffer", t2.send(), 200 === t2.status) {
              const n3 = new Uint8Array(t2.response);
              return this.logger.info(ee, te, `Loaded font: ${e3} (${n3.length} bytes)`), n3;
            }
            return this.logger.error(ee, te, `Failed to load font: ${e3} (HTTP ${t2.status})`), null;
          } catch (t2) {
            return this.logger.error(ee, te, `Error fetching font: ${e3}`, t2), null;
          }
        }
        async fetchFontAsync(e3) {
          if (this.fontConfig.fontLoader) try {
            return this.fontConfig.fontLoader(e3);
          } catch {
            return null;
          }
          try {
            const t2 = await fetch(e3);
            if (t2.ok) {
              const e4 = await t2.arrayBuffer();
              return new Uint8Array(e4);
            }
            return null;
          } catch {
            return null;
          }
        }
      };
      re = "PDFiumEngine";
      oe = "Engine";
      ae = class {
        constructor(t2, n3 = {}) {
          this.pdfiumModule = t2, this.memoryLeakCheckInterval = null, this.fontFallbackManager = null;
          const { logger: r2 = new at(), fontFallback: o3 } = n3;
          this.logger = r2, this.memoryManager = new Z(this.pdfiumModule, this.logger), this.cache = new H(this.pdfiumModule, this.memoryManager), this.logger.isEnabled("debug") && (this.memoryLeakCheckInterval = setInterval(() => {
            this.memoryManager.checkLeaks();
          }, 1e4)), this.logger.debug(re, oe, "initialize"), this.logger.perf(re, oe, "Initialize", "Begin", "General"), this.pdfiumModule.PDFiumExt_Init(), this.logger.perf(re, oe, "Initialize", "End", "General"), o3 && (this.fontFallbackManager = new ne(o3, this.logger), this.fontFallbackManager.initialize(this.pdfiumModule), this.logger.info(re, oe, "Font fallback system enabled"));
        }
        destroy() {
          return this.logger.debug(re, oe, "destroy"), this.logger.perf(re, oe, "Destroy", "Begin", "General"), this.fontFallbackManager && (this.fontFallbackManager.disable(), this.fontFallbackManager = null), this.pdfiumModule.FPDF_DestroyLibrary(), this.memoryLeakCheckInterval && (clearInterval(this.memoryLeakCheckInterval), this.memoryLeakCheckInterval = null), this.logger.perf(re, oe, "Destroy", "End", "General"), Ut.resolve(true);
        }
        getFontFallbackManager() {
          return this.fontFallbackManager;
        }
        withWString(e3, t2) {
          const n3 = 2 * (e3.length + 1), r2 = this.memoryManager.malloc(n3);
          try {
            return this.pdfiumModule.pdfium.stringToUTF16(e3, r2, n3), t2(r2);
          } finally {
            this.memoryManager.free(r2);
          }
        }
        withFloatArray(e3, t2) {
          const n3 = e3 ?? [], r2 = 4 * n3.length, o3 = r2 ? this.memoryManager.malloc(r2) : 0;
          try {
            if (r2) for (let e4 = 0; e4 < n3.length; e4++) this.pdfiumModule.pdfium.setValue(o3 + 4 * e4, n3[e4], "float");
            return t2(o3, n3.length);
          } finally {
            r2 && this.memoryManager.free(o3);
          }
        }
        openDocumentBuffer(e3, n3) {
          this.logger.debug(re, oe, "openDocumentBuffer", e3, n3), this.logger.perf(re, oe, "OpenDocumentBuffer", "Begin", e3.id);
          const r2 = new Uint8Array(e3.content), o3 = r2.length, a3 = this.memoryManager.malloc(o3);
          this.pdfiumModule.pdfium.HEAPU8.set(r2, a3);
          const i3 = this.pdfiumModule.FPDF_LoadMemDocument(a3, o3, (null == n3 ? void 0 : n3.password) ?? "");
          if (!i3) {
            const n4 = this.pdfiumModule.FPDF_GetLastError();
            return this.logger.error(re, oe, `FPDF_LoadMemDocument failed with ${n4}`), this.memoryManager.free(a3), this.logger.perf(re, oe, "OpenDocumentBuffer", "End", e3.id), Ut.reject({ code: n4, message: "FPDF_LoadMemDocument failed" });
          }
          const s4 = this.pdfiumModule.FPDF_GetPageCount(i3), u4 = [], F2 = this.memoryManager.malloc(8);
          for (let n4 = 0; n4 < s4; n4++) {
            if (!this.pdfiumModule.FPDF_GetPageSizeByIndexF(i3, n4, F2)) {
              const n5 = this.pdfiumModule.FPDF_GetLastError();
              return this.logger.error(re, oe, `FPDF_GetPageSizeByIndexF failed with ${n5}`), this.memoryManager.free(F2), this.pdfiumModule.FPDF_CloseDocument(i3), this.memoryManager.free(a3), this.logger.perf(re, oe, "OpenDocumentBuffer", "End", e3.id), Ut.reject({ code: n5, message: "FPDF_GetPageSizeByIndexF failed" });
            }
            const r3 = this.pdfiumModule.EPDF_GetPageRotationByIndex(i3, n4), o4 = { index: n4, size: { width: this.pdfiumModule.pdfium.getValue(F2, "float"), height: this.pdfiumModule.pdfium.getValue(F2 + 4, "float") }, rotation: r3 };
            u4.push(o4);
          }
          this.memoryManager.free(F2);
          const m3 = { id: e3.id, pageCount: s4, pages: u4 };
          return this.cache.setDocument(e3.id, a3, i3), this.logger.perf(re, oe, "OpenDocumentBuffer", "End", e3.id), Ut.resolve(m3);
        }
        getMetadata(e3) {
          this.logger.debug(re, oe, "getMetadata", e3), this.logger.perf(re, oe, "GetMetadata", "Begin", e3.id);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "GetMetadata", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const a3 = this.readMetaText(o3.docPtr, "CreationDate"), i3 = this.readMetaText(o3.docPtr, "ModDate"), s4 = { title: this.readMetaText(o3.docPtr, "Title"), author: this.readMetaText(o3.docPtr, "Author"), subject: this.readMetaText(o3.docPtr, "Subject"), keywords: this.readMetaText(o3.docPtr, "Keywords"), producer: this.readMetaText(o3.docPtr, "Producer"), creator: this.readMetaText(o3.docPtr, "Creator"), creationDate: a3 ? Vt(a3) ?? null : null, modificationDate: i3 ? Vt(i3) ?? null : null, trapped: this.getMetaTrapped(o3.docPtr), custom: this.readAllMeta(o3.docPtr, true) };
          return this.logger.perf(re, oe, "GetMetadata", "End", e3.id), Ut.resolve(s4);
        }
        setMetadata(e3, r2) {
          this.logger.debug(re, oe, "setMetadata", e3, r2), this.logger.perf(re, oe, "SetMetadata", "Begin", e3.id);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "SetMetadata", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const a3 = [["title", "Title"], ["author", "Author"], ["subject", "Subject"], ["keywords", "Keywords"], ["producer", "Producer"], ["creator", "Creator"]];
          let i3 = true;
          for (const [e4, t2] of a3) {
            const n3 = r2[e4];
            if (void 0 === n3) continue;
            const a4 = null === n3 ? null : n3;
            this.setMetaText(o3.docPtr, t2, a4) || (i3 = false);
          }
          const s4 = (e4, t2) => {
            const n3 = r2[e4];
            if (void 0 === n3) return;
            if (null === n3) return void (this.setMetaText(o3.docPtr, t2, null) || (i3 = false));
            const a4 = Zt(n3);
            this.setMetaText(o3.docPtr, t2, a4) || (i3 = false);
          };
          if (s4("creationDate", "CreationDate"), s4("modificationDate", "ModDate"), void 0 !== r2.trapped && (this.setMetaTrapped(o3.docPtr, r2.trapped ?? null) || (i3 = false)), void 0 !== r2.custom) for (const [e4, t2] of Object.entries(r2.custom)) W(e4) ? this.setMetaText(o3.docPtr, e4, t2 ?? null) || (i3 = false) : this.logger.warn(re, oe, "Invalid custom metadata key skipped", e4);
          return this.logger.perf(re, oe, "SetMetadata", "End", e3.id), i3 ? Ut.resolve(true) : Ut.reject({ code: Ht.Unknown, message: "one or more metadata fields could not be written" });
        }
        getDocPermissions(e3) {
          this.logger.debug(re, oe, "getDocPermissions", e3), this.logger.perf(re, oe, "getDocPermissions", "Begin", e3.id);
          const r2 = this.cache.getContext(e3.id);
          if (!r2) return this.logger.perf(re, oe, "getDocPermissions", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const o3 = this.pdfiumModule.FPDF_GetDocPermissions(r2.docPtr);
          return Ut.resolve(o3);
        }
        getDocUserPermissions(e3) {
          this.logger.debug(re, oe, "getDocUserPermissions", e3), this.logger.perf(re, oe, "getDocUserPermissions", "Begin", e3.id);
          const r2 = this.cache.getContext(e3.id);
          if (!r2) return this.logger.perf(re, oe, "getDocUserPermissions", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const o3 = this.pdfiumModule.FPDF_GetDocUserPermissions(r2.docPtr);
          return Ut.resolve(o3);
        }
        getSignatures(e3) {
          this.logger.debug(re, oe, "getSignatures", e3), this.logger.perf(re, oe, "GetSignatures", "Begin", e3.id);
          const r2 = this.cache.getContext(e3.id);
          if (!r2) return this.logger.perf(re, oe, "GetSignatures", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const o3 = [], a3 = this.pdfiumModule.FPDF_GetSignatureCount(r2.docPtr);
          for (let e4 = 0; e4 < a3; e4++) {
            const t2 = this.pdfiumModule.FPDF_GetSignatureObject(r2.docPtr, e4), n3 = U(this.pdfiumModule.pdfium, (e5, n4) => this.pdfiumModule.FPDFSignatureObj_GetContents(t2, e5, n4)), a4 = U(this.pdfiumModule.pdfium, (e5, n4) => 4 * this.pdfiumModule.FPDFSignatureObj_GetByteRange(t2, e5, n4)), i3 = U(this.pdfiumModule.pdfium, (e5, n4) => this.pdfiumModule.FPDFSignatureObj_GetSubFilter(t2, e5, n4)), s4 = V(this.pdfiumModule.pdfium, (e5, n4) => this.pdfiumModule.FPDFSignatureObj_GetReason(t2, e5, n4), this.pdfiumModule.pdfium.UTF16ToString), u4 = V(this.pdfiumModule.pdfium, (e5, n4) => this.pdfiumModule.FPDFSignatureObj_GetTime(t2, e5, n4), this.pdfiumModule.pdfium.UTF8ToString), F2 = this.pdfiumModule.FPDFSignatureObj_GetDocMDPPermission(t2);
            o3.push({ contents: n3, byteRange: a4, subFilter: i3, reason: s4, time: u4, docMDP: F2 });
          }
          return this.logger.perf(re, oe, "GetSignatures", "End", e3.id), Ut.resolve(o3);
        }
        getBookmarks(e3) {
          this.logger.debug(re, oe, "getBookmarks", e3), this.logger.perf(re, oe, "GetBookmarks", "Begin", e3.id);
          const r2 = this.cache.getContext(e3.id);
          if (!r2) return this.logger.perf(re, oe, "getBookmarks", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const o3 = this.readPdfBookmarks(r2.docPtr, 0);
          return this.logger.perf(re, oe, "GetBookmarks", "End", e3.id), Ut.resolve({ bookmarks: o3 });
        }
        setBookmarks(e3, r2) {
          this.logger.debug(re, oe, "setBookmarks", e3, r2), this.logger.perf(re, oe, "SetBookmarks", "Begin", e3.id);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "SetBookmarks", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          if (!this.pdfiumModule.EPDFBookmark_Clear(o3.docPtr)) return this.logger.perf(re, oe, "SetBookmarks", "End", e3.id), Ut.reject({ code: Ht.Unknown, message: "failed to clear existing bookmarks" });
          const a3 = (e4, t2) => {
            var n3;
            for (const r3 of t2) {
              const t3 = this.withWString(r3.title ?? "", (t4) => this.pdfiumModule.EPDFBookmark_AppendChild(o3.docPtr, e4, t4));
              if (!t3) return false;
              if (r3.target) {
                if (!this.applyBookmarkTarget(o3.docPtr, t3, r3.target)) return false;
              }
              if (null == (n3 = r3.children) ? void 0 : n3.length) {
                if (!a3(t3, r3.children)) return false;
              }
            }
            return true;
          }, i3 = a3(0, r2);
          return this.logger.perf(re, oe, "SetBookmarks", "End", e3.id), i3 ? Ut.resolve(true) : Ut.reject({ code: Ht.Unknown, message: "failed to build bookmark tree" });
        }
        deleteBookmarks(e3) {
          this.logger.debug(re, oe, "deleteBookmarks", e3), this.logger.perf(re, oe, "DeleteBookmarks", "Begin", e3.id);
          const r2 = this.cache.getContext(e3.id);
          if (!r2) return this.logger.perf(re, oe, "DeleteBookmarks", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const o3 = this.pdfiumModule.EPDFBookmark_Clear(r2.docPtr);
          return this.logger.perf(re, oe, "DeleteBookmarks", "End", e3.id), o3 ? Ut.resolve(true) : Ut.reject({ code: Ht.Unknown, message: "failed to clear bookmarks" });
        }
        renderPageRaw(e3, t2, n3) {
          this.logger.debug(re, oe, "renderPage", e3, t2, n3), this.logger.perf(re, oe, "RenderPage", "Begin", `${e3.id}-${t2.index}`);
          const r2 = { origin: { x: 0, y: 0 }, size: t2.size }, o3 = this.renderRectEncoded(e3, t2, r2, n3);
          return this.logger.perf(re, oe, "RenderPage", "End", `${e3.id}-${t2.index}`), o3;
        }
        renderPageRect(e3, t2, n3, r2) {
          this.logger.debug(re, oe, "renderPageRect", e3, t2, n3, r2), this.logger.perf(re, oe, "RenderPageRect", "Begin", `${e3.id}-${t2.index}`);
          const o3 = this.renderRectEncoded(e3, t2, n3, r2);
          return this.logger.perf(re, oe, "RenderPageRect", "End", `${e3.id}-${t2.index}`), o3;
        }
        getPageAnnotations(e3, r2) {
          this.logger.debug(re, oe, "getPageAnnotations", e3, r2), this.logger.perf(re, oe, "GetPageAnnotations", "Begin", `${e3.id}-${r2.index}`);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "GetPageAnnotations", "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const a3 = this.readPageAnnotations(o3, r2);
          return this.logger.perf(re, oe, "GetPageAnnotations", "End", `${e3.id}-${r2.index}`), this.logger.debug(re, oe, "GetPageAnnotations", `${e3.id}-${r2.index}`, a3), Ut.resolve(a3);
        }
        createPageAnnotation(e3, r2, s4, u4) {
          this.logger.debug(re, oe, "createPageAnnotation", e3, r2, s4), this.logger.perf(re, oe, "CreatePageAnnotation", "Begin", `${e3.id}-${r2.index}`);
          const F2 = this.cache.getContext(e3.id);
          if (!F2) return this.logger.perf(re, oe, "CreatePageAnnotation", "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const m3 = F2.acquirePage(r2.index), l4 = this.pdfiumModule.EPDFPage_CreateAnnot(m3.pagePtr, s4.type);
          if (!l4) return this.logger.perf(re, oe, "CreatePageAnnotation", "End", `${e3.id}-${r2.index}`), m3.release(), Ut.reject({ code: Ht.CantCreateAnnot, message: "can not create annotation with specified type" });
          if (fn(s4.id) || (s4.id = yn()), !this.setAnnotString(l4, "NM", s4.id)) return this.pdfiumModule.FPDFPage_CloseAnnot(l4), m3.release(), Ut.reject({ code: Ht.CantSetAnnotString, message: "can not set the name of the annotation" });
          if (!this.setPageAnnoRect(r2, l4, s4.rect)) return this.pdfiumModule.FPDFPage_CloseAnnot(l4), m3.release(), this.logger.perf(re, oe, "CreatePageAnnotation", "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.CantSetAnnotRect, message: "can not set the rect of the annotation" });
          let d4 = false;
          switch (s4.type) {
            case Dt.INK:
              d4 = this.addInkStroke(r2, m3.pagePtr, l4, s4);
              break;
            case Dt.STAMP:
              d4 = this.addStampContent(F2.docPtr, r2, m3.pagePtr, l4, s4, null == u4 ? void 0 : u4.imageData);
              break;
            case Dt.TEXT:
              d4 = this.addTextContent(r2, m3.pagePtr, l4, s4);
              break;
            case Dt.FREETEXT:
              d4 = this.addFreeTextContent(r2, m3.pagePtr, l4, s4);
              break;
            case Dt.LINE:
              d4 = this.addLineContent(r2, m3.pagePtr, l4, s4);
              break;
            case Dt.POLYLINE:
            case Dt.POLYGON:
              d4 = this.addPolyContent(r2, m3.pagePtr, l4, s4);
              break;
            case Dt.CIRCLE:
            case Dt.SQUARE:
              d4 = this.addShapeContent(r2, m3.pagePtr, l4, s4);
              break;
            case Dt.UNDERLINE:
            case Dt.STRIKEOUT:
            case Dt.SQUIGGLY:
            case Dt.HIGHLIGHT:
              d4 = this.addTextMarkupContent(r2, m3.pagePtr, l4, s4);
          }
          return d4 ? (void 0 !== s4.blendMode ? this.pdfiumModule.EPDFAnnot_GenerateAppearanceWithBlend(l4, s4.blendMode) : this.pdfiumModule.EPDFAnnot_GenerateAppearance(l4), this.pdfiumModule.FPDFPage_GenerateContent(m3.pagePtr), this.pdfiumModule.FPDFPage_CloseAnnot(l4), m3.release(), this.logger.perf(re, oe, "CreatePageAnnotation", "End", `${e3.id}-${r2.index}`), Ut.resolve(s4.id)) : (this.pdfiumModule.FPDFPage_RemoveAnnot(m3.pagePtr, l4), m3.release(), this.logger.perf(re, oe, "CreatePageAnnotation", "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.CantSetAnnotContent, message: "can not add content of the annotation" }));
        }
        updatePageAnnotation(e3, r2, o3) {
          this.logger.debug(re, oe, "updatePageAnnotation", e3, r2, o3), this.logger.perf(re, oe, "UpdatePageAnnotation", "Begin", `${e3.id}-${r2.index}`);
          const a3 = this.cache.getContext(e3.id);
          if (!a3) return this.logger.perf(re, oe, "UpdatePageAnnotation", "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const s4 = a3.acquirePage(r2.index), u4 = this.getAnnotationByName(s4.pagePtr, o3.id);
          if (!u4) return s4.release(), this.logger.perf(re, oe, "UpdatePageAnnotation", "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.NotFound, message: "annotation not found" });
          if (!this.setPageAnnoRect(r2, u4, o3.rect)) return this.pdfiumModule.FPDFPage_CloseAnnot(u4), s4.release(), this.logger.perf(re, oe, "UpdatePageAnnotation", "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.CantSetAnnotRect, message: "failed to move annotation" });
          let F2 = false;
          switch (o3.type) {
            case Dt.INK:
              if (!this.pdfiumModule.FPDFAnnot_RemoveInkList(u4)) break;
              F2 = this.addInkStroke(r2, s4.pagePtr, u4, o3);
              break;
            case Dt.STAMP:
              F2 = this.addStampContent(a3.docPtr, r2, s4.pagePtr, u4, o3);
              break;
            case Dt.TEXT:
              F2 = this.addTextContent(r2, s4.pagePtr, u4, o3);
              break;
            case Dt.FREETEXT:
              F2 = this.addFreeTextContent(r2, s4.pagePtr, u4, o3);
              break;
            case Dt.CIRCLE:
            case Dt.SQUARE:
              F2 = this.addShapeContent(r2, s4.pagePtr, u4, o3);
              break;
            case Dt.LINE:
              F2 = this.addLineContent(r2, s4.pagePtr, u4, o3);
              break;
            case Dt.POLYGON:
            case Dt.POLYLINE:
              F2 = this.addPolyContent(r2, s4.pagePtr, u4, o3);
              break;
            case Dt.HIGHLIGHT:
            case Dt.UNDERLINE:
            case Dt.STRIKEOUT:
            case Dt.SQUIGGLY:
              F2 = this.addTextMarkupContent(r2, s4.pagePtr, u4, o3);
              break;
            default:
              F2 = false;
          }
          return F2 && (void 0 !== o3.blendMode ? this.pdfiumModule.EPDFAnnot_GenerateAppearanceWithBlend(u4, o3.blendMode) : this.pdfiumModule.EPDFAnnot_GenerateAppearance(u4), this.pdfiumModule.FPDFPage_GenerateContent(s4.pagePtr)), this.pdfiumModule.FPDFPage_CloseAnnot(u4), s4.release(), this.logger.perf(re, oe, "UpdatePageAnnotation", "End", `${e3.id}-${r2.index}`), F2 ? Ut.resolve(true) : Ut.reject({ code: Ht.CantSetAnnotContent, message: "failed to update annotation" });
        }
        removePageAnnotation(e3, r2, o3) {
          this.logger.debug(re, oe, "removePageAnnotation", e3, r2, o3), this.logger.perf(re, oe, "RemovePageAnnotation", "Begin", `${e3.id}-${r2.index}`);
          const a3 = this.cache.getContext(e3.id);
          if (!a3) return this.logger.perf(re, oe, "RemovePageAnnotation", "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const i3 = a3.acquirePage(r2.index);
          let s4 = false;
          return s4 = this.removeAnnotationByName(i3.pagePtr, o3.id), s4 ? (s4 = this.pdfiumModule.FPDFPage_GenerateContent(i3.pagePtr), s4 || this.logger.error(re, oe, "FPDFPage_GenerateContent Failed", `${e3.id}-${r2.index}`)) : this.logger.error(re, oe, "FPDFPage_RemoveAnnot Failed", `${e3.id}-${r2.index}`), i3.release(), this.logger.perf(re, oe, "RemovePageAnnotation", "End", `${e3.id}-${r2.index}`), Ut.resolve(s4);
        }
        getPageTextRects(e3, r2) {
          this.logger.debug(re, oe, "getPageTextRects", e3, r2), this.logger.perf(re, oe, "GetPageTextRects", "Begin", `${e3.id}-${r2.index}`);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "GetPageTextRects", "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const a3 = o3.acquirePage(r2.index), i3 = this.pdfiumModule.FPDFText_LoadPage(a3.pagePtr), s4 = this.readPageTextRects(r2, a3.docPtr, a3.pagePtr, i3);
          return this.pdfiumModule.FPDFText_ClosePage(i3), a3.release(), this.logger.perf(re, oe, "GetPageTextRects", "End", `${e3.id}-${r2.index}`), Ut.resolve(s4);
        }
        renderThumbnailRaw(e3, r2, o3) {
          const { scaleFactor: a3 = 1, ...i3 } = o3 ?? {};
          this.logger.debug(re, oe, "renderThumbnail", e3, r2, o3), this.logger.perf(re, oe, "RenderThumbnail", "Begin", `${e3.id}-${r2.index}`);
          if (!this.cache.getContext(e3.id)) return this.logger.perf(re, oe, "RenderThumbnail", "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const s4 = this.renderPageRaw(e3, r2, { scaleFactor: Math.max(a3, 0.5), ...i3 });
          return this.logger.perf(re, oe, "RenderThumbnail", "End", `${e3.id}-${r2.index}`), s4;
        }
        getAttachments(e3) {
          this.logger.debug(re, oe, "getAttachments", e3), this.logger.perf(re, oe, "GetAttachments", "Begin", e3.id);
          const r2 = this.cache.getContext(e3.id);
          if (!r2) return this.logger.perf(re, oe, "GetAttachments", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const o3 = [], a3 = this.pdfiumModule.FPDFDoc_GetAttachmentCount(r2.docPtr);
          for (let e4 = 0; e4 < a3; e4++) {
            const t2 = this.readPdfAttachment(r2.docPtr, e4);
            o3.push(t2);
          }
          return this.logger.perf(re, oe, "GetAttachments", "End", e3.id), Ut.resolve(o3);
        }
        addAttachment(e3, r2) {
          this.logger.debug(re, oe, "addAttachment", e3, null == r2 ? void 0 : r2.name), this.logger.perf(re, oe, "AddAttachment", "Begin", e3.id);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "AddAttachment", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const { name: a3, description: i3, mimeType: s4, data: u4 } = r2 ?? {};
          if (!a3) return this.logger.perf(re, oe, "AddAttachment", "End", e3.id), Ut.reject({ code: Ht.NotFound, message: "attachment name is required" });
          if (!u4 || (Uint8Array, 0 === u4.byteLength)) return this.logger.perf(re, oe, "AddAttachment", "End", e3.id), Ut.reject({ code: Ht.NotFound, message: "attachment data is empty" });
          const F2 = this.withWString(a3, (e4) => this.pdfiumModule.FPDFDoc_AddAttachment(o3.docPtr, e4));
          if (!F2) return this.logger.perf(re, oe, "AddAttachment", "End", e3.id), Ut.reject({ code: Ht.Unknown, message: `An attachment named "${a3}" already exists` });
          this.withWString(i3, (e4) => this.pdfiumModule.EPDFAttachment_SetDescription(F2, e4)), this.pdfiumModule.EPDFAttachment_SetSubtype(F2, s4);
          const m3 = u4 instanceof Uint8Array ? u4 : new Uint8Array(u4), l4 = m3.byteLength, d4 = this.memoryManager.malloc(l4);
          try {
            this.pdfiumModule.pdfium.HEAPU8.set(m3, d4);
            if (!this.pdfiumModule.FPDFAttachment_SetFile(F2, o3.docPtr, d4, l4)) return this.logger.perf(re, oe, "AddAttachment", "End", e3.id), Ut.reject({ code: Ht.Unknown, message: "failed to write attachment bytes" });
          } finally {
            this.memoryManager.free(d4);
          }
          return this.logger.perf(re, oe, "AddAttachment", "End", e3.id), Ut.resolve(true);
        }
        removeAttachment(e3, r2) {
          this.logger.debug(re, oe, "deleteAttachment", e3, r2), this.logger.perf(re, oe, "DeleteAttachment", "Begin", e3.id);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "DeleteAttachment", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const a3 = this.pdfiumModule.FPDFDoc_GetAttachmentCount(o3.docPtr);
          if (r2.index < 0 || r2.index >= a3) return this.logger.perf(re, oe, "DeleteAttachment", "End", e3.id), Ut.reject({ code: Ht.Unknown, message: `attachment index ${r2.index} out of range` });
          const i3 = this.pdfiumModule.FPDFDoc_DeleteAttachment(o3.docPtr, r2.index);
          return this.logger.perf(re, oe, "DeleteAttachment", "End", e3.id), i3 ? Ut.resolve(true) : Ut.reject({ code: Ht.Unknown, message: "failed to delete attachment" });
        }
        readAttachmentContent(e3, r2) {
          this.logger.debug(re, oe, "readAttachmentContent", e3, r2), this.logger.perf(re, oe, "ReadAttachmentContent", "Begin", e3.id);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "ReadAttachmentContent", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const a3 = this.pdfiumModule.FPDFDoc_GetAttachment(o3.docPtr, r2.index), i3 = this.memoryManager.malloc(4);
          if (!this.pdfiumModule.FPDFAttachment_GetFile(a3, 0, 0, i3)) return this.memoryManager.free(i3), this.logger.perf(re, oe, "ReadAttachmentContent", "End", e3.id), Ut.reject({ code: Ht.CantReadAttachmentSize, message: "can not read attachment size" });
          const s4 = this.pdfiumModule.pdfium.getValue(i3, "i32") >>> 0, u4 = this.memoryManager.malloc(s4);
          if (!this.pdfiumModule.FPDFAttachment_GetFile(a3, u4, s4, i3)) return this.memoryManager.free(i3), this.memoryManager.free(u4), this.logger.perf(re, oe, "ReadAttachmentContent", "End", e3.id), Ut.reject({ code: Ht.CantReadAttachmentContent, message: "can not read attachment content" });
          const F2 = new ArrayBuffer(s4), m3 = new DataView(F2);
          for (let e4 = 0; e4 < s4; e4++) m3.setInt8(e4, this.pdfiumModule.pdfium.getValue(u4 + e4, "i8"));
          return this.memoryManager.free(i3), this.memoryManager.free(u4), this.logger.perf(re, oe, "ReadAttachmentContent", "End", e3.id), Ut.resolve(F2);
        }
        setFormFieldValue(e3, r2, o3, a3) {
          this.logger.debug(re, oe, "SetFormFieldValue", e3, o3, a3), this.logger.perf(re, oe, "SetFormFieldValue", "Begin", `${e3.id}-${o3.id}`);
          const i3 = this.cache.getContext(e3.id);
          if (!i3) return this.logger.debug(re, oe, "SetFormFieldValue", "document is not opened"), this.logger.perf(re, oe, "SetFormFieldValue", "End", `${e3.id}-${o3.id}`), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const s4 = this.pdfiumModule.PDFiumExt_OpenFormFillInfo(), u4 = this.pdfiumModule.PDFiumExt_InitFormFillEnvironment(i3.docPtr, s4), F2 = i3.acquirePage(r2.index);
          this.pdfiumModule.FORM_OnAfterLoadPage(F2.pagePtr, u4);
          const m3 = this.getAnnotationByName(F2.pagePtr, o3.id);
          if (!m3) return F2.release(), this.logger.perf(re, oe, "SetFormFieldValue", "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.NotFound, message: "annotation not found" });
          if (!this.pdfiumModule.FORM_SetFocusedAnnot(u4, m3)) return this.logger.debug(re, oe, "SetFormFieldValue", "failed to set focused annotation"), this.logger.perf(re, oe, "SetFormFieldValue", "End", `${e3.id}-${o3.id}`), this.pdfiumModule.FPDFPage_CloseAnnot(m3), this.pdfiumModule.FORM_OnBeforeClosePage(F2.pagePtr, u4), F2.release(), this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(u4), this.pdfiumModule.PDFiumExt_CloseFormFillInfo(s4), Ut.reject({ code: Ht.CantFocusAnnot, message: "failed to set focused annotation" });
          switch (a3.kind) {
            case "text":
              {
                if (!this.pdfiumModule.FORM_SelectAllText(u4, F2.pagePtr)) return this.logger.debug(re, oe, "SetFormFieldValue", "failed to select all text"), this.logger.perf(re, oe, "SetFormFieldValue", "End", `${e3.id}-${o3.id}`), this.pdfiumModule.FORM_ForceToKillFocus(u4), this.pdfiumModule.FPDFPage_CloseAnnot(m3), this.pdfiumModule.FORM_OnBeforeClosePage(F2.pagePtr, u4), F2.release(), this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(u4), this.pdfiumModule.PDFiumExt_CloseFormFillInfo(s4), Ut.reject({ code: Ht.CantSelectText, message: "failed to select all text" });
                const r3 = 2 * (a3.text.length + 1), i4 = this.memoryManager.malloc(r3);
                this.pdfiumModule.pdfium.stringToUTF16(a3.text, i4, r3), this.pdfiumModule.FORM_ReplaceSelection(u4, F2.pagePtr, i4), this.memoryManager.free(i4);
              }
              break;
            case "selection":
              if (!this.pdfiumModule.FORM_SetIndexSelected(u4, F2.pagePtr, a3.index, a3.isSelected)) return this.logger.debug(re, oe, "SetFormFieldValue", "failed to set index selected"), this.logger.perf(re, oe, "SetFormFieldValue", "End", `${e3.id}-${o3.id}`), this.pdfiumModule.FORM_ForceToKillFocus(u4), this.pdfiumModule.FPDFPage_CloseAnnot(m3), this.pdfiumModule.FORM_OnBeforeClosePage(F2.pagePtr, u4), F2.release(), this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(u4), this.pdfiumModule.PDFiumExt_CloseFormFillInfo(s4), Ut.reject({ code: Ht.CantSelectOption, message: "failed to set index selected" });
              break;
            case "checked": {
              const r3 = 13;
              if (!this.pdfiumModule.FORM_OnChar(u4, F2.pagePtr, r3, 0)) return this.logger.debug(re, oe, "SetFormFieldValue", "failed to set field checked"), this.logger.perf(re, oe, "SetFormFieldValue", "End", `${e3.id}-${o3.id}`), this.pdfiumModule.FORM_ForceToKillFocus(u4), this.pdfiumModule.FPDFPage_CloseAnnot(m3), this.pdfiumModule.FORM_OnBeforeClosePage(F2.pagePtr, u4), F2.release(), this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(u4), this.pdfiumModule.PDFiumExt_CloseFormFillInfo(s4), Ut.reject({ code: Ht.CantCheckField, message: "failed to set field checked" });
            }
          }
          return this.pdfiumModule.FORM_ForceToKillFocus(u4), this.pdfiumModule.FPDFPage_CloseAnnot(m3), this.pdfiumModule.FORM_OnBeforeClosePage(F2.pagePtr, u4), F2.release(), this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(u4), this.pdfiumModule.PDFiumExt_CloseFormFillInfo(s4), Ut.resolve(true);
        }
        flattenPage(e3, r2, o3) {
          const { flag: a3 = jt.Display } = o3 ?? {};
          this.logger.debug(re, oe, "flattenPage", e3, r2, a3), this.logger.perf(re, oe, "flattenPage", "Begin", e3.id);
          const i3 = this.cache.getContext(e3.id);
          if (!i3) return this.logger.perf(re, oe, "flattenPage", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const u4 = i3.acquirePage(r2.index), F2 = this.pdfiumModule.FPDFPage_Flatten(u4.pagePtr, a3);
          return u4.release(), this.logger.perf(re, oe, "flattenPage", "End", e3.id), Ut.resolve(F2);
        }
        extractPages(e3, r2) {
          this.logger.debug(re, oe, "extractPages", e3, r2), this.logger.perf(re, oe, "ExtractPages", "Begin", e3.id);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "ExtractPages", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const a3 = this.pdfiumModule.FPDF_CreateNewDocument();
          if (!a3) return this.logger.perf(re, oe, "ExtractPages", "End", e3.id), Ut.reject({ code: Ht.CantCreateNewDoc, message: "can not create new document" });
          const i3 = this.memoryManager.malloc(4 * r2.length);
          for (let e4 = 0; e4 < r2.length; e4++) this.pdfiumModule.pdfium.setValue(i3 + 4 * e4, r2[e4], "i32");
          if (!this.pdfiumModule.FPDF_ImportPagesByIndex(a3, o3.docPtr, i3, r2.length, 0)) return this.pdfiumModule.FPDF_CloseDocument(a3), this.logger.perf(re, oe, "ExtractPages", "End", e3.id), Ut.reject({ code: Ht.CantImportPages, message: "can not import pages to new document" });
          const s4 = this.saveDocument(a3);
          return this.pdfiumModule.FPDF_CloseDocument(a3), this.logger.perf(re, oe, "ExtractPages", "End", e3.id), Ut.resolve(s4);
        }
        extractText(e3, r2) {
          this.logger.debug(re, oe, "extractText", e3, r2), this.logger.perf(re, oe, "ExtractText", "Begin", e3.id);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "ExtractText", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const a3 = [];
          for (let e4 = 0; e4 < r2.length; e4++) {
            const t2 = o3.acquirePage(r2[e4]), n3 = this.pdfiumModule.FPDFText_LoadPage(t2.pagePtr), i4 = this.pdfiumModule.FPDFText_CountChars(n3), s4 = this.memoryManager.malloc(2 * (i4 + 1));
            this.pdfiumModule.FPDFText_GetText(n3, 0, i4, s4);
            const u4 = this.pdfiumModule.pdfium.UTF16ToString(s4);
            this.memoryManager.free(s4), a3.push(u4), this.pdfiumModule.FPDFText_ClosePage(n3), t2.release();
          }
          const i3 = a3.join("\n\n");
          return this.logger.perf(re, oe, "ExtractText", "End", e3.id), Ut.resolve(i3);
        }
        getTextSlices(e3, r2) {
          if (this.logger.debug(re, oe, "getTextSlices", e3, r2), this.logger.perf(re, oe, "GetTextSlices", "Begin", e3.id), 0 === r2.length) return this.logger.perf(re, oe, "GetTextSlices", "End", e3.id), Ut.resolve([]);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "GetTextSlices", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          try {
            const n3 = new Array(r2.length), a3 = /* @__PURE__ */ new Map();
            r2.forEach((e4, t2) => {
              (a3.get(e4.pageIndex) ?? a3.set(e4.pageIndex, []).get(e4.pageIndex)).push({ slice: e4, pos: t2 });
            });
            for (const [e4, t2] of a3) {
              const r3 = o3.acquirePage(e4), a4 = r3.getTextPage();
              for (const { slice: e5, pos: r4 } of t2) {
                const t3 = this.memoryManager.malloc(2 * (e5.charCount + 1));
                this.pdfiumModule.FPDFText_GetText(a4, e5.charIndex, e5.charCount, t3), n3[r4] = ft(this.pdfiumModule.pdfium.UTF16ToString(t3)), this.memoryManager.free(t3);
              }
              r3.release();
            }
            return this.logger.perf(re, oe, "GetTextSlices", "End", e3.id), Ut.resolve(n3);
          } catch (r3) {
            return this.logger.error(re, oe, "getTextSlices error", r3), this.logger.perf(re, oe, "GetTextSlices", "End", e3.id), Ut.reject({ code: Ht.Unknown, message: String(r3) });
          }
        }
        merge(e3) {
          this.logger.debug(re, oe, "merge", e3);
          const r2 = e3.map((e4) => e4.id).join(".");
          this.logger.perf(re, oe, "Merge", "Begin", r2);
          const o3 = this.pdfiumModule.FPDF_CreateNewDocument();
          if (!o3) return this.logger.perf(re, oe, "Merge", "End", r2), Ut.reject({ code: Ht.CantCreateNewDoc, message: "can not create new document" });
          const a3 = [];
          for (const i4 of e3.reverse()) {
            const e4 = new Uint8Array(i4.content), s5 = e4.length, u4 = this.memoryManager.malloc(s5);
            this.pdfiumModule.pdfium.HEAPU8.set(e4, u4);
            const F2 = this.pdfiumModule.FPDF_LoadMemDocument(u4, s5, "");
            if (!F2) {
              const e5 = this.pdfiumModule.FPDF_GetLastError();
              this.logger.error(re, oe, `FPDF_LoadMemDocument failed with ${e5}`), this.memoryManager.free(u4);
              for (const e6 of a3) this.pdfiumModule.FPDF_CloseDocument(e6.docPtr), this.memoryManager.free(e6.filePtr);
              return this.logger.perf(re, oe, "Merge", "End", r2), Ut.reject({ code: e5, message: "FPDF_LoadMemDocument failed" });
            }
            if (a3.push({ filePtr: u4, docPtr: F2 }), !this.pdfiumModule.FPDF_ImportPages(o3, F2, "", 0)) {
              this.pdfiumModule.FPDF_CloseDocument(o3);
              for (const e5 of a3) this.pdfiumModule.FPDF_CloseDocument(e5.docPtr), this.memoryManager.free(e5.filePtr);
              return this.logger.perf(re, oe, "Merge", "End", r2), Ut.reject({ code: Ht.CantImportPages, message: "can not import pages to new document" });
            }
          }
          const i3 = this.saveDocument(o3);
          this.pdfiumModule.FPDF_CloseDocument(o3);
          for (const e4 of a3) this.pdfiumModule.FPDF_CloseDocument(e4.docPtr), this.memoryManager.free(e4.filePtr);
          const s4 = { id: `${Math.random()}`, content: i3 };
          return this.logger.perf(re, oe, "Merge", "End", r2), Ut.resolve(s4);
        }
        mergePages(e3) {
          const r2 = e3.map((e4) => `${e4.docId}:${e4.pageIndices.join(",")}`).join("|");
          this.logger.debug(re, oe, "mergePages", e3), this.logger.perf(re, oe, "MergePages", "Begin", r2);
          const o3 = this.pdfiumModule.FPDF_CreateNewDocument();
          if (!o3) return this.logger.perf(re, oe, "MergePages", "End", r2), Ut.reject({ code: Ht.CantCreateNewDoc, message: "Cannot create new document" });
          try {
            for (const t2 of [...e3].reverse()) {
              const e4 = this.cache.getContext(t2.docId);
              if (!e4) {
                this.logger.warn(re, oe, `Document ${t2.docId} is not open, skipping`);
                continue;
              }
              const n4 = this.pdfiumModule.FPDF_GetPageCount(e4.docPtr), r3 = t2.pageIndices.filter((e5) => e5 >= 0 && e5 < n4);
              if (0 === r3.length) continue;
              const a4 = r3.map((e5) => e5 + 1).join(",");
              try {
                if (!this.pdfiumModule.FPDF_ImportPages(o3, e4.docPtr, a4, 0)) throw new Error(`Failed to import pages ${a4} from document ${t2.docId}`);
              } finally {
              }
            }
            const n3 = this.saveDocument(o3), a3 = { id: `${Math.random()}`, content: n3 };
            return this.logger.perf(re, oe, "MergePages", "End", r2), Ut.resolve(a3);
          } catch (e4) {
            return this.logger.error(re, oe, "mergePages failed", e4), this.logger.perf(re, oe, "MergePages", "End", r2), Ut.reject({ code: Ht.CantImportPages, message: e4 instanceof Error ? e4.message : "Failed to merge pages" });
          } finally {
            o3 && this.pdfiumModule.FPDF_CloseDocument(o3);
          }
        }
        saveAsCopy(e3) {
          this.logger.debug(re, oe, "saveAsCopy", e3), this.logger.perf(re, oe, "SaveAsCopy", "Begin", e3.id);
          const r2 = this.cache.getContext(e3.id);
          if (!r2) return this.logger.perf(re, oe, "SaveAsCopy", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const o3 = this.saveDocument(r2.docPtr);
          return this.logger.perf(re, oe, "SaveAsCopy", "End", e3.id), Ut.resolve(o3);
        }
        closeDocument(e3) {
          this.logger.debug(re, oe, "closeDocument", e3), this.logger.perf(re, oe, "CloseDocument", "Begin", e3.id);
          const n3 = this.cache.getContext(e3.id);
          return n3 ? (n3.dispose(), this.logger.perf(re, oe, "CloseDocument", "End", e3.id), Ut.resolve(true)) : Ut.resolve(true);
        }
        closeAllDocuments() {
          return this.logger.debug(re, oe, "closeAllDocuments"), this.logger.perf(re, oe, "CloseAllDocuments", "Begin"), this.cache.closeAllDocuments(), this.logger.perf(re, oe, "CloseAllDocuments", "End"), Ut.resolve(true);
        }
        addTextContent(e3, t2, n3, r2) {
          return !!this.setAnnotString(n3, "Contents", r2.contents ?? "") && (!(r2.custom && !this.setAnnotCustom(n3, r2.custom)) && (!!this.setAnnotString(n3, "T", r2.author || "") && (!(r2.modified && !this.setAnnotationDate(n3, "M", r2.modified)) && (!(r2.created && !this.setAnnotationDate(n3, "CreationDate", r2.created)) && (!(r2.inReplyToId && !this.setInReplyToId(t2, n3, r2.inReplyToId)) && (!!this.setAnnotationIcon(n3, r2.icon || Pt.Comment) && (!!this.setAnnotationFlags(n3, r2.flags || ["print", "noZoom", "noRotate"]) && (!(r2.state && !this.setAnnotString(n3, "State", r2.state)) && !(r2.stateModel && !this.setAnnotString(n3, "StateModel", r2.stateModel))))))))));
        }
        addFreeTextContent(e3, t2, n3, r2) {
          if (r2.created && !this.setAnnotationDate(n3, "CreationDate", r2.created)) return false;
          if (r2.custom && !this.setAnnotCustom(n3, r2.custom)) return false;
          if (r2.flags && !this.setAnnotationFlags(n3, r2.flags)) return false;
          if (r2.modified && !this.setAnnotationDate(n3, "M", r2.modified)) return false;
          if (!this.setBorderStyle(n3, Et.SOLID, 0)) return false;
          if (!this.setAnnotString(n3, "Contents", r2.contents ?? "")) return false;
          if (!this.setAnnotString(n3, "T", r2.author || "")) return false;
          if (!this.setAnnotationOpacity(n3, r2.opacity ?? 1)) return false;
          if (!this.setAnnotationTextAlignment(n3, r2.textAlign)) return false;
          if (!this.setAnnotationVerticalAlignment(n3, r2.verticalAlign)) return false;
          if (!this.setAnnotationDefaultAppearance(n3, r2.fontFamily, r2.fontSize, r2.fontColor)) return false;
          if (r2.intent && !this.setAnnotIntent(n3, r2.intent)) return false;
          if (r2.backgroundColor && "transparent" !== r2.backgroundColor) {
            if (!this.setAnnotationColor(n3, r2.backgroundColor ?? "#FFFFFF", zt.Color)) return false;
          } else if (!this.pdfiumModule.EPDFAnnot_ClearColor(n3, zt.Color)) return false;
          return true;
        }
        addInkStroke(e3, t2, n3, r2) {
          return !(r2.created && !this.setAnnotationDate(n3, "CreationDate", r2.created)) && (!(r2.custom && !this.setAnnotCustom(n3, r2.custom)) && (!(r2.flags && !this.setAnnotationFlags(n3, r2.flags)) && (!(r2.modified && !this.setAnnotationDate(n3, "M", r2.modified)) && (!!this.setAnnotString(n3, "Contents", r2.contents ?? "") && (!!this.setBorderStyle(n3, Et.SOLID, r2.strokeWidth) && (!!this.setInkList(e3, n3, r2.inkList) && (!!this.setAnnotString(n3, "T", r2.author || "") && (!!this.setAnnotationOpacity(n3, r2.opacity ?? 1) && !!this.setAnnotationColor(n3, r2.color ?? "#FFFF00", zt.Color)))))))));
        }
        addLineContent(e3, t2, n3, r2) {
          var o3, a3;
          if (r2.created && !this.setAnnotationDate(n3, "CreationDate", r2.created)) return false;
          if (r2.custom && !this.setAnnotCustom(n3, r2.custom)) return false;
          if (r2.flags && !this.setAnnotationFlags(n3, r2.flags)) return false;
          if (r2.modified && !this.setAnnotationDate(n3, "M", r2.modified)) return false;
          if (!this.setLinePoints(e3, n3, r2.linePoints.start, r2.linePoints.end)) return false;
          if (!this.setLineEndings(n3, (null == (o3 = r2.lineEndings) ? void 0 : o3.start) ?? At.None, (null == (a3 = r2.lineEndings) ? void 0 : a3.end) ?? At.None)) return false;
          if (!this.setAnnotString(n3, "Contents", r2.contents ?? "")) return false;
          if (!this.setAnnotString(n3, "T", r2.author || "")) return false;
          if (!this.setBorderStyle(n3, r2.strokeStyle, r2.strokeWidth)) return false;
          if (!this.setBorderDashPattern(n3, r2.strokeDashArray ?? [])) return false;
          if (r2.intent && !this.setAnnotIntent(n3, r2.intent)) return false;
          if (r2.color && "transparent" !== r2.color) {
            if (!this.setAnnotationColor(n3, r2.color ?? "#FFFF00", zt.InteriorColor)) return false;
          } else if (!this.pdfiumModule.EPDFAnnot_ClearColor(n3, zt.InteriorColor)) return false;
          return !!this.setAnnotationOpacity(n3, r2.opacity ?? 1) && !!this.setAnnotationColor(n3, r2.strokeColor ?? "#FFFF00", zt.Color);
        }
        addPolyContent(e3, t2, n3, r2) {
          var o3, a3;
          if (r2.created && !this.setAnnotationDate(n3, "CreationDate", r2.created)) return false;
          if (r2.custom && !this.setAnnotCustom(n3, r2.custom)) return false;
          if (r2.modified && !this.setAnnotationDate(n3, "M", r2.modified)) return false;
          if (r2.flags && !this.setAnnotationFlags(n3, r2.flags)) return false;
          if (r2.type === Dt.POLYLINE && !this.setLineEndings(n3, (null == (o3 = r2.lineEndings) ? void 0 : o3.start) ?? At.None, (null == (a3 = r2.lineEndings) ? void 0 : a3.end) ?? At.None)) return false;
          if (!this.setPdfAnnoVertices(e3, n3, r2.vertices)) return false;
          if (!this.setAnnotString(n3, "Contents", r2.contents ?? "")) return false;
          if (!this.setAnnotString(n3, "T", r2.author || "")) return false;
          if (!this.setBorderStyle(n3, r2.strokeStyle, r2.strokeWidth)) return false;
          if (!this.setBorderDashPattern(n3, r2.strokeDashArray ?? [])) return false;
          if (r2.intent && !this.setAnnotIntent(n3, r2.intent)) return false;
          if (r2.color && "transparent" !== r2.color) {
            if (!this.setAnnotationColor(n3, r2.color ?? "#FFFF00", zt.InteriorColor)) return false;
          } else if (!this.pdfiumModule.EPDFAnnot_ClearColor(n3, zt.InteriorColor)) return false;
          return !!this.setAnnotationOpacity(n3, r2.opacity ?? 1) && !!this.setAnnotationColor(n3, r2.strokeColor ?? "#FFFF00", zt.Color);
        }
        addShapeContent(e3, t2, n3, r2) {
          if (r2.created && !this.setAnnotationDate(n3, "CreationDate", r2.created)) return false;
          if (r2.custom && !this.setAnnotCustom(n3, r2.custom)) return false;
          if (r2.modified && !this.setAnnotationDate(n3, "M", r2.modified)) return false;
          if (!this.setAnnotString(n3, "Contents", r2.contents ?? "")) return false;
          if (!this.setAnnotString(n3, "T", r2.author || "")) return false;
          if (!this.setBorderStyle(n3, r2.strokeStyle, r2.strokeWidth)) return false;
          if (!this.setBorderDashPattern(n3, r2.strokeDashArray ?? [])) return false;
          if (!this.setAnnotationFlags(n3, r2.flags)) return false;
          if (r2.color && "transparent" !== r2.color) {
            if (!this.setAnnotationColor(n3, r2.color ?? "#FFFF00", zt.InteriorColor)) return false;
          } else if (!this.pdfiumModule.EPDFAnnot_ClearColor(n3, zt.InteriorColor)) return false;
          return !!this.setAnnotationOpacity(n3, r2.opacity ?? 1) && !!this.setAnnotationColor(n3, r2.strokeColor ?? "#FFFF00", zt.Color);
        }
        addTextMarkupContent(e3, t2, n3, r2) {
          return !(r2.created && !this.setAnnotationDate(n3, "CreationDate", r2.created)) && (!(r2.custom && !this.setAnnotCustom(n3, r2.custom)) && (!(r2.flags && !this.setAnnotationFlags(n3, r2.flags)) && (!(r2.modified && !this.setAnnotationDate(n3, "M", r2.modified)) && (!!this.syncQuadPointsAnno(e3, n3, r2.segmentRects) && (!!this.setAnnotString(n3, "Contents", r2.contents ?? "") && (!!this.setAnnotString(n3, "T", r2.author || "") && (!!this.setAnnotationOpacity(n3, r2.opacity ?? 1) && !!this.setAnnotationColor(n3, r2.color ?? "#FFFF00", zt.Color))))))));
        }
        addStampContent(e3, t2, n3, r2, o3, a3) {
          if (o3.created && !this.setAnnotationDate(r2, "CreationDate", o3.created)) return false;
          if (o3.custom && !this.setAnnotCustom(r2, o3.custom)) return false;
          if (o3.flags && !this.setAnnotationFlags(r2, o3.flags)) return false;
          if (o3.modified && !this.setAnnotationDate(r2, "M", o3.modified)) return false;
          if (o3.icon && !this.setAnnotationIcon(r2, o3.icon)) return false;
          if (!this.setAnnotString(r2, "T", o3.author || "")) return false;
          if (o3.subject && !this.setAnnotString(r2, "Subj", o3.subject)) return false;
          if (!this.setAnnotString(r2, "Contents", o3.contents ?? "")) return false;
          if (a3) {
            for (let e4 = this.pdfiumModule.FPDFAnnot_GetObjectCount(r2) - 1; e4 >= 0; e4--) this.pdfiumModule.FPDFAnnot_RemoveObject(r2, e4);
            if (!this.addImageObject(e3, t2, n3, r2, o3.rect, a3)) return false;
          }
          return !!this.pdfiumModule.EPDFAnnot_UpdateAppearanceToRect(r2, St.Cover);
        }
        addImageObject(e3, t2, n3, r2, o3, a3) {
          const i3 = a3.width * a3.height, s4 = this.memoryManager.malloc(4 * i3);
          if (!s4) return false;
          for (let e4 = 0; e4 < i3; e4++) {
            const t3 = a3.data[4 * e4], n4 = a3.data[4 * e4 + 1], r3 = a3.data[4 * e4 + 2], o4 = a3.data[4 * e4 + 3];
            this.pdfiumModule.pdfium.setValue(s4 + 4 * e4, r3, "i8"), this.pdfiumModule.pdfium.setValue(s4 + 4 * e4 + 1, n4, "i8"), this.pdfiumModule.pdfium.setValue(s4 + 4 * e4 + 2, t3, "i8"), this.pdfiumModule.pdfium.setValue(s4 + 4 * e4 + 3, o4, "i8");
          }
          const u4 = this.pdfiumModule.FPDFBitmap_CreateEx(a3.width, a3.height, 4, s4, 0);
          if (!u4) return this.memoryManager.free(s4), false;
          const F2 = this.pdfiumModule.FPDFPageObj_NewImageObj(e3);
          if (!F2) return this.pdfiumModule.FPDFBitmap_Destroy(u4), this.memoryManager.free(s4), false;
          if (!this.pdfiumModule.FPDFImageObj_SetBitmap(n3, 0, F2, u4)) return this.pdfiumModule.FPDFBitmap_Destroy(u4), this.pdfiumModule.FPDFPageObj_Destroy(F2), this.memoryManager.free(s4), false;
          const m3 = this.memoryManager.malloc(24);
          if (this.pdfiumModule.pdfium.setValue(m3, a3.width, "float"), this.pdfiumModule.pdfium.setValue(m3 + 4, 0, "float"), this.pdfiumModule.pdfium.setValue(m3 + 8, 0, "float"), this.pdfiumModule.pdfium.setValue(m3 + 12, a3.height, "float"), this.pdfiumModule.pdfium.setValue(m3 + 16, 0, "float"), this.pdfiumModule.pdfium.setValue(m3 + 20, 0, "float"), !this.pdfiumModule.FPDFPageObj_SetMatrix(F2, m3)) return this.memoryManager.free(m3), this.pdfiumModule.FPDFBitmap_Destroy(u4), this.pdfiumModule.FPDFPageObj_Destroy(F2), this.memoryManager.free(s4), false;
          this.memoryManager.free(m3);
          const l4 = this.convertDevicePointToPagePoint(t2, { x: o3.origin.x, y: o3.origin.y + a3.height });
          return this.pdfiumModule.FPDFPageObj_Transform(F2, 1, 0, 0, 1, l4.x, l4.y), this.pdfiumModule.FPDFAnnot_AppendObject(r2, F2) ? (this.pdfiumModule.FPDFBitmap_Destroy(u4), this.memoryManager.free(s4), true) : (this.pdfiumModule.FPDFBitmap_Destroy(u4), this.pdfiumModule.FPDFPageObj_Destroy(F2), this.memoryManager.free(s4), false);
        }
        saveDocument(e3) {
          const t2 = this.pdfiumModule.PDFiumExt_OpenFileWriter();
          this.pdfiumModule.PDFiumExt_SaveAsCopy(e3, t2);
          const n3 = this.pdfiumModule.PDFiumExt_GetFileWriterSize(t2), r2 = this.memoryManager.malloc(n3);
          this.pdfiumModule.PDFiumExt_GetFileWriterData(t2, r2, n3);
          const o3 = new ArrayBuffer(n3), a3 = new DataView(o3);
          for (let e4 = 0; e4 < n3; e4++) a3.setInt8(e4, this.pdfiumModule.pdfium.getValue(r2 + e4, "i8"));
          return this.memoryManager.free(r2), this.pdfiumModule.PDFiumExt_CloseFileWriter(t2), o3;
        }
        readCatalogLanguage(e3) {
          const t2 = this.pdfiumModule.EPDFCatalog_GetLanguage(e3, 0, 0) >>> 0;
          return 0 === t2 ? null : 2 === t2 ? "" : V(this.pdfiumModule.pdfium, (t3, n3) => this.pdfiumModule.EPDFCatalog_GetLanguage(e3, t3, n3), this.pdfiumModule.pdfium.UTF16ToString, t2);
        }
        readMetaText(e3, t2) {
          if (!!!this.pdfiumModule.EPDF_HasMetaText(e3, t2)) return null;
          const n3 = this.pdfiumModule.FPDF_GetMetaText(e3, t2, 0, 0);
          return 2 === n3 ? "" : V(this.pdfiumModule.pdfium, (n4, r2) => this.pdfiumModule.FPDF_GetMetaText(e3, t2, n4, r2), this.pdfiumModule.pdfium.UTF16ToString, n3);
        }
        setMetaText(e3, t2, n3) {
          if (null == n3 || 0 === n3.length) {
            return !!this.pdfiumModule.EPDF_SetMetaText(e3, t2, 0);
          }
          const r2 = 2 * (n3.length + 1), o3 = this.memoryManager.malloc(r2);
          try {
            this.pdfiumModule.pdfium.stringToUTF16(n3, o3, r2);
            return !!this.pdfiumModule.EPDF_SetMetaText(e3, t2, o3);
          } finally {
            this.memoryManager.free(o3);
          }
        }
        getMetaTrapped(e3) {
          const t2 = Number(this.pdfiumModule.EPDF_GetMetaTrapped(e3));
          switch (t2) {
            case bt.NotSet:
            case bt.True:
            case bt.False:
            case bt.Unknown:
              return t2;
            default:
              return bt.Unknown;
          }
        }
        setMetaTrapped(e3, t2) {
          const n3 = null == t2 || void 0 === t2 ? bt.NotSet : t2;
          return !(n3 !== bt.NotSet && n3 !== bt.True && n3 !== bt.False && n3 !== bt.Unknown) && !!this.pdfiumModule.EPDF_SetMetaTrapped(e3, n3);
        }
        getMetaKeyCount(e3, t2) {
          return 0 | Number(this.pdfiumModule.EPDF_GetMetaKeyCount(e3, t2));
        }
        getMetaKeyName(e3, t2, n3) {
          const r2 = this.pdfiumModule.EPDF_GetMetaKeyName(e3, t2, n3, 0, 0);
          return r2 ? V(this.pdfiumModule.pdfium, (r3, o3) => this.pdfiumModule.EPDF_GetMetaKeyName(e3, t2, n3, r3, o3), this.pdfiumModule.pdfium.UTF8ToString, r2) : null;
        }
        readAllMeta(e3, t2 = true) {
          const n3 = this.getMetaKeyCount(e3, t2), r2 = {};
          for (let o3 = 0; o3 < n3; o3++) {
            const n4 = this.getMetaKeyName(e3, o3, t2);
            n4 && (r2[n4] = this.readMetaText(e3, n4));
          }
          return r2;
        }
        readPdfBookmarks(e3, t2 = 0) {
          let n3 = this.pdfiumModule.FPDFBookmark_GetFirstChild(e3, t2);
          const r2 = [];
          for (; n3; ) {
            const t3 = this.readPdfBookmark(e3, n3);
            r2.push(t3);
            n3 = this.pdfiumModule.FPDFBookmark_GetNextSibling(e3, n3);
          }
          return r2;
        }
        readPdfBookmark(e3, t2) {
          const n3 = V(this.pdfiumModule.pdfium, (e4, n4) => this.pdfiumModule.FPDFBookmark_GetTitle(t2, e4, n4), this.pdfiumModule.pdfium.UTF16ToString), r2 = this.readPdfBookmarks(e3, t2);
          return { title: n3, target: this.readPdfBookmarkTarget(e3, () => this.pdfiumModule.FPDFBookmark_GetAction(t2), () => this.pdfiumModule.FPDFBookmark_GetDest(e3, t2)), children: r2 };
        }
        readPageTextRects(e3, t2, n3, r2) {
          const o3 = this.pdfiumModule.FPDFText_CountRects(r2, 0, -1), a3 = [];
          for (let t3 = 0; t3 < o3; t3++) {
            const o4 = this.memoryManager.malloc(8), i3 = this.memoryManager.malloc(8), s4 = this.memoryManager.malloc(8), u4 = this.memoryManager.malloc(8);
            if (!this.pdfiumModule.FPDFText_GetRect(r2, t3, i3, o4, s4, u4)) {
              this.memoryManager.free(i3), this.memoryManager.free(o4), this.memoryManager.free(s4), this.memoryManager.free(u4);
              continue;
            }
            const F2 = this.pdfiumModule.pdfium.getValue(i3, "double"), m3 = this.pdfiumModule.pdfium.getValue(o4, "double"), l4 = this.pdfiumModule.pdfium.getValue(s4, "double"), d4 = this.pdfiumModule.pdfium.getValue(u4, "double");
            this.memoryManager.free(i3), this.memoryManager.free(o4), this.memoryManager.free(s4), this.memoryManager.free(u4);
            const _2 = this.memoryManager.malloc(4), c4 = this.memoryManager.malloc(4);
            this.pdfiumModule.FPDF_PageToDevice(n3, 0, 0, e3.size.width, e3.size.height, 0, F2, m3, _2, c4);
            const P2 = this.pdfiumModule.pdfium.getValue(_2, "i32"), g3 = this.pdfiumModule.pdfium.getValue(c4, "i32");
            this.memoryManager.free(_2), this.memoryManager.free(c4);
            const h3 = { origin: { x: P2, y: g3 }, size: { width: Math.ceil(Math.abs(l4 - F2)), height: Math.ceil(Math.abs(m3 - d4)) } }, D2 = this.pdfiumModule.FPDFText_GetBoundedText(r2, F2, m3, l4, d4, 0, 0), b2 = 2 * (D2 + 1), f2 = this.memoryManager.malloc(b2);
            this.pdfiumModule.FPDFText_GetBoundedText(r2, F2, m3, l4, d4, f2, D2);
            const p4 = this.pdfiumModule.pdfium.UTF16ToString(f2);
            this.memoryManager.free(f2);
            const A2 = this.pdfiumModule.FPDFText_GetCharIndexAtPos(r2, F2, m3, 2, 2);
            let E2 = "", M2 = h3.size.height;
            if (A2 >= 0) {
              M2 = this.pdfiumModule.FPDFText_GetFontSize(r2, A2);
              const e4 = this.pdfiumModule.FPDFText_GetFontInfo(r2, A2, 0, 0, 0) + 1, t4 = this.memoryManager.malloc(e4), n4 = this.memoryManager.malloc(4);
              this.pdfiumModule.FPDFText_GetFontInfo(r2, A2, t4, e4, n4), E2 = this.pdfiumModule.pdfium.UTF8ToString(t4), this.memoryManager.free(t4), this.memoryManager.free(n4);
            }
            const y2 = { content: p4, rect: h3, font: { family: E2, size: M2 } };
            a3.push(y2);
          }
          return a3;
        }
        getPageGeometry(e3, r2) {
          const o3 = "getPageGeometry";
          this.logger.perf(re, oe, o3, "Begin", e3.id);
          const a3 = this.cache.getContext(e3.id);
          if (!a3) return this.logger.perf(re, oe, o3, "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const i3 = a3.acquirePage(r2.index), s4 = i3.getTextPage(), u4 = this.pdfiumModule.FPDFText_CountChars(s4), F2 = [];
          for (let e4 = 0; e4 < u4; e4++) {
            const t2 = this.readGlyphInfo(r2, i3.pagePtr, s4, e4);
            F2.push(t2);
          }
          const m3 = this.buildRunsFromGlyphs(F2, s4);
          return i3.release(), this.logger.perf(re, oe, o3, "End", e3.id), Ut.resolve({ runs: m3 });
        }
        buildRunsFromGlyphs(e3, t2) {
          const n3 = [];
          let r2 = null, o3 = null, a3 = null;
          for (let i3 = 0; i3 < e3.length; i3++) {
            const s4 = e3[i3], u4 = this.pdfiumModule.FPDFText_GetTextObject(t2, i3);
            if (u4 !== o3 && (o3 = u4, r2 = { rect: { x: s4.origin.x, y: s4.origin.y, width: s4.size.width, height: s4.size.height }, charStart: i3, glyphs: [] }, a3 = { minX: s4.origin.x, minY: s4.origin.y, maxX: s4.origin.x + s4.size.width, maxY: s4.origin.y + s4.size.height }, n3.push(r2)), r2.glyphs.push({ x: s4.origin.x, y: s4.origin.y, width: s4.size.width, height: s4.size.height, flags: s4.isEmpty ? 2 : s4.isSpace ? 1 : 0 }), s4.isEmpty) continue;
            const F2 = s4.origin.x + s4.size.width, m3 = s4.origin.y + s4.size.height;
            a3.minX = Math.min(a3.minX, s4.origin.x), a3.minY = Math.min(a3.minY, s4.origin.y), a3.maxX = Math.max(a3.maxX, F2), a3.maxY = Math.max(a3.maxY, m3), r2.rect.x = a3.minX, r2.rect.y = a3.minY, r2.rect.width = a3.maxX - a3.minX, r2.rect.height = a3.maxY - a3.minY;
          }
          return n3;
        }
        readGlyphInfo(e3, t2, n3, r2) {
          const o3 = this.memoryManager.malloc(4), a3 = this.memoryManager.malloc(4), i3 = this.memoryManager.malloc(4), s4 = this.memoryManager.malloc(4), u4 = this.memoryManager.malloc(16);
          let F2 = 0, m3 = 0, l4 = 0, d4 = 0, _2 = false;
          if (this.pdfiumModule.FPDFText_GetLooseCharBox(n3, r2, u4)) {
            const c4 = this.pdfiumModule.pdfium.getValue(u4, "float"), P2 = this.pdfiumModule.pdfium.getValue(u4 + 4, "float"), g3 = this.pdfiumModule.pdfium.getValue(u4 + 8, "float"), h3 = this.pdfiumModule.pdfium.getValue(u4 + 12, "float");
            if (c4 === g3 || P2 === h3) return [u4, o3, a3, i3, s4].forEach((e4) => this.memoryManager.free(e4)), { origin: { x: 0, y: 0 }, size: { width: 0, height: 0 }, isEmpty: true };
            this.pdfiumModule.FPDF_PageToDevice(t2, 0, 0, e3.size.width, e3.size.height, 0, c4, P2, o3, a3), this.pdfiumModule.FPDF_PageToDevice(t2, 0, 0, e3.size.width, e3.size.height, 0, g3, h3, i3, s4);
            const D2 = this.pdfiumModule.pdfium.getValue(o3, "i32"), b2 = this.pdfiumModule.pdfium.getValue(a3, "i32"), f2 = this.pdfiumModule.pdfium.getValue(i3, "i32"), p4 = this.pdfiumModule.pdfium.getValue(s4, "i32");
            F2 = Math.min(D2, f2), m3 = Math.min(b2, p4), l4 = Math.max(1, Math.abs(f2 - D2)), d4 = Math.max(1, Math.abs(p4 - b2));
            _2 = 32 === this.pdfiumModule.FPDFText_GetUnicode(n3, r2);
          }
          return [u4, o3, a3, i3, s4].forEach((e4) => this.memoryManager.free(e4)), { origin: { x: F2, y: m3 }, size: { width: l4, height: d4 }, ..._2 && { isSpace: _2 } };
        }
        getPageGlyphs(e3, r2) {
          this.logger.debug(re, oe, "getPageGlyphs", e3, r2), this.logger.perf(re, oe, "getPageGlyphs", "Begin", e3.id);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return this.logger.perf(re, oe, "getPageGlyphs", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const a3 = o3.acquirePage(r2.index), i3 = a3.getTextPage(), s4 = this.pdfiumModule.FPDFText_CountChars(i3), u4 = new Array(s4);
          for (let e4 = 0; e4 < s4; e4++) {
            const t2 = this.readGlyphInfo(r2, a3.pagePtr, i3, e4);
            t2.isEmpty || (u4[e4] = { ...t2 });
          }
          return a3.release(), this.logger.perf(re, oe, "getPageGlyphs", "End", e3.id), Ut.resolve(u4);
        }
        readCharBox(e3, t2, n3, r2) {
          const o3 = this.memoryManager.malloc(8), a3 = this.memoryManager.malloc(8), i3 = this.memoryManager.malloc(8), s4 = this.memoryManager.malloc(8);
          let u4 = 0, F2 = 0, m3 = 0, l4 = 0;
          if (this.pdfiumModule.FPDFText_GetCharBox(n3, r2, a3, s4, i3, o3)) {
            const n4 = this.pdfiumModule.pdfium.getValue(o3, "double"), r3 = this.pdfiumModule.pdfium.getValue(a3, "double"), d4 = this.pdfiumModule.pdfium.getValue(i3, "double"), _2 = this.pdfiumModule.pdfium.getValue(s4, "double"), c4 = this.memoryManager.malloc(4), P2 = this.memoryManager.malloc(4);
            this.pdfiumModule.FPDF_PageToDevice(t2, 0, 0, e3.size.width, e3.size.height, 0, r3, n4, c4, P2), u4 = this.pdfiumModule.pdfium.getValue(c4, "i32"), F2 = this.pdfiumModule.pdfium.getValue(P2, "i32"), this.memoryManager.free(c4), this.memoryManager.free(P2), m3 = Math.ceil(Math.abs(_2 - r3)), l4 = Math.ceil(Math.abs(n4 - d4));
          }
          return this.memoryManager.free(o3), this.memoryManager.free(a3), this.memoryManager.free(i3), this.memoryManager.free(s4), { origin: { x: u4, y: F2 }, size: { width: m3, height: l4 } };
        }
        readPageAnnotations(e3, t2) {
          return e3.borrowPage(t2.index, (n3) => {
            const r2 = this.pdfiumModule.FPDFPage_GetAnnotCount(n3.pagePtr), o3 = [];
            for (let a3 = 0; a3 < r2; a3++) n3.withAnnotation(a3, (r3) => {
              const a4 = this.readPageAnnotation(e3.docPtr, t2, r3, n3);
              a4 && o3.push(a4);
            });
            return o3;
          });
        }
        readPageAnnotationsRaw(e3, t2) {
          const n3 = this.pdfiumModule.EPDFPage_GetAnnotCountRaw(e3.docPtr, t2.index);
          if (n3 <= 0) return [];
          const r2 = [];
          for (let o3 = 0; o3 < n3; ++o3) {
            const n4 = this.pdfiumModule.EPDFPage_GetAnnotRaw(e3.docPtr, t2.index, o3);
            if (n4) try {
              const o4 = this.readPageAnnotation(e3.docPtr, t2, n4);
              o4 && r2.push(o4);
            } finally {
              this.pdfiumModule.FPDFPage_CloseAnnot(n4);
            }
          }
          return r2;
        }
        getPageAnnotationsRaw(e3, r2) {
          this.logger.debug(re, oe, "getPageAnnotationsRaw", e3, r2), this.logger.perf(re, oe, "GetPageAnnotationsRaw", "Begin", `${e3.id}-${r2.index}`);
          const o3 = this.cache.getContext(e3.id);
          if (!o3) return Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const a3 = this.readPageAnnotationsRaw(o3, r2);
          return this.logger.perf(re, oe, "GetPageAnnotationsRaw", "End", `${e3.id}-${r2.index}`), this.logger.debug(re, oe, "getPageAnnotationsRaw", `${e3.id}-${r2.index}`, a3), Ut.resolve(a3);
        }
        readPageAnnotation(e3, t2, n3, r2) {
          let s4 = this.getAnnotString(n3, "NM");
          s4 && fn(s4) || (s4 = yn(), this.setAnnotString(n3, "NM", s4));
          const u4 = this.pdfiumModule.FPDFAnnot_GetSubtype(n3);
          let F2;
          switch (u4) {
            case Dt.TEXT:
              F2 = this.readPdfTextAnno(t2, n3, s4);
              break;
            case Dt.FREETEXT:
              F2 = this.readPdfFreeTextAnno(t2, n3, s4);
              break;
            case Dt.LINK:
              F2 = this.readPdfLinkAnno(t2, e3, n3, s4);
              break;
            case Dt.WIDGET:
              if (r2) return this.readPdfWidgetAnno(t2, n3, r2.getFormHandle(), s4);
            case Dt.FILEATTACHMENT:
              F2 = this.readPdfFileAttachmentAnno(t2, n3, s4);
              break;
            case Dt.INK:
              F2 = this.readPdfInkAnno(t2, n3, s4);
              break;
            case Dt.POLYGON:
              F2 = this.readPdfPolygonAnno(t2, n3, s4);
              break;
            case Dt.POLYLINE:
              F2 = this.readPdfPolylineAnno(t2, n3, s4);
              break;
            case Dt.LINE:
              F2 = this.readPdfLineAnno(t2, n3, s4);
              break;
            case Dt.HIGHLIGHT:
              F2 = this.readPdfHighlightAnno(t2, n3, s4);
              break;
            case Dt.STAMP:
              F2 = this.readPdfStampAnno(t2, n3, s4);
              break;
            case Dt.SQUARE:
              F2 = this.readPdfSquareAnno(t2, n3, s4);
              break;
            case Dt.CIRCLE:
              F2 = this.readPdfCircleAnno(t2, n3, s4);
              break;
            case Dt.UNDERLINE:
              F2 = this.readPdfUnderlineAnno(t2, n3, s4);
              break;
            case Dt.SQUIGGLY:
              F2 = this.readPdfSquigglyAnno(t2, n3, s4);
              break;
            case Dt.STRIKEOUT:
              F2 = this.readPdfStrikeOutAnno(t2, n3, s4);
              break;
            case Dt.CARET:
              F2 = this.readPdfCaretAnno(t2, n3, s4);
              break;
            default:
              F2 = this.readPdfAnno(t2, u4, n3, s4);
          }
          return F2;
        }
        readAnnotationColor(e3, t2 = zt.Color) {
          const n3 = this.memoryManager.malloc(4), r2 = this.memoryManager.malloc(4), o3 = this.memoryManager.malloc(4);
          let a3;
          return this.pdfiumModule.EPDFAnnot_GetColor(e3, t2, n3, r2, o3) && (a3 = { red: 255 & this.pdfiumModule.pdfium.getValue(n3, "i32"), green: 255 & this.pdfiumModule.pdfium.getValue(r2, "i32"), blue: 255 & this.pdfiumModule.pdfium.getValue(o3, "i32") }), this.memoryManager.free(n3), this.memoryManager.free(r2), this.memoryManager.free(o3), a3;
        }
        getAnnotationColor(e3, t2 = zt.Color) {
          const n3 = this.readAnnotationColor(e3, t2);
          return n3 ? Wt(n3) : void 0;
        }
        setAnnotationColor(e3, t2, n3 = zt.Color) {
          const r2 = Bt(t2);
          return this.pdfiumModule.EPDFAnnot_SetColor(e3, n3, 255 & r2.red, 255 & r2.green, 255 & r2.blue);
        }
        getAnnotationOpacity(e3) {
          const t2 = this.memoryManager.malloc(4), n3 = this.pdfiumModule.EPDFAnnot_GetOpacity(e3, t2) ? this.pdfiumModule.pdfium.getValue(t2, "i32") : 255;
          return this.memoryManager.free(t2), qt(n3);
        }
        setAnnotationOpacity(e3, t2) {
          const n3 = Gt(t2);
          return this.pdfiumModule.EPDFAnnot_SetOpacity(e3, 255 & n3);
        }
        getAnnotationTextAlignment(e3) {
          return this.pdfiumModule.EPDFAnnot_GetTextAlignment(e3);
        }
        setAnnotationTextAlignment(e3, t2) {
          return !!this.pdfiumModule.EPDFAnnot_SetTextAlignment(e3, t2);
        }
        getAnnotationVerticalAlignment(e3) {
          return this.pdfiumModule.EPDFAnnot_GetVerticalAlignment(e3);
        }
        setAnnotationVerticalAlignment(e3, t2) {
          return !!this.pdfiumModule.EPDFAnnot_SetVerticalAlignment(e3, t2);
        }
        getAnnotationDefaultAppearance(e3) {
          const t2 = this.memoryManager.malloc(4), n3 = this.memoryManager.malloc(4), r2 = this.memoryManager.malloc(4), o3 = this.memoryManager.malloc(4), a3 = this.memoryManager.malloc(4);
          if (!!!this.pdfiumModule.EPDFAnnot_GetDefaultAppearance(e3, t2, n3, r2, o3, a3)) return void [t2, n3, r2, o3, a3].forEach((e4) => this.memoryManager.free(e4));
          const i3 = this.pdfiumModule.pdfium, s4 = i3.getValue(t2, "i32"), u4 = i3.getValue(n3, "float"), F2 = 255 & i3.getValue(r2, "i32"), m3 = 255 & i3.getValue(o3, "i32"), l4 = 255 & i3.getValue(a3, "i32");
          return [t2, n3, r2, o3, a3].forEach((e4) => this.memoryManager.free(e4)), { fontFamily: s4, fontSize: u4, fontColor: Wt({ red: F2, green: m3, blue: l4 }) };
        }
        setAnnotationDefaultAppearance(e3, t2, n3, r2) {
          const { red: o3, green: a3, blue: i3 } = Bt(r2);
          return !!this.pdfiumModule.EPDFAnnot_SetDefaultAppearance(e3, t2, n3, 255 & o3, 255 & a3, 255 & i3);
        }
        getBorderStyle(e3) {
          const t2 = this.memoryManager.malloc(4);
          let n3 = 0, r2 = Et.UNKNOWN, o3 = false;
          return r2 = this.pdfiumModule.EPDFAnnot_GetBorderStyle(e3, t2), n3 = this.pdfiumModule.pdfium.getValue(t2, "float"), o3 = r2 !== Et.UNKNOWN, this.memoryManager.free(t2), { ok: o3, style: r2, width: n3 };
        }
        setBorderStyle(e3, t2, n3) {
          return this.pdfiumModule.EPDFAnnot_SetBorderStyle(e3, t2, n3);
        }
        getAnnotationIcon(e3) {
          return this.pdfiumModule.EPDFAnnot_GetIcon(e3);
        }
        setAnnotationIcon(e3, t2) {
          return this.pdfiumModule.EPDFAnnot_SetIcon(e3, t2);
        }
        getBorderEffect(e3) {
          const t2 = this.memoryManager.malloc(4), n3 = !!this.pdfiumModule.EPDFAnnot_GetBorderEffect(e3, t2), r2 = n3 ? this.pdfiumModule.pdfium.getValue(t2, "float") : 0;
          return this.memoryManager.free(t2), { ok: n3, intensity: r2 };
        }
        getRectangleDifferences(e3) {
          const t2 = this.memoryManager.malloc(4), n3 = this.memoryManager.malloc(4), r2 = this.memoryManager.malloc(4), o3 = this.memoryManager.malloc(4), a3 = !!this.pdfiumModule.EPDFAnnot_GetRectangleDifferences(e3, t2, n3, r2, o3), i3 = this.pdfiumModule.pdfium, s4 = i3.getValue(t2, "float"), u4 = i3.getValue(n3, "float"), F2 = i3.getValue(r2, "float"), m3 = i3.getValue(o3, "float");
          return this.memoryManager.free(t2), this.memoryManager.free(n3), this.memoryManager.free(r2), this.memoryManager.free(o3), { ok: a3, left: s4, top: u4, right: F2, bottom: m3 };
        }
        getAnnotationDate(e3, t2) {
          const n3 = this.getAnnotString(e3, t2);
          return n3 ? Vt(n3) : void 0;
        }
        setAnnotationDate(e3, t2, n3) {
          const r2 = Zt(n3);
          return this.setAnnotString(e3, t2, r2);
        }
        getAttachmentDate(e3, t2) {
          const n3 = this.getAttachmentString(e3, t2);
          return n3 ? Vt(n3) : void 0;
        }
        setAttachmentDate(e3, t2, n3) {
          const r2 = Zt(n3);
          return this.setAttachmentString(e3, t2, r2);
        }
        getBorderDashPattern(e3) {
          const t2 = this.pdfiumModule.EPDFAnnot_GetBorderDashPatternCount(e3);
          if (0 === t2) return { ok: false, pattern: [] };
          const n3 = this.memoryManager.malloc(4 * t2), r2 = !!this.pdfiumModule.EPDFAnnot_GetBorderDashPattern(e3, n3, t2), o3 = [];
          if (r2) {
            const e4 = this.pdfiumModule.pdfium;
            for (let r3 = 0; r3 < t2; r3++) o3.push(e4.getValue(n3 + 4 * r3, "float"));
          }
          return this.memoryManager.free(n3), { ok: r2, pattern: o3 };
        }
        setBorderDashPattern(e3, t2) {
          if (!t2 || 0 === t2.length) return this.pdfiumModule.EPDFAnnot_SetBorderDashPattern(e3, 0, 0);
          const n3 = t2.map((e4) => Number.isFinite(e4) && e4 > 0 ? e4 : 0).filter((e4) => e4 > 0);
          if (0 === n3.length) return this.pdfiumModule.EPDFAnnot_SetBorderDashPattern(e3, 0, 0);
          const r2 = 4 * n3.length, o3 = this.memoryManager.malloc(r2);
          for (let e4 = 0; e4 < n3.length; e4++) this.pdfiumModule.pdfium.setValue(o3 + 4 * e4, n3[e4], "float");
          const a3 = !!this.pdfiumModule.EPDFAnnot_SetBorderDashPattern(e3, o3, n3.length);
          return this.memoryManager.free(o3), a3;
        }
        getLineEndings(e3) {
          const t2 = this.memoryManager.malloc(4), n3 = this.memoryManager.malloc(4);
          if (!!!this.pdfiumModule.EPDFAnnot_GetLineEndings(e3, t2, n3)) return this.memoryManager.free(t2), void this.memoryManager.free(n3);
          const r2 = this.pdfiumModule.pdfium.getValue(t2, "i32"), o3 = this.pdfiumModule.pdfium.getValue(n3, "i32");
          return this.memoryManager.free(t2), this.memoryManager.free(n3), { start: r2, end: o3 };
        }
        setLineEndings(e3, t2, n3) {
          return !!this.pdfiumModule.EPDFAnnot_SetLineEndings(e3, t2, n3);
        }
        getLinePoints(e3, t2) {
          const n3 = this.memoryManager.malloc(8), r2 = this.memoryManager.malloc(8);
          if (!this.pdfiumModule.FPDFAnnot_GetLine(t2, n3, r2)) return this.memoryManager.free(n3), void this.memoryManager.free(r2);
          const o3 = this.pdfiumModule.pdfium, a3 = o3.getValue(n3 + 0, "float"), i3 = o3.getValue(n3 + 4, "float"), s4 = o3.getValue(r2 + 0, "float"), u4 = o3.getValue(r2 + 4, "float");
          this.memoryManager.free(n3), this.memoryManager.free(r2);
          return { start: this.convertPagePointToDevicePoint(e3, { x: a3, y: i3 }), end: this.convertPagePointToDevicePoint(e3, { x: s4, y: u4 }) };
        }
        setLinePoints(e3, t2, n3, r2) {
          const o3 = this.convertDevicePointToPagePoint(e3, n3), a3 = this.convertDevicePointToPagePoint(e3, r2);
          if (!o3 || !a3) return false;
          const i3 = this.memoryManager.malloc(16), s4 = this.pdfiumModule.pdfium;
          s4.setValue(i3 + 0, o3.x, "float"), s4.setValue(i3 + 4, o3.y, "float"), s4.setValue(i3 + 8, a3.x, "float"), s4.setValue(i3 + 12, a3.y, "float");
          const u4 = this.pdfiumModule.EPDFAnnot_SetLine(t2, i3, i3 + 8);
          return this.memoryManager.free(i3), !!u4;
        }
        getQuadPointsAnno(e3, t2) {
          const n3 = this.pdfiumModule.FPDFAnnot_CountAttachmentPoints(t2);
          if (0 === n3) return [];
          const r2 = [];
          for (let o3 = 0; o3 < n3; o3++) {
            const n4 = this.memoryManager.malloc(32);
            if (this.pdfiumModule.FPDFAnnot_GetAttachmentPoints(t2, o3, n4)) {
              const t3 = [], o4 = [];
              for (let e4 = 0; e4 < 4; e4++) {
                const r3 = n4 + 8 * e4;
                t3.push(this.pdfiumModule.pdfium.getValue(r3, "float")), o4.push(this.pdfiumModule.pdfium.getValue(r3 + 4, "float"));
              }
              const a3 = this.convertPagePointToDevicePoint(e3, { x: t3[0], y: o4[0] }), i3 = this.convertPagePointToDevicePoint(e3, { x: t3[1], y: o4[1] }), s4 = this.convertPagePointToDevicePoint(e3, { x: t3[2], y: o4[2] }), u4 = this.convertPagePointToDevicePoint(e3, { x: t3[3], y: o4[3] });
              r2.push({ p1: a3, p2: i3, p3: s4, p4: u4 });
            }
            this.memoryManager.free(n4);
          }
          return r2.map(Ke);
        }
        syncQuadPointsAnno(e3, t2, n3) {
          const r2 = this.pdfiumModule.pdfium, o3 = this.pdfiumModule.FPDFAnnot_CountAttachmentPoints(t2), a3 = this.memoryManager.malloc(32), i3 = (t3) => {
            const n4 = Ye(t3), o4 = this.convertDevicePointToPagePoint(e3, n4.p1), i4 = this.convertDevicePointToPagePoint(e3, n4.p2), s5 = this.convertDevicePointToPagePoint(e3, n4.p3), u4 = this.convertDevicePointToPagePoint(e3, n4.p4);
            r2.setValue(a3 + 0, o4.x, "float"), r2.setValue(a3 + 4, o4.y, "float"), r2.setValue(a3 + 8, i4.x, "float"), r2.setValue(a3 + 12, i4.y, "float"), r2.setValue(a3 + 16, u4.x, "float"), r2.setValue(a3 + 20, u4.y, "float"), r2.setValue(a3 + 24, s5.x, "float"), r2.setValue(a3 + 28, s5.y, "float");
          }, s4 = Math.min(o3, n3.length);
          for (let e4 = 0; e4 < s4; e4++) if (i3(n3[e4]), !this.pdfiumModule.FPDFAnnot_SetAttachmentPoints(t2, e4, a3)) return this.memoryManager.free(a3), false;
          for (let e4 = o3; e4 < n3.length; e4++) if (i3(n3[e4]), !this.pdfiumModule.FPDFAnnot_AppendAttachmentPoints(t2, a3)) return this.memoryManager.free(a3), false;
          return this.memoryManager.free(a3), true;
        }
        redactTextInRects(e3, r2, o3, a3) {
          const { recurseForms: i3 = true, drawBlackBoxes: s4 = false } = a3 ?? {};
          this.logger.debug("PDFiumEngine", "Engine", "redactTextInQuads", e3.id, r2.index, o3.length);
          const u4 = "RedactTextInQuads";
          this.logger.perf("PDFiumEngine", "Engine", u4, "Begin", `${e3.id}-${r2.index}`);
          const F2 = this.cache.getContext(e3.id);
          if (!F2) return this.logger.perf("PDFiumEngine", "Engine", u4, "End", `${e3.id}-${r2.index}`), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const m3 = (o3 ?? []).filter((e4) => {
            var t2, n3, r3, o4;
            return e4 && Number.isFinite(null == (t2 = e4.origin) ? void 0 : t2.x) && Number.isFinite(null == (n3 = e4.origin) ? void 0 : n3.y) && Number.isFinite(null == (r3 = e4.size) ? void 0 : r3.width) && Number.isFinite(null == (o4 = e4.size) ? void 0 : o4.height) && e4.size.width > 0 && e4.size.height > 0;
          });
          if (0 === m3.length) return this.logger.perf("PDFiumEngine", "Engine", u4, "End", `${e3.id}-${r2.index}`), Ut.resolve(false);
          const l4 = F2.acquirePage(r2.index), { ptr: d4, count: _2 } = this.allocFSQuadsBufferFromRects(r2, m3);
          let c4 = false;
          try {
            c4 = !!this.pdfiumModule.EPDFText_RedactInQuads(l4.pagePtr, d4, _2, !!i3, !!s4);
          } finally {
            this.memoryManager.free(d4);
          }
          return c4 && (c4 = !!this.pdfiumModule.FPDFPage_GenerateContent(l4.pagePtr)), l4.disposeImmediate(), this.logger.perf("PDFiumEngine", "Engine", u4, "End", `${e3.id}-${r2.index}`), Ut.resolve(!!c4);
        }
        allocFSQuadsBufferFromRects(e3, t2) {
          const n3 = t2.length, r2 = this.memoryManager.malloc(32 * n3), o3 = this.pdfiumModule.pdfium;
          for (let a3 = 0; a3 < n3; a3++) {
            const n4 = t2[a3], i3 = Ye(n4), s4 = this.convertDevicePointToPagePoint(e3, i3.p1), u4 = this.convertDevicePointToPagePoint(e3, i3.p2), F2 = this.convertDevicePointToPagePoint(e3, i3.p3), m3 = this.convertDevicePointToPagePoint(e3, i3.p4), l4 = r2 + 32 * a3;
            o3.setValue(l4 + 0, s4.x, "float"), o3.setValue(l4 + 4, s4.y, "float"), o3.setValue(l4 + 8, u4.x, "float"), o3.setValue(l4 + 12, u4.y, "float"), o3.setValue(l4 + 16, m3.x, "float"), o3.setValue(l4 + 20, m3.y, "float"), o3.setValue(l4 + 24, F2.x, "float"), o3.setValue(l4 + 28, F2.y, "float");
          }
          return { ptr: r2, count: n3 };
        }
        getInkList(e3, t2) {
          const n3 = [], r2 = this.pdfiumModule.FPDFAnnot_GetInkListCount(t2);
          if (r2 <= 0) return n3;
          const o3 = this.pdfiumModule.pdfium;
          for (let a3 = 0; a3 < r2; a3++) {
            const r3 = [], i3 = this.pdfiumModule.FPDFAnnot_GetInkListPath(t2, a3, 0, 0);
            if (i3 > 0) {
              const n4 = this.memoryManager.malloc(8 * i3);
              this.pdfiumModule.FPDFAnnot_GetInkListPath(t2, a3, n4, i3);
              for (let t3 = 0; t3 < i3; t3++) {
                const a4 = n4 + 8 * t3, i4 = o3.getValue(a4 + 0, "float"), s4 = o3.getValue(a4 + 4, "float"), u4 = this.convertPagePointToDevicePoint(e3, { x: i4, y: s4 });
                r3.push({ x: u4.x, y: u4.y });
              }
              this.memoryManager.free(n4);
            }
            n3.push({ points: r3 });
          }
          return n3;
        }
        setInkList(e3, t2, n3) {
          const r2 = this.pdfiumModule.pdfium;
          for (const o3 of n3) {
            const n4 = o3.points.length;
            if (0 === n4) continue;
            const a3 = this.memoryManager.malloc(8 * n4);
            for (let t3 = 0; t3 < n4; t3++) {
              const n5 = o3.points[t3], i4 = this.convertDevicePointToPagePoint(e3, n5);
              r2.setValue(a3 + 8 * t3 + 0, i4.x, "float"), r2.setValue(a3 + 8 * t3 + 4, i4.y, "float");
            }
            const i3 = this.pdfiumModule.FPDFAnnot_AddInkStroke(t2, a3, n4);
            if (this.memoryManager.free(a3), -1 === i3) return false;
          }
          return true;
        }
        readPdfTextAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "T"), u4 = this.getAnnotationDate(t2, "M"), F2 = this.getAnnotationDate(t2, "CreationDate"), m3 = this.getAnnotString(t2, "Contents") || "", l4 = this.getAnnotString(t2, "State"), d4 = this.getAnnotString(t2, "StateModel"), _2 = this.getAnnotationColor(t2), c4 = this.getAnnotationOpacity(t2), P2 = this.getInReplyToId(t2), g3 = this.getAnnotationFlags(t2), h3 = this.getAnnotationIcon(t2);
          return { pageIndex: e3.index, custom: r2, id: n3, type: Dt.TEXT, flags: g3, contents: m3, color: _2 ?? "#FFFF00", opacity: c4, rect: a3, inReplyToId: P2, author: s4, modified: u4, created: F2, state: l4, stateModel: d4, icon: h3 };
        }
        readPdfFreeTextAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "Contents") || "", u4 = this.getAnnotString(t2, "T"), F2 = this.getAnnotationDate(t2, "M"), m3 = this.getAnnotationDate(t2, "CreationDate"), l4 = this.getAnnotString(t2, "DS"), d4 = this.getAnnotationDefaultAppearance(t2), _2 = this.getAnnotationColor(t2), c4 = this.getAnnotationTextAlignment(t2), P2 = this.getAnnotationVerticalAlignment(t2), g3 = this.getAnnotationOpacity(t2), h3 = this.getAnnotRichContent(t2), D2 = this.getAnnotationFlags(t2);
          return { pageIndex: e3.index, custom: r2, id: n3, type: Dt.FREETEXT, fontFamily: (null == d4 ? void 0 : d4.fontFamily) ?? wt.Unknown, fontSize: (null == d4 ? void 0 : d4.fontSize) ?? 12, fontColor: (null == d4 ? void 0 : d4.fontColor) ?? "#000000", verticalAlign: P2, backgroundColor: _2, flags: D2, opacity: g3, textAlign: c4, defaultStyle: l4, richContent: h3, contents: s4, author: u4, modified: F2, created: m3, rect: a3 };
        }
        readPdfLinkAnno(e3, t2, n3, r2) {
          const o3 = this.getAnnotCustom(n3), a3 = this.pdfiumModule.FPDFAnnot_GetLink(n3);
          if (!a3) return;
          const s4 = this.readPageAnnoRect(n3), u4 = this.convertPageRectToDeviceRect(e3, s4), F2 = this.getAnnotString(n3, "T"), m3 = this.getAnnotationDate(n3, "M"), l4 = this.getAnnotationDate(n3, "CreationDate"), d4 = this.getAnnotationFlags(n3), _2 = this.readPdfLinkAnnoTarget(t2, () => this.pdfiumModule.FPDFLink_GetAction(a3), () => this.pdfiumModule.FPDFLink_GetDest(t2, a3));
          return { pageIndex: e3.index, custom: o3, id: r2, type: Dt.LINK, flags: d4, target: _2, rect: u4, author: F2, modified: m3, created: l4 };
        }
        readPdfWidgetAnno(e3, t2, n3, r2) {
          const o3 = this.getAnnotCustom(t2), a3 = this.readPageAnnoRect(t2), s4 = this.convertPageRectToDeviceRect(e3, a3), u4 = this.getAnnotString(t2, "T"), F2 = this.getAnnotationDate(t2, "M"), m3 = this.getAnnotationDate(t2, "CreationDate"), l4 = this.getAnnotationFlags(t2), d4 = this.readPdfWidgetAnnoField(n3, t2);
          return { pageIndex: e3.index, custom: o3, id: r2, type: Dt.WIDGET, flags: l4, rect: s4, field: d4, author: u4, modified: F2, created: m3 };
        }
        readPdfFileAttachmentAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "T"), u4 = this.getAnnotationDate(t2, "M"), F2 = this.getAnnotationDate(t2, "CreationDate"), m3 = this.getAnnotationFlags(t2);
          return { pageIndex: e3.index, custom: r2, id: n3, type: Dt.FILEATTACHMENT, flags: m3, rect: a3, author: s4, modified: u4, created: F2 };
        }
        readPdfInkAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "T"), u4 = this.getAnnotationDate(t2, "M"), F2 = this.getAnnotationDate(t2, "CreationDate"), m3 = this.getAnnotationColor(t2), l4 = this.getAnnotationOpacity(t2), { width: d4 } = this.getBorderStyle(t2), _2 = this.getInkList(e3, t2), c4 = this.pdfiumModule.EPDFAnnot_GetBlendMode(t2), P2 = this.getAnnotIntent(t2), g3 = this.getAnnotationFlags(t2), h3 = this.getAnnotString(t2, "Contents") || "";
          return { pageIndex: e3.index, custom: r2, id: n3, type: Dt.INK, ...P2 && { intent: P2 }, contents: h3, blendMode: c4, flags: g3, color: m3 ?? "#FF0000", opacity: l4, strokeWidth: 0 === d4 ? 1 : d4, rect: a3, inkList: _2, author: s4, modified: u4, created: F2 };
        }
        readPdfPolygonAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "T"), u4 = this.getAnnotationDate(t2, "M"), F2 = this.getAnnotationDate(t2, "CreationDate"), d4 = this.readPdfAnnoVertices(e3, t2), _2 = this.getAnnotString(t2, "Contents") || "", c4 = this.getAnnotationFlags(t2), P2 = this.getAnnotationColor(t2), g3 = this.getAnnotationColor(t2, zt.InteriorColor), h3 = this.getAnnotationOpacity(t2);
          let D2, { style: b2, width: f2 } = this.getBorderStyle(t2);
          if (b2 === Et.DASHED) {
            const { ok: e4, pattern: n4 } = this.getBorderDashPattern(t2);
            e4 && (D2 = n4);
          }
          if (d4.length > 1) {
            const e4 = d4[0], t3 = d4[d4.length - 1];
            e4.x === t3.x && e4.y === t3.y && d4.pop();
          }
          return { pageIndex: e3.index, custom: r2, id: n3, type: Dt.POLYGON, contents: _2, flags: c4, strokeColor: P2 ?? "#FF0000", color: g3 ?? "transparent", opacity: h3, strokeWidth: 0 === f2 ? 1 : f2, strokeStyle: b2, strokeDashArray: D2, rect: a3, vertices: d4, author: s4, modified: u4, created: F2 };
        }
        readPdfPolylineAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "T"), u4 = this.getAnnotationDate(t2, "M"), F2 = this.getAnnotationDate(t2, "CreationDate"), d4 = this.readPdfAnnoVertices(e3, t2), _2 = this.getAnnotString(t2, "Contents") || "", c4 = this.getAnnotationColor(t2), P2 = this.getAnnotationFlags(t2), g3 = this.getAnnotationColor(t2, zt.InteriorColor), h3 = this.getAnnotationOpacity(t2);
          let D2, { style: b2, width: f2 } = this.getBorderStyle(t2);
          if (b2 === Et.DASHED) {
            const { ok: e4, pattern: n4 } = this.getBorderDashPattern(t2);
            e4 && (D2 = n4);
          }
          const p4 = this.getLineEndings(t2);
          return { pageIndex: e3.index, custom: r2, id: n3, type: Dt.POLYLINE, contents: _2, flags: P2, strokeColor: c4 ?? "#FF0000", color: g3 ?? "transparent", opacity: h3, strokeWidth: 0 === f2 ? 1 : f2, strokeStyle: b2, strokeDashArray: D2, lineEndings: p4, rect: a3, vertices: d4, author: s4, modified: u4, created: F2 };
        }
        readPdfLineAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "T"), u4 = this.getAnnotationDate(t2, "M"), F2 = this.getAnnotationDate(t2, "CreationDate"), _2 = this.getLinePoints(e3, t2), c4 = this.getLineEndings(t2), P2 = this.getAnnotString(t2, "Contents") || "", g3 = this.getAnnotationColor(t2), h3 = this.getAnnotationFlags(t2), D2 = this.getAnnotationColor(t2, zt.InteriorColor), b2 = this.getAnnotationOpacity(t2);
          let f2, { style: p4, width: A2 } = this.getBorderStyle(t2);
          if (p4 === Et.DASHED) {
            const { ok: e4, pattern: n4 } = this.getBorderDashPattern(t2);
            e4 && (f2 = n4);
          }
          return { pageIndex: e3.index, custom: r2, id: n3, type: Dt.LINE, flags: h3, rect: a3, contents: P2, strokeWidth: 0 === A2 ? 1 : A2, strokeStyle: p4, strokeDashArray: f2, strokeColor: g3 ?? "#FF0000", color: D2 ?? "transparent", opacity: b2, linePoints: _2 || { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } }, lineEndings: c4 || { start: At.None, end: At.None }, author: s4, modified: u4, created: F2 };
        }
        readPdfHighlightAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getQuadPointsAnno(e3, t2), u4 = this.getAnnotationColor(t2), F2 = this.getAnnotationOpacity(t2), m3 = this.pdfiumModule.EPDFAnnot_GetBlendMode(t2), l4 = this.getAnnotString(t2, "T"), d4 = this.getAnnotationDate(t2, "M"), _2 = this.getAnnotationDate(t2, "CreationDate"), c4 = this.getAnnotString(t2, "Contents") || "", P2 = this.getAnnotationFlags(t2);
          return { pageIndex: e3.index, custom: r2, id: n3, blendMode: m3, type: Dt.HIGHLIGHT, rect: a3, flags: P2, contents: c4, segmentRects: s4, color: u4 ?? "#FFFF00", opacity: F2, author: l4, modified: d4, created: _2 };
        }
        readPdfUnderlineAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "T"), u4 = this.getAnnotationDate(t2, "M"), F2 = this.getAnnotationDate(t2, "CreationDate"), m3 = this.getQuadPointsAnno(e3, t2), l4 = this.getAnnotString(t2, "Contents") || "", d4 = this.getAnnotationColor(t2), _2 = this.getAnnotationOpacity(t2), c4 = this.pdfiumModule.EPDFAnnot_GetBlendMode(t2), P2 = this.getAnnotationFlags(t2);
          return { pageIndex: e3.index, custom: r2, id: n3, blendMode: c4, type: Dt.UNDERLINE, rect: a3, flags: P2, contents: l4, segmentRects: m3, color: d4 ?? "#FF0000", opacity: _2, author: s4, modified: u4, created: F2 };
        }
        readPdfStrikeOutAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "T"), u4 = this.getAnnotationDate(t2, "M"), F2 = this.getAnnotationDate(t2, "CreationDate"), m3 = this.getQuadPointsAnno(e3, t2), l4 = this.getAnnotString(t2, "Contents") || "", d4 = this.getAnnotationColor(t2), _2 = this.getAnnotationOpacity(t2), c4 = this.pdfiumModule.EPDFAnnot_GetBlendMode(t2), P2 = this.getAnnotationFlags(t2);
          return { pageIndex: e3.index, custom: r2, id: n3, blendMode: c4, type: Dt.STRIKEOUT, flags: P2, rect: a3, contents: l4, segmentRects: m3, color: d4 ?? "#FF0000", opacity: _2, author: s4, modified: u4, created: F2 };
        }
        readPdfSquigglyAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "T"), u4 = this.getAnnotationDate(t2, "M"), F2 = this.getAnnotationDate(t2, "CreationDate"), m3 = this.getQuadPointsAnno(e3, t2), l4 = this.getAnnotString(t2, "Contents") || "", d4 = this.getAnnotationColor(t2), _2 = this.getAnnotationOpacity(t2), c4 = this.pdfiumModule.EPDFAnnot_GetBlendMode(t2), P2 = this.getAnnotationFlags(t2);
          return { pageIndex: e3.index, custom: r2, id: n3, blendMode: c4, type: Dt.SQUIGGLY, rect: a3, flags: P2, contents: l4, segmentRects: m3, color: d4 ?? "#FF0000", opacity: _2, author: s4, modified: u4, created: F2 };
        }
        readPdfCaretAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "T"), u4 = this.getAnnotationDate(t2, "M"), F2 = this.getAnnotationDate(t2, "CreationDate"), m3 = this.getAnnotationFlags(t2);
          return { pageIndex: e3.index, custom: r2, id: n3, type: Dt.CARET, rect: a3, flags: m3, author: s4, modified: u4, created: F2 };
        }
        readPdfStampAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.readPageAnnoRect(t2), a3 = this.convertPageRectToDeviceRect(e3, o3), s4 = this.getAnnotString(t2, "T"), u4 = this.getAnnotationDate(t2, "M"), F2 = this.getAnnotationDate(t2, "CreationDate"), m3 = this.getAnnotationFlags(t2), l4 = this.getAnnotString(t2, "Contents") || "";
          return { pageIndex: e3.index, custom: r2, id: n3, type: Dt.STAMP, contents: l4, rect: a3, author: s4, modified: u4, created: F2, flags: m3 };
        }
        readPdfPageObject(e3) {
          switch (this.pdfiumModule.FPDFPageObj_GetType(e3)) {
            case _t.PATH:
              return this.readPathObject(e3);
            case _t.IMAGE:
              return this.readImageObject(e3);
            case _t.FORM:
              return this.readFormObject(e3);
          }
        }
        readPathObject(e3) {
          const t2 = this.pdfiumModule.FPDFPath_CountSegments(e3), n3 = this.memoryManager.malloc(4), r2 = this.memoryManager.malloc(4), o3 = this.memoryManager.malloc(4), a3 = this.memoryManager.malloc(4);
          this.pdfiumModule.FPDFPageObj_GetBounds(e3, n3, r2, o3, a3);
          const i3 = { left: this.pdfiumModule.pdfium.getValue(n3, "float"), bottom: this.pdfiumModule.pdfium.getValue(r2, "float"), right: this.pdfiumModule.pdfium.getValue(o3, "float"), top: this.pdfiumModule.pdfium.getValue(a3, "float") };
          this.memoryManager.free(n3), this.memoryManager.free(r2), this.memoryManager.free(o3), this.memoryManager.free(a3);
          const s4 = [];
          for (let n4 = 0; n4 < t2; n4++) {
            const t3 = this.readPdfSegment(e3, n4);
            s4.push(t3);
          }
          const u4 = this.readPdfPageObjectTransformMatrix(e3);
          return { type: _t.PATH, bounds: i3, segments: s4, matrix: u4 };
        }
        readPdfSegment(e3, t2) {
          const n3 = this.pdfiumModule.FPDFPath_GetPathSegment(e3, t2), r2 = this.pdfiumModule.FPDFPathSegment_GetType(n3), o3 = this.pdfiumModule.FPDFPathSegment_GetClose(n3), a3 = this.memoryManager.malloc(4), i3 = this.memoryManager.malloc(4);
          this.pdfiumModule.FPDFPathSegment_GetPoint(n3, a3, i3);
          const s4 = this.pdfiumModule.pdfium.getValue(a3, "float"), u4 = this.pdfiumModule.pdfium.getValue(i3, "float");
          return this.memoryManager.free(a3), this.memoryManager.free(i3), { type: r2, point: { x: s4, y: u4 }, isClosed: o3 };
        }
        readImageObject(e3) {
          const t2 = this.pdfiumModule.FPDFImageObj_GetBitmap(e3), n3 = this.pdfiumModule.FPDFBitmap_GetBuffer(t2), r2 = this.pdfiumModule.FPDFBitmap_GetWidth(t2), o3 = this.pdfiumModule.FPDFBitmap_GetHeight(t2), a3 = this.pdfiumModule.FPDFBitmap_GetFormat(t2), i3 = r2 * o3, s4 = new Uint8ClampedArray(4 * i3);
          for (let e4 = 0; e4 < i3; e4++) if (2 === a3) {
            const t3 = this.pdfiumModule.pdfium.getValue(n3 + 3 * e4, "i8"), r3 = this.pdfiumModule.pdfium.getValue(n3 + 3 * e4 + 1, "i8"), o4 = this.pdfiumModule.pdfium.getValue(n3 + 3 * e4 + 2, "i8");
            s4[4 * e4] = o4, s4[4 * e4 + 1] = r3, s4[4 * e4 + 2] = t3, s4[4 * e4 + 3] = 100;
          }
          const u4 = { data: s4, width: r2, height: o3 }, F2 = this.readPdfPageObjectTransformMatrix(e3);
          return { type: _t.IMAGE, imageData: u4, matrix: F2 };
        }
        readFormObject(e3) {
          const t2 = this.pdfiumModule.FPDFFormObj_CountObjects(e3), n3 = [];
          for (let r3 = 0; r3 < t2; r3++) {
            const t3 = this.pdfiumModule.FPDFFormObj_GetObject(e3, r3), o3 = this.readPdfPageObject(t3);
            o3 && n3.push(o3);
          }
          const r2 = this.readPdfPageObjectTransformMatrix(e3);
          return { type: _t.FORM, objects: n3, matrix: r2 };
        }
        readPdfPageObjectTransformMatrix(e3) {
          const t2 = this.memoryManager.malloc(24);
          if (this.pdfiumModule.FPDFPageObj_GetMatrix(e3, t2)) {
            const e4 = this.pdfiumModule.pdfium.getValue(t2, "float"), n3 = this.pdfiumModule.pdfium.getValue(t2 + 4, "float"), r2 = this.pdfiumModule.pdfium.getValue(t2 + 8, "float"), o3 = this.pdfiumModule.pdfium.getValue(t2 + 12, "float"), a3 = this.pdfiumModule.pdfium.getValue(t2 + 16, "float"), i3 = this.pdfiumModule.pdfium.getValue(t2 + 20, "float");
            return this.memoryManager.free(t2), { a: e4, b: n3, c: r2, d: o3, e: a3, f: i3 };
          }
          return this.memoryManager.free(t2), { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
        }
        readStampAnnotationContents(e3) {
          const t2 = [], n3 = this.pdfiumModule.FPDFAnnot_GetObjectCount(e3);
          for (let r2 = 0; r2 < n3; r2++) {
            const n4 = this.pdfiumModule.FPDFAnnot_GetObject(e3, r2), o3 = this.readPdfPageObject(n4);
            o3 && t2.push(o3);
          }
          return t2;
        }
        getStrokeWidth(e3) {
          const t2 = this.memoryManager.malloc(4), n3 = this.memoryManager.malloc(4), r2 = this.memoryManager.malloc(4), o3 = this.pdfiumModule.FPDFAnnot_GetBorder(e3, t2, n3, r2) ? this.pdfiumModule.pdfium.getValue(r2, "float") : 1;
          return this.memoryManager.free(t2), this.memoryManager.free(n3), this.memoryManager.free(r2), o3;
        }
        getAnnotationFlags(e3) {
          const t2 = this.pdfiumModule.FPDFAnnot_GetFlags(e3);
          return Ot(t2);
        }
        setAnnotationFlags(e3, t2) {
          const n3 = Lt(t2);
          return this.pdfiumModule.FPDFAnnot_SetFlags(e3, n3);
        }
        readPdfCircleAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.getAnnotationFlags(t2), a3 = this.readPageAnnoRect(t2), s4 = this.convertPageRectToDeviceRect(e3, a3), u4 = this.getAnnotString(t2, "T"), F2 = this.getAnnotationDate(t2, "M"), d4 = this.getAnnotationDate(t2, "CreationDate"), _2 = this.getAnnotString(t2, "Contents") || "", c4 = this.getAnnotationColor(t2, zt.InteriorColor), P2 = this.getAnnotationColor(t2), g3 = this.getAnnotationOpacity(t2);
          let h3, { style: D2, width: b2 } = this.getBorderStyle(t2);
          if (D2 === Et.DASHED) {
            const { ok: e4, pattern: n4 } = this.getBorderDashPattern(t2);
            e4 && (h3 = n4);
          }
          return { pageIndex: e3.index, custom: r2, id: n3, type: Dt.CIRCLE, flags: o3, color: c4 ?? "transparent", opacity: g3, contents: _2, strokeWidth: b2, strokeColor: P2 ?? "#FF0000", strokeStyle: D2, rect: s4, author: u4, modified: F2, created: d4, ...void 0 !== h3 && { strokeDashArray: h3 } };
        }
        readPdfSquareAnno(e3, t2, n3) {
          const r2 = this.getAnnotCustom(t2), o3 = this.getAnnotationFlags(t2), a3 = this.readPageAnnoRect(t2), s4 = this.convertPageRectToDeviceRect(e3, a3), u4 = this.getAnnotString(t2, "T"), F2 = this.getAnnotationDate(t2, "M"), d4 = this.getAnnotationDate(t2, "CreationDate"), _2 = this.getAnnotString(t2, "Contents") || "", c4 = this.getAnnotationColor(t2, zt.InteriorColor), P2 = this.getAnnotationColor(t2), g3 = this.getAnnotationOpacity(t2);
          let h3, { style: D2, width: b2 } = this.getBorderStyle(t2);
          if (D2 === Et.DASHED) {
            const { ok: e4, pattern: n4 } = this.getBorderDashPattern(t2);
            e4 && (h3 = n4);
          }
          return { pageIndex: e3.index, custom: r2, id: n3, type: Dt.SQUARE, flags: o3, color: c4 ?? "transparent", opacity: g3, contents: _2, strokeColor: P2 ?? "#FF0000", strokeWidth: b2, strokeStyle: D2, rect: s4, author: u4, modified: F2, created: d4, ...void 0 !== h3 && { strokeDashArray: h3 } };
        }
        readPdfAnno(e3, t2, n3, r2) {
          const o3 = this.getAnnotCustom(n3), a3 = this.readPageAnnoRect(n3), i3 = this.convertPageRectToDeviceRect(e3, a3), s4 = this.getAnnotString(n3, "T"), u4 = this.getAnnotationDate(n3, "M"), F2 = this.getAnnotationDate(n3, "CreationDate"), m3 = this.getAnnotationFlags(n3);
          return { pageIndex: e3.index, custom: o3, id: r2, flags: m3, type: t2, rect: i3, author: s4, modified: u4, created: F2 };
        }
        getInReplyToId(e3) {
          const t2 = this.pdfiumModule.FPDFAnnot_GetLinkedAnnot(e3, "IRT");
          if (t2) return this.getAnnotString(t2, "NM");
        }
        setInReplyToId(e3, t2, n3) {
          const r2 = this.getAnnotationByName(e3, n3);
          return !!r2 && this.pdfiumModule.EPDFAnnot_SetLinkedAnnot(t2, "IRT", r2);
        }
        getAnnotString(e3, t2) {
          const n3 = this.pdfiumModule.FPDFAnnot_GetStringValue(e3, t2, 0, 0);
          if (0 === n3) return;
          const r2 = 2 * (n3 + 1), o3 = this.memoryManager.malloc(r2);
          this.pdfiumModule.FPDFAnnot_GetStringValue(e3, t2, o3, r2);
          const a3 = this.pdfiumModule.pdfium.UTF16ToString(o3);
          return this.memoryManager.free(o3), a3 || void 0;
        }
        getAttachmentString(e3, t2) {
          const n3 = this.pdfiumModule.FPDFAttachment_GetStringValue(e3, t2, 0, 0);
          if (0 === n3) return;
          const r2 = 2 * (n3 + 1), o3 = this.memoryManager.malloc(r2);
          this.pdfiumModule.FPDFAttachment_GetStringValue(e3, t2, o3, r2);
          const a3 = this.pdfiumModule.pdfium.UTF16ToString(o3);
          return this.memoryManager.free(o3), a3 || void 0;
        }
        getAttachmentNumber(e3, t2) {
          const n3 = this.memoryManager.malloc(4);
          try {
            if (!this.pdfiumModule.EPDFAttachment_GetIntegerValue(e3, t2, n3)) return;
            return this.pdfiumModule.pdfium.getValue(n3, "i32") >>> 0;
          } finally {
            this.memoryManager.free(n3);
          }
        }
        getAnnotCustom(e3) {
          const t2 = this.getAnnotString(e3, "EPDFCustom");
          if (t2) try {
            return JSON.parse(t2);
          } catch (e4) {
            return console.warn("Failed to parse annotation custom data as JSON:", e4), void console.warn("Invalid JSON string:", t2);
          }
        }
        setAnnotCustom(e3, t2) {
          if (null == t2) return this.setAnnotString(e3, "EPDFCustom", "");
          try {
            const n3 = JSON.stringify(t2);
            return this.setAnnotString(e3, "EPDFCustom", n3);
          } catch (e4) {
            return console.warn("Failed to stringify annotation custom data as JSON:", e4), console.warn("Invalid data object:", t2), false;
          }
        }
        getAnnotIntent(e3) {
          const t2 = this.pdfiumModule.EPDFAnnot_GetIntent(e3, 0, 0);
          if (0 === t2) return;
          const n3 = 2 * (t2 + 1), r2 = this.memoryManager.malloc(n3);
          this.pdfiumModule.EPDFAnnot_GetIntent(e3, r2, n3);
          const o3 = this.pdfiumModule.pdfium.UTF16ToString(r2);
          return this.memoryManager.free(r2), o3 && "undefined" !== o3 ? o3 : void 0;
        }
        setAnnotIntent(e3, t2) {
          return this.pdfiumModule.EPDFAnnot_SetIntent(e3, t2);
        }
        getAnnotRichContent(e3) {
          const t2 = this.pdfiumModule.EPDFAnnot_GetRichContent(e3, 0, 0);
          if (0 === t2) return;
          const n3 = 2 * (t2 + 1), r2 = this.memoryManager.malloc(n3);
          this.pdfiumModule.EPDFAnnot_GetRichContent(e3, r2, n3);
          const o3 = this.pdfiumModule.pdfium.UTF16ToString(r2);
          return this.memoryManager.free(r2), o3 || void 0;
        }
        getAnnotationByName(e3, t2) {
          return this.withWString(t2, (t3) => this.pdfiumModule.EPDFPage_GetAnnotByName(e3, t3));
        }
        removeAnnotationByName(e3, t2) {
          return this.withWString(t2, (t3) => this.pdfiumModule.EPDFPage_RemoveAnnotByName(e3, t3));
        }
        setAnnotString(e3, t2, n3) {
          return this.withWString(n3, (n4) => this.pdfiumModule.FPDFAnnot_SetStringValue(e3, t2, n4));
        }
        setAttachmentString(e3, t2, n3) {
          return this.withWString(n3, (n4) => this.pdfiumModule.FPDFAttachment_SetStringValue(e3, t2, n4));
        }
        readPdfAnnoVertices(e3, t2) {
          const n3 = [], r2 = this.pdfiumModule.FPDFAnnot_GetVertices(t2, 0, 0), o3 = this.memoryManager.malloc(8 * r2);
          this.pdfiumModule.FPDFAnnot_GetVertices(t2, o3, r2);
          for (let t3 = 0; t3 < r2; t3++) {
            const r3 = this.pdfiumModule.pdfium.getValue(o3 + 8 * t3, "float"), a3 = this.pdfiumModule.pdfium.getValue(o3 + 8 * t3 + 4, "float"), { x: i3, y: s4 } = this.convertPagePointToDevicePoint(e3, { x: r3, y: a3 }), u4 = n3[n3.length - 1];
            u4 && u4.x === i3 && u4.y === s4 || n3.push({ x: i3, y: s4 });
          }
          return this.memoryManager.free(o3), n3;
        }
        setPdfAnnoVertices(e3, t2, n3) {
          const r2 = this.pdfiumModule.pdfium, o3 = this.memoryManager.malloc(8 * n3.length);
          n3.forEach((t3, n4) => {
            const a4 = this.convertDevicePointToPagePoint(e3, t3);
            r2.setValue(o3 + 8 * n4 + 0, a4.x, "float"), r2.setValue(o3 + 8 * n4 + 4, a4.y, "float");
          });
          const a3 = this.pdfiumModule.EPDFAnnot_SetVertices(t2, o3, n3.length);
          return this.memoryManager.free(o3), a3;
        }
        readPdfBookmarkTarget(e3, t2, n3) {
          const r2 = t2();
          if (r2) {
            return { type: "action", action: this.readPdfAction(e3, r2) };
          }
          {
            const t3 = n3();
            if (t3) {
              return { type: "destination", destination: this.readPdfDestination(e3, t3) };
            }
          }
        }
        readPdfWidgetAnnoField(e3, t2) {
          const n3 = this.pdfiumModule.FPDFAnnot_GetFormFieldFlags(e3, t2), r2 = this.pdfiumModule.FPDFAnnot_GetFormFieldType(e3, t2), o3 = V(this.pdfiumModule.pdfium, (n4, r3) => this.pdfiumModule.FPDFAnnot_GetFormFieldName(e3, t2, n4, r3), this.pdfiumModule.pdfium.UTF16ToString), a3 = V(this.pdfiumModule.pdfium, (n4, r3) => this.pdfiumModule.FPDFAnnot_GetFormFieldAlternateName(e3, t2, n4, r3), this.pdfiumModule.pdfium.UTF16ToString), i3 = V(this.pdfiumModule.pdfium, (n4, r3) => this.pdfiumModule.FPDFAnnot_GetFormFieldValue(e3, t2, n4, r3), this.pdfiumModule.pdfium.UTF16ToString), s4 = [];
          if (r2 === Tt.COMBOBOX || r2 === Tt.LISTBOX) {
            const n4 = this.pdfiumModule.FPDFAnnot_GetOptionCount(e3, t2);
            for (let r3 = 0; r3 < n4; r3++) {
              const n5 = V(this.pdfiumModule.pdfium, (n6, o5) => this.pdfiumModule.FPDFAnnot_GetOptionLabel(e3, t2, r3, n6, o5), this.pdfiumModule.pdfium.UTF16ToString), o4 = this.pdfiumModule.FPDFAnnot_IsOptionSelected(e3, t2, r3);
              s4.push({ label: n5, isSelected: o4 });
            }
          }
          let u4 = false;
          return r2 !== Tt.CHECKBOX && r2 !== Tt.RADIOBUTTON || (u4 = this.pdfiumModule.FPDFAnnot_IsChecked(e3, t2)), { flag: n3, type: r2, name: o3, alternateName: a3, value: i3, isChecked: u4, options: s4 };
        }
        renderPageAnnotationRaw(e3, r2, o3, a3) {
          const { scaleFactor: i3 = 1, rotation: s4 = We.Degree0, dpr: u4 = 1, mode: F2 = Mt.Normal } = a3 ?? {};
          this.logger.debug(re, oe, "renderPageAnnotation", e3, r2, o3, a3), this.logger.perf(re, oe, "RenderPageAnnotation", "Begin", `${e3.id}-${r2.index}-${o3.id}`);
          const m3 = new gt(), l4 = this.cache.getContext(e3.id);
          if (!l4) return this.logger.perf(re, oe, "RenderPageAnnotation", "End", `${e3.id}-${r2.index}-${o3.id}`), Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const d4 = l4.acquirePage(r2.index), _2 = this.getAnnotationByName(d4.pagePtr, o3.id);
          if (!_2) return this.logger.perf(re, oe, "RenderPageAnnotation", "End", `${e3.id}-${r2.index}-${o3.id}`), d4.release(), Ut.reject({ code: Ht.NotFound, message: "annotation not found" });
          const c4 = Math.max(0.01, i3 * u4), P2 = Ge(o3.rect), g3 = Ge(ot(r2.size, P2, s4, c4)), h3 = Math.max(1, g3.size.width), D2 = Math.max(1, g3.size.height), b2 = 4 * h3, f2 = b2 * D2, p4 = this.memoryManager.malloc(f2), A2 = this.pdfiumModule.FPDFBitmap_CreateEx(h3, D2, 4, p4, b2);
          this.pdfiumModule.FPDFBitmap_FillRect(A2, 0, 0, h3, D2, 0);
          const E2 = rt(P2, s4, h3, D2), M2 = this.memoryManager.malloc(24);
          new Float32Array(this.pdfiumModule.pdfium.HEAPF32.buffer, M2, 6).set([E2.a, E2.b, E2.c, E2.d, E2.e, E2.f]);
          let y2 = false;
          try {
            y2 = !!this.pdfiumModule.EPDF_RenderAnnotBitmap(A2, d4.pagePtr, _2, F2, M2, 16);
          } finally {
            this.memoryManager.free(M2), this.pdfiumModule.FPDFBitmap_Destroy(A2), this.pdfiumModule.FPDFPage_CloseAnnot(_2), d4.release();
          }
          if (!y2) return this.memoryManager.free(p4), this.logger.perf(re, oe, "RenderPageAnnotation", "End", `${e3.id}-${r2.index}-${o3.id}`), Ut.reject({ code: Ht.Unknown, message: "EPDF_RenderAnnotBitmap failed" });
          const O2 = this.pdfiumModule.pdfium.HEAPU8.subarray(p4, p4 + f2), k2 = { data: new Uint8ClampedArray(O2), width: h3, height: D2 };
          return m3.resolve(k2), this.memoryManager.free(p4), m3;
        }
        renderRectEncoded(e3, r2, o3, a3) {
          const i3 = new gt(), s4 = (null == a3 ? void 0 : a3.rotation) ?? We.Degree0, u4 = this.cache.getContext(e3.id);
          if (!u4) return Ut.reject({ code: Ht.DocNotOpen, message: "document does not open" });
          const F2 = Math.max(0.01, (null == a3 ? void 0 : a3.scaleFactor) ?? 1) * Math.max(1, (null == a3 ? void 0 : a3.dpr) ?? 1), m3 = o3.size.width, l4 = o3.size.height, d4 = !(1 & ~s4), _2 = Math.max(1, Math.round((d4 ? l4 : m3) * F2)), c4 = Math.max(1, Math.round((d4 ? m3 : l4) * F2)), P2 = 4 * _2, g3 = P2 * c4, h3 = u4.acquirePage(r2.index), D2 = (null == a3 ? void 0 : a3.withForms) ?? false ? h3.getFormHandle() : void 0, b2 = this.memoryManager.malloc(g3), f2 = this.pdfiumModule.FPDFBitmap_CreateEx(_2, c4, 4, b2, P2);
          this.pdfiumModule.FPDFBitmap_FillRect(f2, 0, 0, _2, c4, 4294967295);
          const p4 = rt(o3, s4, _2, c4), A2 = this.memoryManager.malloc(24);
          new Float32Array(this.pdfiumModule.pdfium.HEAPF32.buffer, A2, 6).set([p4.a, p4.b, p4.c, p4.d, p4.e, p4.f]);
          const E2 = this.memoryManager.malloc(16);
          new Float32Array(this.pdfiumModule.pdfium.HEAPF32.buffer, E2, 4).set([0, 0, _2, c4]);
          let M2 = 16;
          (null == a3 ? void 0 : a3.withAnnotations) && (M2 |= 1);
          try {
            if (this.pdfiumModule.FPDF_RenderPageBitmapWithMatrix(f2, h3.pagePtr, A2, E2, M2), void 0 !== D2) {
              const e4 = (function(e5, t3, n4, r3) {
                const o4 = t3.origin.x, a5 = t3.origin.y, i5 = o4 + t3.size.width, s5 = a5 + t3.size.height, u6 = n4.width, F4 = n4.height, m4 = Math.hypot(e5.a, e5.b), l5 = Math.hypot(e5.c, e5.d), d5 = !(1 & ~r3), _3 = d5 ? Math.max(1, Math.round(F4 * m4)) : Math.max(1, Math.round(u6 * m4)), c5 = d5 ? Math.max(1, Math.round(u6 * l5)) : Math.max(1, Math.round(F4 * l5));
                let P3, g4;
                switch (r3) {
                  case We.Degree0:
                    P3 = -Math.round(o4 * m4), g4 = -Math.round(a5 * l5);
                    break;
                  case We.Degree90:
                    P3 = Math.round((s5 - F4) * m4), g4 = -Math.round(o4 * l5);
                    break;
                  case We.Degree180:
                    P3 = Math.round((i5 - u6) * m4), g4 = Math.round((s5 - F4) * l5);
                    break;
                  case We.Degree270:
                    P3 = -Math.round(a5 * m4), g4 = Math.round((i5 - u6) * l5);
                    break;
                  default:
                    P3 = -Math.round(o4 * m4), g4 = -Math.round(a5 * l5);
                }
                return { startX: P3, startY: g4, formsWidth: _3, formsHeight: c5, scaleX: m4, scaleY: l5 };
              })(p4, o3, r2.size, s4), { startX: t2, startY: n3, formsWidth: a4, formsHeight: i4, scaleX: u5, scaleY: F3 } = e4;
              this.pdfiumModule.FPDF_FFLDraw(D2, f2, h3.pagePtr, t2, n3, a4, i4, s4, M2);
            }
          } finally {
            h3.release(), this.memoryManager.free(A2), this.memoryManager.free(E2);
          }
          this.logger.perf(re, oe, "RenderRectEncodedData", "Begin", `${e3.id}-${r2.index}`);
          const y2 = this.pdfiumModule.pdfium.HEAPU8.subarray(b2, b2 + g3);
          this.logger.perf(re, oe, "RenderRectEncodedData", "End", `${e3.id}-${r2.index}`), this.logger.perf(re, oe, "RenderRectEncodedImageData", "Begin", `${e3.id}-${r2.index}`);
          const G2 = { data: new Uint8ClampedArray(y2), width: _2, height: c4 };
          return this.logger.perf(re, oe, "RenderRectEncodedImageData", "End", `${e3.id}-${r2.index}`), i3.resolve(G2), this.pdfiumModule.FPDFBitmap_Destroy(f2), this.memoryManager.free(b2), i3;
        }
        readPdfLinkAnnoTarget(e3, t2, n3) {
          const r2 = n3();
          if (r2) {
            return { type: "destination", destination: this.readPdfDestination(e3, r2) };
          }
          {
            const n4 = t2();
            if (n4) {
              return { type: "action", action: this.readPdfAction(e3, n4) };
            }
          }
        }
        createLocalDestPtr(e3, t2) {
          var n3, r2;
          const o3 = this.pdfiumModule.FPDF_LoadPage(e3, t2.pageIndex);
          if (!o3) return 0;
          try {
            if (t2.zoom.mode === yt.XYZ) {
              const { x: e5, y: n4, zoom: r3 } = t2.zoom.params;
              return this.pdfiumModule.EPDFDest_CreateXYZ(o3, true, e5, true, n4, true, r3);
            }
            let e4, a3 = [];
            switch (t2.zoom.mode) {
              case yt.FitPage:
                e4 = yt.FitPage;
                break;
              case yt.FitHorizontal:
                e4 = yt.FitHorizontal, a3 = [(null == (n3 = t2.view) ? void 0 : n3[0]) ?? 0];
                break;
              case yt.FitVertical:
                e4 = yt.FitVertical, a3 = [(null == (r2 = t2.view) ? void 0 : r2[0]) ?? 0];
                break;
              case yt.FitRectangle:
                {
                  const n4 = t2.view ?? [];
                  a3 = [n4[0] ?? 0, n4[1] ?? 0, n4[2] ?? 0, n4[3] ?? 0], e4 = yt.FitRectangle;
                }
                break;
              case yt.Unknown:
              default:
                return 0;
            }
            return this.withFloatArray(a3, (t3, n4) => this.pdfiumModule.EPDFDest_CreateView(o3, e4, t3, n4));
          } finally {
            this.pdfiumModule.FPDF_ClosePage(o3);
          }
        }
        applyBookmarkTarget(e3, t2, n3) {
          if ("destination" === n3.type) {
            const r3 = this.createLocalDestPtr(e3, n3.destination);
            if (!r3) return false;
            return !!this.pdfiumModule.EPDFBookmark_SetDest(e3, t2, r3);
          }
          const r2 = n3.action;
          switch (r2.type) {
            case kt.Goto: {
              const n4 = this.createLocalDestPtr(e3, r2.destination);
              if (!n4) return false;
              const o3 = this.pdfiumModule.EPDFAction_CreateGoTo(e3, n4);
              return !!o3 && !!this.pdfiumModule.EPDFBookmark_SetAction(e3, t2, o3);
            }
            case kt.URI: {
              const n4 = this.pdfiumModule.EPDFAction_CreateURI(e3, r2.uri);
              return !!n4 && !!this.pdfiumModule.EPDFBookmark_SetAction(e3, t2, n4);
            }
            case kt.LaunchAppOrOpenFile: {
              const n4 = this.withWString(r2.path, (t3) => this.pdfiumModule.EPDFAction_CreateLaunch(e3, t3));
              return !!n4 && !!this.pdfiumModule.EPDFBookmark_SetAction(e3, t2, n4);
            }
            case kt.RemoteGoto:
            case kt.Unsupported:
            default:
              return false;
          }
        }
        readPdfAction(e3, t2) {
          let n3;
          switch (this.pdfiumModule.FPDFAction_GetType(t2)) {
            case kt.Unsupported:
              n3 = { type: kt.Unsupported };
              break;
            case kt.Goto:
              {
                const r2 = this.pdfiumModule.FPDFAction_GetDest(e3, t2);
                if (r2) {
                  const t3 = this.readPdfDestination(e3, r2);
                  n3 = { type: kt.Goto, destination: t3 };
                } else n3 = { type: kt.Unsupported };
              }
              break;
            case kt.RemoteGoto:
              n3 = { type: kt.Unsupported };
              break;
            case kt.URI:
              {
                const r2 = V(this.pdfiumModule.pdfium, (n4, r3) => this.pdfiumModule.FPDFAction_GetURIPath(e3, t2, n4, r3), this.pdfiumModule.pdfium.UTF8ToString);
                n3 = { type: kt.URI, uri: r2 };
              }
              break;
            case kt.LaunchAppOrOpenFile: {
              const e4 = V(this.pdfiumModule.pdfium, (e5, n4) => this.pdfiumModule.FPDFAction_GetFilePath(t2, e5, n4), this.pdfiumModule.pdfium.UTF8ToString);
              n3 = { type: kt.LaunchAppOrOpenFile, path: e4 };
            }
          }
          return n3;
        }
        readPdfDestination(e3, t2) {
          const n3 = this.pdfiumModule.FPDFDest_GetDestPageIndex(e3, t2), r2 = this.memoryManager.malloc(4), o3 = this.memoryManager.malloc(16), a3 = this.pdfiumModule.FPDFDest_GetView(t2, r2, o3), i3 = this.pdfiumModule.pdfium.getValue(r2, "i32"), s4 = [];
          for (let e4 = 0; e4 < i3; e4++) {
            const t3 = o3 + 4 * e4;
            s4.push(this.pdfiumModule.pdfium.getValue(t3, "float"));
          }
          if (this.memoryManager.free(r2), this.memoryManager.free(o3), a3 === yt.XYZ) {
            const e4 = this.memoryManager.malloc(1), r3 = this.memoryManager.malloc(1), o4 = this.memoryManager.malloc(1), i4 = this.memoryManager.malloc(4), u4 = this.memoryManager.malloc(4), F2 = this.memoryManager.malloc(4);
            if (this.pdfiumModule.FPDFDest_GetLocationInPage(t2, e4, r3, o4, i4, u4, F2)) {
              const t3 = this.pdfiumModule.pdfium.getValue(e4, "i8"), m3 = this.pdfiumModule.pdfium.getValue(r3, "i8"), l4 = this.pdfiumModule.pdfium.getValue(o4, "i8"), d4 = t3 ? this.pdfiumModule.pdfium.getValue(i4, "float") : 0, _2 = m3 ? this.pdfiumModule.pdfium.getValue(u4, "float") : 0, c4 = l4 ? this.pdfiumModule.pdfium.getValue(F2, "float") : 0;
              return this.memoryManager.free(e4), this.memoryManager.free(r3), this.memoryManager.free(o4), this.memoryManager.free(i4), this.memoryManager.free(u4), this.memoryManager.free(F2), { pageIndex: n3, zoom: { mode: a3, params: { x: d4, y: _2, zoom: c4 } }, view: s4 };
            }
            return this.memoryManager.free(e4), this.memoryManager.free(r3), this.memoryManager.free(o4), this.memoryManager.free(i4), this.memoryManager.free(u4), this.memoryManager.free(F2), { pageIndex: n3, zoom: { mode: a3, params: { x: 0, y: 0, zoom: 0 } }, view: s4 };
          }
          return { pageIndex: n3, zoom: { mode: a3 }, view: s4 };
        }
        readPdfAttachment(e3, t2) {
          const n3 = this.pdfiumModule.FPDFDoc_GetAttachment(e3, t2), r2 = V(this.pdfiumModule.pdfium, (e4, t3) => this.pdfiumModule.FPDFAttachment_GetName(n3, e4, t3), this.pdfiumModule.pdfium.UTF16ToString), o3 = V(this.pdfiumModule.pdfium, (e4, t3) => this.pdfiumModule.EPDFAttachment_GetDescription(n3, e4, t3), this.pdfiumModule.pdfium.UTF16ToString), a3 = V(this.pdfiumModule.pdfium, (e4, t3) => this.pdfiumModule.FPDFAttachment_GetSubtype(n3, e4, t3), this.pdfiumModule.pdfium.UTF16ToString), i3 = this.getAttachmentDate(n3, "CreationDate"), s4 = V(this.pdfiumModule.pdfium, (e4, t3) => this.pdfiumModule.FPDFAttachment_GetStringValue(n3, "Checksum", e4, t3), this.pdfiumModule.pdfium.UTF16ToString);
          return { index: t2, name: r2, description: o3, mimeType: a3, size: this.getAttachmentNumber(n3, "Size"), creationDate: i3, checksum: s4 };
        }
        convertDevicePointToPagePoint(e3, t2) {
          const n3 = e3.size.width, r2 = e3.size.height, o3 = 3 & e3.rotation;
          return 0 === o3 ? { x: t2.x, y: r2 - t2.y } : 1 === o3 ? { x: t2.y, y: t2.x } : 2 === o3 ? { x: n3 - t2.x, y: t2.y } : { x: r2 - t2.y, y: n3 - t2.x };
        }
        convertPagePointToDevicePoint(e3, t2) {
          const n3 = e3.size.width, r2 = e3.size.height, o3 = 3 & e3.rotation;
          return 0 === o3 ? { x: t2.x, y: r2 - t2.y } : 1 === o3 ? { x: t2.y, y: t2.x } : 2 === o3 ? { x: n3 - t2.x, y: t2.y } : { x: n3 - t2.y, y: r2 - t2.x };
        }
        convertPageRectToDeviceRect(e3, t2) {
          const { x: n3, y: r2 } = this.convertPagePointToDevicePoint(e3, { x: t2.left, y: t2.top });
          return { origin: { x: n3, y: r2 }, size: { width: Math.abs(t2.right - t2.left), height: Math.abs(t2.top - t2.bottom) } };
        }
        readPageAnnoAppearanceStreams(e3) {
          return { normal: this.readPageAnnoAppearanceStream(e3, Mt.Normal), rollover: this.readPageAnnoAppearanceStream(e3, Mt.Rollover), down: this.readPageAnnoAppearanceStream(e3, Mt.Down) };
        }
        readPageAnnoAppearanceStream(e3, t2 = Mt.Normal) {
          const n3 = 2 * (this.pdfiumModule.FPDFAnnot_GetAP(e3, t2, 0, 0) + 1), r2 = this.memoryManager.malloc(n3);
          this.pdfiumModule.FPDFAnnot_GetAP(e3, t2, r2, n3);
          const o3 = this.pdfiumModule.pdfium.UTF16ToString(r2);
          return this.memoryManager.free(r2), o3;
        }
        setPageAnnoAppearanceStream(e3, t2 = Mt.Normal, n3) {
          const r2 = 2 * (n3.length + 1), o3 = this.memoryManager.malloc(r2);
          try {
            this.pdfiumModule.pdfium.stringToUTF16(n3, o3, r2);
            return !!this.pdfiumModule.FPDFAnnot_SetAP(e3, t2, o3);
          } finally {
            this.memoryManager.free(o3);
          }
        }
        setPageAnnoRect(e3, t2, n3) {
          const r2 = Math.floor(n3.origin.x), o3 = Math.floor(n3.origin.y), a3 = Math.floor(n3.origin.x + n3.size.width), i3 = Math.floor(n3.origin.y + n3.size.height), s4 = this.convertDevicePointToPagePoint(e3, { x: r2, y: o3 }), u4 = this.convertDevicePointToPagePoint(e3, { x: a3, y: o3 }), F2 = this.convertDevicePointToPagePoint(e3, { x: a3, y: i3 }), m3 = this.convertDevicePointToPagePoint(e3, { x: r2, y: i3 });
          let l4 = Math.min(s4.x, u4.x, F2.x, m3.x), d4 = Math.max(s4.x, u4.x, F2.x, m3.x), _2 = Math.min(s4.y, u4.y, F2.y, m3.y), c4 = Math.max(s4.y, u4.y, F2.y, m3.y);
          l4 > d4 && ([l4, d4] = [d4, l4]), _2 > c4 && ([_2, c4] = [c4, _2]);
          const P2 = this.memoryManager.malloc(16), g3 = this.pdfiumModule.pdfium;
          g3.setValue(P2 + 0, l4, "float"), g3.setValue(P2 + 4, c4, "float"), g3.setValue(P2 + 8, d4, "float"), g3.setValue(P2 + 12, _2, "float");
          const h3 = this.pdfiumModule.FPDFAnnot_SetRect(t2, P2);
          return this.memoryManager.free(P2), !!h3;
        }
        readPageAnnoRect(e3) {
          const t2 = this.memoryManager.malloc(16), n3 = { left: 0, top: 0, right: 0, bottom: 0 };
          return this.pdfiumModule.FPDFAnnot_GetRect(e3, t2) && (n3.left = this.pdfiumModule.pdfium.getValue(t2, "float"), n3.top = this.pdfiumModule.pdfium.getValue(t2 + 4, "float"), n3.right = this.pdfiumModule.pdfium.getValue(t2 + 8, "float"), n3.bottom = this.pdfiumModule.pdfium.getValue(t2 + 12, "float")), this.memoryManager.free(t2), n3;
        }
        getHighlightRects(e3, t2, n3, r2) {
          const o3 = this.pdfiumModule.FPDFText_CountRects(t2, n3, r2), a3 = [], i3 = this.memoryManager.malloc(8), s4 = this.memoryManager.malloc(8), u4 = this.memoryManager.malloc(8), F2 = this.memoryManager.malloc(8);
          for (let n4 = 0; n4 < o3; n4++) {
            if (!this.pdfiumModule.FPDFText_GetRect(t2, n4, i3, s4, u4, F2)) continue;
            const r3 = this.pdfiumModule.pdfium.getValue(i3, "double"), o4 = this.pdfiumModule.pdfium.getValue(s4, "double"), m3 = this.pdfiumModule.pdfium.getValue(u4, "double"), l4 = this.pdfiumModule.pdfium.getValue(F2, "double"), d4 = this.convertPagePointToDevicePoint(e3, { x: r3, y: o4 }), _2 = this.convertPagePointToDevicePoint(e3, { x: m3, y: o4 }), c4 = this.convertPagePointToDevicePoint(e3, { x: m3, y: l4 }), P2 = this.convertPagePointToDevicePoint(e3, { x: r3, y: l4 }), g3 = [d4.x, _2.x, c4.x, P2.x], h3 = [d4.y, _2.y, c4.y, P2.y], D2 = Math.min(...g3), b2 = Math.min(...h3), f2 = Math.max(...g3) - D2, p4 = Math.max(...h3) - b2;
            a3.push({ origin: { x: D2, y: b2 }, size: { width: Math.ceil(f2), height: Math.ceil(p4) } });
          }
          return this.memoryManager.free(i3), this.memoryManager.free(s4), this.memoryManager.free(u4), this.memoryManager.free(F2), a3;
        }
        searchInPage(e3, r2, o3, a3) {
          this.logger.debug(re, oe, "searchInPage", e3, r2, o3, a3), this.logger.perf(re, oe, "SearchInPage", "Begin", `${e3.id}-${r2.index}`);
          const i3 = this.cache.getContext(e3.id);
          if (!i3) return this.logger.perf(re, oe, "PreparePrintDocument", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "Document is not open" });
          const s4 = 2 * (o3.length + 1), u4 = this.memoryManager.malloc(s4);
          this.pdfiumModule.pdfium.stringToUTF16(o3, u4, s4);
          try {
            const e4 = this.searchAllInPage(i3, r2, u4, a3);
            return Ut.resolve(e4);
          } finally {
            this.memoryManager.free(u4);
          }
        }
        getAnnotationsBatch(e3, t2) {
          this.logger.debug(re, oe, "getAnnotationsBatch", e3.id, t2.length);
          const r2 = new gt();
          return queueMicrotask(() => {
            this.logger.perf(re, oe, "GetAnnotationsBatch", "Begin", e3.id);
            const o3 = this.cache.getContext(e3.id);
            if (!o3) return void r2.reject({ code: Ht.DocNotOpen, message: "Document is not open" });
            const a3 = {}, i3 = t2.length;
            for (let e4 = 0; e4 < t2.length; e4++) {
              const n3 = t2[e4], s4 = this.readPageAnnotationsRaw(o3, n3);
              a3[n3.index] = s4, r2.progress({ pageIndex: n3.index, result: s4, completed: e4 + 1, total: i3 });
            }
            this.logger.perf(re, oe, "GetAnnotationsBatch", "End", e3.id), r2.resolve(a3);
          }), r2;
        }
        searchBatch(e3, t2, r2, o3) {
          this.logger.debug(re, oe, "searchBatch", e3.id, t2.length, r2);
          const a3 = new gt();
          return queueMicrotask(() => {
            this.logger.perf(re, oe, "SearchBatch", "Begin", e3.id);
            const i3 = this.cache.getContext(e3.id);
            if (!i3) return void a3.reject({ code: Ht.DocNotOpen, message: "Document is not open" });
            const s4 = 2 * (r2.length + 1), u4 = this.memoryManager.malloc(s4);
            this.pdfiumModule.pdfium.stringToUTF16(r2, u4, s4);
            try {
              const n3 = {}, r3 = t2.length;
              for (let e4 = 0; e4 < t2.length; e4++) {
                const s5 = t2[e4], F2 = this.searchAllInPage(i3, s5, u4, o3);
                n3[s5.index] = F2, a3.progress({ pageIndex: s5.index, result: F2, completed: e4 + 1, total: r3 });
              }
              this.logger.perf(re, oe, "SearchBatch", "End", e3.id), a3.resolve(n3);
            } finally {
              this.memoryManager.free(u4);
            }
          }), a3;
        }
        buildContext(e3, t2, n3, r2 = 30) {
          const o3 = /[\s\u00A0.,;:!?()\[\]{}<>/\\\-"'`"\u2013\u2014]/;
          let a3 = t2;
          for (; a3 > 0 && o3.test(e3[a3 - 1]); ) a3--;
          let i3 = 0;
          for (; a3 > 0 && i3 < r2; ) a3--, o3.test(e3[a3]) || i3++;
          a3 = ((t3) => {
            for (; t3 > 0 && !o3.test(e3[t3 - 1]); ) t3--;
            return t3;
          })(a3);
          let s4 = t2 + n3;
          for (; s4 < e3.length && o3.test(e3[s4]); ) s4++;
          for (i3 = 0; s4 < e3.length && i3 < r2; ) o3.test(e3[s4]) || i3++, s4++;
          s4 = ((t3) => {
            for (; t3 < e3.length && !o3.test(e3[t3]); ) t3++;
            return t3;
          })(s4);
          const u4 = e3.slice(a3, t2).replace(/\s+/g, " ").trimStart(), F2 = e3.slice(t2, t2 + n3), m3 = e3.slice(t2 + n3, s4).replace(/\s+/g, " ").trimEnd();
          return { before: this.tidy(u4), match: this.tidy(F2), after: this.tidy(m3), truncatedLeft: a3 > 0, truncatedRight: s4 < e3.length };
        }
        tidy(e3) {
          return e3.replace(/-\uFFFE\s*/g, "").replace(/[\uFFFE\u00AD\u200B\u2060\uFEFF]/g, "").replace(/\s+/g, " ");
        }
        searchAllInPage(e3, t2, n3, r2) {
          return e3.borrowPage(t2.index, (e4) => {
            const o3 = e4.getTextPage(), a3 = this.pdfiumModule.FPDFText_CountChars(o3), i3 = this.memoryManager.malloc(2 * (a3 + 1));
            this.pdfiumModule.FPDFText_GetText(o3, 0, a3, i3);
            const s4 = this.pdfiumModule.pdfium.UTF16ToString(i3);
            this.memoryManager.free(i3);
            const u4 = [], F2 = this.pdfiumModule.FPDFText_FindStart(o3, n3, r2, 0);
            for (; this.pdfiumModule.FPDFText_FindNext(F2); ) {
              const e5 = this.pdfiumModule.FPDFText_GetSchResultIndex(F2), n4 = this.pdfiumModule.FPDFText_GetSchCount(F2), r3 = this.getHighlightRects(t2, o3, e5, n4), a4 = this.buildContext(s4, e5, n4);
              u4.push({ pageIndex: t2.index, charIndex: e5, charCount: n4, rects: r3, context: a4 });
            }
            return this.pdfiumModule.FPDFText_FindClose(F2), u4;
          });
        }
        preparePrintDocument(e3, r2) {
          const { includeAnnotations: o3 = true, pageRange: a3 = null } = r2 ?? {};
          this.logger.debug(re, oe, "preparePrintDocument", e3, r2), this.logger.perf(re, oe, "PreparePrintDocument", "Begin", e3.id);
          const i3 = this.cache.getContext(e3.id);
          if (!i3) return this.logger.perf(re, oe, "PreparePrintDocument", "End", e3.id), Ut.reject({ code: Ht.DocNotOpen, message: "Document is not open" });
          const s4 = this.pdfiumModule.FPDF_CreateNewDocument();
          if (!s4) return this.logger.perf(re, oe, "PreparePrintDocument", "End", e3.id), Ut.reject({ code: Ht.CantCreateNewDoc, message: "Cannot create print document" });
          try {
            const r3 = this.sanitizePageRange(a3, e3.pageCount);
            if (!this.pdfiumModule.FPDF_ImportPages(s4, i3.docPtr, r3 ?? "", 0)) return this.pdfiumModule.FPDF_CloseDocument(s4), this.logger.error(re, oe, "Failed to import pages for printing"), this.logger.perf(re, oe, "PreparePrintDocument", "End", e3.id), Ut.reject({ code: Ht.CantImportPages, message: "Failed to import pages for printing" });
            if (!o3) {
              const r4 = this.removeAnnotationsFromPrintDocument(s4);
              if (!r4.success) return this.pdfiumModule.FPDF_CloseDocument(s4), this.logger.error(re, oe, `Failed to remove annotations: ${r4.error}`), this.logger.perf(re, oe, "PreparePrintDocument", "End", e3.id), Ut.reject({ code: Ht.Unknown, message: `Failed to prepare print document: ${r4.error}` });
              this.logger.debug(re, oe, `Removed ${r4.annotationsRemoved} annotations from ${r4.pagesProcessed} pages`);
            }
            const u4 = this.saveDocument(s4);
            return this.pdfiumModule.FPDF_CloseDocument(s4), this.logger.perf(re, oe, "PreparePrintDocument", "End", e3.id), Ut.resolve(u4);
          } catch (r3) {
            return s4 && this.pdfiumModule.FPDF_CloseDocument(s4), this.logger.error(re, oe, "preparePrintDocument failed", r3), this.logger.perf(re, oe, "PreparePrintDocument", "End", e3.id), Ut.reject({ code: Ht.Unknown, message: r3 instanceof Error ? r3.message : "Failed to prepare print document" });
          }
        }
        removeAnnotationsFromPrintDocument(e3) {
          let t2 = 0, n3 = 0;
          try {
            const r2 = this.pdfiumModule.FPDF_GetPageCount(e3);
            for (let o3 = 0; o3 < r2; o3++) {
              const r3 = this.pdfiumModule.EPDFPage_GetAnnotCountRaw(e3, o3);
              if (r3 <= 0) {
                n3++;
                continue;
              }
              let a3 = 0;
              for (let n4 = r3 - 1; n4 >= 0; n4--) {
                this.pdfiumModule.EPDFPage_RemoveAnnotRaw(e3, o3, n4) ? (a3++, t2++) : this.logger.warn(re, oe, `Failed to remove annotation ${n4} from page ${o3}`);
              }
              if (a3 > 0) {
                const t3 = this.pdfiumModule.FPDF_LoadPage(e3, o3);
                t3 && (this.pdfiumModule.FPDFPage_GenerateContent(t3), this.pdfiumModule.FPDF_ClosePage(t3));
              }
              n3++;
            }
            return { success: true, annotationsRemoved: t2, pagesProcessed: n3 };
          } catch (e4) {
            return { success: false, annotationsRemoved: t2, pagesProcessed: n3, error: e4 instanceof Error ? e4.message : "Unknown error during annotation removal" };
          }
        }
        sanitizePageRange(e3, t2) {
          if (!e3 || "" === e3.trim()) return null;
          try {
            const n3 = [], r2 = e3.split(",");
            for (const e4 of r2) {
              const r3 = e4.trim();
              if (r3.includes("-")) {
                const [e5, o4] = r3.split("-").map((e6) => e6.trim()), a4 = parseInt(e5, 10), i4 = parseInt(o4, 10);
                if (isNaN(a4) || isNaN(i4)) {
                  this.logger.warn(re, oe, `Invalid range: ${r3}`);
                  continue;
                }
                const s5 = Math.max(1, Math.min(a4, t2)), u4 = Math.max(1, Math.min(i4, t2));
                for (let e6 = s5; e6 <= u4; e6++) n3.includes(e6) || n3.push(e6);
              } else {
                const e5 = parseInt(r3, 10);
                if (isNaN(e5)) {
                  this.logger.warn(re, oe, `Invalid page number: ${r3}`);
                  continue;
                }
                const o4 = Math.max(1, Math.min(e5, t2));
                n3.includes(o4) || n3.push(o4);
              }
            }
            if (0 === n3.length) return this.logger.warn(re, oe, "No valid pages in range, using all pages"), null;
            n3.sort((e4, t3) => e4 - t3);
            const o3 = [];
            let a3 = n3[0], i3 = n3[0];
            for (let e4 = 1; e4 < n3.length; e4++) n3[e4] === i3 + 1 || (a3 === i3 ? o3.push(a3.toString()) : i3 - a3 === 1 ? (o3.push(a3.toString()), o3.push(i3.toString())) : o3.push(`${a3}-${i3}`), a3 = n3[e4]), i3 = n3[e4];
            a3 === i3 ? o3.push(a3.toString()) : i3 - a3 === 1 ? (o3.push(a3.toString()), o3.push(i3.toString())) : o3.push(`${a3}-${i3}`);
            const s4 = o3.join(",");
            return this.logger.debug(re, oe, `Sanitized page range: "${e3}" -> "${s4}"`), s4;
          } catch (e4) {
            return this.logger.error(re, oe, `Error sanitizing page range: ${e4}`), null;
          }
        }
      };
    }
  });

  // node_modules/@embedpdf/snippet/dist/embedpdf-Ob4AJbqq.js
  function e(e3, t2) {
    (null == t2 || t2 > e3.length) && (t2 = e3.length);
    for (var n3 = 0, o3 = Array(t2); n3 < t2; n3++) o3[n3] = e3[n3];
    return o3;
  }
  function t(e3, t2, n3, o3, i3, r2, a3) {
    try {
      var s4 = e3[r2](a3), l4 = s4.value;
    } catch (e4) {
      return void n3(e4);
    }
    s4.done ? t2(l4) : Promise.resolve(l4).then(o3, i3);
  }
  function n2(e3) {
    return function() {
      var n3 = this, o3 = arguments;
      return new Promise(function(i3, r2) {
        var a3 = e3.apply(n3, o3);
        function s4(e4) {
          t(a3, i3, r2, s4, l4, "next", e4);
        }
        function l4(e4) {
          t(a3, i3, r2, s4, l4, "throw", e4);
        }
        s4(void 0);
      });
    };
  }
  function o2(e3, t2, n3) {
    return t2 = l3(t2), (function(e4, t3) {
      if (t3 && ("object" == typeof t3 || "function" == typeof t3)) return t3;
      if (void 0 !== t3) throw new TypeError("Derived constructors may only return object or undefined");
      return (function(e5) {
        if (void 0 === e5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e5;
      })(e4);
    })(e3, d3() ? Reflect.construct(t2, n3 || [], l3(e3).constructor) : t2.apply(e3, n3));
  }
  function i2(e3, t2) {
    if (!(e3 instanceof t2)) throw new TypeError("Cannot call a class as a function");
  }
  function r(e3, t2, n3) {
    return t2 && (function(e4, t3) {
      for (var n4 = 0; n4 < t3.length; n4++) {
        var o3 = t3[n4];
        o3.enumerable = o3.enumerable || false, o3.configurable = true, "value" in o3 && (o3.writable = true), Object.defineProperty(e4, b(o3.key), o3);
      }
    })(e3.prototype, t2), Object.defineProperty(e3, "prototype", { writable: false }), e3;
  }
  function a2(e3, t2) {
    var n3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
    if (!n3) {
      if (Array.isArray(e3) || (n3 = x(e3)) || t2) {
        n3 && (e3 = n3);
        var o3 = 0, i3 = function() {
        };
        return { s: i3, n: function() {
          return o3 >= e3.length ? { done: true } : { done: false, value: e3[o3++] };
        }, e: function(e4) {
          throw e4;
        }, f: i3 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var r2, a3 = true, s4 = false;
    return { s: function() {
      n3 = n3.call(e3);
    }, n: function() {
      var e4 = n3.next();
      return a3 = e4.done, e4;
    }, e: function(e4) {
      s4 = true, r2 = e4;
    }, f: function() {
      try {
        a3 || null == n3.return || n3.return();
      } finally {
        if (s4) throw r2;
      }
    } };
  }
  function s3(e3, t2, n3) {
    return (t2 = b(t2)) in e3 ? Object.defineProperty(e3, t2, { value: n3, enumerable: true, configurable: true, writable: true }) : e3[t2] = n3, e3;
  }
  function l3(e3) {
    return l3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
      return e4.__proto__ || Object.getPrototypeOf(e4);
    }, l3(e3);
  }
  function c3(e3, t2) {
    if ("function" != typeof t2 && null !== t2) throw new TypeError("Super expression must either be null or a function");
    e3.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e3, writable: true, configurable: true } }), Object.defineProperty(e3, "prototype", { writable: false }), t2 && v(e3, t2);
  }
  function d3() {
    try {
      var e3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (e4) {
    }
    return (d3 = function() {
      return !!e3;
    })();
  }
  function u3(e3, t2) {
    var n3 = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var o3 = Object.getOwnPropertySymbols(e3);
      t2 && (o3 = o3.filter(function(t3) {
        return Object.getOwnPropertyDescriptor(e3, t3).enumerable;
      })), n3.push.apply(n3, o3);
    }
    return n3;
  }
  function h2(e3) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n3 = null != arguments[t2] ? arguments[t2] : {};
      t2 % 2 ? u3(Object(n3), true).forEach(function(t3) {
        s3(e3, t3, n3[t3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n3)) : u3(Object(n3)).forEach(function(t3) {
        Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(n3, t3));
      });
    }
    return e3;
  }
  function m2(e3, t2) {
    if (null == e3) return {};
    var n3, o3, i3 = (function(e4, t3) {
      if (null == e4) return {};
      var n4 = {};
      for (var o4 in e4) if ({}.hasOwnProperty.call(e4, o4)) {
        if (-1 !== t3.indexOf(o4)) continue;
        n4[o4] = e4[o4];
      }
      return n4;
    })(e3, t2);
    if (Object.getOwnPropertySymbols) {
      var r2 = Object.getOwnPropertySymbols(e3);
      for (o3 = 0; o3 < r2.length; o3++) n3 = r2[o3], -1 === t2.indexOf(n3) && {}.propertyIsEnumerable.call(e3, n3) && (i3[n3] = e3[n3]);
    }
    return i3;
  }
  function g2() {
    var e3, t2, n3 = "function" == typeof Symbol ? Symbol : {}, o3 = n3.iterator || "@@iterator", i3 = n3.toStringTag || "@@toStringTag";
    function r2(n4, o4, i4, r3) {
      var l5 = o4 && o4.prototype instanceof s4 ? o4 : s4, c5 = Object.create(l5.prototype);
      return p3(c5, "_invoke", (function(n5, o5, i5) {
        var r4, s5, l6, c6 = 0, d5 = i5 || [], u5 = false, h4 = { p: 0, n: 0, v: e3, a: m3, f: m3.bind(e3, 4), d: function(t3, n6) {
          return r4 = t3, s5 = 0, l6 = e3, h4.n = n6, a3;
        } };
        function m3(n6, o6) {
          for (s5 = n6, l6 = o6, t2 = 0; !u5 && c6 && !i6 && t2 < d5.length; t2++) {
            var i6, r5 = d5[t2], m4 = h4.p, g3 = r5[2];
            n6 > 3 ? (i6 = g3 === o6) && (l6 = r5[(s5 = r5[4]) ? 5 : (s5 = 3, 3)], r5[4] = r5[5] = e3) : r5[0] <= m4 && ((i6 = n6 < 2 && m4 < r5[1]) ? (s5 = 0, h4.v = o6, h4.n = r5[1]) : m4 < g3 && (i6 = n6 < 3 || r5[0] > o6 || o6 > g3) && (r5[4] = n6, r5[5] = o6, h4.n = g3, s5 = 0));
          }
          if (i6 || n6 > 1) return a3;
          throw u5 = true, o6;
        }
        return function(i6, d6, g3) {
          if (c6 > 1) throw TypeError("Generator is already running");
          for (u5 && 1 === d6 && m3(d6, g3), s5 = d6, l6 = g3; (t2 = s5 < 2 ? e3 : l6) || !u5; ) {
            r4 || (s5 ? s5 < 3 ? (s5 > 1 && (h4.n = -1), m3(s5, l6)) : h4.n = l6 : h4.v = l6);
            try {
              if (c6 = 2, r4) {
                if (s5 || (i6 = "next"), t2 = r4[i6]) {
                  if (!(t2 = t2.call(r4, l6))) throw TypeError("iterator result is not an object");
                  if (!t2.done) return t2;
                  l6 = t2.value, s5 < 2 && (s5 = 0);
                } else 1 === s5 && (t2 = r4.return) && t2.call(r4), s5 < 2 && (l6 = TypeError("The iterator does not provide a '" + i6 + "' method"), s5 = 1);
                r4 = e3;
              } else if ((t2 = (u5 = h4.n < 0) ? l6 : n5.call(o5, h4)) !== a3) break;
            } catch (t3) {
              r4 = e3, s5 = 1, l6 = t3;
            } finally {
              c6 = 1;
            }
          }
          return { value: t2, done: u5 };
        };
      })(n4, i4, r3), true), c5;
    }
    var a3 = {};
    function s4() {
    }
    function l4() {
    }
    function c4() {
    }
    t2 = Object.getPrototypeOf;
    var d4 = [][o3] ? t2(t2([][o3]())) : (p3(t2 = {}, o3, function() {
      return this;
    }), t2), u4 = c4.prototype = s4.prototype = Object.create(d4);
    function h3(e4) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(e4, c4) : (e4.__proto__ = c4, p3(e4, i3, "GeneratorFunction")), e4.prototype = Object.create(u4), e4;
    }
    return l4.prototype = c4, p3(u4, "constructor", c4), p3(c4, "constructor", l4), l4.displayName = "GeneratorFunction", p3(c4, i3, "GeneratorFunction"), p3(u4), p3(u4, i3, "Generator"), p3(u4, o3, function() {
      return this;
    }), p3(u4, "toString", function() {
      return "[object Generator]";
    }), (g2 = function() {
      return { w: r2, m: h3 };
    })();
  }
  function p3(e3, t2, n3, o3) {
    var i3 = Object.defineProperty;
    try {
      i3({}, "", {});
    } catch (e4) {
      i3 = 0;
    }
    p3 = function(e4, t3, n4, o4) {
      function r2(t4, n5) {
        p3(e4, t4, function(e5) {
          return this._invoke(t4, n5, e5);
        });
      }
      t3 ? i3 ? i3(e4, t3, { value: n4, enumerable: !o4, configurable: !o4, writable: !o4 }) : e4[t3] = n4 : (r2("next", 0), r2("throw", 1), r2("return", 2));
    }, p3(e3, t2, n3, o3);
  }
  function v(e3, t2) {
    return v = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t3) {
      return e4.__proto__ = t3, e4;
    }, v(e3, t2);
  }
  function f(e3, t2) {
    return (function(e4) {
      if (Array.isArray(e4)) return e4;
    })(e3) || (function(e4, t3) {
      var n3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
      if (null != n3) {
        var o3, i3, r2, a3, s4 = [], l4 = true, c4 = false;
        try {
          if (r2 = (n3 = n3.call(e4)).next, 0 === t3) ;
          else for (; !(l4 = (o3 = r2.call(n3)).done) && (s4.push(o3.value), s4.length !== t3); l4 = true) ;
        } catch (e5) {
          c4 = true, i3 = e5;
        } finally {
          try {
            if (!l4 && null != n3.return && (a3 = n3.return(), Object(a3) !== a3)) return;
          } finally {
            if (c4) throw i3;
          }
        }
        return s4;
      }
    })(e3, t2) || x(e3, t2) || (function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    })();
  }
  function y(t2) {
    return (function(t3) {
      if (Array.isArray(t3)) return e(t3);
    })(t2) || (function(e3) {
      if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"]) return Array.from(e3);
    })(t2) || x(t2) || (function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    })();
  }
  function b(e3) {
    var t2 = (function(e4, t3) {
      if ("object" != typeof e4 || !e4) return e4;
      var n3 = e4[Symbol.toPrimitive];
      if (void 0 !== n3) {
        var o3 = n3.call(e4, t3);
        if ("object" != typeof o3) return o3;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === t3 ? String : Number)(e4);
    })(e3, "string");
    return "symbol" == typeof t2 ? t2 : t2 + "";
  }
  function w(e3) {
    return w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
      return typeof e4;
    } : function(e4) {
      return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
    }, w(e3);
  }
  function x(t2, n3) {
    if (t2) {
      if ("string" == typeof t2) return e(t2, n3);
      var o3 = {}.toString.call(t2).slice(8, -1);
      return "Object" === o3 && t2.constructor && (o3 = t2.constructor.name), "Map" === o3 || "Set" === o3 ? Array.from(t2) : "Arguments" === o3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o3) ? e(t2, n3) : void 0;
    }
  }
  function $2(e3, t2) {
    for (var n3 in t2) e3[n3] = t2[n3];
    return e3;
  }
  function F(e3) {
    e3 && e3.parentNode && e3.parentNode.removeChild(e3);
  }
  function j2(e3, t2, n3) {
    var o3, i3, r2, a3 = {};
    for (r2 in t2) "key" == r2 ? o3 = t2[r2] : "ref" == r2 ? i3 = t2[r2] : a3[r2] = t2[r2];
    if (arguments.length > 2 && (a3.children = arguments.length > 3 ? C.call(arguments, 2) : n3), "function" == typeof e3 && null != e3.defaultProps) for (r2 in e3.defaultProps) void 0 === a3[r2] && (a3[r2] = e3.defaultProps[r2]);
    return H2(e3, a3, o3, i3, null);
  }
  function H2(e3, t2, n3, o3, i3) {
    var r2 = { type: e3, props: t2, key: n3, ref: o3, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == i3 ? ++S : i3, __i: -1, __u: 0 };
    return null == i3 && null != I.vnode && I.vnode(r2), r2;
  }
  function U2(e3) {
    return e3.children;
  }
  function W2(e3, t2) {
    this.props = e3, this.context = t2;
  }
  function B2(e3, t2) {
    if (null == t2) return e3.__ ? B2(e3.__, e3.__i + 1) : null;
    for (var n3; t2 < e3.__k.length; t2++) if (null != (n3 = e3.__k[t2]) && null != n3.__e) return n3.__e;
    return "function" == typeof e3.type ? B2(e3) : null;
  }
  function q2(e3) {
    var t2, n3;
    if (null != (e3 = e3.__) && null != e3.__c) {
      for (e3.__e = e3.__c.base = null, t2 = 0; t2 < e3.__k.length; t2++) if (null != (n3 = e3.__k[t2]) && null != n3.__e) {
        e3.__e = e3.__c.base = n3.__e;
        break;
      }
      return q2(e3);
    }
  }
  function G(e3) {
    (!e3.__d && (e3.__d = true) && k.push(e3) && !V2.__r++ || D != I.debounceRendering) && ((D = I.debounceRendering) || M)(V2);
  }
  function V2() {
    for (var e3, t2, n3, o3, i3, r2, a3, s4 = 1; k.length; ) k.length > s4 && k.sort(P), e3 = k.shift(), s4 = k.length, e3.__d && (n3 = void 0, o3 = void 0, i3 = (o3 = (t2 = e3).__v).__e, r2 = [], a3 = [], t2.__P && ((n3 = $2({}, o3)).__v = o3.__v + 1, I.vnode && I.vnode(n3), te2(t2.__P, n3, o3, t2.__n, t2.__P.namespaceURI, 32 & o3.__u ? [i3] : null, r2, null == i3 ? B2(o3) : i3, !!(32 & o3.__u), a3), n3.__v = o3.__v, n3.__.__k[n3.__i] = n3, oe2(r2, n3, a3), o3.__e = o3.__ = null, n3.__e != i3 && q2(n3)));
    V2.__r = 0;
  }
  function Z2(e3, t2, n3, o3, i3, r2, a3, s4, l4, c4, d4) {
    var u4, h3, m3, g3, p4, v2, f2, y2 = o3 && o3.__k || N2, b2 = t2.length;
    for (l4 = (function(e4, t3, n4, o4, i4) {
      var r3, a4, s5, l5, c5, d5 = n4.length, u5 = d5, h4 = 0;
      for (e4.__k = new Array(i4), r3 = 0; r3 < i4; r3++) null != (a4 = t3[r3]) && "boolean" != typeof a4 && "function" != typeof a4 ? ("string" == typeof a4 || "number" == typeof a4 || "bigint" == typeof a4 || a4.constructor == String ? a4 = e4.__k[r3] = H2(null, a4, null, null, null) : L2(a4) ? a4 = e4.__k[r3] = H2(U2, { children: a4 }, null, null, null) : null == a4.constructor && a4.__b > 0 ? a4 = e4.__k[r3] = H2(a4.type, a4.props, a4.key, a4.ref ? a4.ref : null, a4.__v) : e4.__k[r3] = a4, l5 = r3 + h4, a4.__ = e4, a4.__b = e4.__b + 1, -1 != (c5 = a4.__i = X2(a4, n4, l5, u5)) && (u5--, (s5 = n4[c5]) && (s5.__u |= 2)), null == s5 || null == s5.__v ? (-1 == c5 && (i4 > d5 ? h4-- : i4 < d5 && h4++), "function" != typeof a4.type && (a4.__u |= 4)) : c5 != l5 && (c5 == l5 - 1 ? h4-- : c5 == l5 + 1 ? h4++ : (c5 > l5 ? h4-- : h4++, a4.__u |= 4))) : e4.__k[r3] = null;
      if (u5) for (r3 = 0; r3 < d5; r3++) null != (s5 = n4[r3]) && !(2 & s5.__u) && (s5.__e == o4 && (o4 = B2(s5)), se(s5, s5));
      return o4;
    })(n3, t2, y2, l4, b2), u4 = 0; u4 < b2; u4++) null != (m3 = n3.__k[u4]) && (h3 = -1 == m3.__i ? R : y2[m3.__i] || R, m3.__i = u4, v2 = te2(e3, m3, h3, i3, r2, a3, s4, l4, c4, d4), g3 = m3.__e, m3.ref && h3.ref != m3.ref && (h3.ref && ae2(h3.ref, null, m3), d4.push(m3.ref, m3.__c || g3, m3)), null == p4 && null != g3 && (p4 = g3), (f2 = !!(4 & m3.__u)) || h3.__k === m3.__k ? l4 = K2(m3, l4, e3, f2) : "function" == typeof m3.type && void 0 !== v2 ? l4 = v2 : g3 && (l4 = g3.nextSibling), m3.__u &= -7);
    return n3.__e = p4, l4;
  }
  function K2(e3, t2, n3, o3) {
    var i3, r2;
    if ("function" == typeof e3.type) {
      for (i3 = e3.__k, r2 = 0; i3 && r2 < i3.length; r2++) i3[r2] && (i3[r2].__ = e3, t2 = K2(i3[r2], t2, n3, o3));
      return t2;
    }
    e3.__e != t2 && (o3 && (t2 && e3.type && !t2.parentNode && (t2 = B2(e3)), n3.insertBefore(e3.__e, t2 || null)), t2 = e3.__e);
    do {
      t2 = t2 && t2.nextSibling;
    } while (null != t2 && 8 == t2.nodeType);
    return t2;
  }
  function Y2(e3, t2) {
    return t2 = t2 || [], null == e3 || "boolean" == typeof e3 || (L2(e3) ? e3.some(function(e4) {
      Y2(e4, t2);
    }) : t2.push(e3)), t2;
  }
  function X2(e3, t2, n3, o3) {
    var i3, r2, a3, s4 = e3.key, l4 = e3.type, c4 = t2[n3], d4 = null != c4 && !(2 & c4.__u);
    if (null === c4 && null == s4 || d4 && s4 == c4.key && l4 == c4.type) return n3;
    if (o3 > (d4 ? 1 : 0)) {
      for (i3 = n3 - 1, r2 = n3 + 1; i3 >= 0 || r2 < t2.length; ) if (null != (c4 = t2[a3 = i3 >= 0 ? i3-- : r2++]) && !(2 & c4.__u) && s4 == c4.key && l4 == c4.type) return a3;
    }
    return -1;
  }
  function Q2(e3, t2, n3) {
    "-" == t2[0] ? e3.setProperty(t2, null == n3 ? "" : n3) : e3[t2] = null == n3 ? "" : "number" != typeof n3 || O.test(t2) ? n3 : n3 + "px";
  }
  function J2(e3, t2, n3, o3, i3) {
    var r2, a3;
    e: if ("style" == t2) if ("string" == typeof n3) e3.style.cssText = n3;
    else {
      if ("string" == typeof o3 && (e3.style.cssText = o3 = ""), o3) for (t2 in o3) n3 && t2 in n3 || Q2(e3.style, t2, "");
      if (n3) for (t2 in n3) o3 && n3[t2] == o3[t2] || Q2(e3.style, t2, n3[t2]);
    }
    else if ("o" == t2[0] && "n" == t2[1]) r2 = t2 != (t2 = t2.replace(A, "$1")), a3 = t2.toLowerCase(), t2 = a3 in e3 || "onFocusOut" == t2 || "onFocusIn" == t2 ? a3.slice(2) : t2.slice(2), e3.l || (e3.l = {}), e3.l[t2 + r2] = n3, n3 ? o3 ? n3.u = o3.u : (n3.u = T, e3.addEventListener(t2, r2 ? E : z2, r2)) : e3.removeEventListener(t2, r2 ? E : z2, r2);
    else {
      if ("http://www.w3.org/2000/svg" == i3) t2 = t2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" != t2 && "height" != t2 && "href" != t2 && "list" != t2 && "form" != t2 && "tabIndex" != t2 && "download" != t2 && "rowSpan" != t2 && "colSpan" != t2 && "role" != t2 && "popover" != t2 && t2 in e3) try {
        e3[t2] = null == n3 ? "" : n3;
        break e;
      } catch (e4) {
      }
      "function" == typeof n3 || (null == n3 || false === n3 && "-" != t2[4] ? e3.removeAttribute(t2) : e3.setAttribute(t2, "popover" == t2 && 1 == n3 ? "" : n3));
    }
  }
  function ee2(e3) {
    return function(t2) {
      if (this.l) {
        var n3 = this.l[t2.type + e3];
        if (null == t2.t) t2.t = T++;
        else if (t2.t < n3.u) return;
        return n3(I.event ? I.event(t2) : t2);
      }
    };
  }
  function te2(e3, t2, n3, o3, i3, r2, a3, s4, l4, c4) {
    var d4, u4, h3, m3, g3, p4, v2, f2, y2, b2, w2, x2, C2, S2, k2, D2, M2, P2 = t2.type;
    if (null != t2.constructor) return null;
    128 & n3.__u && (l4 = !!(32 & n3.__u), r2 = [s4 = t2.__e = n3.__e]), (d4 = I.__b) && d4(t2);
    e: if ("function" == typeof P2) try {
      if (f2 = t2.props, y2 = "prototype" in P2 && P2.prototype.render, b2 = (d4 = P2.contextType) && o3[d4.__c], w2 = d4 ? b2 ? b2.props.value : d4.__ : o3, n3.__c ? v2 = (u4 = t2.__c = n3.__c).__ = u4.__E : (y2 ? t2.__c = u4 = new P2(f2, w2) : (t2.__c = u4 = new W2(f2, w2), u4.constructor = P2, u4.render = le), b2 && b2.sub(u4), u4.state || (u4.state = {}), u4.__n = o3, h3 = u4.__d = true, u4.__h = [], u4._sb = []), y2 && null == u4.__s && (u4.__s = u4.state), y2 && null != P2.getDerivedStateFromProps && (u4.__s == u4.state && (u4.__s = $2({}, u4.__s)), $2(u4.__s, P2.getDerivedStateFromProps(f2, u4.__s))), m3 = u4.props, g3 = u4.state, u4.__v = t2, h3) y2 && null == P2.getDerivedStateFromProps && null != u4.componentWillMount && u4.componentWillMount(), y2 && null != u4.componentDidMount && u4.__h.push(u4.componentDidMount);
      else {
        if (y2 && null == P2.getDerivedStateFromProps && f2 !== m3 && null != u4.componentWillReceiveProps && u4.componentWillReceiveProps(f2, w2), t2.__v == n3.__v || !u4.__e && null != u4.shouldComponentUpdate && false === u4.shouldComponentUpdate(f2, u4.__s, w2)) {
          for (t2.__v != n3.__v && (u4.props = f2, u4.state = u4.__s, u4.__d = false), t2.__e = n3.__e, t2.__k = n3.__k, t2.__k.some(function(e4) {
            e4 && (e4.__ = t2);
          }), x2 = 0; x2 < u4._sb.length; x2++) u4.__h.push(u4._sb[x2]);
          u4._sb = [], u4.__h.length && a3.push(u4);
          break e;
        }
        null != u4.componentWillUpdate && u4.componentWillUpdate(f2, u4.__s, w2), y2 && null != u4.componentDidUpdate && u4.__h.push(function() {
          u4.componentDidUpdate(m3, g3, p4);
        });
      }
      if (u4.context = w2, u4.props = f2, u4.__P = e3, u4.__e = false, C2 = I.__r, S2 = 0, y2) {
        for (u4.state = u4.__s, u4.__d = false, C2 && C2(t2), d4 = u4.render(u4.props, u4.state, u4.context), k2 = 0; k2 < u4._sb.length; k2++) u4.__h.push(u4._sb[k2]);
        u4._sb = [];
      } else do {
        u4.__d = false, C2 && C2(t2), d4 = u4.render(u4.props, u4.state, u4.context), u4.state = u4.__s;
      } while (u4.__d && ++S2 < 25);
      u4.state = u4.__s, null != u4.getChildContext && (o3 = $2($2({}, o3), u4.getChildContext())), y2 && !h3 && null != u4.getSnapshotBeforeUpdate && (p4 = u4.getSnapshotBeforeUpdate(m3, g3)), D2 = d4, null != d4 && d4.type === U2 && null == d4.key && (D2 = ie2(d4.props.children)), s4 = Z2(e3, L2(D2) ? D2 : [D2], t2, n3, o3, i3, r2, a3, s4, l4, c4), u4.base = t2.__e, t2.__u &= -161, u4.__h.length && a3.push(u4), v2 && (u4.__E = u4.__ = null);
    } catch (e4) {
      if (t2.__v = null, l4 || null != r2) if (e4.then) {
        for (t2.__u |= l4 ? 160 : 128; s4 && 8 == s4.nodeType && s4.nextSibling; ) s4 = s4.nextSibling;
        r2[r2.indexOf(s4)] = null, t2.__e = s4;
      } else {
        for (M2 = r2.length; M2--; ) F(r2[M2]);
        ne2(t2);
      }
      else t2.__e = n3.__e, t2.__k = n3.__k, e4.then || ne2(t2);
      I.__e(e4, t2, n3);
    }
    else null == r2 && t2.__v == n3.__v ? (t2.__k = n3.__k, t2.__e = n3.__e) : s4 = t2.__e = re2(n3.__e, t2, n3, o3, i3, r2, a3, l4, c4);
    return (d4 = I.diffed) && d4(t2), 128 & t2.__u ? void 0 : s4;
  }
  function ne2(e3) {
    e3 && e3.__c && (e3.__c.__e = true), e3 && e3.__k && e3.__k.forEach(ne2);
  }
  function oe2(e3, t2, n3) {
    for (var o3 = 0; o3 < n3.length; o3++) ae2(n3[o3], n3[++o3], n3[++o3]);
    I.__c && I.__c(t2, e3), e3.some(function(t3) {
      try {
        e3 = t3.__h, t3.__h = [], e3.some(function(e4) {
          e4.call(t3);
        });
      } catch (e4) {
        I.__e(e4, t3.__v);
      }
    });
  }
  function ie2(e3) {
    return "object" != typeof e3 || null == e3 || e3.__b && e3.__b > 0 ? e3 : L2(e3) ? e3.map(ie2) : $2({}, e3);
  }
  function re2(e3, t2, n3, o3, i3, r2, a3, s4, l4) {
    var c4, d4, u4, h3, m3, g3, p4, v2 = n3.props || R, f2 = t2.props, y2 = t2.type;
    if ("svg" == y2 ? i3 = "http://www.w3.org/2000/svg" : "math" == y2 ? i3 = "http://www.w3.org/1998/Math/MathML" : i3 || (i3 = "http://www.w3.org/1999/xhtml"), null != r2) {
      for (c4 = 0; c4 < r2.length; c4++) if ((m3 = r2[c4]) && "setAttribute" in m3 == !!y2 && (y2 ? m3.localName == y2 : 3 == m3.nodeType)) {
        e3 = m3, r2[c4] = null;
        break;
      }
    }
    if (null == e3) {
      if (null == y2) return document.createTextNode(f2);
      e3 = document.createElementNS(i3, y2, f2.is && f2), s4 && (I.__m && I.__m(t2, r2), s4 = false), r2 = null;
    }
    if (null == y2) v2 === f2 || s4 && e3.data == f2 || (e3.data = f2);
    else {
      if (r2 = r2 && C.call(e3.childNodes), !s4 && null != r2) for (v2 = {}, c4 = 0; c4 < e3.attributes.length; c4++) v2[(m3 = e3.attributes[c4]).name] = m3.value;
      for (c4 in v2) if (m3 = v2[c4], "children" == c4) ;
      else if ("dangerouslySetInnerHTML" == c4) u4 = m3;
      else if (!(c4 in f2)) {
        if ("value" == c4 && "defaultValue" in f2 || "checked" == c4 && "defaultChecked" in f2) continue;
        J2(e3, c4, null, m3, i3);
      }
      for (c4 in f2) m3 = f2[c4], "children" == c4 ? h3 = m3 : "dangerouslySetInnerHTML" == c4 ? d4 = m3 : "value" == c4 ? g3 = m3 : "checked" == c4 ? p4 = m3 : s4 && "function" != typeof m3 || v2[c4] === m3 || J2(e3, c4, m3, v2[c4], i3);
      if (d4) s4 || u4 && (d4.__html == u4.__html || d4.__html == e3.innerHTML) || (e3.innerHTML = d4.__html), t2.__k = [];
      else if (u4 && (e3.innerHTML = ""), Z2("template" == t2.type ? e3.content : e3, L2(h3) ? h3 : [h3], t2, n3, o3, "foreignObject" == y2 ? "http://www.w3.org/1999/xhtml" : i3, r2, a3, r2 ? r2[0] : n3.__k && B2(n3, 0), s4, l4), null != r2) for (c4 = r2.length; c4--; ) F(r2[c4]);
      s4 || (c4 = "value", "progress" == y2 && null == g3 ? e3.removeAttribute("value") : null != g3 && (g3 !== e3[c4] || "progress" == y2 && !g3 || "option" == y2 && g3 != v2[c4]) && J2(e3, c4, g3, v2[c4], i3), c4 = "checked", null != p4 && p4 != e3[c4] && J2(e3, c4, p4, v2[c4], i3));
    }
    return e3;
  }
  function ae2(e3, t2, n3) {
    try {
      if ("function" == typeof e3) {
        var o3 = "function" == typeof e3.__u;
        o3 && e3.__u(), o3 && null == t2 || (e3.__u = e3(t2));
      } else e3.current = t2;
    } catch (e4) {
      I.__e(e4, n3);
    }
  }
  function se(e3, t2, n3) {
    var o3, i3;
    if (I.unmount && I.unmount(e3), (o3 = e3.ref) && (o3.current && o3.current != e3.__e || ae2(o3, null, t2)), null != (o3 = e3.__c)) {
      if (o3.componentWillUnmount) try {
        o3.componentWillUnmount();
      } catch (e4) {
        I.__e(e4, t2);
      }
      o3.base = o3.__P = null;
    }
    if (o3 = e3.__k) for (i3 = 0; i3 < o3.length; i3++) o3[i3] && se(o3[i3], t2, n3 || "function" != typeof e3.type);
    n3 || F(e3.__e), e3.__c = e3.__ = e3.__e = void 0;
  }
  function le(e3, t2, n3) {
    return this.constructor(e3, n3);
  }
  function ce(e3, t2, n3) {
    var o3, i3, r2;
    t2 == document && (t2 = document.documentElement), I.__ && I.__(e3, t2), o3 = false ? null : t2.__k, i3 = [], r2 = [], te2(t2, e3 = t2.__k = j2(U2, null, [e3]), o3 || R, R, t2.namespaceURI, o3 ? null : t2.firstChild ? C.call(t2.childNodes) : null, i3, o3 ? o3.__e : t2.firstChild, false, r2), oe2(i3, e3, r2);
  }
  function de(e3) {
    function t2(e4) {
      var n3, o3;
      return this.getChildContext || (n3 = /* @__PURE__ */ new Set(), (o3 = {})[t2.__c] = this, this.getChildContext = function() {
        return o3;
      }, this.componentWillUnmount = function() {
        n3 = null;
      }, this.shouldComponentUpdate = function(e5) {
        this.props.value != e5.value && n3.forEach(function(e6) {
          e6.__e = true, G(e6);
        });
      }, this.sub = function(e5) {
        n3.add(e5);
        var t3 = e5.componentWillUnmount;
        e5.componentWillUnmount = function() {
          n3 && n3.delete(e5), t3 && t3.call(e5);
        };
      }), e4.children;
    }
    return t2.__c = "__cC" + _++, t2.__ = e3, t2.Provider = t2.__l = (t2.Consumer = function(e4, t3) {
      return e4.children(t3);
    }).contextType = t2, t2;
  }
  function Se(e3, t2) {
    fe.__h && fe.__h(he, e3, pe || t2), pe = 0;
    var n3 = he.__H || (he.__H = { __: [], __h: [] });
    return e3 >= n3.__.length && n3.__.push({}), n3.__[e3];
  }
  function ke(e3) {
    return pe = 1, De(Fe, e3);
  }
  function De(e3, t2, n3) {
    var o3 = Se(ue++, 2);
    if (o3.t = e3, !o3.__c && (o3.__ = [n3 ? n3(t2) : Fe(void 0, t2), function(e4) {
      var t3 = o3.__N ? o3.__N[0] : o3.__[0], n4 = o3.t(t3, e4);
      t3 !== n4 && (o3.__N = [n4, o3.__[1]], o3.__c.setState({}));
    }], o3.__c = he, !he.__f)) {
      var i3 = function(e4, t3, n4) {
        if (!o3.__c.__H) return true;
        var i4 = o3.__c.__H.__.filter(function(e5) {
          return !!e5.__c;
        });
        if (i4.every(function(e5) {
          return !e5.__N;
        })) return !r2 || r2.call(this, e4, t3, n4);
        var a4 = o3.__c.props !== e4;
        return i4.forEach(function(e5) {
          if (e5.__N) {
            var t4 = e5.__[0];
            e5.__ = e5.__N, e5.__N = void 0, t4 !== e5.__[0] && (a4 = true);
          }
        }), r2 && r2.call(this, e4, t3, n4) || a4;
      };
      he.__f = true;
      var r2 = he.shouldComponentUpdate, a3 = he.componentWillUpdate;
      he.componentWillUpdate = function(e4, t3, n4) {
        if (this.__e) {
          var o4 = r2;
          r2 = void 0, i3(e4, t3, n4), r2 = o4;
        }
        a3 && a3.call(this, e4, t3, n4);
      }, he.shouldComponentUpdate = i3;
    }
    return o3.__N || o3.__;
  }
  function Me(e3, t2) {
    var n3 = Se(ue++, 3);
    !fe.__s && $e(n3.__H, t2) && (n3.__ = e3, n3.u = t2, he.__H.__h.push(n3));
  }
  function Pe(e3, t2) {
    var n3 = Se(ue++, 4);
    !fe.__s && $e(n3.__H, t2) && (n3.__ = e3, n3.u = t2, he.__h.push(n3));
  }
  function Ae(e3) {
    return pe = 5, Te(function() {
      return { current: e3 };
    }, []);
  }
  function Te(e3, t2) {
    var n3 = Se(ue++, 7);
    return $e(n3.__H, t2) && (n3.__ = e3(), n3.__H = t2, n3.__h = e3), n3.__;
  }
  function ze(e3, t2) {
    return pe = 8, Te(function() {
      return e3;
    }, t2);
  }
  function Ee(e3) {
    var t2 = he.context[e3.__c], n3 = Se(ue++, 9);
    return n3.c = e3, t2 ? (null == n3.__ && (n3.__ = true, t2.sub(he)), t2.props.value) : e3.__;
  }
  function _e() {
    for (var e3; e3 = ve.shift(); ) if (e3.__P && e3.__H) try {
      e3.__H.__h.forEach(Oe), e3.__H.__h.forEach(Le), e3.__H.__h = [];
    } catch (t2) {
      e3.__H.__h = [], fe.__e(t2, e3.__v);
    }
  }
  function Ne(e3) {
    var t2, n3 = function() {
      clearTimeout(o3), Re && cancelAnimationFrame(t2), setTimeout(e3);
    }, o3 = setTimeout(n3, 35);
    Re && (t2 = requestAnimationFrame(n3));
  }
  function Oe(e3) {
    var t2 = he, n3 = e3.__c;
    "function" == typeof n3 && (e3.__c = void 0, n3()), he = t2;
  }
  function Le(e3) {
    var t2 = he;
    e3.__c = e3.__(), he = t2;
  }
  function $e(e3, t2) {
    return !e3 || e3.length !== t2.length || t2.some(function(t3, n3) {
      return t3 !== e3[n3];
    });
  }
  function Fe(e3, t2) {
    return "function" == typeof t2 ? t2(e3) : t2;
  }
  function Ue(e3, t2, n3, o3, i3, r2) {
    t2 || (t2 = {});
    var a3, s4, l4 = t2;
    if ("ref" in l4) for (s4 in l4 = {}, t2) "ref" == s4 ? a3 = t2[s4] : l4[s4] = t2[s4];
    var c4 = { type: e3, props: l4, key: n3, ref: a3, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: --He, __i: -1, __u: 0, __source: i3, __self: r2 };
    if ("function" == typeof e3 && (a3 = e3.defaultProps)) for (s4 in a3) void 0 === l4[s4] && (l4[s4] = a3[s4]);
    return I.vnode && I.vnode(c4), c4;
  }
  function Be(e3) {
    return { x: Math.floor(e3.x), y: Math.floor(e3.y) };
  }
  function qe(e3) {
    return { width: Math.ceil(e3.width), height: Math.ceil(e3.height) };
  }
  function Ge(e3) {
    return { origin: Be(e3.origin), size: qe(e3.size) };
  }
  function Ve(e3) {
    const { width: t2, height: n3 } = e3;
    return { width: n3, height: t2 };
  }
  function Ze(e3, t2, n3) {
    return { width: (e3 = t2 % 2 == 0 ? e3 : Ve(e3)).width * n3, height: e3.height * n3 };
  }
  function Ke(e3) {
    const t2 = [e3.p1.x, e3.p2.x, e3.p3.x, e3.p4.x], n3 = [e3.p1.y, e3.p2.y, e3.p3.y, e3.p4.y];
    return { origin: { x: Math.min(...t2), y: Math.min(...n3) }, size: { width: Math.max(...t2) - Math.min(...t2), height: Math.max(...n3) - Math.min(...n3) } };
  }
  function Ye(e3) {
    return { p1: { x: e3.origin.x, y: e3.origin.y }, p2: { x: e3.origin.x + e3.size.width, y: e3.origin.y }, p3: { x: e3.origin.x + e3.size.width, y: e3.origin.y + e3.size.height }, p4: { x: e3.origin.x, y: e3.origin.y + e3.size.height } };
  }
  function Xe(e3, t2, n3) {
    let o3 = t2.x, i3 = t2.y;
    switch (n3) {
      case 0:
        o3 = t2.x, i3 = t2.y;
        break;
      case 1:
        o3 = e3.height - t2.y, i3 = t2.x;
        break;
      case 2:
        o3 = e3.width - t2.x, i3 = e3.height - t2.y;
        break;
      case 3:
        o3 = t2.y, i3 = e3.width - t2.x;
    }
    return { x: o3, y: i3 };
  }
  function Qe(e3, t2) {
    return { x: e3.x * t2, y: e3.y * t2 };
  }
  function Je(e3) {
    if (0 === e3.length) return { origin: { x: 0, y: 0 }, size: { width: 0, height: 0 } };
    const t2 = e3.map((e4) => e4.x), n3 = e3.map((e4) => e4.y), o3 = Math.min(...t2), i3 = Math.min(...n3);
    return { origin: { x: o3, y: i3 }, size: { width: Math.max(...t2) - o3, height: Math.max(...n3) - i3 } };
  }
  function et(e3, t2) {
    return { origin: { x: e3.origin.x - t2, y: e3.origin.y - t2 }, size: { width: e3.size.width + 2 * t2, height: e3.size.height + 2 * t2 } };
  }
  function tt(e3, t2, n3) {
    let o3 = t2.origin.x, i3 = t2.origin.y, r2 = t2.size;
    switch (n3) {
      case 0:
        break;
      case 1:
        o3 = e3.height - t2.origin.y - t2.size.height, i3 = t2.origin.x, r2 = Ve(t2.size);
        break;
      case 2:
        o3 = e3.width - t2.origin.x - t2.size.width, i3 = e3.height - t2.origin.y - t2.size.height;
        break;
      case 3:
        o3 = t2.origin.y, i3 = e3.width - t2.origin.x - t2.size.width, r2 = Ve(t2.size);
    }
    return { origin: { x: o3, y: i3 }, size: { width: r2.width, height: r2.height } };
  }
  function nt(e3, t2) {
    return { origin: { x: e3.origin.x * t2, y: e3.origin.y * t2 }, size: { width: e3.size.width * t2, height: e3.size.height * t2 } };
  }
  function ot(e3, t2, n3, o3) {
    return nt(tt(e3, t2, n3), o3);
  }
  function it(e3) {
    if (0 === e3.length) return null;
    let t2 = e3[0].origin.x, n3 = e3[0].origin.y, o3 = e3[0].origin.x + e3[0].size.width, i3 = e3[0].origin.y + e3[0].size.height;
    for (const r2 of e3) t2 = Math.min(t2, r2.origin.x), n3 = Math.min(n3, r2.origin.y), o3 = Math.max(o3, r2.origin.x + r2.size.width), i3 = Math.max(i3, r2.origin.y + r2.size.height);
    return { origin: { x: t2, y: n3 }, size: { width: o3 - t2, height: i3 - n3 } };
  }
  function rt(e3, t2, n3, o3) {
    const i3 = e3.origin.x, r2 = e3.origin.y, a3 = e3.size.width, s4 = e3.size.height, l4 = n3 / a3, c4 = o3 / s4, d4 = n3 / s4, u4 = o3 / a3;
    switch (t2) {
      case 0:
        return { a: l4, b: 0, c: 0, d: c4, e: -l4 * i3, f: -c4 * r2 };
      case 3:
        return { a: 0, b: -u4, c: d4, d: 0, e: -d4 * r2, f: u4 * (i3 + a3) };
      case 2:
        return { a: -l4, b: 0, c: 0, d: -c4, e: l4 * (i3 + a3), f: c4 * (r2 + s4) };
      case 1:
        return { a: 0, b: u4, c: -d4, d: 0, e: d4 * (r2 + s4), f: -u4 * i3 };
    }
  }
  function ft(e3) {
    return e3.replace(vt, "");
  }
  function Ot(e3) {
    return Object.keys(Rt).filter((t2) => 0 !== (e3 & t2)).map((e4) => Rt[e4]);
  }
  function Lt(e3) {
    return e3.reduce((e4, t2) => e4 | Nt[t2], 0);
  }
  function Wt(e3) {
    const t2 = (e4) => ((e5) => Math.max(0, Math.min(255, e5)))(e4).toString(16).padStart(2, "0");
    return `#${t2(e3.red)}${t2(e3.green)}${t2(e3.blue)}`;
  }
  function Bt(e3) {
    /^#?[0-9a-f]{3}$/i.test(e3) && (e3 = e3.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, "#$1$1$2$2$3$3").toLowerCase());
    const [, t2, n3, o3] = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(e3) ?? (() => {
      throw new Error(`Invalid hex colour: "${e3}"`);
    })();
    return { red: parseInt(t2, 16), green: parseInt(n3, 16), blue: parseInt(o3, 16) };
  }
  function qt(e3) {
    return ((e4) => Math.max(0, Math.min(255, e4)))(e3) / 255;
  }
  function Gt(e3) {
    return ((e4, t2 = 255) => Math.max(0, Math.min(t2, e4)))(Math.round(255 * e3));
  }
  function Vt(e3) {
    if (!(null == e3 ? void 0 : e3.startsWith("D:")) || e3.length < 16) return;
    const t2 = +e3.slice(2, 6), n3 = +e3.slice(6, 8) - 1, o3 = +e3.slice(8, 10), i3 = +e3.slice(10, 12), r2 = +e3.slice(12, 14), a3 = +e3.slice(14, 16);
    return new Date(Date.UTC(t2, n3, o3, i3, r2, a3));
  }
  function Zt(e3 = /* @__PURE__ */ new Date()) {
    const t2 = (e4, t3 = 2) => e4.toString().padStart(t3, "0");
    return `D:${e3.getUTCFullYear()}${t2(e3.getUTCMonth() + 1)}${t2(e3.getUTCDate())}${t2(e3.getUTCHours())}${t2(e3.getUTCMinutes())}${t2(e3.getUTCSeconds())}`;
  }
  function Xt(e3) {
    return (function(e4) {
      return Yt[e4] ?? Yt[xt.Left];
    })(e3).css;
  }
  function rn(e3) {
    return nn[e3] ?? en;
  }
  function an(e3) {
    return rn(e3).bold;
  }
  function sn(e3) {
    return rn(e3).italic;
  }
  function ln(e3, { bold: t2, italic: n3 }) {
    return on.get(`${e3}_${t2}_${n3}`) ?? Jt;
  }
  function dn(e3) {
    switch (e3) {
      case "Courier":
        return "Courier";
      case "Helvetica":
      default:
        return "Helvetica";
      case "Times":
        return "Times";
      case "Symbol":
        return "Symbol";
      case "ZapfDingbats":
        return "ZapfDingbats";
    }
  }
  function mn(e3) {
    return (function(e4) {
      return hn[e4] ?? hn[It.Normal];
    })(e3).css;
  }
  function pn(e3) {
    if (e3 instanceof at) return { type: "noop" };
    if (e3 instanceof st) return { type: "console" };
    if (e3 instanceof ct) return { type: "perf" };
    if (e3 instanceof lt) {
      const t2 = e3;
      return { type: "level", config: { level: t2.level, logger: pn(t2.logger) } };
    }
    if (e3 instanceof dt) {
      return { type: "all", config: { loggers: e3.loggers.map(pn) } };
    }
    return { type: "noop" };
  }
  function fn(e3) {
    return vn.test(e3);
  }
  function yn() {
    var e3;
    if ("function" == typeof (null == (e3 = globalThis.crypto) ? void 0 : e3.randomUUID)) return globalThis.crypto.randomUUID();
    const t2 = (function(e4) {
      var t3;
      if ("function" == typeof (null == (t3 = globalThis.crypto) ? void 0 : t3.getRandomValues)) return globalThis.crypto.getRandomValues(new Uint8Array(e4));
      if ("function" == typeof __require) try {
        const { randomBytes: t4 } = __require("crypto");
        return t4(e4);
      } catch {
      }
      const n4 = new Uint8Array(e4);
      for (let t4 = 0; t4 < e4; t4++) n4[t4] = Math.floor(256 * Math.random());
      return n4;
    })(16);
    t2[6] = 15 & t2[6] | 64, t2[8] = 63 & t2[8] | 128;
    const n3 = Array.from(t2, (e4) => e4.toString(16).padStart(2, "0")).join("");
    return `${n3.slice(0, 8)}-${n3.slice(8, 12)}-${n3.slice(12, 16)}-${n3.slice(16, 20)}-${n3.slice(20)}`;
  }
  function wn() {
  }
  function qn(e3, t2, n3) {
    const o3 = e3.activeDocumentId;
    if (o3 !== t2) return o3;
    if (void 0 !== n3) return n3 && e3.documents[n3] ? n3 : null;
    const i3 = e3.documentOrder.indexOf(t2);
    return -1 === i3 ? null : i3 > 0 ? e3.documentOrder[i3 - 1] : i3 < e3.documentOrder.length - 1 ? e3.documentOrder[i3 + 1] : null;
  }
  function Zn(e3, t2) {
    return { package: e3, config: t2 };
  }
  function Kn(e3) {
    return "autoMountElements" in e3 && "function" == typeof e3.autoMountElements;
  }
  function Jn(e3) {
    return "keyExtractor" in e3;
  }
  function eo(e3, t2, n3) {
    return e3 < t2 ? t2 : e3 > n3 ? n3 : e3;
  }
  function to(e3, t2, n3) {
    if (e3 === t2) return true;
    if (null == e3 || null == t2) return e3 === t2;
    const o3 = typeof e3;
    if (o3 !== typeof t2) return false;
    if ("object" === o3) {
      n3 || (n3 = /* @__PURE__ */ new Set());
      const o4 = (function(e4, t3) {
        return `${io(e4)}__${io(t3)}`;
      })(e3, t2);
      if (n3.has(o4)) return true;
      n3.add(o4);
      const i3 = Array.isArray(e3), r2 = Array.isArray(t2);
      return i3 && r2 ? (function(e4, t3, n4) {
        if (e4.length !== t3.length) return false;
        const o5 = new Array(t3.length).fill(false);
        e: for (let i4 = 0; i4 < e4.length; i4++) {
          const r3 = e4[i4];
          for (let e5 = 0; e5 < t3.length; e5++) if (!o5[e5] && to(r3, t3[e5], n4)) {
            o5[e5] = true;
            continue e;
          }
          return false;
        }
        return true;
      })(e3, t2, n3) : !i3 && !r2 && (function(e4, t3, n4) {
        const o5 = Object.keys(e4).sort(), i4 = Object.keys(t3).sort();
        if (o5.length !== i4.length) return false;
        for (let e5 = 0; e5 < o5.length; e5++) if (o5[e5] !== i4[e5]) return false;
        for (const i5 of o5) {
          if (!to(e4[i5], t3[i5], n4)) return false;
        }
        return true;
      })(e3, t2, n3);
    }
    return false;
  }
  function io(e3) {
    return oo.has(e3) || oo.set(e3, ++no), oo.get(e3);
  }
  function ro() {
    const e3 = /* @__PURE__ */ new Set();
    return { emit: (t2 = void 0) => e3.forEach((e4) => e4(t2)), on: (t2) => (e3.add(t2), () => e3.delete(t2)), off: (t2) => e3.delete(t2), clear: () => e3.clear() };
  }
  function ao(e3, t2 = to) {
    const n3 = /* @__PURE__ */ new Set(), o3 = /* @__PURE__ */ new Map();
    let i3 = e3;
    const r2 = (e4, t3) => {
      let r3 = e4, a3 = () => {
      };
      if (t3) {
        if (Jn(t3)) {
          const n4 = new Qn(e4, t3);
          r3 = n4.handle, a3 = () => n4.destroy();
        } else {
          const n4 = new Xn(e4, t3);
          r3 = n4.handle, a3 = () => n4.destroy();
        }
        o3.set(e4, { wrapped: r3, destroy: a3 });
      }
      return void 0 !== i3 && r3(i3), n3.add(r3), () => {
        n3.delete(r3), a3(), o3.delete(e4);
      };
    };
    return { get value() {
      return i3;
    }, emit(e4 = void 0) {
      void 0 !== i3 && t2(i3, e4) || (i3 = e4, ((e5) => {
        n3.forEach((t3) => t3(e5));
      })(e4));
    }, on: r2, off(e4) {
      const t3 = o3.get(e4);
      t3 ? (n3.delete(t3.wrapped), t3.destroy(), o3.delete(e4)) : n3.delete(e4);
    }, clear() {
      n3.clear(), o3.forEach((e4) => e4.destroy()), o3.clear();
    }, select: (e4, t3 = to) => (n4, o4) => {
      let a3;
      if (void 0 !== i3) {
        const t4 = e4(i3);
        a3 = t4, n4(t4);
      }
      return r2((o5) => {
        const i4 = e4(o5);
        void 0 !== a3 && t3(a3, i4) || (a3 = i4, n4(i4));
      }, o4);
    } };
  }
  function so(e3, t2) {
    const n3 = (null == t2 ? void 0 : t2.cache) ?? true, o3 = (null == t2 ? void 0 : t2.equality) ?? to, i3 = /* @__PURE__ */ new Map(), r2 = /* @__PURE__ */ new Map(), a3 = /* @__PURE__ */ new Map(), s4 = /* @__PURE__ */ new Set(), l4 = /* @__PURE__ */ new Map(), c4 = (e4) => String(e4);
    return { emit(t3, a4) {
      const l5 = c4(t3);
      if (n3) {
        const e4 = i3.get(l5);
        if (void 0 !== e4 && o3(e4, a4)) return;
        i3.set(l5, a4);
      }
      const d4 = r2.get(l5);
      d4 && d4.forEach((e4) => e4(a4));
      const u4 = e3(t3, a4);
      s4.forEach((e4) => e4(u4));
    }, forScope(e4) {
      const t3 = c4(e4);
      return (e5, o4) => {
        const s5 = ((e6) => {
          let t4 = r2.get(e6);
          return t4 || (t4 = /* @__PURE__ */ new Set(), r2.set(e6, t4)), t4;
        })(t3), l5 = ((e6) => {
          let t4 = a3.get(e6);
          return t4 || (t4 = /* @__PURE__ */ new Map(), a3.set(e6, t4)), t4;
        })(t3);
        let c5 = e5, d4 = () => {
        };
        if (o4) {
          if (Jn(o4)) {
            const t4 = new Qn(e5, o4);
            c5 = t4.handle, d4 = () => t4.destroy();
          } else {
            const t4 = new Xn(e5, o4);
            c5 = t4.handle, d4 = () => t4.destroy();
          }
          l5.set(e5, { wrapped: c5, destroy: d4 });
        }
        if (n3) {
          const e6 = i3.get(t3);
          void 0 !== e6 && c5(e6);
        }
        return s5.add(c5), () => {
          s5.delete(c5), d4(), l5.delete(e5), 0 === s5.size && r2.delete(t3), 0 === l5.size && a3.delete(t3);
        };
      };
    }, onGlobal: (e4, t3) => {
      let n4 = e4, o4 = () => {
      };
      if (t3) {
        if (Jn(t3)) {
          const i4 = new Qn(e4, t3);
          n4 = i4.handle, o4 = () => i4.destroy();
        } else {
          const i4 = new Xn(e4, t3);
          n4 = i4.handle, o4 = () => i4.destroy();
        }
        l4.set(e4, { wrapped: n4, destroy: o4 });
      }
      return s4.add(n4), () => {
        s4.delete(n4), o4(), l4.delete(e4);
      };
    }, getValue: (e4) => n3 ? i3.get(c4(e4)) : void 0, getScopes: () => n3 ? Array.from(i3.keys()) : Array.from(r2.keys()), clearScope(e4) {
      const t3 = c4(e4);
      n3 && i3.delete(t3);
      const o4 = r2.get(t3);
      o4 && (o4.clear(), r2.delete(t3));
      const s5 = a3.get(t3);
      s5 && (s5.forEach((e5) => e5.destroy()), s5.clear(), a3.delete(t3));
    }, clear() {
      n3 && i3.clear(), r2.forEach((e4) => e4.clear()), r2.clear(), a3.forEach((e4) => {
        e4.forEach((e5) => e5.destroy()), e4.clear();
      }), a3.clear(), s4.clear(), l4.forEach((e4) => e4.destroy()), l4.clear();
    } };
  }
  function co(e3) {
    return new lo(e3);
  }
  function ho({ plugins: e3, children: t2 }) {
    const { utilities: n3, wrappers: o3 } = Te(() => {
      const t3 = [], n4 = [];
      for (const o4 of e3) {
        const e4 = o4.package;
        if (Kn(e4)) {
          const o5 = e4.autoMountElements() || [];
          for (const e5 of o5) "utility" === e5.type ? t3.push(e5.component) : "wrapper" === e5.type && n4.push(e5.component);
        }
      }
      return { utilities: t3, wrappers: n4 };
    }, [e3]);
    return Ue(U2, { children: [o3.reduce((e4, t3) => Ue(t3, { children: e4 }), t2), n3.map((e4, t3) => Ue(e4, {}, `utility-${t3}`))] });
  }
  function mo({ engine: e3, logger: t2, onInitialized: n3, plugins: o3, children: i3, autoMountDomElements: r2 = true }) {
    const [a3, s4] = ke(null), [l4, c4] = ke(null), [d4, u4] = ke(true), [h3, m3] = ke(false), g3 = Ae(n3);
    Me(() => {
      g3.current = n3;
    }, [n3]), Me(() => {
      const n4 = new Vn(e3, { logger: t2 });
      n4.registerPluginBatch(o3);
      let i4;
      return (async () => {
        var e4;
        if (await n4.initialize(), n4.isDestroyed()) return;
        const t3 = n4.getStore();
        c4(t3.getState().core);
        const o4 = t3.subscribe((e5, n5, o5) => {
          t3.isCoreAction(e5) && n5.core !== o5.core && c4(n5.core);
        });
        if (await (null == (e4 = g3.current) ? void 0 : e4.call(g3, n4)), !n4.isDestroyed()) return n4.pluginsReady().then(() => {
          n4.isDestroyed() || m3(true);
        }), s4(n4), u4(false), o4;
        o4();
      })().then((e4) => {
        i4 = e4;
      }).catch(console.error), () => {
        null == i4 || i4(), n4.destroy(), s4(null), c4(null), u4(true), m3(false);
      };
    }, [e3, o3]);
    const p4 = Te(() => {
      const e4 = (null == l4 ? void 0 : l4.activeDocumentId) ?? null, t3 = (null == l4 ? void 0 : l4.documents) ?? {}, n4 = (null == l4 ? void 0 : l4.documentOrder) ?? [], o4 = e4 && t3[e4] ? t3[e4] : null, i4 = n4.map((e5) => t3[e5]).filter((e5) => null != e5);
      return { registry: a3, coreState: l4, isInitializing: d4, pluginsReady: h3, activeDocumentId: e4, activeDocument: o4, documents: t3, documentStates: i4 };
    }, [a3, l4, d4, h3]), v2 = "function" == typeof i3 ? i3(p4) : i3;
    return Ue(uo.Provider, { value: p4, children: h3 && r2 ? Ue(ho, { plugins: o3, children: v2 }) : v2 });
  }
  function go(e3) {
    const { registry: t2 } = (function() {
      const e4 = Ee(uo);
      if (void 0 === e4) throw new Error("useCapability must be used within a PDFContext.Provider");
      const { registry: t3, isInitializing: n4 } = e4;
      if (n4) return e4;
      if (null === t3) throw new Error("PDF registry failed to initialize properly");
      return e4;
    })();
    if (null === t2) return { plugin: null, isLoading: true, ready: new Promise(() => {
    }) };
    const n3 = t2.getPlugin(e3);
    if (!n3) throw new Error(`Plugin ${e3} not found`);
    return { plugin: n3, isLoading: false, ready: n3.ready() };
  }
  function po(e3) {
    const { plugin: t2, isLoading: n3, ready: o3 } = go(e3);
    if (!t2) return { provides: null, isLoading: n3, ready: o3 };
    if (!t2.provides) throw new Error(`Plugin ${e3} does not provide a capability`);
    return { provides: t2.provides(), isLoading: n3, ready: o3 };
  }
  function vo() {
    const { coreState: e3 } = Ee(uo);
    return e3;
  }
  function fo(e3) {
    const t2 = vo();
    return Te(() => t2 && e3 ? t2.documents[e3] ?? null : null, [t2, e3]);
  }
  function Eo(e3, t2) {
    return { type: Ao, payload: { documentId: e3, isSmoothScrolling: t2 } };
  }
  function jo(e3) {
    const { plugin: t2 } = go(Oo.id), n3 = Ae(null);
    return Pe(() => {
      if (!t2) return;
      const o3 = n3.current;
      if (!o3) return;
      try {
        t2.registerViewport(e3);
      } catch (t3) {
        return void console.error(`Failed to register viewport for document ${e3}:`, t3);
      }
      const i3 = () => {
        t2.setViewportScrollMetrics(e3, { scrollTop: o3.scrollTop, scrollLeft: o3.scrollLeft });
      };
      o3.addEventListener("scroll", i3);
      const r2 = new ResizeObserver(() => {
        t2.setViewportResizeMetrics(e3, { width: o3.offsetWidth, height: o3.offsetHeight, clientWidth: o3.clientWidth, clientHeight: o3.clientHeight, scrollTop: o3.scrollTop, scrollLeft: o3.scrollLeft, scrollWidth: o3.scrollWidth, scrollHeight: o3.scrollHeight, clientLeft: o3.clientLeft, clientTop: o3.clientTop });
      });
      r2.observe(o3);
      const a3 = t2.onScrollRequest(e3, ({ x: e4, y: t3, behavior: n4 = "auto" }) => {
        requestAnimationFrame(() => {
          o3.scrollTo({ left: e4, top: t3, behavior: n4 });
        });
      });
      return () => {
        t2.unregisterViewport(e3), r2.disconnect(), o3.removeEventListener("scroll", i3), a3();
      };
    }, [t2, e3]), n3;
  }
  function Ho({ children: e3, documentId: t2, ...n3 }) {
    const [o3, i3] = ke(0), r2 = jo(t2), { provides: a3 } = Fo(), s4 = ((e4) => {
      const { provides: t3 } = Fo(), [n4, o4] = ke((null == t3 ? void 0 : t3.isGated(e4)) ?? false);
      return Me(() => {
        if (t3) return o4(t3.isGated(e4)), t3.onGateChange((t4) => {
          t4.documentId === e4 && o4(t4.isGated);
        });
      }, [t3, e4]), n4;
    })(t2);
    Me(() => {
      a3 && i3(a3.getViewportGap());
    }, [a3]);
    const { style: l4, ...c4 } = n3;
    return Ue($o.Provider, { value: r2, children: Ue("div", { ...c4, ref: r2, style: { width: "100%", height: "100%", overflow: "auto", ..."object" == typeof l4 ? l4 : {}, padding: `${o3}px` }, children: !s4 && e3 }) });
  }
  function Yo(e3, t2) {
    return { type: Zo, payload: { documentId: e3, state: t2 } };
  }
  function ii({ documentId: e3, renderPage: t2, ...n3 }) {
    const { plugin: o3 } = go(Jo.id), [i3, r2] = ke({ layout: null, docId: null });
    Me(() => {
      if (!o3 || !e3) return;
      const t3 = o3.onScrollerData(e3, (t4) => {
        r2({ layout: t4, docId: e3 });
      });
      return () => {
        t3(), r2({ layout: null, docId: null }), o3.clearLayoutReady(e3);
      };
    }, [o3, e3]);
    const a3 = i3.docId === e3 ? i3.layout : null;
    return Pe(() => {
      o3 && e3 && a3 && o3.setLayoutReady(e3);
    }, [o3, e3, a3]), a3 ? Ue("div", { ...n3, style: { width: `${a3.totalWidth}px`, height: `${a3.totalHeight}px`, position: "relative", boxSizing: "border-box", margin: "0 auto", ...a3.strategy === Uo.Horizontal && { display: "flex", flexDirection: "row" } }, children: [Ue("div", { style: { ...a3.strategy === Uo.Horizontal ? { width: a3.startSpacing, height: "100%", flexShrink: 0 } : { height: a3.startSpacing, width: "100%" } } }), Ue("div", { style: { gap: a3.pageGap, display: "flex", alignItems: "center", position: "relative", boxSizing: "border-box", ...a3.strategy === Uo.Horizontal ? { flexDirection: "row", minHeight: "100%" } : { flexDirection: "column", minWidth: "fit-content" } }, children: a3.items.map((e4) => Ue("div", { style: { display: "flex", justifyContent: "center", gap: a3.pageGap }, children: e4.pageLayouts.map((e5) => Ue("div", { style: { width: `${e5.rotatedWidth}px`, height: `${e5.rotatedHeight}px` }, children: t2({ ...e5 }) }, e5.pageNumber)) }, e4.pageNumbers[0])) }), Ue("div", { style: { ...a3.strategy === Uo.Horizontal ? { width: a3.endSpacing, height: "100%", flexShrink: 0 } : { height: a3.endSpacing, width: "100%" } } })] }) : null;
  }
  function di(e3, t2) {
    return { type: ci, payload: { documentId: e3, grouping: t2 } };
  }
  function ji(e3, t2) {
    if (!t2) return e3;
    const n3 = { ...e3 };
    for (const [e4, o3] of Object.entries(t2)) n3[e4] ? n3[e4] = { ...n3[e4], ...o3, items: o3.items ?? n3[e4].items, responsive: o3.responsive ?? n3[e4].responsive } : n3[e4] = o3;
    return n3;
  }
  function Hi(e3, t2) {
    if (!t2) return e3;
    const n3 = { ...e3 };
    for (const [e4, o3] of Object.entries(t2)) n3[e4] ? n3[e4] = { ...n3[e4], ...o3, items: o3.items ?? n3[e4].items } : n3[e4] = o3;
    return n3;
  }
  function Ui(e3, t2) {
    if (!t2) return e3;
    const n3 = { ...e3 };
    for (const [e4, o3] of Object.entries(t2)) n3[e4] ? n3[e4] = { ...n3[e4], ...o3, content: o3.content ?? n3[e4].content } : n3[e4] = o3;
    return n3;
  }
  function Wi(e3, t2) {
    var n3;
    if (!(null == (n3 = e3.responsive) ? void 0 : n3.breakpoints)) return null;
    const o3 = (function(e4, t3, n4) {
      if (!n4 || !(null == t3 ? void 0 : t3.groups)) return e4;
      const o4 = t3.groups.find((e5) => e5.locales.includes(n4));
      if (!o4) return e4;
      const i4 = {};
      for (const [t4, n5] of Object.entries(e4)) {
        const e5 = o4.breakpoints[t4];
        e5 ? i4[t4] = { minWidth: n5.minWidth, maxWidth: n5.maxWidth, hide: e5.replaceHide ? e5.replaceHide : [...n5.hide || [], ...e5.hide || []], show: e5.replaceShow ? e5.replaceShow : [...n5.show || [], ...e5.show || []] } : i4[t4] = n5;
      }
      return i4;
    })(e3.responsive.breakpoints, e3.responsive.localeOverrides, t2), i3 = /* @__PURE__ */ new Map(), r2 = /* @__PURE__ */ new Map();
    for (const [e4, t3] of Object.entries(o3)) r2.set(e4, { minWidth: t3.minWidth, maxWidth: t3.maxWidth });
    const a3 = /* @__PURE__ */ new Set(), s4 = (e4) => {
      e4.forEach((e5) => {
        a3.add(e5.id), "group" === e5.type && e5.items && s4(e5.items), "tab-group" === e5.type && e5.tabs && s4(e5.tabs), "section" === e5.type && e5.items && s4(e5.items);
      });
    };
    s4(e3.items);
    for (const e4 of a3) {
      const t3 = [];
      let n4 = true;
      const r3 = Array.from(Object.entries(o3)).sort((e5, t4) => (e5[1].minWidth ?? 0) - (t4[1].minWidth ?? 0));
      r3.forEach(([o4, i4], r4) => {
        var a4, s5;
        const l4 = null == (a4 = i4.hide) ? void 0 : a4.includes(e4), c4 = null == (s5 = i4.show) ? void 0 : s5.includes(e4);
        (l4 || c4) && (t3.push({ breakpointId: o4, minWidth: i4.minWidth, maxWidth: i4.maxWidth, visible: c4 || !l4, priority: r4 }), 0 === r4 && (n4 = c4 || !l4));
      }), t3.length > 0 && i3.set(e4, { itemId: e4, shouldRender: true, visibilityRules: t3, defaultVisible: n4 });
    }
    return { items: i3, breakpoints: r2 };
  }
  function Qi(e3, t2 = {}) {
    const n3 = { ...Xi, ...t2.config }, o3 = t2.locale, i3 = er(e3, o3), r2 = [];
    r2.push((function(e4) {
      const t3 = e4 ? ` (locale: ${e4})` : "";
      return `/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */
/* EmbedPDF UI Stylesheet - Auto-generated${t3}                         */
/* DO NOT EDIT MANUALLY - This file is generated from your UI schema            */
/* \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 */`;
    })(o3));
    const a3 = (function(e4, t3) {
      const n4 = [], o4 = t3.useContainerQueries ? "@container" : "@media", i4 = /* @__PURE__ */ new Set();
      return e4.responsiveItems.forEach((e5, t4) => {
        if (i4.has(t4)) return;
        i4.add(t4);
        const r3 = (function(e6, t5, n5) {
          if (0 === t5.visibilityRules.length) return null;
          const o5 = [], i5 = Yi.ITEM(e6);
          t5.defaultVisible || o5.push(`${i5} { display: none; }`);
          for (const e7 of t5.visibilityRules) {
            const t6 = [];
            if (void 0 !== e7.minWidth && t6.push(`(min-width: ${e7.minWidth}px)`), void 0 !== e7.maxWidth && t6.push(`(max-width: ${e7.maxWidth}px)`), t6.length > 0) {
              const r4 = e7.visible ? "flex" : "none";
              o5.push(`${n5} ${t6.join(" and ")} {
  ${i5} { display: ${r4}; }
}`);
            }
          }
          return o5.length > 0 ? o5.join("\n") : null;
        })(t4, e5, o4);
        r3 && n4.push(r3);
      }), 0 === n4.length ? "" : `/* \u2500\u2500\u2500 Responsive Visibility Rules \u2500\u2500\u2500 */
/* Items show/hide based on container width */

${n4.join("\n\n")}`;
    })(i3, n3);
    a3 && r2.push(a3);
    const s4 = (function(e4) {
      if (0 === e4.categories.size) return "";
      const t3 = [], n4 = Array.from(e4.categories).sort();
      for (const e5 of n4) t3.push(`${Yi.ROOT}[${Zi}~="${e5}"] [${Vi}~="${e5}"] {
  display: none !important;
}`);
      return `/* \u2500\u2500\u2500 Category Visibility Rules \u2500\u2500\u2500 */
/* Items hide when ANY of their categories is disabled */
/* Use: data-disabled-categories="category1 category2" on root element */

${t3.join("\n\n")}`;
    })(i3);
    s4 && r2.push(s4);
    const l4 = (function(e4, t3) {
      if (0 === e4.dependencies.length) return "";
      const n4 = [], o4 = t3.useContainerQueries ? "@container" : "@media";
      for (const t4 of e4.dependencies) {
        const i4 = hr(t4, e4, o4);
        i4.length > 0 && n4.push(...i4);
      }
      return 0 === n4.length ? "" : `/* \u2500\u2500\u2500 Dependency Visibility Rules \u2500\u2500\u2500 */
/* Container elements hide when all their dependencies are hidden */

${n4.join("\n\n")}`;
    })(i3, n3);
    return l4 && r2.push(l4), r2.filter((e4) => e4.trim()).join("\n\n");
  }
  function Ji(e3, t2) {
    const n3 = new Set(t2), o3 = [];
    return e3.forEach((e4, t3) => {
      e4.some((e5) => n3.has(e5)) && o3.push(t3);
    }), o3;
  }
  function er(e3, t2) {
    const n3 = /* @__PURE__ */ new Set(), o3 = /* @__PURE__ */ new Map(), i3 = [], r2 = /* @__PURE__ */ new Map(), a3 = /* @__PURE__ */ new Map();
    for (const [s4, l4] of Object.entries(e3.menus)) tr(s4, l4, n3, o3, i3, r2, a3, t2);
    for (const [r3, s4] of Object.entries(e3.toolbars)) rr(r3, s4, n3, o3, i3, a3, t2);
    for (const [t3, r3] of Object.entries(e3.sidebars)) lr(t3, r3, n3, o3, i3);
    for (const [r3, s4] of Object.entries(e3.selectionMenus || {})) cr(r3, s4, n3, o3, i3, a3, t2);
    return { categories: n3, itemCategories: o3, dependencies: i3, menuBreakpoints: r2, responsiveItems: a3 };
  }
  function tr(e3, t2, n3, o3, i3, r2, a3, s4) {
    ur(e3, t2.categories, t2.visibilityDependsOn, n3, o3, i3), nr(t2.items, n3, o3, i3);
    const l4 = Wi(t2, s4);
    l4 && l4.items.forEach((e4, t3) => {
      a3.set(t3, e4);
    });
    const c4 = (function(e4, t3, n4) {
      var o4;
      const i4 = [], r3 = Wi(e4, n4);
      if ((null == (o4 = e4.responsive) ? void 0 : o4.breakpoints) && r3) {
        const e5 = Array.from(r3.breakpoints.entries()).sort((e6, t4) => (e6[1].minWidth ?? 0) - (t4[1].minWidth ?? 0));
        for (const [n5, o5] of e5) {
          const e6 = ir(r3, o5), n6 = /* @__PURE__ */ new Set();
          for (const o6 of e6) {
            const e7 = t3.get(o6);
            e7 && e7.forEach((e8) => n6.add(e8));
          }
          i4.push({ minWidth: o5.minWidth, maxWidth: o5.maxWidth, visibleItemIds: e6, visibleCategories: n6 });
        }
      } else {
        const n5 = [], o5 = /* @__PURE__ */ new Set();
        or(e4.items, t3, n5, o5), i4.push({ visibleItemIds: n5, visibleCategories: o5 });
      }
      return i4;
    })(t2, o3, s4);
    r2.set(e3, c4);
  }
  function nr(e3, t2, n3, o3) {
    for (const i3 of e3) ur(i3.id, i3.categories, i3.visibilityDependsOn, t2, n3, o3), "section" === i3.type && nr(i3.items, t2, n3, o3);
  }
  function or(e3, t2, n3, o3) {
    for (const i3 of e3) {
      n3.push(i3.id);
      const e4 = t2.get(i3.id);
      e4 && e4.forEach((e5) => o3.add(e5)), "section" === i3.type && or(i3.items, t2, n3, o3);
    }
  }
  function ir(e3, t2) {
    const n3 = [];
    return e3.items.forEach((e4, o3) => {
      let i3 = e4.defaultVisible;
      for (const n4 of e4.visibilityRules) {
        (void 0 === n4.minWidth || void 0 !== t2.minWidth && t2.minWidth >= n4.minWidth) && (void 0 === n4.maxWidth || void 0 !== t2.maxWidth && t2.maxWidth <= n4.maxWidth) && (i3 = n4.visible);
      }
      i3 && n3.push(o3);
    }), n3;
  }
  function rr(e3, t2, n3, o3, i3, r2, a3) {
    ur(e3, t2.categories, t2.visibilityDependsOn, n3, o3, i3);
    const s4 = Wi(t2, a3);
    s4 && s4.items.forEach((e4, t3) => {
      r2.set(t3, e4);
    }), ar(t2.items, n3, o3, i3);
  }
  function ar(e3, t2, n3, o3) {
    for (const i3 of e3) ur(i3.id, i3.categories, i3.visibilityDependsOn, t2, n3, o3), "group" === i3.type && i3.items && ar(i3.items, t2, n3, o3), "tab-group" === i3.type && i3.tabs && sr(i3.tabs, t2, n3, o3);
  }
  function sr(e3, t2, n3, o3) {
    for (const i3 of e3) ur(i3.id, i3.categories, i3.visibilityDependsOn, t2, n3, o3);
  }
  function lr(e3, t2, n3, o3, i3) {
    if (ur(e3, t2.categories, t2.visibilityDependsOn, n3, o3, i3), "tabs" === t2.content.type) for (const e4 of t2.content.tabs) ur(e4.id, e4.categories, e4.visibilityDependsOn, n3, o3, i3);
  }
  function cr(e3, t2, n3, o3, i3, r2, a3) {
    if (ur(e3, t2.categories, t2.visibilityDependsOn, n3, o3, i3), t2.responsive) {
      const e4 = Wi(t2, a3);
      e4 && e4.items.forEach((e5, t3) => {
        r2.set(t3, e5);
      });
    }
    dr(t2.items, n3, o3, i3);
  }
  function dr(e3, t2, n3, o3) {
    for (const i3 of e3) ur(i3.id, i3.categories, i3.visibilityDependsOn, t2, n3, o3), "group" === i3.type && i3.items && dr(i3.items, t2, n3, o3);
  }
  function ur(e3, t2, n3, o3, i3, r2) {
    var a3;
    (null == t2 ? void 0 : t2.length) && (t2.forEach((e4) => o3.add(e4)), i3.set(e3, t2)), n3 && (n3.menuId || (null == (a3 = n3.itemIds) ? void 0 : a3.length)) && r2.push({ itemId: e3, dependsOnMenuId: n3.menuId, dependsOnItemIds: n3.itemIds });
  }
  function hr(e3, t2, n3, o3) {
    var i3;
    const r2 = [];
    if (e3.dependsOnMenuId) {
      const o4 = t2.menuBreakpoints.get(e3.dependsOnMenuId);
      if (o4 && o4.length > 0) {
        r2.push(`/* "${e3.itemId}" depends on menu "${e3.dependsOnMenuId}" */`);
        for (const t3 of o4) {
          if (0 === t3.visibleItemIds.length) continue;
          const o5 = t3.visibleItemIds.sort().map((e4) => Yi.HIDDEN_ITEM(e4)).join(""), i4 = `${Yi.ROOT}${o5} ${Yi.ITEM(e3.itemId)} {
  display: none !important;
}`, a3 = [];
          void 0 !== t3.minWidth && a3.push(`(min-width: ${t3.minWidth}px)`), void 0 !== t3.maxWidth && a3.push(`(max-width: ${t3.maxWidth}px)`), a3.length > 0 ? r2.push(`${n3} ${a3.join(" and ")} {
  ${i4}
}`) : r2.push(i4);
        }
      }
    }
    if (null == (i3 = e3.dependsOnItemIds) ? void 0 : i3.length) {
      r2.push(`/* "${e3.itemId}" depends on items: ${e3.dependsOnItemIds.join(", ")} */`);
      const t3 = e3.dependsOnItemIds.sort().map((e4) => Yi.HIDDEN_ITEM(e4)).join("");
      r2.push(`${Yi.ROOT}${t3} ${Yi.ITEM(e3.itemId)} {
  display: none !important;
}`);
    }
    return r2;
  }
  function mr(e3, t2) {
    var n3;
    return { [Gi]: e3.id, [Vi]: (null == (n3 = e3.categories) ? void 0 : n3.join(" ")) || void 0, ...t2 };
  }
  function yr(e3, t2) {
    const n3 = (function(e4) {
      return e4.ui ?? null;
    })(e3);
    return (null == n3 ? void 0 : n3.documents[t2]) ?? null;
  }
  function br(e3, t2) {
    return `${e3}-${t2}`;
  }
  function wr(e3, t2, n3, o3, i3) {
    const r2 = (function(e4, t3, n4, o4) {
      const i4 = yr(e4, t3);
      return i4 ? i4.activeToolbars[br(n4, o4)] ?? null : null;
    })(e3, t2, n3, o3);
    return !(!r2 || !r2.isOpen) && (!i3 || r2.toolbarId === i3);
  }
  function xr(e3, t2, n3, o3, i3) {
    const r2 = (function(e4, t3, n4, o4) {
      const i4 = yr(e4, t3);
      return i4 ? i4.activeSidebars[br(n4, o4)] ?? null : null;
    })(e3, t2, n3, o3);
    return !(!r2 || !r2.isOpen) && (!i3 || r2.sidebarId === i3);
  }
  function Dr() {
    const e3 = Ee(kr);
    if (!e3) throw new Error("useUIContainer must be used within a UIProvider");
    return e3;
  }
  function Pr({ children: e3 }) {
    const t2 = Ae(/* @__PURE__ */ new Map()), n3 = { register: ze((e4, n4, o3) => {
      const i3 = `${e4}:${n4}`;
      t2.current.set(i3, o3);
    }, []), unregister: ze((e4, n4) => {
      const o3 = `${e4}:${n4}`;
      t2.current.delete(o3);
    }, []), getAnchor: ze((e4, n4) => {
      const o3 = `${e4}:${n4}`;
      return t2.current.get(o3) || null;
    }, []) };
    return Ue(Mr.Provider, { value: n3, children: e3 });
  }
  function Ar() {
    const e3 = Ee(Mr);
    if (!e3) throw new Error("useAnchorRegistry must be used within UIProvider");
    return e3;
  }
  function Tr(e3, t2) {
    const n3 = Ar(), o3 = Ae(null), i3 = Ae(e3), r2 = Ae(t2);
    return i3.current = e3, r2.current = t2, ze((e4) => {
      const t3 = o3.current;
      o3.current = e4, e4 ? e4 !== t3 && n3.register(i3.current, r2.current, e4) : t3 && n3.unregister(i3.current, r2.current);
    }, [n3]);
  }
  function Er({ children: e3, initialComponents: t2 = {} }) {
    const n3 = Ae(new Map(Object.entries(t2))), o3 = { register: ze((e4, t3) => {
      n3.current.set(e4, t3);
    }, []), unregister: ze((e4) => {
      n3.current.delete(e4);
    }, []), get: ze((e4) => n3.current.get(e4), []), has: ze((e4) => n3.current.has(e4), []), getRegisteredIds: ze(() => Array.from(n3.current.keys()), []) };
    return Ue(zr.Provider, { value: o3, children: e3 });
  }
  function _r() {
    const e3 = (function() {
      const e4 = Ee(zr);
      if (!e4) throw new Error("useComponentRegistry must be used within UIProvider");
      return e4;
    })();
    return { renderCustomComponent: (t2, n3, o3) => {
      const i3 = e3.get(t2);
      return i3 ? Ue(i3, { documentId: n3, ...o3 || {} }) : (console.error(`Component "${t2}" not found in registry`), null);
    } };
  }
  function Nr({ children: e3, renderers: t2 }) {
    return Ue(Rr.Provider, { value: t2, children: e3 });
  }
  function Or() {
    const e3 = Ee(Rr);
    if (!e3) throw new Error("useRenderers must be used within UIProvider");
    return e3;
  }
  function Lr(e3, t2) {
    var n3;
    const { provides: o3 } = Ir(), i3 = Or(), r2 = ze((n4) => {
      var r3;
      const a4 = null == o3 ? void 0 : o3.getSchema(), s4 = null == (r3 = null == a4 ? void 0 : a4.selectionMenus) ? void 0 : r3[e3];
      if (!s4) return null;
      if (!n4.selected) return null;
      return Ue(i3.selectionMenu, { schema: s4, documentId: t2, props: n4 });
    }, [o3, i3, e3, t2]), a3 = null == o3 ? void 0 : o3.getSchema();
    if (null == (n3 = null == a3 ? void 0 : a3.selectionMenus) ? void 0 : n3[e3]) return r2;
  }
  function $r({ container: e3, documentId: t2 }) {
    const n3 = Sr(t2), { provides: o3 } = Ir(), i3 = Ar(), r2 = Or(), [a3, s4] = ke(null), l4 = (null == n3 ? void 0 : n3.openMenus) || {}, c4 = null == o3 ? void 0 : o3.getSchema();
    Me(() => {
      const e4 = Object.keys(l4);
      if (e4.length > 0) {
        const n4 = e4[0];
        if (!n4) return void s4(null);
        const o4 = l4[n4];
        if (o4 && o4.triggeredByItemId) {
          const e5 = i3.getAnchor(t2, o4.triggeredByItemId);
          s4({ menuId: n4, anchorEl: e5 });
        } else s4(null);
      } else s4(null);
    }, [l4, i3, t2]);
    if (!a3 || !c4) return null;
    const d4 = c4.menus[a3.menuId];
    if (!d4) return console.warn(`Menu "${a3.menuId}" not found in schema`), null;
    return Ue(r2.menu, { schema: d4, documentId: t2, anchorEl: a3.anchorEl, onClose: () => {
      a3 && (null == o3 || o3.forDocument(t2).closeMenu(a3.menuId));
    }, container: e3 });
  }
  function Fr({ children: e3, style: t2, ...n3 }) {
    const { plugin: o3 } = go(pr.id), { provides: i3 } = Ir(), [r2, a3] = ke([]), [s4, l4] = ke([]), c4 = Ae(null), d4 = Ae(null), u4 = Ae(null), h3 = Ae(null), m3 = Te(() => ({ containerRef: h3, getContainer: () => h3.current }), []), g3 = ze((e4) => {
      const t3 = u4.current;
      if (u4.current = e4, h3.current = e4, e4 && e4 !== t3 && o3) {
        const t4 = (function(e5) {
          const t5 = e5.getRootNode();
          return t5 instanceof ShadowRoot ? t5 : document.head;
        })(e4);
        d4.current = t4;
        const n4 = t4.querySelector(Yi.STYLES);
        if (n4) return c4.current = n4, void (n4.textContent = o3.getStylesheet());
        const i4 = o3.getStylesheet(), r3 = document.createElement("style");
        r3.setAttribute(qi, ""), r3.textContent = i4, t4 instanceof ShadowRoot ? t4.insertBefore(r3, t4.firstChild) : t4.appendChild(r3), c4.current = r3;
      }
    }, [o3]);
    Me(() => () => {
      var e4;
      (null == (e4 = c4.current) ? void 0 : e4.parentNode) && !u4.current && c4.current.remove(), c4.current = null, d4.current = null;
    }, []), Me(() => {
      if (o3) return o3.onStylesheetInvalidated(() => {
        c4.current && (c4.current.textContent = o3.getStylesheet());
      });
    }, [o3]), Me(() => {
      if (i3) return a3(i3.getDisabledCategories()), l4(i3.getHiddenItems()), i3.onCategoryChanged(({ disabledCategories: e4, hiddenItems: t3 }) => {
        a3(e4), l4(t3);
      });
    }, [i3]);
    const p4 = Te(() => r2.length > 0 ? r2.join(" ") : void 0, [r2]), v2 = Te(() => s4.length > 0 ? s4.join(" ") : void 0, [s4]), f2 = Te(() => {
      const e4 = { containerType: "inline-size" };
      return t2 && "object" == typeof t2 ? { ...e4, ...t2 } : e4;
    }, [t2]), y2 = { [Bi]: "", [Zi]: p4, [Ki]: v2 };
    return Ue(kr.Provider, { value: m3, children: Ue("div", { ref: g3, ...y2, ...n3, style: f2, children: e3 }) });
  }
  function jr({ children: e3, documentId: t2, components: n3 = {}, renderers: o3, menuContainer: i3, ...r2 }) {
    return Ue(Pr, { children: Ue(Er, { initialComponents: n3, children: Ue(Nr, { renderers: o3, children: Ue(Fr, { ...r2, children: [e3, Ue($r, { documentId: t2, container: i3 })] }) }) }) });
  }
  function Br({ documentId: e3, children: t2 }) {
    const n3 = fo(e3);
    if (!n3) return null;
    return Ue(U2, { children: t2({ documentState: n3, isLoading: "loading" === n3.status, isError: "error" === n3.status, isLoaded: "loaded" === n3.status }) });
  }
  function Pa(e3) {
    const [t2, n3] = [e3[0], e3[1]], o3 = n3.clientX - t2.clientX, i3 = n3.clientY - t2.clientY;
    return Math.hypot(o3, i3);
  }
  function Aa(e3, t2 = {}) {
    const { provides: n3 } = po("viewport"), { provides: o3 } = Ma(), i3 = Ee($o), r2 = Ae(null);
    return Pe(() => {
      const a3 = r2.current, s4 = null == i3 ? void 0 : i3.current;
      if (a3 && s4 && o3) return (function({ element: e4, container: t3, documentId: n4, zoomProvides: o4, viewportGap: i4 = 0, options: r3 = {} }) {
        const { enablePinch: a4 = true, enableWheel: s5 = true } = r3;
        if ("undefined" == typeof window) return () => {
        };
        const l4 = o4.forDocument(n4), c4 = () => l4.getState();
        let d4 = 0, u4 = 1, h3 = false, m3 = 0, g3 = null, p4 = 1, v2 = 0, f2 = 0, y2 = 0, b2 = 0, w2 = 0, x2 = 0, C2 = 0, I2 = 0, S2 = 0, k2 = 0, D2 = 0, M2 = 0, P2 = 0;
        const A2 = (e5, t4, n5) => Math.min(Math.max(e5, t4), n5), T2 = () => {
          const n5 = t3.clientWidth - 2 * i4, o5 = e4.offsetWidth, r4 = o5 < n5 ? (n5 - o5) / 2 : 0;
          e4.style.marginLeft = `${r4}px`;
        }, z3 = (e5) => {
          const t4 = v2 * e5, n5 = f2 * e5;
          let o5 = S2 * (1 - e5);
          const i5 = I2 - t4 / 2 - y2, r4 = k2 - P2 * e5 - y2, a5 = Math.max(0, t4 - C2), s6 = 0.3 * C2, l5 = Math.min(1, a5 / s6);
          let c5 = i5 + (r4 - i5) * l5;
          return n5 > x2 - 2 * M2 && (o5 = A2(b2 + o5, x2 - M2 - n5, M2) - b2), t4 > w2 - 2 * M2 && (c5 = A2(y2 + c5, w2 - M2 - t4, M2) - y2), { tx: c5, ty: o5, blend: l5, finalWidth: t4 };
        }, E2 = (t4) => {
          u4 = t4;
          const { tx: n5, ty: o5 } = z3(t4);
          e4.style.transformOrigin = "0 0", e4.style.transform = `translate(${n5}px, ${o5}px) scale(${t4})`;
        }, _2 = () => {
          e4.style.transform = "none", e4.style.transformOrigin = "0 0", u4 = 1;
        }, R2 = () => {
          const { tx: e5, finalWidth: t4 } = z3(u4), n5 = (u4 - 1) * d4;
          let o5, i5 = D2;
          if (t4 <= C2) o5 = I2;
          else {
            const t5 = 1 - u4;
            o5 = Math.abs(t5) > 1e-3 ? y2 + e5 / t5 : k2;
          }
          l4.requestZoomBy(n5, { vx: o5, vy: i5 }), _2(), d4 = 0;
        }, N3 = (n5, o5) => {
          const r4 = t3.getBoundingClientRect(), a5 = e4.getBoundingClientRect();
          M2 = i4, v2 = a5.width, f2 = a5.height, y2 = a5.left - r4.left, b2 = a5.top - r4.top, w2 = r4.width, x2 = r4.height, C2 = t3.clientWidth, I2 = t3.clientLeft + C2 / 2;
          const s6 = n5 - a5.left;
          S2 = o5 - a5.top, k2 = n5 - r4.left, D2 = o5 - r4.top, P2 = v2 < C2 ? k2 * v2 / C2 : s6;
        }, O2 = (e5) => {
          if (2 !== e5.touches.length) return;
          h3 = true, d4 = c4().currentZoomLevel, m3 = Pa(e5.touches);
          const t4 = (function(e6) {
            const [t5, n5] = [e6[0], e6[1]];
            return { x: (t5.clientX + n5.clientX) / 2, y: (t5.clientY + n5.clientY) / 2 };
          })(e5.touches);
          N3(t4.x, t4.y), e5.preventDefault();
        }, L3 = (e5) => {
          if (!h3 || 2 !== e5.touches.length) return;
          const t4 = Pa(e5.touches);
          E2(t4 / m3), e5.preventDefault();
        }, $3 = (e5) => {
          h3 && (e5.touches.length >= 2 || (h3 = false, R2()));
        }, F2 = (e5) => {
          if (!e5.ctrlKey && !e5.metaKey) return;
          e5.preventDefault(), null === g3 ? (d4 = c4().currentZoomLevel, p4 = 1, N3(e5.clientX, e5.clientY)) : clearTimeout(g3);
          const t4 = 1 - 0.01 * e5.deltaY;
          p4 *= t4, p4 = Math.max(0.1, Math.min(10, p4)), E2(p4), g3 = setTimeout(() => {
            g3 = null, R2(), p4 = 1;
          }, 150);
        }, j3 = l4.onStateChange(() => T2()), H3 = new ResizeObserver(() => T2());
        return H3.observe(e4), H3.observe(t3), T2(), a4 && (t3.addEventListener("touchstart", O2, { passive: false }), t3.addEventListener("touchmove", L3, { passive: false }), t3.addEventListener("touchend", $3), t3.addEventListener("touchcancel", $3)), s5 && t3.addEventListener("wheel", F2, { passive: false }), () => {
          a4 && (t3.removeEventListener("touchstart", O2), t3.removeEventListener("touchmove", L3), t3.removeEventListener("touchend", $3), t3.removeEventListener("touchcancel", $3)), s5 && t3.removeEventListener("wheel", F2), g3 && clearTimeout(g3), j3(), H3.disconnect(), _2(), e4.style.marginLeft = "";
        };
      })({ element: a3, container: s4, documentId: e3, zoomProvides: o3, viewportGap: (null == n3 ? void 0 : n3.getViewportGap()) || 0, options: t2 });
    }, [n3, o3, e3, i3, t2.enablePinch, t2.enableWheel]), { elementRef: r2 };
  }
  function Ta({ children: e3, documentId: t2, style: n3, enablePinch: o3 = true, enableWheel: i3 = true, ...r2 }) {
    const a3 = Te(() => ({ enablePinch: o3, enableWheel: i3 }), [o3, i3]), { elementRef: s4 } = Aa(t2, a3);
    return Ue("div", { ref: s4, ...r2, style: { ...n3, display: "inline-block", overflow: "visible", boxSizing: "border-box" }, children: e3 });
  }
  function Oa({ documentId: e3, pageIndex: t2, scale: n3, dpr: o3, style: i3, ...r2 }) {
    const { provides: a3 } = po(_a.id), s4 = fo(e3), [l4, c4] = ke(null), d4 = Ae(null), u4 = Te(() => s4 && s4.pageRefreshVersions[t2] || 0, [s4, t2]), h3 = Te(() => void 0 !== n3 ? n3 : (null == s4 ? void 0 : s4.scale) ?? 1, [n3, null == s4 ? void 0 : s4.scale]), m3 = Te(() => void 0 !== o3 ? o3 : window.devicePixelRatio, [o3]);
    Me(() => {
      if (!a3) return;
      const n4 = a3.forDocument(e3).renderPage({ pageIndex: t2, options: { scaleFactor: h3, dpr: m3 } });
      return n4.wait((e4) => {
        const t3 = URL.createObjectURL(e4);
        c4(t3), d4.current = t3;
      }, wn), () => {
        d4.current ? (URL.revokeObjectURL(d4.current), d4.current = null) : n4.abort({ code: Ht.Cancelled, message: "canceled render task" });
      };
    }, [e3, t2, h3, m3, a3, u4]);
    return Ue(U2, { children: l4 && Ue("img", { src: l4, onLoad: () => {
      d4.current && (URL.revokeObjectURL(d4.current), d4.current = null);
    }, ...r2, style: { width: "100%", height: "100%", ...i3 || {} } }) });
  }
  function Ga({ children: e3, documentId: t2, pageIndex: n3, rotation: o3, scale: i3, style: r2, ...a3 }) {
    var s4, l4, c4, d4;
    const { plugin: u4 } = go(Wa.id), h3 = fo(t2), m3 = null == (l4 = null == (s4 = null == h3 ? void 0 : h3.document) ? void 0 : s4.pages) ? void 0 : l4[n3], g3 = (null == (c4 = null == m3 ? void 0 : m3.size) ? void 0 : c4.width) ?? 0, p4 = (null == (d4 = null == m3 ? void 0 : m3.size) ? void 0 : d4.height) ?? 0, v2 = o3 ?? (null == h3 ? void 0 : h3.rotation) ?? 0, f2 = i3 ?? (null == h3 ? void 0 : h3.scale) ?? 1, y2 = (null == u4 ? void 0 : u4.getMatrixAsString({ width: g3 * f2, height: p4 * f2, rotation: v2 })) ?? "matrix(1, 0, 0, 1, 0, 0)";
    return m3 ? Ue("div", { ...a3, style: { position: "absolute", transformOrigin: "0 0", transform: y2, ...r2 }, children: e3 }) : null;
  }
  function os(e3, t2) {
    return { type: Qa, payload: { documentId: e3, showAll: t2 } };
  }
  function is(e3, t2, n3, o3) {
    return { type: es, payload: { documentId: e3, results: t2, total: n3, activeResultIndex: o3 } };
  }
  function rs(e3, t2) {
    return { type: ns, payload: { documentId: e3, index: t2 } };
  }
  function gs({ documentId: e3, pageIndex: t2, scale: n3, style: o3, highlightColor: i3 = "#FFFF00", activeHighlightColor: r2 = "#FFBF00", ...a3 }) {
    const { provides: s4 } = ms(), [l4, c4] = ke(null), d4 = fo(e3), u4 = Te(() => null == s4 ? void 0 : s4.forDocument(e3), [s4, e3]), h3 = Te(() => void 0 !== n3 ? n3 : (null == d4 ? void 0 : d4.scale) ?? 1, [n3, null == d4 ? void 0 : d4.scale]);
    if (Me(() => {
      if (!u4) return void c4(null);
      const e4 = u4.getState();
      return c4({ results: e4.results, activeResultIndex: e4.activeResultIndex, showAllResults: e4.showAllResults, active: e4.active }), u4.onSearchResultStateChange((e5) => {
        c4(e5);
      });
    }, [u4]), !l4 || !l4.active) return null;
    return Ue("div", { style: { ...o3, pointerEvents: "none" }, ...a3, children: l4.results.map((e4, t3) => ({ result: e4, originalIndex: t3 })).filter(({ result: e4 }) => e4.pageIndex === t2).filter(({ originalIndex: e4 }) => l4.showAllResults || e4 === l4.activeResultIndex).map(({ result: e4, originalIndex: t3 }) => e4.rects.map((e5, n4) => Ue("div", { style: { position: "absolute", top: e5.origin.y * h3, left: e5.origin.x * h3, width: e5.size.width * h3, height: e5.size.height * h3, backgroundColor: t3 === l4.activeResultIndex ? r2 : i3, mixBlendMode: "multiply", transform: "scale(1.02)", transformOrigin: "center", transition: "opacity .3s ease-in-out", opacity: 1 } }, `${t3}-${n4}`))) });
  }
  function As(e3, t2) {
    return e3.rects[t2] ?? [];
  }
  function Ts(e3, t2) {
    return it(As(e3, t2));
  }
  function zs(e3) {
    const t2 = [], n3 = e3.rects;
    for (const e4 in n3) {
      const o3 = Number(e4), i3 = it(n3[o3]);
      i3 && t2.push({ page: o3, rect: i3 });
    }
    return t2;
  }
  function Es(e3, t2) {
    const n3 = e3.rects[t2] || [];
    if (0 === n3.length) return null;
    const o3 = Ts(e3, t2);
    return o3 ? { pageIndex: t2, rect: o3, segmentRects: n3 } : null;
  }
  function _s(e3) {
    const t2 = [], n3 = Object.keys(e3.rects).map(Number);
    for (const o3 of n3) {
      const n4 = e3.rects[o3] || [];
      if (0 === n4.length) continue;
      const i3 = Ts(e3, o3);
      i3 && t2.push({ pageIndex: o3, rect: i3, segmentRects: n4 });
    }
    return t2;
  }
  function Rs(e3, t2) {
    for (const n3 of e3.runs) {
      if (!(t2.y >= n3.rect.y && t2.y <= n3.rect.y + n3.rect.height && t2.x >= n3.rect.x && t2.x <= n3.rect.x + n3.rect.width)) continue;
      const e4 = n3.glyphs.findIndex((e5) => t2.x >= e5.x && t2.x <= e5.x + e5.width && t2.y >= e5.y && t2.y <= e5.y + e5.height);
      if (-1 !== e4) return n3.charStart + e4;
    }
    return -1;
  }
  function Ns(e3, t2, n3) {
    if (!e3 || !t2) return null;
    if (n3 < e3.start.page || n3 > e3.end.page) return null;
    const o3 = n3 === e3.start.page ? e3.start.index : 0, i3 = t2.runs[t2.runs.length - 1], r2 = i3.charStart + i3.glyphs.length - 1;
    return { from: o3, to: n3 === e3.end.page ? e3.end.index : r2 };
  }
  function Os(e3, t2, n3, o3 = true) {
    const i3 = [];
    for (const o4 of e3.runs) {
      const e4 = o4.charStart, r2 = e4 + o4.glyphs.length - 1;
      if (r2 < t2 || e4 > n3) continue;
      const a3 = Math.max(t2, e4) - e4, s4 = Math.min(n3, r2) - e4;
      let l4 = 1 / 0, c4 = -1 / 0, d4 = 1 / 0, u4 = -1 / 0, h3 = 0;
      for (let e5 = a3; e5 <= s4; e5++) {
        const t3 = o4.glyphs[e5];
        2 !== t3.flags && (l4 = Math.min(l4, t3.x), c4 = Math.max(c4, t3.x + t3.width), d4 = Math.min(d4, t3.y), u4 = Math.max(u4, t3.y + t3.height), h3++);
      }
      l4 !== 1 / 0 && h3 > 0 && i3.push({ rect: { origin: { x: l4, y: d4 }, size: { width: c4 - l4, height: u4 - d4 } }, charCount: h3 });
    }
    return o3 ? (function(e4) {
      const t3 = [];
      let n4 = null, o4 = null;
      for (const i4 of e4) n4 && o4 ? js(n4, i4) ? o4 = Ls(o4, i4.rect) : (t3.push(o4), o4 = i4.rect) : o4 = i4.rect, n4 = i4;
      o4 && !$s(o4) && t3.push(o4);
      return t3;
    })(i3) : i3.map((e4) => e4.rect);
  }
  function Ls(e3, t2) {
    const n3 = Math.min(e3.origin.x, t2.origin.x), o3 = Math.min(e3.origin.y, t2.origin.y);
    return { origin: { x: n3, y: o3 }, size: { width: Math.max(e3.origin.x + e3.size.width, t2.origin.x + t2.size.width) - n3, height: Math.max(e3.origin.y + e3.size.height, t2.origin.y + t2.size.height) - o3 } };
  }
  function $s(e3) {
    return e3.size.width <= 0 || e3.size.height <= 0;
  }
  function Fs(e3, t2) {
    if ($s(e3) || $s(t2)) return 0;
    const n3 = Ls(e3, t2);
    if (n3.size.height === e3.size.height || n3.size.height === t2.size.height) return 1;
    const o3 = (function(e4, t3) {
      const n4 = Math.max(e4.origin.x, t3.origin.x), o4 = Math.max(e4.origin.y, t3.origin.y), i3 = Math.min(e4.origin.x + e4.size.width, t3.origin.x + t3.size.width), r2 = Math.min(e4.origin.y + e4.size.height, t3.origin.y + t3.size.height);
      return { origin: { x: n4, y: o4 }, size: { width: Math.max(0, i3 - n4), height: Math.max(0, r2 - o4) } };
    })(e3, t2);
    return o3.size.height / n3.size.height;
  }
  function js(e3, t2) {
    const n3 = e3.rect, o3 = t2.rect;
    if (Fs(n3, o3) < 0.8) return false;
    const i3 = 1 * n3.size.width / e3.charCount, r2 = 1 * o3.size.width / t2.charCount, a3 = n3.origin.x - i3, s4 = n3.origin.x + n3.size.width + i3, l4 = o3.origin.x - r2;
    return a3 < o3.origin.x + o3.size.width + r2 && s4 > l4;
  }
  function qs({ children: e3, ...t2 }) {
    const { rect: n3, rotation: o3 } = t2, { matrix: i3, width: r2, height: a3 } = (function(e4, t3) {
      const { width: n4, height: o4 } = e4.size;
      switch (t3 % 4) {
        case 1:
          return { matrix: `matrix(0, -1, 1, 0, 0, ${o4})`, width: o4, height: n4 };
        case 2:
          return { matrix: `matrix(-1, 0, 0, -1, ${n4}, ${o4})`, width: n4, height: o4 };
        case 3:
          return { matrix: `matrix(0, 1, -1, 0, ${n4}, 0)`, width: o4, height: n4 };
        default:
          return { matrix: "matrix(1, 0, 0, 1, 0, 0)", width: n4, height: o4 };
      }
    })(n3, o3), s4 = Ae(null);
    Me(() => {
      const e4 = s4.current;
      if (!e4) return;
      const t3 = (e5) => {
        e5.stopPropagation();
      }, n4 = (e5) => {
        e5.stopPropagation();
      };
      return e4.addEventListener("pointerdown", t3, { capture: true }), e4.addEventListener("touchstart", n4, { capture: true }), () => {
        e4.removeEventListener("pointerdown", t3, { capture: true }), e4.removeEventListener("touchstart", n4, { capture: true });
      };
    }, []);
    return Ue(U2, { children: e3({ menuWrapperProps: { style: { position: "absolute", left: n3.origin.x, top: n3.origin.y, transform: i3, transformOrigin: "0 0", width: r2, height: a3, pointerEvents: "none", zIndex: 3 }, ref: (e4) => {
      s4.current = e4;
    } }, matrix: i3, rect: { origin: { x: n3.origin.x, y: n3.origin.y }, size: { width: r2, height: a3 } } }) });
  }
  function Vs(e3, t2) {
    return "n" === e3 || "s" === e3 ? "ns-resize" : "e" === e3 || "w" === e3 ? "ew-resize" : t2 % 2 == 0 ? { nw: "nwse-resize", ne: "nesw-resize", sw: "nesw-resize", se: "nwse-resize" }[e3] : { nw: "nesw-resize", ne: "nwse-resize", sw: "nwse-resize", se: "nesw-resize" }[e3];
  }
  function Zs(e3, t2, n3) {
    const o3 = -e3 / 2;
    return "center" === n3 ? o3 : "outside" === n3 ? o3 - t2 : o3 + t2;
  }
  function Ks(e3) {
    const { controller: t2, resizeUI: n3, vertexUI: o3, includeVertices: i3 = false, handleAttrs: r2, vertexAttrs: a3 } = e3, { dragProps: s4, createResizeProps: l4, createVertexProps: c4 } = (function(e4) {
      const { onUpdate: t3, enabled: n4 = true, ...o4 } = e4, i4 = Ae(null), r3 = Ae(t3);
      Me(() => {
        r3.current = t3;
      }, [t3]), Me(() => {
        i4.current ? i4.current.updateConfig(o4) : i4.current = new Gs(o4, (e5) => {
          var t4;
          return null == (t4 = r3.current) ? void 0 : t4.call(r3, e5);
        });
      }, [o4.element, o4.constraints, o4.maintainAspectRatio, o4.pageRotation, o4.scale, o4.vertices]);
      const a4 = ze((e5) => {
        var t4;
        n4 && (e5.preventDefault(), e5.stopPropagation(), null == (t4 = i4.current) || t4.startDrag(e5.clientX, e5.clientY), e5.currentTarget.setPointerCapture(e5.pointerId));
      }, [n4]), s5 = ze((e5) => {
        var t4;
        e5.preventDefault(), e5.stopPropagation(), null == (t4 = i4.current) || t4.move(e5.clientX, e5.clientY);
      }, []), l5 = ze((e5) => {
        var t4, n5, o5;
        e5.preventDefault(), e5.stopPropagation(), null == (t4 = i4.current) || t4.end(), null == (o5 = (n5 = e5.currentTarget).releasePointerCapture) || o5.call(n5, e5.pointerId);
      }, []), c5 = ze((e5) => ({ onPointerDown: (t4) => {
        var o5;
        n4 && (t4.preventDefault(), t4.stopPropagation(), null == (o5 = i4.current) || o5.startResize(e5, t4.clientX, t4.clientY), t4.currentTarget.setPointerCapture(t4.pointerId));
      }, onPointerMove: s5, onPointerUp: l5, onPointerCancel: l5 }), [n4, s5, l5]), d5 = ze((e5) => ({ onPointerDown: (t4) => {
        var o5;
        n4 && (t4.preventDefault(), t4.stopPropagation(), null == (o5 = i4.current) || o5.startVertexEdit(e5, t4.clientX, t4.clientY), t4.currentTarget.setPointerCapture(t4.pointerId));
      }, onPointerMove: s5, onPointerUp: l5, onPointerCancel: l5 }), [n4, s5, l5]);
      return { dragProps: n4 ? { onPointerDown: a4, onPointerMove: s5, onPointerUp: l5, onPointerCancel: l5 } : {}, createResizeProps: c5, createVertexProps: d5 };
    })(t2), d4 = Te(() => (function(e4, t3 = {}) {
      const { handleSize: n4 = 8, spacing: o4 = 1, offsetMode: i4 = "outside", includeSides: r3 = false, zIndex: a4 = 3, rotationAwareCursor: s5 = true } = t3, l5 = (e4.pageRotation ?? 0) % 4, c5 = (e5) => ({ [e5]: Zs(n4, o4, i4) + "px" });
      return [["nw", { ...c5("top"), ...c5("left") }], ["ne", { ...c5("top"), ...c5("right") }], ["sw", { ...c5("bottom"), ...c5("left") }], ["se", { ...c5("bottom"), ...c5("right") }], ...r3 ? [["n", { ...c5("top"), left: `calc(50% - ${n4 / 2}px)` }], ["s", { ...c5("bottom"), left: `calc(50% - ${n4 / 2}px)` }], ["w", { ...c5("left"), top: `calc(50% - ${n4 / 2}px)` }], ["e", { ...c5("right"), top: `calc(50% - ${n4 / 2}px)` }]] : []].map(([e5, t4]) => ({ handle: e5, style: { position: "absolute", width: n4 + "px", height: n4 + "px", borderRadius: "50%", zIndex: a4, cursor: s5 ? Vs(e5, l5) : "default", touchAction: "none", ...t4 }, attrs: { "data-epdf-handle": e5 } }));
    })(t2, n3).map((e4) => {
      var t3;
      return { key: null == (t3 = e4.attrs) ? void 0 : t3["data-epdf-handle"], style: e4.style, ...l4(e4.handle), ...e4.attrs ?? {}, ...(null == r2 ? void 0 : r2(e4.handle)) ?? {} };
    }), [t2.element.origin.x, t2.element.origin.y, t2.element.size.width, t2.element.size.height, t2.scale, t2.pageRotation, t2.maintainAspectRatio, null == n3 ? void 0 : n3.handleSize, null == n3 ? void 0 : n3.spacing, null == n3 ? void 0 : n3.offsetMode, null == n3 ? void 0 : n3.includeSides, null == n3 ? void 0 : n3.zIndex, null == n3 ? void 0 : n3.rotationAwareCursor, l4, r2]), u4 = Te(() => {
      if (!i3) return [];
      const e4 = (function(e5, t3 = {}, n4) {
        const { vertexSize: o4 = 12, zIndex: i4 = 4 } = t3, r3 = e5.element, a4 = e5.scale ?? 1;
        return (n4 ?? e5.vertices ?? []).map((e6, t4) => ({ handle: "nw", style: { position: "absolute", left: (e6.x - r3.origin.x) * a4 - o4 / 2 + "px", top: (e6.y - r3.origin.y) * a4 - o4 / 2 + "px", width: o4 + "px", height: o4 + "px", borderRadius: "50%", cursor: "pointer", zIndex: i4, touchAction: "none" }, attrs: { "data-epdf-vertex": t4 } }));
      })(t2, o3, t2.vertices);
      return e4.map((e5, t3) => ({ key: t3, style: e5.style, ...c4(t3), ...e5.attrs ?? {}, ...(null == a3 ? void 0 : a3(t3)) ?? {} }));
    }, [i3, t2.element.origin.x, t2.element.origin.y, t2.element.size.width, t2.element.size.height, t2.scale, t2.vertices, null == o3 ? void 0 : o3.vertexSize, null == o3 ? void 0 : o3.zIndex, c4, a3]);
    return { dragProps: s4, resize: d4, vertices: u4 };
  }
  function Xs({ documentId: e3, pageIndex: t2, scale: n3, rotation: o3, background: i3 = "rgba(33,150,243)", selectionMenu: r2 }) {
    const { plugin: a3 } = go(Us.id), s4 = fo(e3), [l4, c4] = ke([]), [d4, u4] = ke(null), [h3, m3] = ke(null);
    Me(() => {
      if (a3 && e3) return a3.registerSelectionOnPage({ documentId: e3, pageIndex: t2, onRectsChange: ({ rects: e4, boundingRect: t3 }) => {
        c4(e4), u4(t3);
      } });
    }, [a3, e3, t2]), Me(() => {
      if (a3 && e3) return a3.onMenuPlacement(e3, (e4) => {
        m3(e4);
      });
    }, [a3, e3]);
    const g3 = Te(() => void 0 !== n3 ? n3 : (null == s4 ? void 0 : s4.scale) ?? 1, [n3, null == s4 ? void 0 : s4.scale]), p4 = Te(() => void 0 !== o3 ? o3 : (null == s4 ? void 0 : s4.rotation) ?? We.Degree0, [o3, null == s4 ? void 0 : s4.rotation]), v2 = r2 && h3 && h3.pageIndex === t2 && h3.isVisible;
    return d4 ? Ue(U2, { children: [Ue("div", { style: { position: "absolute", left: d4.origin.x * g3, top: d4.origin.y * g3, width: d4.size.width * g3, height: d4.size.height * g3, mixBlendMode: "multiply", isolation: "isolate", pointerEvents: "none" }, children: l4.map((e4, t3) => Ue("div", { style: { position: "absolute", left: (e4.origin.x - d4.origin.x) * g3, top: (e4.origin.y - d4.origin.y) * g3, width: e4.size.width * g3, height: e4.size.height * g3, background: i3 } }, t3)) }), v2 && Ue(qs, { rect: { origin: { x: h3.rect.origin.x * g3, y: h3.rect.origin.y * g3 }, size: { width: h3.rect.size.width * g3, height: h3.rect.size.height * g3 } }, rotation: p4, children: (e4) => r2({ ...e4, context: { type: "selection", pageIndex: t2 }, selected: true, placement: h3 }) })] }) : null;
  }
  function ll({ tileSize: e3 = 768, overlapPx: t2 = 2.5, extraRings: n3 = 0, scale: o3, rotation: i3, page: r2, metric: a3 }) {
    const s4 = r2.size.width * o3, l4 = r2.size.height * o3, c4 = e3 - t2, d4 = (function(e4, t3, n4, o4) {
      return nt(tt(e4, t3, (4 - n4) % 4), 1 / o4);
    })(Ze(r2.size, i3, o3), { origin: { x: a3.scaled.pageX, y: a3.scaled.pageY }, size: { width: a3.scaled.visibleWidth, height: a3.scaled.visibleHeight } }, i3, 1), u4 = d4.origin.x, h3 = d4.origin.y, m3 = u4 + d4.size.width, g3 = h3 + d4.size.height, p4 = Math.floor((s4 - 1) / c4), v2 = Math.floor((l4 - 1) / c4), f2 = Math.max(0, Math.floor(u4 / c4) - n3), y2 = Math.min(p4, Math.floor((m3 - 1) / c4) + n3), b2 = Math.max(0, Math.floor(h3 / c4) - n3), w2 = Math.min(v2, Math.floor((g3 - 1) / c4) + n3), x2 = [];
    for (let t3 = f2; t3 <= y2; t3++) {
      const n4 = t3 * c4, i4 = Math.min(e3, s4 - n4), a4 = n4 / o3, d5 = i4 / o3;
      for (let s5 = b2; s5 <= w2; s5++) {
        const u5 = s5 * c4, h4 = Math.min(e3, l4 - u5), m4 = u5 / o3, g4 = h4 / o3;
        x2.push({ id: `p${r2.index}-${o3}-x${n4}-y${u5}-w${i4}-h${h4}`, col: t3, row: s5, pageRect: { origin: { x: a4, y: m4 }, size: { width: d5, height: g4 } }, screenRect: { origin: { x: n4, y: u5 }, size: { width: i4, height: h4 } }, status: "queued", srcScale: o3, isFallback: false });
      }
    }
    return x2;
  }
  function ml({ documentId: e3, pageIndex: t2, tile: n3, dpr: o3, scale: i3 }) {
    const { provides: r2 } = hl(), a3 = Te(() => null == r2 ? void 0 : r2.forDocument(e3), [r2, e3]), [s4, l4] = ke(), c4 = Ae(null), d4 = i3 / n3.srcScale;
    Me(() => {
      if ("ready" === n3.status && c4.current) return;
      if (!a3) return;
      const e4 = a3.renderTile({ pageIndex: t2, tile: n3, dpr: o3 });
      return e4.wait((e5) => {
        const t3 = URL.createObjectURL(e5);
        c4.current = t3, l4(t3);
      }, wn), () => {
        c4.current ? (URL.revokeObjectURL(c4.current), c4.current = null) : e4.abort({ code: Ht.Cancelled, message: "canceled render task" });
      };
    }, [a3, t2, n3.id]);
    return s4 ? Ue("img", { src: s4, onLoad: () => {
      c4.current && (URL.revokeObjectURL(c4.current), c4.current = null);
    }, style: { position: "absolute", left: n3.screenRect.origin.x * d4, top: n3.screenRect.origin.y * d4, width: n3.screenRect.size.width * d4, height: n3.screenRect.size.height * d4, display: "block" } }) : null;
  }
  function gl({ documentId: e3, pageIndex: t2, scale: n3, style: o3, ...i3 }) {
    const { provides: r2 } = hl(), a3 = fo(e3), [s4, l4] = ke([]);
    Me(() => {
      if (r2) return r2.onTileRendering((n4) => {
        n4.documentId === e3 && l4(n4.tiles[t2] ?? []);
      });
    }, [r2, e3, t2]);
    const c4 = Te(() => void 0 !== n3 ? n3 : (null == a3 ? void 0 : a3.scale) ?? 1, [n3, null == a3 ? void 0 : a3.scale]);
    return Ue("div", { style: { ...o3 }, ...i3, children: null == s4 ? void 0 : s4.map((n4) => Ue(ml, { documentId: e3, pageIndex: t2, tile: n4, dpr: window.devicePixelRatio, scale: c4 }, n4.id)) });
  }
  function xl(e3, t2) {
    return { type: fl, payload: { documentId: e3, state: t2 } };
  }
  function Pl({ documentId: e3, style: t2, children: n3, ...o3 }) {
    const { plugin: i3 } = Ml(), r2 = Ae(null), [a3, s4] = ke({ window: null, docId: null }), l4 = a3.docId === e3 ? a3.window : null;
    Me(() => {
      if (!i3) return;
      const t3 = i3.provides().forDocument(e3), n4 = t3.getWindow();
      n4 && s4({ window: n4, docId: e3 });
      const o4 = t3.onWindow((t4) => {
        s4({ window: t4, docId: e3 });
      });
      return () => {
        o4(), s4({ window: null, docId: null });
      };
    }, [i3, e3]), Me(() => {
      const t3 = r2.current;
      if (!t3 || !i3) return;
      const n4 = i3.provides().forDocument(e3), o4 = () => n4.updateWindow(t3.scrollTop, t3.clientHeight);
      return t3.addEventListener("scroll", o4), () => t3.removeEventListener("scroll", o4);
    }, [i3, e3]), Me(() => {
      const t3 = r2.current;
      if (!t3 || !i3) return;
      const n4 = i3.provides().forDocument(e3), o4 = new ResizeObserver(() => {
        n4.updateWindow(t3.scrollTop, t3.clientHeight);
      });
      return o4.observe(t3), () => o4.disconnect();
    }, [i3, e3]), Me(() => {
      const t3 = r2.current;
      if (!t3 || !i3) return;
      i3.provides().forDocument(e3).updateWindow(t3.scrollTop, t3.clientHeight);
    }, [l4, i3, e3]), Me(() => {
      const t3 = r2.current;
      if (!t3 || !i3 || !l4) return;
      return i3.provides().forDocument(e3).onScrollTo(({ top: e4, behavior: n4 }) => {
        t3.scrollTo({ top: e4, behavior: n4 });
      });
    }, [i3, e3, !!l4]);
    const c4 = (null == i3 ? void 0 : i3.cfg.paddingY) ?? 0;
    return Ue("div", { ref: r2, style: { overflowY: "auto", position: "relative", paddingTop: c4, paddingBottom: c4, height: "100%", ...t2 }, ...o3, children: Ue("div", { style: { height: (null == l4 ? void 0 : l4.totalHeight) ?? 0, position: "relative" }, children: null == l4 ? void 0 : l4.items.map((e4) => n3(e4)) }) });
  }
  function Al({ documentId: e3, meta: t2, style: n3, ...o3 }) {
    const { provides: i3 } = po(kl.id), { plugin: r2 } = Ml(), [a3, s4] = ke(), l4 = Ae(null), [c4, d4] = ke(0);
    Me(() => {
      if (!r2) return;
      return r2.provides().forDocument(e3).onRefreshPages((e4) => {
        e4.includes(t2.pageIndex) && d4((e5) => e5 + 1);
      });
    }, [r2, e3, t2.pageIndex]), Me(() => {
      const n4 = null == i3 ? void 0 : i3.forDocument(e3), o4 = null == n4 ? void 0 : n4.renderThumb(t2.pageIndex, window.devicePixelRatio);
      return null == o4 || o4.wait((e4) => {
        const t3 = URL.createObjectURL(e4);
        l4.current = t3, s4(t3);
      }, wn), () => {
        l4.current ? (URL.revokeObjectURL(l4.current), l4.current = null) : null == o4 || o4.abort({ code: Ht.Cancelled, message: "canceled render task" });
      };
    }, [i3, e3, t2.pageIndex, c4]);
    return a3 ? Ue("img", { src: a3, onLoad: () => {
      l4.current && (URL.revokeObjectURL(l4.current), l4.current = null);
    }, style: n3, ...o3 }) : null;
  }
  function Ql(e3) {
    return e3.object.type === Dt.INK;
  }
  function Jl(e3) {
    return e3.object.type === Dt.CIRCLE;
  }
  function ec(e3) {
    return e3.object.type === Dt.POLYGON;
  }
  function tc(e3) {
    return e3.object.type === Dt.SQUARE;
  }
  function nc(e3) {
    return e3.object.type === Dt.LINE;
  }
  function oc(e3) {
    return e3.object.type === Dt.POLYLINE;
  }
  function ic(e3) {
    return e3.object.type === Dt.HIGHLIGHT;
  }
  function rc(e3) {
    return e3.object.type === Dt.UNDERLINE;
  }
  function ac(e3) {
    return e3.object.type === Dt.STRIKEOUT;
  }
  function sc(e3) {
    return e3.object.type === Dt.SQUIGGLY;
  }
  function lc(e3) {
    return e3.object.type === Dt.FREETEXT;
  }
  function cc(e3) {
    return e3.object.type === Dt.STAMP;
  }
  function dc(e3) {
    return e3.object.type === Dt.TEXT;
  }
  function uc(e3) {
    return (function(e4) {
      return ic(e4) || rc(e4) || ac(e4) || sc(e4);
    })(e3) || Ql(e3) || tc(e3) || Jl(e3) || ec(e3) || nc(e3) || oc(e3) || lc(e3) || cc(e3);
  }
  function pc(e3, t2) {
    const n3 = e3.tools.find((e4) => e4.id === t2);
    return null == n3 ? void 0 : n3.defaults;
  }
  function bc(e3) {
    let t2 = e3;
    return [() => t2, (e4) => {
      t2 = e4;
    }];
  }
  function xc({ threshold: e3 = 5, getTool: t2, onClickDetected: n3 }) {
    const [o3, i3] = bc(null), [r2, a3] = bc(false);
    return { onStart: (e4) => {
      i3(e4), a3(false);
    }, onMove: (t3) => {
      const n4 = o3();
      if (!n4 || r2()) return;
      Math.sqrt(Math.pow(t3.x - n4.x, 2) + Math.pow(t3.y - n4.y, 2)) > e3 && a3(true);
    }, onEnd: (e4) => {
      var s4;
      if (o3() && !r2()) {
        const o4 = t2();
        o4 && "clickBehavior" in o4 && (null == (s4 = o4.clickBehavior) ? void 0 : s4.enabled) && n3(e4, o4);
      }
      i3(null), a3(false);
    }, hasMoved: r2, reset: () => {
      i3(null), a3(false);
    } };
  }
  function Ic(e3) {
    const t2 = (e4) => {
      const t3 = 9 * e4, n3 = Math.PI / 6;
      return { x: -t3 * Math.cos(n3), y: t3 * Math.sin(n3) };
    };
    return { getSvgPath: (n3) => {
      const { x: o3, y: i3 } = t2(n3);
      return e3 ? `M 0 0 L ${o3} ${i3} L ${o3} ${-i3} Z` : `M ${o3} ${i3} L 0 0 L ${o3} ${-i3}`;
    }, getLocalPoints: (e4) => {
      const { x: n3, y: o3 } = t2(e4);
      return [{ x: 0, y: 0 }, { x: n3, y: o3 }, { x: n3, y: -o3 }];
    }, getRotation: (e4) => e4, filled: e3 };
  }
  function Sc(e3, t2) {
    const n3 = (t3) => t3 * e3 / 2;
    return { getSvgPath: (e4) => {
      const t3 = n3(e4);
      return `M ${-t3} 0 L ${t3} 0`;
    }, getLocalPoints: (e4) => {
      const t3 = n3(e4);
      return [{ x: -t3, y: 0 }, { x: t3, y: 0 }];
    }, getRotation: t2, filled: false };
  }
  function Pc(e3, t2, n3) {
    if (!e3 || 0 === e3.length) return { origin: { x: 0, y: 0 }, size: { width: 0, height: 0 } };
    const o3 = [...e3], i3 = (e4, t3) => Math.atan2(t3.y - e4.y, t3.x - e4.x), r2 = (e4, n4, i4) => {
      if (!e4) return;
      const r3 = Mc[e4];
      if (!r3) return;
      const a3 = r3.getLocalPoints(t2), s4 = r3.getRotation(i4), l4 = a3.map((e5) => (function(e6, t3, n5) {
        const o4 = Math.cos(t3), i5 = Math.sin(t3), r4 = e6.x * o4 - e6.y * i5, a4 = e6.x * i5 + e6.y * o4;
        return { x: r4 + n5.x, y: a4 + n5.y };
      })(e5, s4, n4));
      o3.push(...l4);
    };
    if (e3.length >= 2) {
      const t3 = i3(e3[1], e3[0]);
      r2(null == n3 ? void 0 : n3.start, e3[0], t3);
      const o4 = e3.length - 1, a3 = i3(e3[o4 - 1], e3[o4]);
      r2(null == n3 ? void 0 : n3.end, e3[o4], a3);
    }
    if (o3.length <= 1) {
      const n4 = e3[0] || { x: 0, y: 0 }, o4 = t2;
      return { origin: { x: n4.x - o4, y: n4.y - o4 }, size: { width: 2 * o4, height: 2 * o4 } };
    }
    return et(Je(o3), t2 / 2 + 1.2 * t2);
  }
  function Bc(e3) {
    return (t2) => (null == t2 ? void 0 : t2.id) === e3;
  }
  function ld(e3) {
    return { type: nd, payload: { mode: e3 } };
  }
  function cd(e3) {
    return { type: od, payload: { rules: e3 } };
  }
  function Cd(e3) {
    return "undefined" != typeof TouchEvent && e3 instanceof TouchEvent;
  }
  function Id(e3, t2, n3, o3) {
    const i3 = e3.forDocument(t2.documentId);
    let r2 = e3.getHandlersForScope(t2);
    const a3 = () => {
      var e4;
      return false !== (null == (e4 = i3.getActiveInteractionMode()) ? void 0 : e4.wantsRawTouch);
    }, s4 = {};
    let l4 = a3();
    const c4 = (e4) => {
      xd.forEach((t3) => {
        const o4 = s4[t3] ?? (s4[t3] = f2);
        var i4;
        n3.addEventListener(t3, o4, (i4 = e4, t3.startsWith("touch") ? { passive: !i4 } : { passive: false }));
      });
    }, d4 = () => {
      xd.forEach((e4) => {
        const t3 = s4[e4];
        t3 && n3.removeEventListener(e4, t3);
      });
    };
    c4(l4), n3.style.touchAction = l4 ? "none" : "";
    const u4 = i3.onModeChange(() => {
      if ("global" === t2.type) {
        const e4 = i3.getActiveInteractionMode();
        n3.style.cursor = "global" === (null == e4 ? void 0 : e4.scope) ? e4.cursor ?? "auto" : "auto";
      }
      r2 = e3.getHandlersForScope(t2);
      const o4 = a3();
      o4 !== l4 && (d4(), c4(o4), l4 = o4, n3.style.touchAction = l4 ? "none" : "");
    }), h3 = e3.onHandlerChange(() => {
      r2 = e3.getHandlersForScope(t2);
    }), m3 = i3.getActiveInteractionMode(), g3 = i3.getCurrentCursor();
    n3.style.cursor = "global" === t2.type && "global" !== (null == m3 ? void 0 : m3.scope) ? "auto" : g3;
    const p4 = i3.onCursorChange((e4) => {
      var o4;
      "global" === t2.type && "global" !== (null == (o4 = i3.getActiveInteractionMode()) ? void 0 : o4.scope) || (n3.style.cursor = e4);
    }), v2 = (e4, t3) => {
      if (o3) return o3(e4, t3);
      const n4 = t3.getBoundingClientRect();
      return { x: e4.clientX - n4.left, y: e4.clientY - n4.top };
    };
    function f2(t3) {
      var o4;
      if (e3.isPaused()) return;
      const a4 = e3.getExclusionRules();
      if (t3.target && (function(e4, t4) {
        var n4, o5, i4;
        if (!e4) return false;
        let r3 = e4;
        for (; r3; ) {
          if (null == (n4 = t4.classes) ? void 0 : n4.length) {
            for (const e5 of t4.classes) if (null == (o5 = r3.classList) ? void 0 : o5.contains(e5)) return true;
          }
          if (null == (i4 = t4.dataAttributes) ? void 0 : i4.length) {
            for (const e5 of t4.dataAttributes) if (r3.hasAttribute(e5)) return true;
          }
          r3 = r3.parentElement;
        }
        return false;
      })(t3.target, a4)) return;
      const s5 = bd[t3.type];
      if (!s5 || !(null == r2 ? void 0 : r2[s5])) return;
      let c5, d5;
      if (Cd(t3) && l4 && ("touchmove" === t3.type || "touchcancel" === t3.type) && t3.preventDefault(), Cd(t3)) {
        const e4 = "touchend" === t3.type || "touchcancel" === t3.type ? t3.changedTouches[0] : t3.touches[0];
        if (!e4) return;
        c5 = v2(e4, n3), d5 = { clientX: e4.clientX, clientY: e4.clientY, ctrlKey: t3.ctrlKey, shiftKey: t3.shiftKey, altKey: t3.altKey, metaKey: t3.metaKey, target: t3.target, currentTarget: t3.currentTarget, setPointerCapture: () => {
        }, releasePointerCapture: () => {
        } };
      } else {
        const e4 = t3;
        c5 = v2(e4, n3), d5 = { clientX: e4.clientX, clientY: e4.clientY, ctrlKey: e4.ctrlKey, shiftKey: e4.shiftKey, altKey: e4.altKey, metaKey: e4.metaKey, target: e4.target, currentTarget: e4.currentTarget, setPointerCapture: () => {
          var t4, n4;
          null == (n4 = null == (t4 = e4.target) ? void 0 : t4.setPointerCapture) || n4.call(t4, e4.pointerId);
        }, releasePointerCapture: () => {
          var t4, n4;
          null == (n4 = null == (t4 = e4.target) ? void 0 : t4.releasePointerCapture) || n4.call(t4, e4.pointerId);
        } };
      }
      null == (o4 = r2[s5]) || o4.call(r2, c5, d5, i3.getActiveMode());
    }
    return () => {
      d4(), u4(), p4(), h3();
    };
  }
  function Ad({ scale: e3, documentId: t2, pageIndex: n3, rotation: o3, pageWidth: i3, pageHeight: r2, trackedAnnotation: a3, children: s4, isSelected: l4, isDraggable: c4, isResizable: d4, lockAspectRatio: u4 = false, style: h3 = {}, vertexConfig: m3, selectionMenu: g3, outlineOffset: p4 = 1, onDoubleClick: v2, onSelect: f2, zIndex: y2 = 1, resizeUI: b2, vertexUI: w2, selectionOutlineColor: x2 = "#007ACC", customAnnotationRenderer: C2, ...I2 }) {
    const [S2, k2] = ke(a3.object), { provides: D2 } = Md(), M2 = Ae(null), P2 = Te(() => D2 ? D2.forDocument(t2) : null, [D2, t2]), A2 = S2 ? { ...a3.object, ...S2 } : a3.object, T2 = (null == b2 ? void 0 : b2.color) ?? "#007ACC", z3 = (null == w2 ? void 0 : w2.color) ?? "#007ACC", E2 = (null == b2 ? void 0 : b2.size) ?? 12, _2 = (null == w2 ? void 0 : w2.size) ?? 12, { dragProps: R2, vertices: N3, resize: O2 } = Ks({ controller: { element: A2.rect, vertices: null == m3 ? void 0 : m3.extractVertices(A2), constraints: { minWidth: 10, minHeight: 10, boundingBox: { width: i3, height: r2 } }, maintainAspectRatio: u4, pageRotation: o3, scale: e3, enabled: l4, onUpdate: (e4) => {
      var t3;
      if (!(null == (t3 = e4.transformData) ? void 0 : t3.type)) return;
      "start" === e4.state && (M2.current = A2);
      const o4 = e4.transformData.type, i4 = M2.current ?? A2, r3 = e4.transformData.changes.vertices ? null == m3 ? void 0 : m3.transformAnnotation(i4, e4.transformData.changes.vertices) : { rect: e4.transformData.changes.rect }, s5 = null == D2 ? void 0 : D2.transformAnnotation(i4, { type: o4, changes: r3, metadata: e4.transformData.metadata });
      s5 && k2((e5) => ({ ...e5, ...s5 })), "end" === e4.state && s5 && (M2.current = null, null == P2 || P2.updateAnnotation(n3, a3.object.id, s5));
    } }, resizeUI: { handleSize: E2, spacing: p4, offsetMode: "outside", includeSides: !u4, zIndex: y2 + 1 }, vertexUI: { vertexSize: _2, zIndex: y2 + 2 }, includeVertices: !!m3 }), L3 = (function(e4, { delay: t3 = 300, tolerancePx: n4 = 18 } = {}) {
      const o4 = Ae({ t: 0, x: 0, y: 0 }), i4 = ze((i5) => {
        if (!e4) return;
        if ("mouse" === i5.pointerType || false === i5.isPrimary) return;
        const r4 = performance.now(), a4 = i5.clientX, s5 = i5.clientY, l5 = r4 - o4.current.t <= t3, c5 = a4 - o4.current.x, d5 = s5 - o4.current.y;
        l5 && c5 * c5 + d5 * d5 <= n4 * n4 && (null == e4 || e4(i5)), o4.current = { t: r4, x: a4, y: s5 };
      }, [e4, t3, n4]), r3 = ze((t4) => {
        null == e4 || e4(t4);
      }, [e4]);
      return e4 ? { [Bs]: r3, onPointerUpCapture: i4 } : {};
    })(v2);
    return Me(() => {
      k2(a3.object);
    }, [a3.object]), Ue("div", { "data-no-interaction": true, children: [Ue("div", { ...c4 && l4 ? R2 : {}, ...L3, style: { position: "absolute", left: A2.rect.origin.x * e3, top: A2.rect.origin.y * e3, width: A2.rect.size.width * e3, height: A2.rect.size.height * e3, outline: l4 ? `1px solid ${x2}` : "none", outlineOffset: l4 ? `${p4}px` : "0px", pointerEvents: l4 ? "auto" : "none", touchAction: "none", cursor: l4 && c4 ? "move" : "default", zIndex: y2, ...h3 }, ...I2, children: [(() => {
      const t3 = "function" == typeof s4 ? s4(A2) : s4, a4 = null == C2 ? void 0 : C2({ annotation: A2, children: t3, isSelected: l4, scale: e3, rotation: o3, pageWidth: i3, pageHeight: r2, pageIndex: n3, onSelect: f2 });
      return null != a4 ? a4 : t3;
    })(), l4 && d4 && O2.map(({ key: e4, ...t3 }) => (null == b2 ? void 0 : b2.component) ? b2.component({ key: e4, ...t3, backgroundColor: T2 }) : Ue("div", { ...t3, style: { ...t3.style, backgroundColor: T2 } }, e4)), l4 && N3.map(({ key: e4, ...t3 }) => (null == w2 ? void 0 : w2.component) ? w2.component({ key: e4, ...t3, backgroundColor: z3 }) : Ue("div", { ...t3, style: { ...t3.style, backgroundColor: z3 } }, e4))] }), g3 && Ue(qs, { rect: { origin: { x: A2.rect.origin.x * e3, y: A2.rect.origin.y * e3 }, size: { width: A2.rect.size.width * e3, height: A2.rect.size.height * e3 } }, rotation: o3, children: (e4) => g3({ ...e4, context: { type: "annotation", annotation: a3, pageIndex: n3 }, selected: l4, placement: { suggestTop: false } }) })] });
  }
  function Td({ color: e3 = "#FFFF00", opacity: t2 = 0.5, segmentRects: n3, rect: o3, scale: i3, onClick: r2, style: a3 }) {
    return Ue(U2, { children: n3.map((n4, s4) => Ue("div", { onPointerDown: r2, onTouchStart: r2, style: { position: "absolute", left: (o3 ? n4.origin.x - o3.origin.x : n4.origin.x) * i3, top: (o3 ? n4.origin.y - o3.origin.y : n4.origin.y) * i3, width: n4.size.width * i3, height: n4.size.height * i3, background: e3, opacity: t2, pointerEvents: r2 ? "auto" : "none", cursor: r2 ? "pointer" : "default", zIndex: r2 ? 1 : void 0, ...a3 } }, s4)) });
  }
  function zd({ color: e3 = "#FFFF00", opacity: t2 = 0.5, segmentRects: n3, rect: o3, scale: i3, onClick: r2, style: a3 }) {
    const s4 = 2 * i3;
    return Ue(U2, { children: n3.map((n4, l4) => Ue("div", { onPointerDown: r2, onTouchStart: r2, style: { position: "absolute", left: (o3 ? n4.origin.x - o3.origin.x : n4.origin.x) * i3, top: (o3 ? n4.origin.y - o3.origin.y : n4.origin.y) * i3, width: n4.size.width * i3, height: n4.size.height * i3, background: "transparent", pointerEvents: r2 ? "auto" : "none", cursor: r2 ? "pointer" : "default", zIndex: r2 ? 1 : 0, ...a3 }, children: Ue("div", { style: { position: "absolute", left: 0, bottom: 0, width: "100%", height: s4, background: e3, opacity: t2, pointerEvents: "none" } }) }, l4)) });
  }
  function Ed({ color: e3 = "#FFFF00", opacity: t2 = 0.5, segmentRects: n3, rect: o3, scale: i3, onClick: r2, style: a3 }) {
    const s4 = 2 * i3;
    return Ue(U2, { children: n3.map((n4, l4) => Ue("div", { onPointerDown: r2, onTouchStart: r2, style: { position: "absolute", left: (o3 ? n4.origin.x - o3.origin.x : n4.origin.x) * i3, top: (o3 ? n4.origin.y - o3.origin.y : n4.origin.y) * i3, width: n4.size.width * i3, height: n4.size.height * i3, background: "transparent", pointerEvents: r2 ? "auto" : "none", cursor: r2 ? "pointer" : "default", zIndex: r2 ? 1 : 0, ...a3 }, children: Ue("div", { style: { position: "absolute", left: 0, top: "50%", width: "100%", height: s4, background: e3, opacity: t2, transform: "translateY(-50%)", pointerEvents: "none" } }) }, l4)) });
  }
  function _d({ color: e3 = "#FFFF00", opacity: t2 = 0.5, segmentRects: n3, rect: o3, scale: i3, onClick: r2, style: a3 }) {
    const s4 = 2 * i3, l4 = 6 * i3, c4 = `url("data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="${l4}" height="${2 * s4}" viewBox="0 0 ${l4} ${2 * s4}">
      <path d="M0 ${s4} Q ${l4 / 4} 0 ${l4 / 2} ${s4} T ${l4} ${s4}"
            fill="none" stroke="${e3}" stroke-width="${s4}" stroke-linecap="round"/>
    </svg>`)}")`;
    return Ue(U2, { children: n3.map((e4, n4) => Ue("div", { onPointerDown: r2, onTouchStart: r2, style: { position: "absolute", left: (o3 ? e4.origin.x - o3.origin.x : e4.origin.x) * i3, top: (o3 ? e4.origin.y - o3.origin.y : e4.origin.y) * i3, width: e4.size.width * i3, height: e4.size.height * i3, background: "transparent", pointerEvents: r2 ? "auto" : "none", cursor: r2 ? "pointer" : "default", zIndex: r2 ? 1 : 0, ...a3 }, children: Ue("div", { style: { position: "absolute", left: 0, bottom: 0, width: "100%", height: 2 * s4, backgroundImage: c4, backgroundRepeat: "repeat-x", backgroundSize: `${l4}px ${2 * s4}px`, opacity: t2, pointerEvents: "none" } }) }, n4)) });
  }
  function Rd({ isSelected: e3, color: t2 = "#000000", opacity: n3 = 1, strokeWidth: o3, inkList: i3, rect: r2, scale: a3, onClick: s4 }) {
    const l4 = Te(() => i3.map(({ points: e4 }) => {
      let t3 = "";
      return e4.forEach(({ x: e5, y: n4 }, o4) => {
        const i4 = e5 - r2.origin.x, a4 = n4 - r2.origin.y;
        t3 += (0 === o4 ? "M" : "L") + i4 + " " + a4 + " ";
      }), t3.trim();
    }), [i3, r2]), c4 = r2.size.width * a3, d4 = r2.size.height * a3;
    return Ue("svg", { style: { position: "absolute", width: c4, height: d4, pointerEvents: "none", zIndex: 2, overflow: "visible" }, width: c4, height: d4, viewBox: `0 0 ${r2.size.width} ${r2.size.height}`, children: l4.map((i4, r3) => Ue("path", { d: i4, fill: "none", opacity: n3, onPointerDown: s4, onTouchStart: s4, style: { cursor: e3 ? "move" : "pointer", pointerEvents: e3 ? "none" : "visibleStroke", stroke: t2, strokeWidth: o3, strokeLinecap: "round", strokeLinejoin: "round" } }, r3)) });
  }
  function Nd({ isSelected: e3, color: t2 = "#000000", strokeColor: n3, opacity: o3 = 1, strokeWidth: i3, strokeStyle: r2 = Et.SOLID, strokeDashArray: a3, rect: s4, scale: l4, onClick: c4 }) {
    const { width: d4, height: u4, x: h3, y: m3 } = Te(() => {
      const e4 = s4.size.width, t3 = s4.size.height;
      return { width: Math.max(e4 - i3, 0), height: Math.max(t3 - i3, 0), x: i3 / 2, y: i3 / 2 };
    }, [s4, i3]), g3 = (d4 + i3) * l4, p4 = (u4 + i3) * l4;
    return Ue("svg", { style: { position: "absolute", width: g3, height: p4, pointerEvents: "none", zIndex: 2 }, width: g3, height: p4, viewBox: `0 0 ${d4 + i3} ${u4 + i3}`, children: Ue("rect", { x: h3, y: m3, width: d4, height: u4, fill: t2, opacity: o3, onPointerDown: c4, onTouchStart: c4, style: { cursor: e3 ? "move" : "pointer", pointerEvents: e3 ? "none" : "transparent" === t2 ? "visibleStroke" : "visible", stroke: n3 ?? t2, strokeWidth: i3, ...r2 === Et.DASHED && { strokeDasharray: null == a3 ? void 0 : a3.join(",") } } }) });
  }
  function Od({ color: e3 = "#000000", strokeColor: t2, opacity: n3 = 1, strokeWidth: o3, strokeStyle: i3 = Et.SOLID, strokeDashArray: r2, rect: a3, scale: s4, onClick: l4, isSelected: c4 }) {
    const { width: d4, height: u4, cx: h3, cy: m3, rx: g3, ry: p4 } = Te(() => {
      const e4 = a3.size.width, t3 = a3.size.height, n4 = Math.max(e4 - o3, 0), i4 = Math.max(t3 - o3, 0);
      return { width: e4, height: t3, cx: o3 / 2 + n4 / 2, cy: o3 / 2 + i4 / 2, rx: n4 / 2, ry: i4 / 2 };
    }, [a3, o3]), v2 = d4 * s4, f2 = u4 * s4;
    return Ue("svg", { style: { position: "absolute", width: v2, height: f2, pointerEvents: "none", zIndex: 2 }, width: v2, height: f2, viewBox: `0 0 ${d4} ${u4}`, children: Ue("ellipse", { cx: h3, cy: m3, rx: g3, ry: p4, fill: e3, opacity: n3, onPointerDown: l4, onTouchStart: l4, style: { cursor: c4 ? "move" : "pointer", pointerEvents: c4 ? "none" : "transparent" === e3 ? "visibleStroke" : "visible", stroke: t2 ?? e3, strokeWidth: o3, ...i3 === Et.DASHED && { strokeDasharray: null == r2 ? void 0 : r2.join(",") } } }) });
  }
  function Ld({ color: e3 = "transparent", opacity: t2 = 1, strokeWidth: n3, strokeColor: o3 = "#000000", strokeStyle: i3 = Et.SOLID, strokeDashArray: r2, rect: a3, linePoints: s4, lineEndings: l4, scale: c4, onClick: d4, isSelected: u4 }) {
    const { x1: h3, y1: m3, x2: g3, y2: p4 } = Te(() => ({ x1: s4.start.x - a3.origin.x, y1: s4.start.y - a3.origin.y, x2: s4.end.x - a3.origin.x, y2: s4.end.y - a3.origin.y }), [s4, a3]), v2 = Te(() => {
      const e4 = Math.atan2(p4 - m3, g3 - h3);
      return { start: zc.createEnding(null == l4 ? void 0 : l4.start, n3, e4 + Math.PI, h3, m3), end: zc.createEnding(null == l4 ? void 0 : l4.end, n3, e4, g3, p4) };
    }, [l4, n3, h3, m3, g3, p4]), f2 = a3.size.width * c4, y2 = a3.size.height * c4;
    return Ue("svg", { style: { position: "absolute", width: f2, height: y2, pointerEvents: "none", zIndex: 2, overflow: "visible" }, width: f2, height: y2, viewBox: `0 0 ${a3.size.width} ${a3.size.height}`, children: [Ue("line", { x1: h3, y1: m3, x2: g3, y2: p4, opacity: t2, onPointerDown: d4, onTouchStart: d4, style: { cursor: u4 ? "move" : "pointer", pointerEvents: u4 ? "none" : "visibleStroke", stroke: o3, strokeWidth: n3, strokeLinecap: "butt", ...i3 === Et.DASHED && { strokeDasharray: null == r2 ? void 0 : r2.join(",") } } }), v2.start && Ue("path", { d: v2.start.d, transform: v2.start.transform, onPointerDown: d4, onTouchStart: d4, stroke: o3, style: { cursor: u4 ? "move" : "pointer", strokeWidth: n3, strokeLinecap: "butt", pointerEvents: u4 ? "none" : v2.start.filled ? "visible" : "visibleStroke", ...i3 === Et.DASHED && { strokeDasharray: null == r2 ? void 0 : r2.join(",") } }, fill: v2.start.filled ? e3 : "none" }), v2.end && Ue("path", { d: v2.end.d, transform: v2.end.transform, stroke: o3, onPointerDown: d4, onTouchStart: d4, style: { cursor: u4 ? "move" : "pointer", strokeWidth: n3, strokeLinecap: "butt", pointerEvents: u4 ? "none" : v2.end.filled ? "visible" : "visibleStroke", ...i3 === Et.DASHED && { strokeDasharray: null == r2 ? void 0 : r2.join(",") } }, fill: v2.end.filled ? e3 : "none" })] });
  }
  function $d({ rect: e3, vertices: t2, color: n3 = "transparent", strokeColor: o3 = "#000000", opacity: i3 = 1, strokeWidth: r2, scale: a3, isSelected: s4, onClick: l4, lineEndings: c4 }) {
    const d4 = Te(() => t2.map(({ x: t3, y: n4 }) => ({ x: t3 - e3.origin.x, y: n4 - e3.origin.y })), [t2, e3]), u4 = Te(() => {
      if (!d4.length) return "";
      const [e4, ...t3] = d4;
      return `M ${e4.x} ${e4.y} ` + t3.map((e5) => `L ${e5.x} ${e5.y} `).join("").trim();
    }, [d4]), h3 = Te(() => {
      if (d4.length < 2) return { start: null, end: null };
      const e4 = (e5, t4) => Math.atan2(t4.y - e5.y, t4.x - e5.x), t3 = e4(d4[0], d4[1]), n4 = e4(d4[d4.length - 2], d4[d4.length - 1]);
      return { start: zc.createEnding(null == c4 ? void 0 : c4.start, r2, t3 + Math.PI, d4[0].x, d4[0].y), end: zc.createEnding(null == c4 ? void 0 : c4.end, r2, n4, d4[d4.length - 1].x, d4[d4.length - 1].y) };
    }, [d4, c4, r2]), m3 = e3.size.width * a3, g3 = e3.size.height * a3;
    return Ue("svg", { style: { position: "absolute", width: m3, height: g3, pointerEvents: "none", zIndex: 2, overflow: "visible" }, width: m3, height: g3, viewBox: `0 0 ${e3.size.width} ${e3.size.height}`, children: [Ue("path", { d: u4, onPointerDown: l4, onTouchStart: l4, opacity: i3, style: { fill: "none", stroke: o3 ?? n3, strokeWidth: r2, cursor: s4 ? "move" : "pointer", pointerEvents: s4 ? "none" : "visibleStroke", strokeLinecap: "butt", strokeLinejoin: "miter" } }), h3.start && Ue("path", { d: h3.start.d, transform: h3.start.transform, stroke: o3, fill: h3.start.filled ? n3 : "none", onPointerDown: l4, onTouchStart: l4, style: { cursor: s4 ? "move" : "pointer", strokeWidth: r2, pointerEvents: s4 ? "none" : h3.start.filled ? "visible" : "visibleStroke", strokeLinecap: "butt" } }), h3.end && Ue("path", { d: h3.end.d, transform: h3.end.transform, stroke: o3, fill: h3.end.filled ? n3 : "none", onPointerDown: l4, onTouchStart: l4, style: { cursor: s4 ? "move" : "pointer", strokeWidth: r2, pointerEvents: s4 ? "none" : h3.end.filled ? "visible" : "visibleStroke", strokeLinecap: "butt" } })] });
  }
  function Fd({ rect: e3, vertices: t2, color: n3 = "transparent", strokeColor: o3 = "#000000", opacity: i3 = 1, strokeWidth: r2, strokeStyle: a3 = Et.SOLID, strokeDashArray: s4, scale: l4, isSelected: c4, onClick: d4, currentVertex: u4, handleSize: h3 = 14 }) {
    const m3 = u4 ? [...t2, u4] : t2, g3 = Te(() => m3.map(({ x: t3, y: n4 }) => ({ x: t3 - e3.origin.x, y: n4 - e3.origin.y })), [m3, e3]), p4 = Te(() => {
      if (!g3.length) return "";
      const [e4, ...t3] = g3, n4 = !!u4;
      return (`M ${e4.x} ${e4.y} ` + t3.map((e5) => `L ${e5.x} ${e5.y}`).join(" ") + (n4 ? "" : " Z")).trim();
    }, [g3, u4]), v2 = u4 && t2.length > 0, f2 = e3.size.width * l4, y2 = e3.size.height * l4;
    return Ue("svg", { style: { position: "absolute", width: f2, height: y2, pointerEvents: "none", zIndex: 2, overflow: "visible" }, width: f2, height: y2, viewBox: `0 0 ${e3.size.width} ${e3.size.height}`, children: [Ue("path", { d: p4, onPointerDown: d4, onTouchStart: d4, opacity: i3, style: { fill: u4 ? "none" : n3, stroke: o3 ?? n3, strokeWidth: r2, cursor: c4 ? "move" : "pointer", pointerEvents: c4 ? "none" : "transparent" === n3 ? "visibleStroke" : "visible", strokeLinecap: "butt", strokeLinejoin: "miter", ...a3 === Et.DASHED && { strokeDasharray: null == s4 ? void 0 : s4.join(",") } } }), v2 && t2.length > 1 && Ue("path", { d: `M ${g3[g3.length - 1].x} ${g3[g3.length - 1].y} L ${g3[0].x} ${g3[0].y}`, fill: "none", style: { stroke: o3, strokeWidth: r2, strokeDasharray: "4,4", opacity: 0.7 } }), v2 && t2.length >= 2 && Ue("rect", { x: g3[0].x - h3 / l4 / 2, y: g3[0].y - h3 / l4 / 2, width: h3 / l4, height: h3 / l4, fill: o3, opacity: 0.4, stroke: o3, strokeWidth: r2 / 2 })] });
  }
  function jd({ isSelected: e3, isEditing: t2, annotation: n3, pageIndex: o3, scale: i3, onClick: r2 }) {
    const a3 = Ae(null), { provides: s4 } = Md(), [l4, c4] = ke(false);
    Me(() => {
      if (t2 && a3.current) {
        const e4 = a3.current;
        e4.focus();
        const t3 = window.getSelection();
        if (t3) {
          const n4 = document.createRange();
          n4.selectNodeContents(e4), n4.collapse(false), t3.removeAllRanges(), t3.addRange(n4);
        }
      }
    }, [t2]), Pe(() => {
      try {
        const e4 = navigator, t3 = /iPad|iPhone|iPod/.test(navigator.userAgent) || "MacIntel" === navigator.platform && (null == e4 ? void 0 : e4.maxTouchPoints) > 1;
        c4(t3);
      } catch {
        c4(false);
      }
    }, []);
    const d4 = n3.object.fontSize * i3, u4 = l4 && t2 && d4 > 0 && d4 < 16, h3 = u4 ? 16 : d4, m3 = u4 ? d4 / 16 : 1, g3 = u4 ? 100 / m3 : 100;
    return Ue("div", { style: { position: "absolute", width: n3.object.rect.size.width * i3, height: n3.object.rect.size.height * i3, cursor: e3 && !t2 ? "move" : "default", pointerEvents: e3 && !t2 ? "none" : "auto", zIndex: 2 }, onPointerDown: r2, onTouchStart: r2, children: Ue("span", { ref: a3, onBlur: () => {
      s4 && a3.current && s4.updateAnnotation(o3, n3.object.id, { contents: a3.current.innerText });
    }, tabIndex: 0, style: { color: n3.object.fontColor, fontSize: h3, fontFamily: (p4 = n3.object.fontFamily, rn(p4).css), textAlign: Xt(n3.object.textAlign), flexDirection: "column", justifyContent: n3.object.verticalAlign === Ct.Top ? "flex-start" : n3.object.verticalAlign === Ct.Middle ? "center" : "flex-end", display: "flex", backgroundColor: n3.object.backgroundColor, opacity: n3.object.opacity, width: u4 ? `${g3}%` : "100%", height: u4 ? `${g3}%` : "100%", lineHeight: "1.18", overflow: "hidden", cursor: t2 ? "text" : "pointer", outline: "none", transform: u4 ? `scale(${m3})` : void 0, transformOrigin: "top left" }, contentEditable: t2, ...Dd, children: n3.object.contents }) });
    var p4;
  }
  function Hd({ documentId: e3, pageIndex: t2, annotation: n3, scaleFactor: o3 = 1, style: i3, ...r2 }) {
    const { provides: a3 } = Md(), [s4, l4] = ke(null), c4 = Ae(null), { width: d4, height: u4 } = n3.rect.size;
    Me(() => {
      if (a3) {
        const i4 = a3.forDocument(e3).renderAnnotation({ pageIndex: t2, annotation: n3, options: { scaleFactor: o3, dpr: window.devicePixelRatio } });
        return i4.wait((e4) => {
          const t3 = URL.createObjectURL(e4);
          l4(t3), c4.current = t3;
        }, wn), () => {
          c4.current ? (URL.revokeObjectURL(c4.current), c4.current = null) : i4.abort({ code: Ht.Cancelled, message: "canceled render task" });
        };
      }
    }, [t2, o3, a3, e3, n3.id, d4, u4]);
    return Ue(U2, { children: s4 && Ue("img", { src: s4, onLoad: () => {
      c4.current && (URL.revokeObjectURL(c4.current), c4.current = null);
    }, ...r2, style: { width: "100%", height: "100%", display: "block", ...i3 || {} } }) });
  }
  function Ud({ isSelected: e3, annotation: t2, documentId: n3, pageIndex: o3, scale: i3, onClick: r2 }) {
    return Ue("div", { style: { position: "absolute", width: "100%", height: "100%", zIndex: 2, pointerEvents: e3 ? "none" : "auto", cursor: "pointer" }, onPointerDown: r2, onTouchStart: r2, children: Ue(Hd, { documentId: n3, pageIndex: o3, annotation: { ...t2.object, id: t2.object.id }, scaleFactor: i3 }) });
  }
  function Wd(e3) {
    const { documentId: t2, pageIndex: n3, scale: o3, selectionMenu: i3 } = e3, { provides: r2 } = Md(), { provides: a3 } = Ys(), [s4, l4] = ke([]), { register: c4 } = (function({ modeId: e4, pageIndex: t3, documentId: n4 }) {
      const { provides: o4 } = yd();
      return { register: (i4, r3) => {
        const a4 = (null == r3 ? void 0 : r3.modeId) ?? e4, s5 = (null == r3 ? void 0 : r3.pageIndex) ?? t3, l5 = (null == r3 ? void 0 : r3.documentId) ?? n4;
        return a4 ? null == o4 ? void 0 : o4.registerHandlers({ modeId: a4, handlers: i4, pageIndex: s5, documentId: l5 }) : null == o4 ? void 0 : o4.registerAlways({ scope: void 0 !== s5 ? { type: "page", documentId: l5, pageIndex: s5 } : { type: "global", documentId: l5 }, handlers: i4 });
      } };
    })({ documentId: t2, pageIndex: n3 }), [d4, u4] = ke(null), [h3, m3] = ke(null), g3 = Te(() => r2 ? r2.forDocument(t2) : null, [r2, t2]);
    Me(() => {
      if (g3) {
        const e4 = g3.getState();
        return l4(hc(e4, n3)), u4(gc(e4, n3)), g3.onStateChange((e5) => {
          l4(hc(e5, n3)), u4(gc(e5, n3));
        });
      }
    }, [g3, n3]);
    const p4 = Te(() => ({ onPointerDown: (e4, t3) => {
      t3.target === t3.currentTarget && g3 && (g3.deselectAnnotation(), m3(null));
    } }), [g3]), v2 = ze((e4, t3) => {
      e4.stopPropagation(), g3 && a3 && (g3.selectAnnotation(n3, t3.object.id), a3.clear(), t3.object.id !== h3 && m3(null));
    }, [g3, a3, h3, n3]);
    return Me(() => c4(p4, { documentId: t2 }), [c4, p4]), Ue(U2, { children: s4.map((r3) => {
      const a4 = (null == d4 ? void 0 : d4.object.id) === r3.object.id, s5 = h3 === r3.object.id, l5 = null == g3 ? void 0 : g3.findToolForAnnotation(r3.object);
      return Ql(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: (null == l5 ? void 0 : l5.interaction.isDraggable) ?? true, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? true, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), style: { mixBlendMode: mn(r3.object.blendMode ?? It.Normal) }, ...e3, children: (e4) => Ue(Rd, { ...e4, isSelected: a4, scale: o3, onClick: (e5) => v2(e5, r3) }) }, r3.object.id) : tc(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: (null == l5 ? void 0 : l5.interaction.isDraggable) ?? true, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? true, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), style: { mixBlendMode: mn(r3.object.blendMode ?? It.Normal) }, ...e3, children: (e4) => Ue(Nd, { ...e4, isSelected: a4, scale: o3, onClick: (e5) => v2(e5, r3) }) }, r3.object.id) : Jl(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: (null == l5 ? void 0 : l5.interaction.isDraggable) ?? true, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? true, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), style: { mixBlendMode: mn(r3.object.blendMode ?? It.Normal) }, ...e3, children: (e4) => Ue(Od, { ...e4, isSelected: a4, scale: o3, onClick: (e5) => v2(e5, r3) }) }, r3.object.id) : rc(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: (null == l5 ? void 0 : l5.interaction.isDraggable) ?? false, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? false, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), zIndex: 0, style: { mixBlendMode: mn(r3.object.blendMode ?? It.Normal) }, ...e3, children: (e4) => Ue(zd, { ...e4, scale: o3, onClick: (e5) => v2(e5, r3) }) }, r3.object.id) : ac(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: (null == l5 ? void 0 : l5.interaction.isDraggable) ?? false, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? false, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), zIndex: 0, style: { mixBlendMode: mn(r3.object.blendMode ?? It.Normal) }, ...e3, children: (e4) => Ue(Ed, { ...e4, scale: o3, onClick: (e5) => v2(e5, r3) }) }, r3.object.id) : sc(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: (null == l5 ? void 0 : l5.interaction.isDraggable) ?? false, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? false, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), zIndex: 0, style: { mixBlendMode: mn(r3.object.blendMode ?? It.Normal) }, ...e3, children: (e4) => Ue(_d, { ...e4, scale: o3, onClick: (e5) => v2(e5, r3) }) }, r3.object.id) : ic(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: (null == l5 ? void 0 : l5.interaction.isDraggable) ?? false, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? false, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), zIndex: 0, style: { mixBlendMode: mn(r3.object.blendMode ?? It.Multiply) }, ...e3, children: (e4) => Ue(Td, { ...e4, scale: o3, onClick: (e5) => v2(e5, r3) }) }, r3.object.id) : nc(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: (null == l5 ? void 0 : l5.interaction.isDraggable) ?? true, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? false, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), vertexConfig: { extractVertices: (e4) => [e4.linePoints.start, e4.linePoints.end], transformAnnotation: (e4, t3) => ({ ...e4, linePoints: { start: t3[0], end: t3[1] } }) }, style: { mixBlendMode: mn(r3.object.blendMode ?? It.Normal) }, ...e3, children: (e4) => Ue(U2, { children: Ue(Ld, { ...e4, isSelected: a4, scale: o3, onClick: (e5) => v2(e5, r3) }) }) }, r3.object.id) : oc(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: (null == l5 ? void 0 : l5.interaction.isDraggable) ?? true, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? false, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), vertexConfig: { extractVertices: (e4) => e4.vertices, transformAnnotation: (e4, t3) => ({ ...e4, vertices: t3 }) }, style: { mixBlendMode: mn(r3.object.blendMode ?? It.Normal) }, ...e3, children: (e4) => Ue(U2, { children: Ue($d, { ...e4, isSelected: a4, scale: o3, onClick: (e5) => v2(e5, r3) }) }) }, r3.object.id) : ec(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: (null == l5 ? void 0 : l5.interaction.isDraggable) ?? true, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? false, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), vertexConfig: { extractVertices: (e4) => e4.vertices, transformAnnotation: (e4, t3) => ({ ...e4, vertices: t3 }) }, style: { mixBlendMode: mn(r3.object.blendMode ?? It.Normal) }, ...e3, children: (e4) => Ue(U2, { children: Ue(Fd, { ...e4, isSelected: a4, scale: o3, onClick: (e5) => v2(e5, r3) }) }) }, r3.object.id) : lc(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: ((null == l5 ? void 0 : l5.interaction.isDraggable) ?? true) && !s5, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? true, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), style: { mixBlendMode: mn(r3.object.blendMode ?? It.Normal) }, onDoubleClick: (e4) => {
        e4.stopPropagation(), m3(r3.object.id);
      }, ...e3, children: (e4) => Ue(jd, { isSelected: a4, isEditing: s5, annotation: { ...r3, object: e4 }, pageIndex: n3, scale: o3, onClick: (e5) => v2(e5, r3) }) }, r3.object.id) : cc(r3) ? Ue(Ad, { trackedAnnotation: r3, isSelected: a4, isDraggable: (null == l5 ? void 0 : l5.interaction.isDraggable) ?? true, isResizable: (null == l5 ? void 0 : l5.interaction.isResizable) ?? true, lockAspectRatio: (null == l5 ? void 0 : l5.interaction.lockAspectRatio) ?? false, selectionMenu: i3, onSelect: (e4) => v2(e4, r3), style: { mixBlendMode: mn(r3.object.blendMode ?? It.Normal) }, ...e3, children: (e4) => Ue(Ud, { isSelected: a4, annotation: r3, documentId: t2, pageIndex: n3, scale: o3, onClick: (e5) => v2(e5, r3) }) }, r3.object.id) : null;
    }) });
  }
  function Bd({ documentId: e3, pageIndex: t2, scale: n3 }) {
    var o3, i3, r2, a3, s4, l4, c4, d4, u4, h3, m3, g3;
    const { provides: p4 } = Ys(), { provides: v2 } = Md(), [f2, y2] = ke([]), [b2, w2] = ke(null), [x2, C2] = ke(null);
    if (Me(() => {
      if (p4) return p4.forDocument(e3).onSelectionChange(() => {
        y2(p4.forDocument(e3).getHighlightRectsForPage(t2)), w2(p4.forDocument(e3).getBoundingRectForPage(t2));
      });
    }, [p4, e3, t2]), Me(() => {
      if (v2) return C2(v2.forDocument(e3).getActiveTool()), v2.forDocument(e3).onActiveToolChange((e4) => C2(e4));
    }, [v2, e3]), !b2) return null;
    if (!x2 || !x2.defaults) return null;
    switch (x2.defaults.type) {
      case Dt.UNDERLINE:
        return Ue("div", { style: { mixBlendMode: mn((null == (o3 = x2.defaults) ? void 0 : o3.blendMode) ?? It.Normal), pointerEvents: "none", position: "absolute", inset: 0 }, children: Ue(zd, { color: null == (i3 = x2.defaults) ? void 0 : i3.color, opacity: null == (r2 = x2.defaults) ? void 0 : r2.opacity, segmentRects: f2, scale: n3 }) });
      case Dt.HIGHLIGHT:
        return Ue("div", { style: { mixBlendMode: mn((null == (a3 = x2.defaults) ? void 0 : a3.blendMode) ?? It.Multiply), pointerEvents: "none", position: "absolute", inset: 0 }, children: Ue(Td, { color: null == (s4 = x2.defaults) ? void 0 : s4.color, opacity: null == (l4 = x2.defaults) ? void 0 : l4.opacity, segmentRects: f2, scale: n3 }) });
      case Dt.STRIKEOUT:
        return Ue("div", { style: { mixBlendMode: mn((null == (c4 = x2.defaults) ? void 0 : c4.blendMode) ?? It.Normal), pointerEvents: "none", position: "absolute", inset: 0 }, children: Ue(Ed, { color: null == (d4 = x2.defaults) ? void 0 : d4.color, opacity: null == (u4 = x2.defaults) ? void 0 : u4.opacity, segmentRects: f2, scale: n3 }) });
      case Dt.SQUIGGLY:
        return Ue("div", { style: { mixBlendMode: mn((null == (h3 = x2.defaults) ? void 0 : h3.blendMode) ?? It.Normal), pointerEvents: "none", position: "absolute", inset: 0 }, children: Ue(_d, { color: null == (m3 = x2.defaults) ? void 0 : m3.color, opacity: null == (g3 = x2.defaults) ? void 0 : g3.opacity, segmentRects: f2, scale: n3 }) });
      default:
        return null;
    }
  }
  function qd({ preview: e3, scale: t2 }) {
    const { bounds: n3 } = e3, o3 = { position: "absolute", left: n3.origin.x * t2, top: n3.origin.y * t2, width: n3.size.width * t2, height: n3.size.height * t2, pointerEvents: "none", zIndex: 10 };
    return e3.type === Dt.CIRCLE ? Ue("div", { style: o3, children: Ue(Od, { isSelected: false, scale: t2, ...e3.data }) }) : e3.type === Dt.SQUARE ? Ue("div", { style: o3, children: Ue(Nd, { isSelected: false, scale: t2, ...e3.data }) }) : e3.type === Dt.POLYGON ? Ue("div", { style: o3, children: Ue(Fd, { isSelected: false, scale: t2, ...e3.data }) }) : e3.type === Dt.POLYLINE ? Ue("div", { style: o3, children: Ue($d, { isSelected: false, scale: t2, ...e3.data }) }) : e3.type === Dt.LINE ? Ue("div", { style: o3, children: Ue(Ld, { isSelected: false, scale: t2, ...e3.data }) }) : e3.type === Dt.INK ? Ue("div", { style: o3, children: Ue(Rd, { isSelected: false, scale: t2, ...e3.data }) }) : e3.type === Dt.FREETEXT ? Ue("div", { style: o3, children: Ue("div", { style: { width: "100%", height: "100%", border: `1px dashed ${e3.data.fontColor || "#000000"}`, backgroundColor: "transparent" } }) }) : null;
  }
  function Gd({ documentId: e3, pageIndex: t2, scale: n3 }) {
    const { plugin: o3 } = go(Wc.id), [i3, r2] = ke(/* @__PURE__ */ new Map()), a3 = Ae(null), s4 = Ae(null), l4 = Te(() => ({ requestFile: ({ accept: e4, onFile: t3 }) => {
      if (!a3.current) return;
      const n4 = a3.current;
      n4.accept = e4, n4.onchange = (e5) => {
        var o4;
        const i4 = null == (o4 = e5.target.files) ? void 0 : o4[0];
        i4 && (t3(i4), n4.value = "");
      }, n4.click();
    }, processImage: ({ source: e4, maxWidth: t3, maxHeight: n4, onComplete: o4 }) => {
      const i4 = s4.current;
      if (!i4 || !i4.getContext) return;
      const r3 = i4.getContext("2d");
      if (!r3) return;
      const a4 = new Image();
      a4.crossOrigin = "Anonymous", a4.onload = () => {
        let { naturalWidth: s5, naturalHeight: l5 } = a4;
        const c4 = t3 ? t3 / s5 : 1, d4 = n4 ? n4 / l5 : 1, u4 = Math.min(c4, d4, 1), h3 = s5 * u4, m3 = l5 * u4;
        i4.width = h3, i4.height = m3, r3.drawImage(a4, 0, 0, h3, m3);
        const g3 = r3.getImageData(0, 0, h3, m3);
        "string" != typeof e4 && URL.revokeObjectURL(a4.src), o4({ imageData: g3, width: h3, height: m3 });
      }, a4.src = "string" == typeof e4 ? e4 : URL.createObjectURL(e4);
    } }), []);
    return Me(() => {
      if (o3) return o3.registerPageHandlers(e3, t2, n3, { services: l4, onPreview: (e4, t3) => {
        r2((n4) => {
          const o4 = new Map(n4);
          return t3 ? o4.set(e4, t3) : o4.delete(e4), o4;
        });
      } });
    }, [e3, t2, n3, o3, l4]), Ue(U2, { children: [Ue("input", { ref: a3, type: "file", style: { display: "none" } }), Ue("canvas", { ref: s4, style: { display: "none" } }), Array.from(i3.entries()).map(([e4, t3]) => Ue(qd, { preview: t3, scale: n3 }, e4))] });
  }
  function Vd({ style: e3, documentId: t2, pageIndex: n3, scale: o3, rotation: i3, selectionMenu: r2, resizeUI: a3, vertexUI: s4, selectionOutlineColor: l4, customAnnotationRenderer: c4, ...d4 }) {
    var u4, h3, m3, g3;
    const p4 = fo(t2), v2 = null == (h3 = null == (u4 = null == p4 ? void 0 : p4.document) ? void 0 : u4.pages) ? void 0 : h3[n3], f2 = (null == (m3 = null == v2 ? void 0 : v2.size) ? void 0 : m3.width) ?? 0, y2 = (null == (g3 = null == v2 ? void 0 : v2.size) ? void 0 : g3.height) ?? 0, b2 = Te(() => void 0 !== o3 ? o3 : (null == p4 ? void 0 : p4.scale) ?? 1, [o3, null == p4 ? void 0 : p4.scale]);
    return Ue("div", { style: { ...e3 }, ...d4, children: [Ue(Wd, { documentId: t2, selectionMenu: r2, pageIndex: n3, scale: b2, rotation: Te(() => void 0 !== i3 ? i3 : (null == p4 ? void 0 : p4.rotation) ?? We.Degree0, [i3, null == p4 ? void 0 : p4.rotation]), pageWidth: f2, pageHeight: y2, resizeUI: a3, vertexUI: s4, selectionOutlineColor: l4, customAnnotationRenderer: c4 }), Ue(Bd, { documentId: t2, pageIndex: n3, scale: b2 }), Ue(Gd, { documentId: t2, pageIndex: n3, scale: b2 })] });
  }
  async function au(e3, t2, n3) {
    if ("enter" === e3.action) {
      const o3 = (function(e4, t3, n4) {
        if (!t3 || "enter" !== e4.action) return t3;
        let o4 = null;
        return n4 && (o4 = t3.querySelector(n4), o4 || console.warn(`Fullscreen: Could not find element with selector "${n4}" within the wrapper. Falling back to wrapper element.`)), o4 || (o4 = t3), o4;
      })(e3, t2, n3);
      o3 && !document.fullscreenElement && await o3.requestFullscreen();
    } else document.fullscreenElement && await document.exitFullscreen();
  }
  function gh({ color: e3 = "#FFFF00", opacity: t2 = 1, border: n3 = "1px solid red", rects: o3, rect: i3, scale: r2, onClick: a3, style: s4, ...l4 }) {
    return Ue(U2, { children: o3.map((o4, c4) => Ue("div", { onPointerDown: a3, onTouchStart: a3, style: { position: "absolute", border: n3, left: (i3 ? o4.origin.x - i3.origin.x : o4.origin.x) * r2, top: (i3 ? o4.origin.y - i3.origin.y : o4.origin.y) * r2, width: o4.size.width * r2, height: o4.size.height * r2, background: e3, opacity: t2, pointerEvents: a3 ? "auto" : "none", cursor: a3 ? "pointer" : "default", zIndex: a3 ? 1 : void 0, ...s4 }, ...l4 }, c4)) });
  }
  function ph({ documentId: e3, pageIndex: t2, scale: n3 }) {
    const { plugin: o3 } = hh(), [i3, r2] = ke([]), [a3, s4] = ke(null);
    return Me(() => {
      if (o3) return o3.onRedactionSelectionChange(e3, (e4) => {
        const n4 = e4.find((e5) => e5.pageIndex === t2);
        r2((null == n4 ? void 0 : n4.segmentRects) ?? []), s4((null == n4 ? void 0 : n4.rect) ?? null);
      });
    }, [o3, e3, t2]), a3 ? Ue("div", { style: { mixBlendMode: "normal", pointerEvents: "none", position: "absolute", inset: 0 }, children: Ue(gh, { color: "transparent", opacity: 1, rects: i3, scale: n3, border: "1px solid red" }) }) : null;
  }
  function vh({ documentId: e3, pageIndex: t2, scale: n3, bboxStroke: o3 = "rgba(0,0,0,0.8)", rotation: i3 = We.Degree0, selectionMenu: r2 }) {
    const { provides: a3 } = po(ch.id), [s4, l4] = ke([]), [c4, d4] = ke(null);
    Me(() => {
      if (!a3) return;
      const n4 = a3.forDocument(e3), o4 = n4.getState();
      l4(o4.pending[t2] ?? []), d4(o4.selected && o4.selected.page === t2 ? o4.selected.id : null);
      const i4 = n4.onPendingChange((e4) => l4(e4[t2] ?? [])), r3 = n4.onSelectedChange((e4) => {
        d4(e4 && e4.page === t2 ? e4.id : null);
      });
      return () => {
        null == i4 || i4(), null == r3 || r3();
      };
    }, [a3, e3, t2]);
    const u4 = ze((n4, o4) => {
      n4.stopPropagation(), a3 && a3.forDocument(e3).selectPending(t2, o4);
    }, [a3, e3, t2]);
    return s4.length ? Ue("div", { style: { position: "absolute", inset: 0, pointerEvents: "none" }, children: s4.map((e4) => {
      if ("area" === e4.kind) {
        const a5 = e4.rect;
        return Ue(U2, { children: [Ue("div", { style: { position: "absolute", left: a5.origin.x * n3, top: a5.origin.y * n3, width: a5.size.width * n3, height: a5.size.height * n3, background: "transparent", outline: c4 === e4.id ? `1px solid ${o3}` : "none", outlineOffset: "2px", border: "1px solid red", pointerEvents: "auto", cursor: "pointer" }, onPointerDown: (t3) => u4(t3, e4.id), onTouchStart: (t3) => u4(t3, e4.id) }), r2 && Ue(qs, { rect: { origin: { x: a5.origin.x * n3, y: a5.origin.y * n3 }, size: { width: a5.size.width * n3, height: a5.size.height * n3 } }, rotation: i3, children: (n4) => r2({ ...n4, context: { type: "redaction", item: e4, pageIndex: t2 }, selected: c4 === e4.id, placement: { suggestTop: false } }) })] }, e4.id);
      }
      const a4 = e4.rect;
      return Ue(U2, { children: [Ue("div", { style: { position: "absolute", left: a4.origin.x * n3, top: a4.origin.y * n3, width: a4.size.width * n3, height: a4.size.height * n3, background: "transparent", outline: c4 === e4.id ? `1px solid ${o3}` : "none", outlineOffset: "2px", pointerEvents: "auto", cursor: c4 === e4.id ? "pointer" : "default" }, children: Ue(gh, { rect: a4, rects: e4.rects, color: "transparent", border: "1px solid red", scale: n3, onClick: (t3) => u4(t3, e4.id) }) }), r2 && Ue(qs, { rect: { origin: { x: a4.origin.x * n3, y: a4.origin.y * n3 }, size: { width: a4.size.width * n3, height: a4.size.height * n3 } }, rotation: i3, children: (n4) => r2({ ...n4, context: { type: "redaction", item: e4, pageIndex: t2 }, selected: c4 === e4.id, placement: { suggestTop: false } }) })] }, e4.id);
    }) }) : null;
  }
  function Lm(e3) {
    var t2 = e3.children, n3 = e3.onClick, o3 = e3.active, i3 = void 0 !== o3 && o3, r2 = e3.disabled, a3 = void 0 !== r2 && r2, s4 = e3.className, l4 = void 0 === s4 ? "" : s4, c4 = e3.anchorRef, d4 = m2(e3, Om);
    return j2("button", h2({ ref: c4, onClick: n3, disabled: a3, className: Nm("flex h-[32px] w-auto min-w-[32px] items-center justify-center rounded-md p-[5px] transition-colors hover:bg-interactive-hover hover:ring hover:ring-accent cursor-pointer rounded-none px-2 py-1 text-sm hover:bg-transparent border-b-2 hover:border-b-fg-muted hover:ring-transparent", i3 ? "border-b-accent text-accent hover:border-b-accent" : "border-b-transparent", a3 ? "cursor-not-allowed opacity-50" : "", l4) }, d4), t2);
  }
  function Gm(e3) {
    return qm.test(e3.trim());
  }
  function Vm(e3, t2) {
    for (var n3 = (function(e4) {
      var t3, n4;
      return "path" in e4 ? { viewBox: e4.viewBox || "0 0 24 24", paths: [{ d: e4.path, stroke: null !== (t3 = e4.stroke) && void 0 !== t3 ? t3 : "primary", fill: null !== (n4 = e4.fill) && void 0 !== n4 ? n4 : "none", strokeWidth: e4.strokeWidth }], strokeLinecap: e4.strokeLinecap || "round", strokeLinejoin: e4.strokeLinejoin || "round", strokeWidth: e4.strokeWidth } : { viewBox: e4.viewBox || "0 0 24 24", paths: e4.paths, strokeLinecap: e4.strokeLinecap || "round", strokeLinejoin: e4.strokeLinejoin || "round", strokeWidth: e4.strokeWidth };
    })(t2), o3 = 0; o3 < n3.paths.length; o3++) {
      var i3 = n3.paths[o3];
      if (!i3.d || !Gm(i3.d)) throw new Error('Invalid path data for icon "'.concat(e3, '" at path index ').concat(o3, ". ") + "Path must only contain valid SVG path commands.");
    }
    Bm.set(e3, n3);
  }
  function Zm(e3) {
    for (var t2 = 0, n3 = Object.entries(e3); t2 < n3.length; t2++) {
      var o3 = f(n3[t2], 2);
      Vm(o3[0], o3[1]);
    }
  }
  function Km(e3, t2, n3) {
    return e3 && "none" !== e3 ? "primary" === e3 ? t2 : "secondary" === e3 ? n3 : "currentColor" === e3 ? "currentColor" : e3 : "none";
  }
  function Ym(e3) {
    var t2, n3 = e3.icon, o3 = e3.title, i3 = e3.size, r2 = void 0 === i3 ? 24 : i3, a3 = e3.strokeWidth, s4 = void 0 === a3 ? 2 : a3, l4 = e3.primaryColor, c4 = void 0 === l4 ? "currentColor" : l4, d4 = e3.secondaryColor, u4 = void 0 === d4 ? "none" : d4, h3 = e3.className, m3 = Wm[n3];
    if (m3) return j2(m3, { size: r2, strokeWidth: s4, primaryColor: c4, secondaryColor: u4, className: h3, title: o3 });
    if (t2 = n3, Bm.has(t2)) {
      var g3 = (function(e4) {
        return Bm.get(e4);
      })(n3);
      return (function(e4, t3) {
        var n4, o4 = t3.size, i4 = t3.strokeWidth, r3 = t3.primaryColor, a4 = t3.secondaryColor, s5 = t3.className, l5 = t3.title, c5 = null !== (n4 = e4.strokeWidth) && void 0 !== n4 ? n4 : i4;
        return j2("svg", { width: o4, height: o4, viewBox: e4.viewBox, "stroke-linecap": e4.strokeLinecap, "stroke-linejoin": e4.strokeLinejoin, class: s5, role: "img", "aria-label": l5 }, e4.paths.map(function(e5, t4) {
          var n5, o5 = Km(e5.stroke, r3, a4), i5 = Km(e5.fill, r3, a4), s6 = null !== (n5 = e5.strokeWidth) && void 0 !== n5 ? n5 : c5;
          return j2("path", { key: t4, d: e5.d, stroke: o5, fill: i5, "stroke-width": "none" !== o5 ? s6 : void 0, opacity: e5.opacity });
        }));
      })(g3, { size: r2, strokeWidth: s4, primaryColor: c4, secondaryColor: u4, className: h3, title: o3 });
    }
    return console.warn("Icon not found: ".concat(n3)), null;
  }
  function Qm(e3) {
    var t2 = e3.id, n3 = e3.children, o3 = e3.onClick, i3 = e3.active, r2 = void 0 !== i3 && i3, a3 = e3.disabled, s4 = void 0 !== a3 && a3, l4 = e3.className, c4 = void 0 === l4 ? "" : l4, d4 = e3.tooltip, u4 = e3.elementRef, g3 = m2(e3, Xm);
    return j2("button", h2({ id: t2, ref: u4, onClick: o3, className: "flex h-[32px] w-auto min-w-[32px] items-center justify-center rounded-md p-[5px] transition-colors ".concat(r2 ? "bg-interactive-selected text-accent ring-accent border-none shadow ring" : "hover:bg-interactive-hover hover:ring-accent hover:ring", " ").concat(s4 ? "cursor-not-allowed opacity-50 hover:bg-transparent hover:ring-0" : "cursor-pointer", " ").concat(c4), title: d4 }, g3), n3);
  }
  function ag(e3, t2, n3) {
    return eg(e3, Jm(t2, n3));
  }
  function sg(e3, t2) {
    return "function" == typeof e3 ? e3(t2) : e3;
  }
  function lg(e3) {
    return e3.split("-")[0];
  }
  function cg(e3) {
    return e3.split("-")[1];
  }
  function dg(e3) {
    return "x" === e3 ? "y" : "x";
  }
  function ug(e3) {
    return "y" === e3 ? "height" : "width";
  }
  function mg(e3) {
    return hg.has(lg(e3)) ? "y" : "x";
  }
  function gg(e3) {
    return dg(mg(e3));
  }
  function pg(e3) {
    return e3.replace(/start|end/g, (e4) => rg[e4]);
  }
  function wg(e3, t2, n3, o3) {
    const i3 = cg(e3);
    let r2 = (function(e4, t3, n4) {
      switch (e4) {
        case "top":
        case "bottom":
          return n4 ? t3 ? fg : vg : t3 ? vg : fg;
        case "left":
        case "right":
          return t3 ? yg : bg;
        default:
          return [];
      }
    })(lg(e3), "start" === n3, o3);
    return i3 && (r2 = r2.map((e4) => e4 + "-" + i3), t2 && (r2 = r2.concat(r2.map(pg)))), r2;
  }
  function xg(e3) {
    return e3.replace(/left|right|bottom|top/g, (e4) => ig[e4]);
  }
  function Cg(e3) {
    return "number" != typeof e3 ? (function(e4) {
      return { top: 0, right: 0, bottom: 0, left: 0, ...e4 };
    })(e3) : { top: e3, right: e3, bottom: e3, left: e3 };
  }
  function Ig(e3) {
    const { x: t2, y: n3, width: o3, height: i3 } = e3;
    return { width: o3, height: i3, top: n3, left: t2, right: t2 + o3, bottom: n3 + i3, x: t2, y: n3 };
  }
  function Sg(e3, t2, n3) {
    let { reference: o3, floating: i3 } = e3;
    const r2 = mg(t2), a3 = gg(t2), s4 = ug(a3), l4 = lg(t2), c4 = "y" === r2, d4 = o3.x + o3.width / 2 - i3.width / 2, u4 = o3.y + o3.height / 2 - i3.height / 2, h3 = o3[s4] / 2 - i3[s4] / 2;
    let m3;
    switch (l4) {
      case "top":
        m3 = { x: d4, y: o3.y - i3.height };
        break;
      case "bottom":
        m3 = { x: d4, y: o3.y + o3.height };
        break;
      case "right":
        m3 = { x: o3.x + o3.width, y: u4 };
        break;
      case "left":
        m3 = { x: o3.x - i3.width, y: u4 };
        break;
      default:
        m3 = { x: o3.x, y: o3.y };
    }
    switch (cg(t2)) {
      case "start":
        m3[a3] -= h3 * (n3 && c4 ? -1 : 1);
        break;
      case "end":
        m3[a3] += h3 * (n3 && c4 ? -1 : 1);
    }
    return m3;
  }
  async function kg(e3, t2) {
    var n3;
    void 0 === t2 && (t2 = {});
    const { x: o3, y: i3, platform: r2, rects: a3, elements: s4, strategy: l4 } = e3, { boundary: c4 = "clippingAncestors", rootBoundary: d4 = "viewport", elementContext: u4 = "floating", altBoundary: h3 = false, padding: m3 = 0 } = sg(t2, e3), g3 = Cg(m3), p4 = s4[h3 ? "floating" === u4 ? "reference" : "floating" : u4], v2 = Ig(await r2.getClippingRect({ element: null == (n3 = await (null == r2.isElement ? void 0 : r2.isElement(p4))) || n3 ? p4 : p4.contextElement || await (null == r2.getDocumentElement ? void 0 : r2.getDocumentElement(s4.floating)), boundary: c4, rootBoundary: d4, strategy: l4 })), f2 = "floating" === u4 ? { x: o3, y: i3, width: a3.floating.width, height: a3.floating.height } : a3.reference, y2 = await (null == r2.getOffsetParent ? void 0 : r2.getOffsetParent(s4.floating)), b2 = await (null == r2.isElement ? void 0 : r2.isElement(y2)) && await (null == r2.getScale ? void 0 : r2.getScale(y2)) || { x: 1, y: 1 }, w2 = Ig(r2.convertOffsetParentRelativeRectToViewportRelativeRect ? await r2.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: s4, rect: f2, offsetParent: y2, strategy: l4 }) : f2);
    return { top: (v2.top - w2.top + g3.top) / b2.y, bottom: (w2.bottom - v2.bottom + g3.bottom) / b2.y, left: (v2.left - w2.left + g3.left) / b2.x, right: (w2.right - v2.right + g3.right) / b2.x };
  }
  function Mg() {
    return "undefined" != typeof window;
  }
  function Pg(e3) {
    return zg(e3) ? (e3.nodeName || "").toLowerCase() : "#document";
  }
  function Ag(e3) {
    var t2;
    return (null == e3 || null == (t2 = e3.ownerDocument) ? void 0 : t2.defaultView) || window;
  }
  function Tg(e3) {
    var t2;
    return null == (t2 = (zg(e3) ? e3.ownerDocument : e3.document) || window.document) ? void 0 : t2.documentElement;
  }
  function zg(e3) {
    return !!Mg() && (e3 instanceof Node || e3 instanceof Ag(e3).Node);
  }
  function Eg(e3) {
    return !!Mg() && (e3 instanceof Element || e3 instanceof Ag(e3).Element);
  }
  function _g(e3) {
    return !!Mg() && (e3 instanceof HTMLElement || e3 instanceof Ag(e3).HTMLElement);
  }
  function Rg(e3) {
    return !(!Mg() || "undefined" == typeof ShadowRoot) && (e3 instanceof ShadowRoot || e3 instanceof Ag(e3).ShadowRoot);
  }
  function Og(e3) {
    const { overflow: t2, overflowX: n3, overflowY: o3, display: i3 } = Zg(e3);
    return /auto|scroll|overlay|hidden|clip/.test(t2 + o3 + n3) && !Ng.has(i3);
  }
  function $g(e3) {
    return Lg.has(Pg(e3));
  }
  function jg(e3) {
    return Fg.some((t2) => {
      try {
        return e3.matches(t2);
      } catch (e4) {
        return false;
      }
    });
  }
  function Bg(e3) {
    const t2 = qg(), n3 = Eg(e3) ? Zg(e3) : e3;
    return Hg.some((e4) => !!n3[e4] && "none" !== n3[e4]) || !!n3.containerType && "normal" !== n3.containerType || !t2 && !!n3.backdropFilter && "none" !== n3.backdropFilter || !t2 && !!n3.filter && "none" !== n3.filter || Ug.some((e4) => (n3.willChange || "").includes(e4)) || Wg.some((e4) => (n3.contain || "").includes(e4));
  }
  function qg() {
    return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
  }
  function Vg(e3) {
    return Gg.has(Pg(e3));
  }
  function Zg(e3) {
    return Ag(e3).getComputedStyle(e3);
  }
  function Kg(e3) {
    return Eg(e3) ? { scrollLeft: e3.scrollLeft, scrollTop: e3.scrollTop } : { scrollLeft: e3.scrollX, scrollTop: e3.scrollY };
  }
  function Yg(e3) {
    if ("html" === Pg(e3)) return e3;
    const t2 = e3.assignedSlot || e3.parentNode || Rg(e3) && e3.host || Tg(e3);
    return Rg(t2) ? t2.host : t2;
  }
  function Xg(e3) {
    const t2 = Yg(e3);
    return Vg(t2) ? e3.ownerDocument ? e3.ownerDocument.body : e3.body : _g(t2) && Og(t2) ? t2 : Xg(t2);
  }
  function Qg(e3, t2, n3) {
    var o3;
    void 0 === t2 && (t2 = []), void 0 === n3 && (n3 = true);
    const i3 = Xg(e3), r2 = i3 === (null == (o3 = e3.ownerDocument) ? void 0 : o3.body), a3 = Ag(i3);
    if (r2) {
      const e4 = Jg(a3);
      return t2.concat(a3, a3.visualViewport || [], Og(i3) ? i3 : [], e4 && n3 ? Qg(e4) : []);
    }
    return t2.concat(i3, Qg(i3, [], n3));
  }
  function Jg(e3) {
    return e3.parent && Object.getPrototypeOf(e3.parent) ? e3.frameElement : null;
  }
  function ep(e3) {
    const t2 = Zg(e3);
    let n3 = parseFloat(t2.width) || 0, o3 = parseFloat(t2.height) || 0;
    const i3 = _g(e3), r2 = i3 ? e3.offsetWidth : n3, a3 = i3 ? e3.offsetHeight : o3, s4 = tg(n3) !== r2 || tg(o3) !== a3;
    return s4 && (n3 = r2, o3 = a3), { width: n3, height: o3, $: s4 };
  }
  function tp(e3) {
    return Eg(e3) ? e3 : e3.contextElement;
  }
  function np(e3) {
    const t2 = tp(e3);
    if (!_g(t2)) return og(1);
    const n3 = t2.getBoundingClientRect(), { width: o3, height: i3, $: r2 } = ep(t2);
    let a3 = (r2 ? tg(n3.width) : n3.width) / o3, s4 = (r2 ? tg(n3.height) : n3.height) / i3;
    return a3 && Number.isFinite(a3) || (a3 = 1), s4 && Number.isFinite(s4) || (s4 = 1), { x: a3, y: s4 };
  }
  function ip(e3) {
    const t2 = Ag(e3);
    return qg() && t2.visualViewport ? { x: t2.visualViewport.offsetLeft, y: t2.visualViewport.offsetTop } : op;
  }
  function rp(e3, t2, n3, o3) {
    void 0 === t2 && (t2 = false), void 0 === n3 && (n3 = false);
    const i3 = e3.getBoundingClientRect(), r2 = tp(e3);
    let a3 = og(1);
    t2 && (o3 ? Eg(o3) && (a3 = np(o3)) : a3 = np(e3));
    const s4 = (function(e4, t3, n4) {
      return void 0 === t3 && (t3 = false), !(!n4 || t3 && n4 !== Ag(e4)) && t3;
    })(r2, n3, o3) ? ip(r2) : og(0);
    let l4 = (i3.left + s4.x) / a3.x, c4 = (i3.top + s4.y) / a3.y, d4 = i3.width / a3.x, u4 = i3.height / a3.y;
    if (r2) {
      const e4 = Ag(r2), t3 = o3 && Eg(o3) ? Ag(o3) : o3;
      let n4 = e4, i4 = Jg(n4);
      for (; i4 && o3 && t3 !== n4; ) {
        const e5 = np(i4), t4 = i4.getBoundingClientRect(), o4 = Zg(i4), r3 = t4.left + (i4.clientLeft + parseFloat(o4.paddingLeft)) * e5.x, a4 = t4.top + (i4.clientTop + parseFloat(o4.paddingTop)) * e5.y;
        l4 *= e5.x, c4 *= e5.y, d4 *= e5.x, u4 *= e5.y, l4 += r3, c4 += a4, n4 = Ag(i4), i4 = Jg(n4);
      }
    }
    return Ig({ width: d4, height: u4, x: l4, y: c4 });
  }
  function ap(e3, t2) {
    const n3 = Kg(e3).scrollLeft;
    return t2 ? t2.left + n3 : rp(Tg(e3)).left + n3;
  }
  function sp(e3, t2) {
    const n3 = e3.getBoundingClientRect();
    return { x: n3.left + t2.scrollLeft - ap(e3, n3), y: n3.top + t2.scrollTop };
  }
  function cp(e3, t2, n3) {
    let o3;
    if ("viewport" === t2) o3 = (function(e4, t3) {
      const n4 = Ag(e4), o4 = Tg(e4), i3 = n4.visualViewport;
      let r2 = o4.clientWidth, a3 = o4.clientHeight, s4 = 0, l4 = 0;
      if (i3) {
        r2 = i3.width, a3 = i3.height;
        const e5 = qg();
        (!e5 || e5 && "fixed" === t3) && (s4 = i3.offsetLeft, l4 = i3.offsetTop);
      }
      const c4 = ap(o4);
      if (c4 <= 0) {
        const e5 = o4.ownerDocument, t4 = e5.body, n5 = getComputedStyle(t4), i4 = "CSS1Compat" === e5.compatMode && parseFloat(n5.marginLeft) + parseFloat(n5.marginRight) || 0, a4 = Math.abs(o4.clientWidth - t4.clientWidth - i4);
        a4 <= 25 && (r2 -= a4);
      } else c4 <= 25 && (r2 += c4);
      return { width: r2, height: a3, x: s4, y: l4 };
    })(e3, n3);
    else if ("document" === t2) o3 = (function(e4) {
      const t3 = Tg(e4), n4 = Kg(e4), o4 = e4.ownerDocument.body, i3 = eg(t3.scrollWidth, t3.clientWidth, o4.scrollWidth, o4.clientWidth), r2 = eg(t3.scrollHeight, t3.clientHeight, o4.scrollHeight, o4.clientHeight);
      let a3 = -n4.scrollLeft + ap(e4);
      const s4 = -n4.scrollTop;
      return "rtl" === Zg(o4).direction && (a3 += eg(t3.clientWidth, o4.clientWidth) - i3), { width: i3, height: r2, x: a3, y: s4 };
    })(Tg(e3));
    else if (Eg(t2)) o3 = (function(e4, t3) {
      const n4 = rp(e4, true, "fixed" === t3), o4 = n4.top + e4.clientTop, i3 = n4.left + e4.clientLeft, r2 = _g(e4) ? np(e4) : og(1);
      return { width: e4.clientWidth * r2.x, height: e4.clientHeight * r2.y, x: i3 * r2.x, y: o4 * r2.y };
    })(t2, n3);
    else {
      const n4 = ip(e3);
      o3 = { x: t2.x - n4.x, y: t2.y - n4.y, width: t2.width, height: t2.height };
    }
    return Ig(o3);
  }
  function dp(e3, t2) {
    const n3 = Yg(e3);
    return !(n3 === t2 || !Eg(n3) || Vg(n3)) && ("fixed" === Zg(n3).position || dp(n3, t2));
  }
  function up(e3, t2, n3) {
    const o3 = _g(t2), i3 = Tg(t2), r2 = "fixed" === n3, a3 = rp(e3, true, r2, t2);
    let s4 = { scrollLeft: 0, scrollTop: 0 };
    const l4 = og(0);
    function c4() {
      l4.x = ap(i3);
    }
    if (o3 || !o3 && !r2) if (("body" !== Pg(t2) || Og(i3)) && (s4 = Kg(t2)), o3) {
      const e4 = rp(t2, true, r2, t2);
      l4.x = e4.x + t2.clientLeft, l4.y = e4.y + t2.clientTop;
    } else i3 && c4();
    r2 && !o3 && i3 && c4();
    const d4 = !i3 || o3 || r2 ? og(0) : sp(i3, s4);
    return { x: a3.left + s4.scrollLeft - l4.x - d4.x, y: a3.top + s4.scrollTop - l4.y - d4.y, width: a3.width, height: a3.height };
  }
  function hp(e3) {
    return "static" === Zg(e3).position;
  }
  function mp(e3, t2) {
    if (!_g(e3) || "fixed" === Zg(e3).position) return null;
    if (t2) return t2(e3);
    let n3 = e3.offsetParent;
    return Tg(e3) === n3 && (n3 = n3.ownerDocument.body), n3;
  }
  function gp(e3, t2) {
    const n3 = Ag(e3);
    if (jg(e3)) return n3;
    if (!_g(e3)) {
      let t3 = Yg(e3);
      for (; t3 && !Vg(t3); ) {
        if (Eg(t3) && !hp(t3)) return t3;
        t3 = Yg(t3);
      }
      return n3;
    }
    let o3 = mp(e3, t2);
    for (; o3 && $g(o3) && hp(o3); ) o3 = mp(o3, t2);
    return o3 && Vg(o3) && hp(o3) && !Bg(o3) ? n3 : o3 || (function(e4) {
      let t3 = Yg(e4);
      for (; _g(t3) && !Vg(t3); ) {
        if (Bg(t3)) return t3;
        if (jg(t3)) return null;
        t3 = Yg(t3);
      }
      return null;
    })(e3) || n3;
  }
  function vp(e3, t2) {
    return e3.x === t2.x && e3.y === t2.y && e3.width === t2.width && e3.height === t2.height;
  }
  function fp(e3, t2, n3, o3) {
    void 0 === o3 && (o3 = {});
    const { ancestorScroll: i3 = true, ancestorResize: r2 = true, elementResize: a3 = "function" == typeof ResizeObserver, layoutShift: s4 = "function" == typeof IntersectionObserver, animationFrame: l4 = false } = o3, c4 = tp(e3), d4 = i3 || r2 ? [...c4 ? Qg(c4) : [], ...Qg(t2)] : [];
    d4.forEach((e4) => {
      i3 && e4.addEventListener("scroll", n3, { passive: true }), r2 && e4.addEventListener("resize", n3);
    });
    const u4 = c4 && s4 ? (function(e4, t3) {
      let n4, o4 = null;
      const i4 = Tg(e4);
      function r3() {
        var e5;
        clearTimeout(n4), null == (e5 = o4) || e5.disconnect(), o4 = null;
      }
      return (function a4(s5, l5) {
        void 0 === s5 && (s5 = false), void 0 === l5 && (l5 = 1), r3();
        const c5 = e4.getBoundingClientRect(), { left: d5, top: u5, width: h4, height: m4 } = c5;
        if (s5 || t3(), !h4 || !m4) return;
        const g4 = { rootMargin: -ng(u5) + "px " + -ng(i4.clientWidth - (d5 + h4)) + "px " + -ng(i4.clientHeight - (u5 + m4)) + "px " + -ng(d5) + "px", threshold: eg(0, Jm(1, l5)) || 1 };
        let p5 = true;
        function v2(t4) {
          const o5 = t4[0].intersectionRatio;
          if (o5 !== l5) {
            if (!p5) return a4();
            o5 ? a4(false, o5) : n4 = setTimeout(() => {
              a4(false, 1e-7);
            }, 1e3);
          }
          1 !== o5 || vp(c5, e4.getBoundingClientRect()) || a4(), p5 = false;
        }
        try {
          o4 = new IntersectionObserver(v2, { ...g4, root: i4.ownerDocument });
        } catch (e5) {
          o4 = new IntersectionObserver(v2, g4);
        }
        o4.observe(e4);
      })(true), r3;
    })(c4, n3) : null;
    let h3, m3 = -1, g3 = null;
    a3 && (g3 = new ResizeObserver((e4) => {
      let [o4] = e4;
      o4 && o4.target === c4 && g3 && (g3.unobserve(t2), cancelAnimationFrame(m3), m3 = requestAnimationFrame(() => {
        var e5;
        null == (e5 = g3) || e5.observe(t2);
      })), n3();
    }), c4 && !l4 && g3.observe(c4), g3.observe(t2));
    let p4 = l4 ? rp(e3) : null;
    return l4 && (function t3() {
      const o4 = rp(e3);
      p4 && !vp(p4, o4) && n3();
      p4 = o4, h3 = requestAnimationFrame(t3);
    })(), n3(), () => {
      var e4;
      d4.forEach((e5) => {
        i3 && e5.removeEventListener("scroll", n3), r2 && e5.removeEventListener("resize", n3);
      }), null == u4 || u4(), null == (e4 = g3) || e4.disconnect(), g3 = null, l4 && cancelAnimationFrame(h3);
    };
  }
  function Sp(e3) {
    var t2 = e3.children, n3 = e3.content, o3 = e3.position, i3 = void 0 === o3 ? "top" : o3, r2 = e3.className, a3 = void 0 === r2 ? "" : r2, l4 = e3.delay, c4 = void 0 === l4 ? 200 : l4, d4 = e3.style, u4 = void 0 === d4 ? "dark" : d4, h3 = e3.trigger, m3 = void 0 === h3 ? "hover" : h3, g3 = Ae(null), p4 = Ae(null), v2 = Ae(null), y2 = f(ke(false), 2), b2 = y2[0], w2 = y2[1], x2 = Ae(null);
    return Me(function() {
      var e4;
      if (null !== (e4 = g3.current) && void 0 !== e4 && e4.base && p4.current) return fp(g3.current.base, p4.current, function() {
        Cp(g3.current.base, p4.current, { placement: i3, middleware: [yp(8), wp(), bp({ padding: 8 }), xp({ element: v2.current, padding: 6 })] }).then(function(e5) {
          var t3, n4 = e5.x, o4 = e5.y, i4 = e5.placement, r3 = e5.middlewareData;
          Object.assign(p4.current.style, { left: "".concat(n4, "px"), top: "".concat(o4, "px") });
          var a4 = null !== (t3 = r3.arrow) && void 0 !== t3 ? t3 : {}, l5 = a4.x, c5 = a4.y, d5 = { top: "bottom", bottom: "top", left: "right", right: "left" }[i4.split("-")[0]];
          Object.assign(v2.current.style, s3({ left: null != l5 ? "".concat(l5, "px") : "", top: null != c5 ? "".concat(c5, "px") : "", right: "", bottom: "" }, d5, "-4px"));
        });
      });
    }, [i3, b2]), Me(function() {
      var e4, t3 = null === (e4 = g3.current) || void 0 === e4 ? void 0 : e4.base, n4 = p4.current;
      if (t3 && n4) {
        var o4 = function() {
          x2.current && clearTimeout(x2.current);
        }, i4 = function() {
          o4(), x2.current = setTimeout(function() {
            return w2(true);
          }, c4);
        }, r3 = function() {
          o4(), w2(false);
        }, a4 = function() {
          return w2(function(e5) {
            return !e5;
          });
        };
        return "hover" === m3 ? (t3.addEventListener("mouseenter", i4), t3.addEventListener("mouseleave", r3), n4.addEventListener("mouseenter", i4), n4.addEventListener("mouseleave", r3), t3.addEventListener("pointerdown", r3)) : "click" === m3 && t3.addEventListener("click", a4), "none" === m3 && (x2.current && clearTimeout(x2.current), w2(false)), function() {
          o4(), "hover" === m3 ? (t3.removeEventListener("mouseenter", i4), t3.removeEventListener("mouseleave", r3), n4.removeEventListener("mouseenter", i4), n4.removeEventListener("mouseleave", r3), t3.removeEventListener("pointerdown", r3)) : "click" === m3 && t3.removeEventListener("click", a4);
        };
      }
    }, [m3, c4]), j2(U2, null, j2("div", { ref: p4, role: "tooltip", className: "z-100 pointer-events-none absolute select-none whitespace-nowrap rounded-lg px-3 py-2 text-sm shadow-md transition-opacity duration-150 ".concat("dark" === u4 ? "bg-tooltip-bg text-tooltip-fg" : "border-border-subtle bg-bg-elevated text-fg-primary border", " ").concat(b2 ? "opacity-100" : "opacity-0", " ").concat(a3, " "), style: { visibility: b2 ? "visible" : "hidden" } }, n3, j2("div", { ref: v2, className: "absolute h-2 w-2 rotate-45 bg-inherit ".concat("light" === u4 ? "border-border-subtle border" : "", " ") })), j2(Ip, { ref: g3 }, t2));
  }
  function kp(e3) {
    var t2 = e3.commandId, n3 = e3.documentId, o3 = e3.variant, i3 = void 0 === o3 ? "icon" : o3, r2 = e3.itemId, a3 = e3.className, s4 = ta(t2, n3), l4 = Tr(n3, r2 || t2);
    if (!s4 || !s4.visible) return null;
    var c4 = s4.iconProps || {};
    return j2(Sp, { content: s4.label, position: "bottom", delay: 500, trigger: s4.active ? "none" : "hover" }, j2(Qm, { elementRef: l4, onClick: function() {
      s4.disabled || s4.execute();
    }, active: s4.active, disabled: s4.disabled, className: a3 || "p-1", "aria-label": s4.label }, "text" === i3 ? j2("span", { className: "text-sm" }, s4.label) : "icon-text" === i3 ? j2(U2, null, s4.icon && j2(Ym, { icon: s4.icon, className: "mr-2 h-5 w-5", primaryColor: c4.primaryColor, secondaryColor: c4.secondaryColor }), j2("span", null, s4.label)) : "tab" === i3 ? j2("span", { className: "px-3 py-1" }, s4.label) : s4.icon ? j2(Ym, { icon: s4.icon, className: Nm("h-5 w-5", c4.className), primaryColor: c4.primaryColor, secondaryColor: c4.secondaryColor }) : j2("span", null, s4.label)));
  }
  function Dp(e3) {
    var t2 = e3.schema, n3 = e3.documentId, o3 = e3.isOpen, i3 = e3.className, r2 = void 0 === i3 ? "" : i3;
    if (!o3) return null;
    var a3 = "secondary" === t2.position.slot, s4 = (function(e4) {
      switch (e4) {
        case "top":
          return "border-b border-border-default bg-bg-surface px-4 py-2";
        case "bottom":
          return "border-t border-border-default bg-bg-surface px-4 py-2";
        case "left":
          return "border-r border-border-default bg-bg-surface px-2 py-3 flex-col";
        case "right":
          return "border-l border-border-default bg-bg-surface px-2 py-3 flex-col";
      }
    })(t2.position.placement);
    return j2("div", h2({ className: Nm("flex items-center gap-2", s4, a3 ? "bg-bg-surface-alt" : "", r2) }, mr(t2)), t2.items.map(function(e4) {
      return j2(Mp, { key: e4.id, item: e4, documentId: n3 });
    }));
  }
  function Mp(e3) {
    var t2 = e3.item, n3 = e3.documentId;
    switch (t2.type) {
      case "command-button":
        return j2(Pp, { item: t2, documentId: n3 });
      case "tab-group":
        return j2(Ap, { item: t2, documentId: n3 });
      case "divider":
        return j2(Ep, { item: t2 });
      case "spacer":
        return j2(_p, { item: t2 });
      case "group":
        return j2(Rp, { item: t2, documentId: n3 });
      case "custom":
        return j2(Np, { item: t2, documentId: n3 });
      default:
        return console.warn("Unknown toolbar item type:", t2), null;
    }
  }
  function Pp(e3) {
    var t2 = e3.item, n3 = e3.documentId;
    return j2("div", h2({}, mr(t2)), j2(kp, { commandId: t2.commandId, documentId: n3, itemId: t2.id, variant: t2.variant }));
  }
  function Ap(e3) {
    var t2 = e3.item, n3 = e3.documentId;
    return j2("div", h2(h2({ className: "flex items-center gap-2" }, mr(t2)), {}, { role: "tablist" }), t2.tabs.map(function(e4) {
      return j2(Tp, { key: e4.id, tab: e4, documentId: n3 });
    }));
  }
  function Tp(e3) {
    var t2 = e3.tab, n3 = e3.documentId, o3 = ta(t2.commandId, n3), i3 = Tr(n3, t2.id);
    if (!o3 || !o3.visible) return null;
    return j2("div", h2({}, mr(t2)), j2(Lm, { anchorRef: i3, active: o3.active, onClick: function() {
      o3.disabled || o3.execute();
    }, disabled: o3.disabled }, "text" === t2.variant && o3.label, "icon" === t2.variant && o3.icon && j2(zp, { icon: o3.icon, iconProps: o3.iconProps }), "icon-text" === t2.variant && j2(U2, null, o3.icon && j2(zp, { icon: o3.icon, iconProps: o3.iconProps }), o3.label)));
  }
  function zp(e3) {
    var t2 = e3.icon, n3 = e3.iconProps;
    return j2(Ym, { icon: t2, className: "h-5 w-5", primaryColor: null == n3 ? void 0 : n3.primaryColor, secondaryColor: null == n3 ? void 0 : n3.secondaryColor });
  }
  function Ep(e3) {
    var t2 = e3.item;
    return j2("div", h2({}, mr(t2)), j2("div", { className: "vertical" === t2.orientation ? "bg-border-default h-6 w-px" : "bg-border-default h-px w-6", "aria-hidden": "true" }));
  }
  function _p(e3) {
    var t2 = e3.item;
    return j2("div", h2(h2({ className: t2.flex ? "flex-1" : "w-4" }, mr(t2)), {}, { "aria-hidden": "true" }));
  }
  function Rp(e3) {
    var t2 = e3.item, n3 = e3.documentId, o3 = t2.gap ? "gap-".concat(t2.gap) : "gap-2", i3 = (function(e4) {
      switch (e4) {
        case "start":
        default:
          return "justify-start";
        case "center":
          return "justify-center";
        case "end":
          return "justify-end";
      }
    })(t2.alignment);
    return j2("div", h2({ className: Nm("flex items-center", o3, i3) }, mr(t2)), t2.items.map(function(e4) {
      return j2(Mp, { key: e4.id, item: e4, documentId: n3 });
    }));
  }
  function Np(e3) {
    var t2 = e3.item, n3 = e3.documentId, o3 = _r().renderCustomComponent;
    return j2("div", h2({}, mr(t2)), o3(t2.componentId, n3, t2.props));
  }
  function Op(e3, t2) {
    for (var n3 in e3) if ("__source" !== n3 && !(n3 in t2)) return true;
    for (var o3 in t2) if ("__source" !== o3 && e3[o3] !== t2[o3]) return true;
    return false;
  }
  function Lp(e3, t2) {
    this.props = e3, this.context = t2;
  }
  function Hp(e3, t2, n3) {
    return e3 && (e3.__c && e3.__c.__H && (e3.__c.__H.__.forEach(function(e4) {
      "function" == typeof e4.__c && e4.__c();
    }), e3.__c.__H = null), null != (e3 = (function(e4, t3) {
      for (var n4 in t3) e4[n4] = t3[n4];
      return e4;
    })({}, e3)).__c && (e3.__c.__P === n3 && (e3.__c.__P = t2), e3.__c.__e = true, e3.__c = null), e3.__k = e3.__k && e3.__k.map(function(e4) {
      return Hp(e4, t2, n3);
    })), e3;
  }
  function Up(e3, t2, n3) {
    return e3 && n3 && (e3.__v = null, e3.__k = e3.__k && e3.__k.map(function(e4) {
      return Up(e4, t2, n3);
    }), e3.__c && e3.__c.__P === t2 && (e3.__e && n3.appendChild(e3.__e), e3.__c.__e = true, e3.__c.__P = n3)), e3;
  }
  function Wp() {
    this.__u = 0, this.o = null, this.__b = null;
  }
  function Bp(e3) {
    var t2 = e3.__.__c;
    return t2 && t2.__a && t2.__a(e3);
  }
  function qp() {
    this.i = null, this.l = null;
  }
  function Vp(e3) {
    return this.getChildContext = function() {
      return e3.context;
    }, e3.children;
  }
  function Zp(e3) {
    var t2 = this, n3 = e3.h;
    if (t2.componentWillUnmount = function() {
      ce(null, t2.v), t2.v = null, t2.h = null;
    }, t2.h && t2.h !== n3 && t2.componentWillUnmount(), !t2.v) {
      for (var o3 = t2.__v; null !== o3 && !o3.__m && null !== o3.__; ) o3 = o3.__;
      t2.h = n3, t2.v = { nodeType: 1, parentNode: n3, childNodes: [], __k: { __m: o3.__m }, contains: function() {
        return true;
      }, insertBefore: function(e4, n4) {
        this.childNodes.push(e4), t2.h.insertBefore(e4, n4);
      }, removeChild: function(e4) {
        this.childNodes.splice(this.childNodes.indexOf(e4) >>> 1, 1), t2.h.removeChild(e4);
      } };
    }
    ce(j2(Vp, { context: t2.context }, e3.__v), t2.v);
  }
  function Kp(e3, t2) {
    var n3 = j2(Zp, { __v: e3, h: t2 });
    return n3.containerInfo = t2, n3;
  }
  function ov() {
  }
  function iv() {
    return this.cancelBubble;
  }
  function rv() {
    return this.defaultPrevented;
  }
  function dv(e3) {
    var t2 = e3.schema, n3 = e3.documentId, o3 = e3.isOpen, i3 = e3.onClose, r2 = Dr().getContainer, a3 = ke(function() {
      var e4 = r2();
      return !!e4 && e4.clientWidth < 768;
    }), s4 = f(a3, 2), l4 = s4[0], c4 = s4[1];
    Me(function() {
      var e4 = r2();
      if (e4) {
        var t3 = new ResizeObserver(function() {
          var t4 = e4.clientWidth;
          c4(t4 < 768);
        });
        return t3.observe(e4), function() {
          return t3.disconnect();
        };
      }
    }, [r2]);
    var d4 = t2.position, u4 = t2.content, h3 = t2.width, m3 = _r().renderCustomComponent, g3 = r2();
    if (l4 && g3) return Kp(j2(uv, { schema: t2, documentId: n3, isOpen: o3, onClose: i3, renderCustomComponent: m3, content: u4, rootElement: g3 }), g3);
    if (!o3) return null;
    var p4 = (function(e4) {
      switch (e4) {
        case "left":
          return "border-r";
        case "right":
          return "border-l";
        case "top":
          return "border-b";
        case "bottom":
          return "border-t";
      }
    })(d4.placement), v2 = h3 ? { width: h3 } : void 0;
    return j2("div", { className: "".concat(p4, " border-border-default bg-bg-surface flex flex-col shadow-lg"), style: v2, "data-sidebar-id": t2.id }, j2("div", { className: "min-h-0 flex-1" }, "tabs" === u4.type && j2(hv, { content: u4, documentId: n3, renderCustomComponent: m3 }), "component" === u4.type && j2(U2, null, m3(u4.componentId, n3, {}))));
  }
  function uv(e3) {
    var t2 = e3.schema, n3 = e3.documentId, o3 = e3.isOpen, i3 = e3.onClose, r2 = e3.renderCustomComponent, a3 = e3.content, s4 = e3.rootElement, l4 = f(ke("closed"), 2), c4 = l4[0], d4 = l4[1], u4 = f(ke(false), 2), h3 = u4[0], m3 = u4[1], g3 = f(ke(0), 2), p4 = g3[0], v2 = g3[1], y2 = f(ke(false), 2), b2 = y2[0], w2 = y2[1], x2 = Ae(null), C2 = Ae({ y: 0, height: 0, time: 0, state: "half" }), I2 = Ae({ y: 0, time: 0 });
    Me(function() {
      if (!o3) {
        d4("closed");
        var e4 = setTimeout(function() {
          w2(false);
        }, 300);
        return function() {
          return clearTimeout(e4);
        };
      }
      w2(true), requestAnimationFrame(function() {
        requestAnimationFrame(function() {
          d4("half");
        });
      });
    }, [o3]);
    var S2 = function(e4) {
      switch (e4) {
        case "closed":
          return 0;
        case "half":
          return 50;
        case "full":
          return 100;
      }
    }, k2 = ze(function(e4) {
      if (x2.current) {
        var t3, n4 = s4.clientHeight, o4 = x2.current.offsetHeight / n4 * 100;
        t3 = o4 >= 75 ? "full" : o4 <= 25 ? "closed" : "half", C2.current = { y: e4, height: o4, time: Date.now(), state: t3 }, I2.current = { y: e4, time: Date.now() }, v2(0), t3 !== c4 && d4(t3), m3(true);
      }
    }, [s4, c4]), D2 = ze(function(e4) {
      if (h3) {
        var t3 = s4.clientHeight, n4 = (C2.current.y - e4) / t3 * 100, o4 = Math.max(0, Math.min(100, C2.current.height + n4));
        I2.current = { y: e4, time: Date.now() };
        var i4 = S2(C2.current.state);
        v2(o4 - i4);
      }
    }, [h3, s4]), M2 = ze(function() {
      if (h3) {
        if (Math.abs(C2.current.y - I2.current.y) < 5) return m3(false), void v2(0);
        var e4 = S2(C2.current.state) + p4, t3 = Date.now() - I2.current.time, n4 = I2.current.y - C2.current.y, o4 = (function(e5, t4) {
          return Math.abs(t4) > 0.5 ? t4 > 0 ? e5 > 50 ? "half" : "closed" : e5 < 50 ? "half" : "full" : e5 >= 75 ? "full" : e5 <= 25 ? "closed" : "half";
        })(e4, t3 > 0 ? n4 / t3 : 0);
        "closed" === o4 ? (d4("closed"), m3(false), v2(0), i3()) : (m3(false), v2(0), d4(o4));
      }
    }, [h3, p4, i3]), P2 = ze(function(e4) {
      k2(e4.touches[0].clientY);
    }, [k2]), A2 = ze(function(e4) {
      h3 && (e4.cancelable && e4.preventDefault(), D2(e4.touches[0].clientY));
    }, [h3, D2]), T2 = ze(function() {
      M2();
    }, [M2]), z3 = ze(function(e4) {
      e4.preventDefault(), k2(e4.clientY);
    }, [k2]);
    if (Me(function() {
      if (h3) {
        var e4 = function(e5) {
          D2(e5.clientY);
        }, t3 = function() {
          M2();
        };
        return document.addEventListener("mousemove", e4), document.addEventListener("mouseup", t3), function() {
          document.removeEventListener("mousemove", e4), document.removeEventListener("mouseup", t3);
        };
      }
    }, [h3, D2, M2]), !b2) return null;
    var E2 = S2(h3 ? C2.current.state : c4), _2 = h3 ? Math.max(0, Math.min(100, E2 + p4)) : E2, R2 = 0.3 * Math.min(_2 / 50, 1);
    return j2(U2, null, j2("div", { className: "bg-bg-overlay absolute inset-0 z-40 transition-opacity duration-300 ".concat(0 === _2 ? "pointer-events-none" : ""), style: { opacity: R2 }, onClick: i3 }), j2("div", { ref: x2, className: "bg-bg-surface absolute inset-x-0 bottom-0 z-50 flex flex-col rounded-t-2xl shadow-2xl ".concat(h3 ? "" : "transition-[height] duration-300 ease-out"), style: { height: "".concat(_2, "%") }, "data-sidebar-id": t2.id }, j2("div", { className: "flex flex-shrink-0 cursor-grab touch-none items-center justify-center py-3 active:cursor-grabbing", onTouchStart: P2, onTouchMove: A2, onTouchEnd: T2, onMouseDown: z3 }, j2("div", { className: "bg-border-default h-1.5 w-12 rounded-full" })), j2("div", { className: "min-h-0 flex-1 overflow-hidden" }, "tabs" === a3.type && j2(hv, { content: a3, documentId: n3, renderCustomComponent: r2 }), "component" === a3.type && j2(U2, null, r2(a3.componentId, n3, {})))));
  }
  function hv(e3) {
    var t2, n3 = e3.content, o3 = e3.documentId, i3 = e3.renderCustomComponent, r2 = f(ke((null === (t2 = n3.tabs[0]) || void 0 === t2 ? void 0 : t2.id) || ""), 2), a3 = r2[0], s4 = r2[1];
    return j2("div", { className: "flex h-full flex-1 flex-col" }, j2("div", { role: "tablist", className: "bg-bg-surface mx-4 my-4 flex flex-shrink-0 overflow-hidden" }, n3.tabs.map(function(e4, t3, n4) {
      var o4 = a3 === e4.id, i4 = 0 === t3, r3 = t3 === n4.length - 1;
      return j2("button", { key: e4.id, role: "tab", "aria-selected": o4, tabIndex: o4 ? 0 : -1, onClick: function() {
        return s4(e4.id);
      }, className: "relative flex h-7 flex-1 cursor-pointer items-center justify-center border outline-none transition-colors ".concat(i4 ? "rounded-l-md" : "", " ").concat(r3 ? "rounded-r-md" : "", " ").concat(r3 ? "" : "border-r-0", " ").concat(o4 ? "border-accent bg-accent text-fg-on-accent" : "border-border-default text-fg-secondary hover:bg-interactive-hover") }, e4.icon && j2(Ym, { icon: e4.icon, className: "h-5 w-5" }));
    })), j2("div", { className: "min-h-0 flex-1 overflow-auto" }, n3.tabs.filter(function(e4) {
      return e4.id === a3;
    }).map(function(e4) {
      return j2(U2, { key: e4.id }, i3(e4.componentId, o3, {}));
    })));
  }
  function mv(e3) {
    var t2 = e3.schema, n3 = e3.documentId, o3 = e3.anchorEl, i3 = e3.onClose, r2 = Dr().getContainer, a3 = (function(e4) {
      var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 768, n4 = f(ke(function() {
        var n5 = e4();
        return !!n5 && n5.clientWidth < t3;
      }), 2), o4 = n4[0], i4 = n4[1];
      return Me(function() {
        var n5 = e4();
        if (n5) {
          var o5 = new ResizeObserver(function() {
            i4(n5.clientWidth < t3);
          });
          return o5.observe(n5), function() {
            return o5.disconnect();
          };
        }
      }, [e4, t3]), o4;
    })(r2, 768), s4 = r2(), l4 = (() => {
      const { provides: e4 } = Ir();
      return (null == e4 ? void 0 : e4.getSchema()) ?? null;
    })(), c4 = f(ke([{ menuId: t2.id, schema: t2, title: void 0 }]), 2), d4 = c4[0], u4 = c4[1];
    Me(function() {
      u4([{ menuId: t2.id, schema: t2, title: void 0 }]);
    }, [t2]);
    var h3 = d4[d4.length - 1], m3 = ze(function(e4, t3) {
      if (l4) {
        var n4 = l4.menus[e4];
        n4 ? u4(function(o4) {
          return [].concat(y(o4), [{ menuId: e4, schema: n4, title: t3 }]);
        }) : console.warn("Submenu schema not found: ".concat(e4));
      }
    }, [l4]), g3 = ze(function() {
      d4.length > 1 && u4(function(e4) {
        return e4.slice(0, -1);
      });
    }, [d4.length]);
    return h3 ? a3 && s4 ? Kp(j2(gv, { currentMenu: h3, menuStack: d4, documentId: n3, onClose: i3, onNavigateBack: g3, onNavigateToSubmenu: m3, container: s4 }), s4) : j2(pv, { currentMenu: h3, documentId: n3, anchorEl: o3, onClose: i3, onNavigateToSubmenu: m3 }) : null;
  }
  function gv(e3) {
    var t2 = e3.currentMenu, n3 = e3.menuStack, o3 = e3.documentId, i3 = e3.onClose, r2 = e3.onNavigateBack, a3 = e3.onNavigateToSubmenu, s4 = e3.container, l4 = f(ke(false), 2), c4 = l4[0], d4 = l4[1], u4 = f(ke(false), 2), m3 = u4[0], g3 = u4[1], p4 = f(ke(0), 2), v2 = p4[0], y2 = p4[1], b2 = Ae(null), w2 = Ae(null), x2 = Ae({ isDragging: false, startY: 0, currentY: 0, startTime: 0, sheetHeight: 0 });
    Me(function() {
      d4(true), requestAnimationFrame(function() {
        requestAnimationFrame(function() {
          g3(true);
        });
      });
    }, []);
    var C2 = f(ke(null), 2), I2 = C2[0], S2 = C2[1];
    Me(function() {
      if (w2.current) {
        var e4 = (n3.length > 1 ? 60 : 0) + w2.current.scrollHeight + 24, t3 = 0.8 * s4.clientHeight;
        S2(Math.min(e4, t3));
      }
    }, [t2, n3.length, s4]);
    var k2 = ze(function() {
      g3(false), setTimeout(function() {
        d4(false), i3();
      }, 300);
    }, [i3]), D2 = ze(function(e4) {
      b2.current && (x2.current = { isDragging: true, startY: e4, currentY: e4, startTime: Date.now(), sheetHeight: b2.current.offsetHeight });
    }, []), M2 = ze(function(e4) {
      if (x2.current.isDragging) {
        var t3 = e4 - x2.current.startY, n4 = Math.max(0, t3);
        x2.current.currentY = e4, y2(n4);
      }
    }, []), P2 = ze(function() {
      if (x2.current.isDragging) {
        var e4 = x2.current, t3 = e4.startY, n4 = e4.currentY, o4 = e4.startTime, i4 = e4.sheetHeight, r3 = Math.abs(t3 - n4);
        if (x2.current.isDragging = false, r3 < 5) y2(0);
        else {
          var a4 = n4 - t3, s5 = a4 / i4 * 100, l5 = Date.now() - o4;
          s5 > 30 || (l5 > 0 ? a4 / l5 : 0) > 0.5 ? k2() : y2(0);
        }
      }
    }, [k2]), A2 = ze(function(e4) {
      D2(e4.touches[0].clientY);
    }, [D2]), T2 = ze(function(e4) {
      x2.current.isDragging && e4.cancelable && e4.preventDefault(), M2(e4.touches[0].clientY);
    }, [M2]), z3 = ze(function() {
      P2();
    }, [P2]), E2 = ze(function(e4) {
      e4.preventDefault(), D2(e4.clientY);
    }, [D2]);
    if (Me(function() {
      if (x2.current.isDragging) {
        var e4 = function(e5) {
          return M2(e5.clientY);
        }, t3 = function() {
          return P2();
        };
        return document.addEventListener("mousemove", e4), document.addEventListener("mouseup", t3), function() {
          document.removeEventListener("mousemove", e4), document.removeEventListener("mouseup", t3);
        };
      }
    }, [M2, P2]), Me(function() {
      var e4 = function(e5) {
        "Escape" === e5.key && k2();
      };
      return document.addEventListener("keydown", e4), function() {
        return document.removeEventListener("keydown", e4);
      };
    }, [k2]), !c4) return null;
    var _2 = m3 ? v2 : I2 || 400;
    return j2(U2, null, j2("div", { className: "bg-bg-overlay absolute inset-0 z-40 transition-opacity duration-300 ".concat(m3 ? "opacity-100" : "opacity-0"), onClick: k2 }), j2("div", h2({ ref: b2, className: "bg-bg-surface absolute inset-x-0 bottom-0 z-50 flex flex-col rounded-t-2xl shadow-2xl ".concat(x2.current.isDragging ? "" : "transition-transform duration-300 ease-out"), style: { maxHeight: "80%", transform: "translateY(".concat(_2, "px)") } }, mr(t2.schema)), j2("div", { className: "flex flex-shrink-0 cursor-grab touch-none items-center justify-center py-3 active:cursor-grabbing", onTouchStart: A2, onTouchMove: T2, onTouchEnd: z3, onMouseDown: E2 }, j2("div", { className: "bg-border-default h-1.5 w-12 rounded-full" })), n3.length > 1 && j2("div", { className: "border-border-subtle flex items-center gap-3 border-b px-4 pb-3" }, j2("button", { onClick: r2, className: "hover:bg-interactive-hover rounded-full p-1" }, j2(Fm, { className: "h-5 w-5" })), j2("h3", { className: "text-fg-primary font-semibold" }, t2.title || "Menu")), j2("div", { ref: w2, className: "flex-1 overflow-y-auto py-2" }, t2.schema.items.map(function(e4) {
      return j2(vv, { key: e4.id, item: e4, documentId: o3, onClose: k2, isMobile: true, onNavigateToSubmenu: a3 });
    }))));
  }
  function pv(e3) {
    var t2 = e3.currentMenu, n3 = e3.documentId, o3 = e3.anchorEl, i3 = e3.onClose, r2 = e3.onNavigateToSubmenu, a3 = Ae(null), s4 = f(ke(null), 2), l4 = s4[0], c4 = s4[1];
    Me(function() {
      if (o3) {
        var e4 = function() {
          var e5, t3 = o3.getBoundingClientRect(), n4 = (null === (e5 = a3.current) || void 0 === e5 ? void 0 : e5.offsetWidth) || 200, i4 = t3.bottom + 4, r3 = t3.left;
          r3 + n4 > window.innerWidth && (r3 = window.innerWidth - n4 - 8), r3 < 8 && (r3 = 8), c4({ top: i4, left: r3 });
        };
        return e4(), window.addEventListener("scroll", e4), window.addEventListener("resize", e4), function() {
          window.removeEventListener("scroll", e4), window.removeEventListener("resize", e4);
        };
      }
    }, [o3]), Me(function() {
      var e4 = function(e5) {
        if (a3.current) {
          var t4 = e5.composedPath(), n4 = t4.includes(a3.current), r3 = o3 && t4.includes(o3);
          n4 || r3 || i3();
        }
      }, t3 = setTimeout(function() {
        document.addEventListener("mousedown", e4);
      }, 0);
      return function() {
        clearTimeout(t3), document.removeEventListener("mousedown", e4);
      };
    }, [i3, o3]), Me(function() {
      var e4 = function(e5) {
        "Escape" === e5.key && i3();
      };
      return document.addEventListener("keydown", e4), function() {
        return document.removeEventListener("keydown", e4);
      };
    }, [i3]);
    var d4 = l4 ? { position: "fixed", top: "".concat(l4.top, "px"), left: "".concat(l4.left, "px"), zIndex: 1e3 } : { display: "none" };
    return j2("div", h2(h2({ ref: a3 }, mr(t2.schema)), {}, { className: "border-border-default bg-bg-elevated min-w-[200px] rounded-lg border py-2 shadow-lg", style: d4 }), t2.schema.items.map(function(e4) {
      return j2(vv, { key: e4.id, item: e4, documentId: n3, onClose: i3, isMobile: false, onNavigateToSubmenu: r2 });
    }));
  }
  function vv(e3) {
    var t2 = e3.item, n3 = e3.documentId, o3 = e3.onClose, i3 = e3.isMobile, r2 = e3.onNavigateToSubmenu;
    switch (t2.type) {
      case "command":
        return j2(fv, { item: t2, documentId: n3, onClose: o3, isMobile: i3 });
      case "submenu":
        return j2(yv, { item: t2, documentId: n3, isMobile: i3, onNavigateToSubmenu: r2 });
      case "divider":
        return j2("div", h2({}, mr(t2)), j2("hr", { className: "border-border-subtle my-2" }));
      case "section":
        return j2(bv, { item: t2, documentId: n3, onClose: o3, isMobile: i3, onNavigateToSubmenu: r2 });
      default:
        return null;
    }
  }
  function fv(e3) {
    var t2, n3, o3 = e3.item, i3 = e3.documentId, r2 = e3.onClose, a3 = e3.isMobile, s4 = ta(o3.commandId, i3);
    if (!s4 || !s4.visible) return null;
    var l4, c4, d4 = function() {
      s4.disabled || (s4.execute(), r2());
    };
    return a3 ? j2("button", h2(h2({}, mr(o3)), {}, { onClick: d4, disabled: s4.disabled, className: "active:bg-interactive-active flex w-full items-center gap-3 px-4 py-3 text-left text-base transition-colors ".concat(s4.disabled ? "cursor-not-allowed opacity-50" : "cursor-pointer", " ").concat(s4.active ? "bg-interactive-selected text-accent" : "text-fg-secondary"), role: "menuitem" }), s4.icon && j2(Ym, { icon: s4.icon, className: "h-5 w-5", primaryColor: null === (l4 = s4.iconProps) || void 0 === l4 ? void 0 : l4.primaryColor, secondaryColor: null === (c4 = s4.iconProps) || void 0 === c4 ? void 0 : c4.secondaryColor }), j2("span", { className: "flex-1" }, s4.label)) : j2("button", h2(h2({}, mr(o3)), {}, { onClick: d4, disabled: s4.disabled, className: "flex w-full items-center justify-between gap-2 px-4 py-1 text-left ".concat(s4.disabled ? "pointer-events-none cursor-not-allowed opacity-50" : "cursor-pointer", " ").concat(s4.active && !s4.disabled ? "bg-accent text-fg-on-accent" : "text-fg-muted hover:bg-accent hover:text-fg-on-accent"), role: "menuitem" }), j2("div", { className: "flex items-center gap-2" }, j2("div", { className: "flex h-6 w-6 items-center justify-center" }, s4.icon && j2(Ym, { icon: s4.icon, className: "h-6 w-6", primaryColor: null === (t2 = s4.iconProps) || void 0 === t2 ? void 0 : t2.primaryColor, secondaryColor: null === (n3 = s4.iconProps) || void 0 === n3 ? void 0 : n3.secondaryColor })), j2("span", { className: "text-sm" }, s4.label)));
  }
  function yv(e3) {
    var t2 = e3.item, n3 = e3.documentId, o3 = e3.isMobile, i3 = e3.onNavigateToSubmenu, r2 = ma(n3).translate, a3 = t2.labelKey ? r2(t2.labelKey) : t2.label || "", s4 = function() {
      return i3(t2.menuId, a3);
    };
    return o3 ? j2("button", h2(h2({}, mr(t2)), {}, { onClick: s4, className: "text-fg-secondary active:bg-interactive-active flex w-full cursor-pointer items-center gap-3 px-4 py-3 text-left text-base transition-colors", role: "menuitem" }), j2("span", { className: "flex-1" }, a3), j2($m, { className: "h-4 w-4" })) : j2("button", h2(h2({}, mr(t2)), {}, { onClick: s4, className: "text-fg-muted hover:bg-accent hover:text-fg-on-accent flex w-full cursor-pointer items-center justify-between gap-2 px-4 py-1 text-left", role: "menuitem" }), j2("span", { className: "text-sm" }, a3), j2($m, { className: "h-6 w-6" }));
  }
  function bv(e3) {
    var t2 = e3.item, n3 = e3.documentId, o3 = e3.onClose, i3 = e3.isMobile, r2 = e3.onNavigateToSubmenu, a3 = ma(n3).translate, s4 = t2.labelKey ? a3(t2.labelKey) : t2.label || "";
    return j2("div", h2({}, mr(t2)), j2("div", { className: "text-fg-secondary px-4 py-3 text-xs font-medium uppercase" }, s4), t2.items.map(function(e4) {
      return j2(vv, { key: e4.id, item: e4, documentId: n3, onClose: o3, isMobile: i3, onNavigateToSubmenu: r2 });
    }));
  }
  function wv(e3) {
    var t2 = e3.schema, n3 = e3.documentId, o3 = e3.isOpen, i3 = e3.onClose, r2 = e3.onExited, a3 = t2.content, s4 = _r().renderCustomComponent;
    return "component" !== a3.type ? (console.warn("SchemaModal only supports component content type, got: ".concat(a3.type)), null) : j2(U2, null, s4(a3.componentId, n3, { isOpen: o3, onClose: i3, onExited: r2 }));
  }
  function xv(e3) {
    var t2 = e3.documentId;
    e3.onClose;
    var n3 = oi(t2), o3 = n3.state, i3 = n3.provides;
    return j2("div", { className: "flex h-full flex-1 flex-col" }, j2("div", { className: "flex-1 overflow-hidden" }, j2(Pl, { documentId: t2, style: { width: "100%", height: "100%" } }, function(e4) {
      return j2("div", { key: e4.pageIndex, style: { position: "absolute", width: "100%", height: e4.wrapperHeight, top: e4.top, display: "flex", flexDirection: "column", alignItems: "center", cursor: "pointer" }, onClick: function() {
        var t3;
        null == i3 || null === (t3 = i3.scrollToPage) || void 0 === t3 || t3.call(i3, { pageNumber: e4.pageIndex + 1 });
      } }, j2("div", { style: { width: e4.width, height: e4.height, border: "2px solid ".concat(o3.currentPage === e4.pageIndex + 1 ? "var(--ep-accent-primary)" : "var(--ep-border-default)"), borderRadius: "4px", overflow: "hidden", boxShadow: o3.currentPage === e4.pageIndex + 1 ? "0 0 0 2px var(--ep-interactive-focus-ring)" : "none" } }, j2(Al, { documentId: t2, meta: e4, style: { width: "100%", height: "100%" } })), j2("div", { style: { height: e4.labelHeight, display: "flex", alignItems: "center", justifyContent: "center", marginTop: "4px" } }, j2("span", { className: "text-fg-secondary text-xs" }, e4.pageIndex + 1)));
    })));
  }
  function Cv(e3) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 300, n3 = f(ke(e3), 2), o3 = n3[0], i3 = n3[1];
    return Me(function() {
      var n4 = window.setTimeout(function() {
        return i3(e3);
      }, t2);
      return function() {
        return clearTimeout(n4);
      };
    }, [e3, t2]), o3;
  }
  function kv(e3) {
    var t2 = e3.documentId;
    e3.onClose;
    var n3 = ((e4) => {
      const { provides: t3 } = ms(), [n4, o4] = ke(as), i4 = Te(() => null == t3 ? void 0 : t3.forDocument(e4), [t3, e4]);
      return Me(() => {
        if (i4) return o4(i4.getState()), i4.onStateChange((e5) => o4(e5));
        o4(as);
      }, [i4]), { state: n4, provides: i4 ?? null };
    })(t2), o3 = n3.state, i3 = n3.provides, r2 = ni().provides, a3 = ma(t2).translate, s4 = Ae(null), l4 = f(ke(""), 2), c4 = l4[0], d4 = l4[1];
    Me(function() {
    }, []), Me(function() {
      o3.query && !c4 && d4(o3.query);
    }, [o3.query]), Me(function() {
      void 0 !== o3.activeResultIndex && o3.activeResultIndex >= 0 && m3(o3.activeResultIndex);
    }, [o3.activeResultIndex]);
    var u4 = Cv(c4, 300);
    Me(function() {
      u4 !== o3.query && (null == i3 || i3.searchAllPages(u4));
    }, [u4, i3, o3.query]);
    var h3 = function(e4, t3) {
      t3 ? null == i3 || i3.setFlags([].concat(y(o3.flags), [e4])) : null == i3 || i3.setFlags(o3.flags.filter(function(t4) {
        return t4 !== e4;
      }));
    }, m3 = function(e4) {
      var n4, i4 = o3.results[e4];
      if (i4) {
        var a4 = i4.rects.reduce(function(e5, t3) {
          return { x: Math.min(e5.x, t3.origin.x), y: Math.min(e5.y, t3.origin.y) };
        }, { x: 1 / 0, y: 1 / 0 });
        null == r2 || null === (n4 = r2.forDocument(t2)) || void 0 === n4 || n4.scrollToPage({ pageNumber: i4.pageIndex + 1, pageCoordinates: a4, alignX: 50, alignY: 25 });
      }
    }, g3 = (function(e4) {
      var t3 = {};
      return e4.forEach(function(e5, n4) {
        t3[e5.pageIndex] || (t3[e5.pageIndex] = []), t3[e5.pageIndex].push({ hit: e5, index: n4 });
      }), t3;
    })(o3.results);
    return j2("div", { className: "bg-bg-surface flex h-full flex-col" }, j2("div", { className: "p-4" }, j2("div", { className: "relative" }, j2("div", { className: "pointer-events-none absolute inset-y-0 left-0 flex items-center pl-2" }, j2(Hm, { className: "text-fg-muted h-4 w-4" })), j2("input", { ref: s4, type: "text", placeholder: a3("search.placeholder"), value: c4, onInput: function(e4) {
      var t3 = e4.target;
      d4(t3.value);
    }, className: "border-border-default bg-bg-input focus:border-accent focus:ring-accent w-full rounded-md border py-1 pl-8 pr-9 text-base focus:outline-none focus:ring-1" }), c4 && j2("div", { className: "absolute inset-y-0 right-0 flex cursor-pointer items-center pr-3", onClick: function() {
      d4(""), s4.current && s4.current.focus();
    } }, j2(Um, { className: "text-fg-muted hover:text-fg-secondary h-4 w-4" }))), j2("div", { className: "mt-3 flex flex-col gap-2" }, j2(Iv, { label: a3("search.caseSensitive"), checked: o3.flags.includes(Ft.MatchCase), onChange: function(e4) {
      return h3(Ft.MatchCase, e4);
    } }), j2(Iv, { label: a3("search.wholeWord"), checked: o3.flags.includes(Ft.MatchWholeWord), onChange: function(e4) {
      return h3(Ft.MatchWholeWord, e4);
    } })), j2("hr", { className: "border-border-subtle mb-2 mt-5" }), o3.active && j2("div", { className: "flex h-[32px] flex-row items-center justify-between" }, j2("div", { className: "text-fg-muted text-xs" }, a3("search.resultsFound", { params: { count: o3.total } })), o3.total > 1 && j2("div", { className: "flex flex-row" }, j2(Qm, { onClick: function() {
      null == i3 || i3.previousResult();
    } }, j2(Fm, { className: "h-4 w-4" })), j2(Qm, { onClick: function() {
      null == i3 || i3.nextResult();
    } }, j2($m, { className: "h-4 w-4" }))))), j2("div", { className: "flex min-h-0 flex-1 flex-col gap-2 overflow-y-auto px-4" }, Object.entries(g3).map(function(e4) {
      var t3 = f(e4, 2), n4 = t3[0], r3 = t3[1];
      return j2("div", { key: n4, className: "mt-2 first:mt-0" }, j2("div", { className: "bg-bg-surface/80 text-fg-muted py-2 text-xs backdrop-blur" }, a3("search.page", { params: { page: Number(n4) + 1 } })), j2("div", { className: "flex flex-col gap-2" }, r3.map(function(e5) {
        var t4 = e5.hit, n5 = e5.index;
        return j2(Sv, { key: n5, hit: t4, active: n5 === o3.activeResultIndex, onClick: function() {
          null == i3 || i3.goToResult(n5);
        } });
      })));
    }), j2("div", null)));
  }
  function Dv(e3) {
    var t2 = e3.documentId, n3 = po(uu.id).provides, o3 = ni().provides, i3 = ma(t2).translate, r2 = fo(t2), a3 = f(ke([]), 2), s4 = a3[0], l4 = a3[1], c4 = f(ke(/* @__PURE__ */ new Set()), 2), d4 = c4[0], u4 = c4[1], h3 = f(ke(true), 2), m3 = h3[0], g3 = h3[1];
    Me(function() {
      if (n3 && null != r2 && r2.document) {
        g3(true);
        var e4 = n3.getBookmarks();
        return e4.wait(function(e5) {
          var t3 = e5.bookmarks;
          l4(t3);
          var n4 = t3.map(function(e6, t4) {
            return "bookmark-".concat(t4);
          });
          u4(new Set(n4)), g3(false);
        }, function() {
          g3(false);
        }), function() {
          e4.abort({ code: Ht.Cancelled, message: "Bookmark task cancelled" });
        };
      }
    }, [n3, null == r2 ? void 0 : r2.document]);
    var p4 = function(e4, t3) {
      var n4, i4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a4 = "bookmark-".concat(t3), s5 = e4.children && e4.children.length > 0, l5 = d4.has(a4);
      return j2("div", { key: a4, className: "select-none" }, j2("div", { className: "hover:bg-interactive-hover flex cursor-pointer items-center gap-1 px-2 py-1", style: { paddingLeft: "".concat(16 * i4 + 8, "px") }, onClick: function() {
        return (function(e5) {
          if (o3 && e5.target) {
            var t4;
            if ("action" === e5.target.type) {
              var n5 = e5.target.action;
              if (n5.type === kt.Goto || n5.type === kt.RemoteGoto) t4 = n5.destination;
              else if (n5.type === kt.URI) return void window.open(n5.uri, "_blank");
            } else "destination" === e5.target.type && (t4 = e5.target.destination);
            if (t4) if (t4.zoom.mode === yt.XYZ) {
              var i5, a5 = null == r2 || null === (i5 = r2.document) || void 0 === i5 ? void 0 : i5.pages.find(function(e6) {
                return e6.index === t4.pageIndex;
              });
              if (!a5) return;
              o3.scrollToPage({ pageNumber: t4.pageIndex + 1, pageCoordinates: t4.zoom.params ? { x: t4.zoom.params.x, y: a5.size.height - t4.zoom.params.y } : void 0, behavior: "smooth" });
            } else o3.scrollToPage({ pageNumber: t4.pageIndex + 1, behavior: "smooth" });
          }
        })(e4);
      } }, s5 && j2("button", { onClick: function(e5) {
        e5.stopPropagation(), (function(e6) {
          u4(function(t4) {
            var n5 = new Set(t4);
            return n5.has(e6) ? n5.delete(e6) : n5.add(e6), n5;
          });
        })(a4);
      }, className: "flex h-4 w-4 items-center justify-center" }, j2(l5 ? jm : $m, { className: "h-3 w-3" })), !s5 && j2("div", { className: "w-4" }), j2("span", { className: "text-fg-secondary text-sm" }, e4.title)), s5 && l5 && j2("div", null, null === (n4 = e4.children) || void 0 === n4 ? void 0 : n4.map(function(e5, t4) {
        return p4(e5, t4, i4 + 1);
      })));
    };
    return null == r2 || !r2.document || m3 ? j2("div", { className: "text-fg-secondary flex h-full flex-col gap-3 p-4 text-sm" }, j2("div", { className: "text-fg-primary font-medium" }, i3("outline.title")), j2("p", null, i3("outline.loading"))) : 0 === s4.length ? j2("div", { className: "flex h-full items-center justify-center p-6" }, j2("div", { className: "text-fg-muted text-center" }, j2("div", { className: "text-sm" }, i3("outline.noOutline")), j2("div", { className: "mt-1 text-xs" }, i3("outline.noBookmarks")))) : j2("div", { className: "bg-bg-surface flex h-full flex-col" }, j2("div", { className: "flex-1 overflow-y-auto" }, j2("div", { className: "outline-tree" }, s4.map(function(e4, t3) {
      return p4(e4, t3);
    }))));
  }
  function Mv(e3) {
    var t2 = e3.size, n3 = void 0 === t2 ? "md" : t2, o3 = e3.text, i3 = e3.className, r2 = { sm: "w-6 h-6", md: "w-10 h-10", lg: "w-16 h-16" };
    return j2("div", { className: "flex flex-col items-center justify-center gap-3 ".concat(void 0 === i3 ? "" : i3) }, j2("div", { className: "relative" }, j2("div", { className: "".concat(r2[n3], " border-border-default animate-spin rounded-full border-4") }), j2("div", { className: "".concat(r2[n3], " border-r-accent border-t-accent absolute left-0 top-0 animate-spin rounded-full border-4 border-transparent") })), o3 && j2("p", { className: "".concat({ sm: "text-sm", md: "text-base", lg: "text-lg" }[n3], " text-fg-secondary animate-pulse font-medium") }, o3));
  }
  function Pv(e3) {
    var t2 = e3.size, n3 = void 0 === t2 ? "md" : t2, o3 = e3.className, i3 = void 0 === o3 ? "" : o3;
    return j2("div", { className: "".concat({ sm: "w-4 h-4 border-2", md: "w-6 h-6 border-2", lg: "w-8 h-8 border-3" }[n3], " border-border-default border-t-accent animate-spin rounded-full ").concat(i3) });
  }
  function qv(e3) {
    var t2 = e3.documentId, n3 = ((e4) => {
      const { provides: t3 } = Ma(), [n4, o4] = ke(Ca);
      return Me(() => {
        if (!t3) return;
        const n5 = t3.forDocument(e4);
        return o4(n5.getState()), n5.onStateChange((e5) => {
          o4(e5);
        });
      }, [t3, e4]), { state: n4, provides: (null == t3 ? void 0 : t3.forDocument(e4)) ?? null };
    })(t2), o3 = n3.state, i3 = n3.provides, r2 = f(ke(""), 2), a3 = r2[0], s4 = r2[1];
    if (!i3) return null;
    var l4 = Math.round(100 * o3.currentZoomLevel);
    Me(function() {
      s4(l4.toString());
    }, [l4]);
    return j2("div", { className: "relative" }, j2("div", { className: "bg-interactive-hover flex items-center rounded" }, j2("form", { onSubmit: function(e4) {
      e4.preventDefault();
      var t3 = e4.target, n4 = new FormData(t3), o4 = parseFloat(n4.get("zoom") || a3);
      !isNaN(o4) && o4 > 0 && i3.requestZoom(o4 / 100);
    }, className: "block" }, j2("input", { name: "zoom", type: "text", inputMode: "numeric", pattern: "\\d*", className: "h-6 w-8 border-0 bg-transparent p-0 text-right text-sm outline-none focus:outline-none", "aria-label": "Set zoom", autoFocus: false, value: a3, onInput: function(e4) {
      var t3 = e4.target.value.replace(/[^0-9]/g, "");
      s4(t3);
    }, onBlur: function() {
      (!a3 || parseFloat(a3) <= 0) && s4(l4.toString());
    } }), j2("span", { className: "text-sm" }, "%")), j2(kp, { commandId: "zoom:toggle-menu", documentId: t2, itemId: "zoom-menu-button" }), j2(kp, { commandId: "zoom:out", documentId: t2 }), j2(kp, { commandId: "zoom:in", documentId: t2 })));
  }
  function gf(e3) {
    var t2 = e3.active, n3 = void 0 !== t2 && t2, o3 = e3.disabled, i3 = void 0 !== o3 && o3, r2 = e3.onClick, a3 = e3.title, s4 = e3.children, l4 = e3.className, c4 = void 0 === l4 ? "" : l4;
    return j2("button", { type: "button", title: a3, disabled: i3, onClick: r2, className: "h-9 w-9 rounded border px-2 py-1 text-sm transition-colors ".concat(n3 ? "border-accent bg-accent text-fg-on-accent" : "border-border-default bg-bg-input text-fg-primary hover:bg-interactive-hover", " disabled:cursor-not-allowed disabled:opacity-40 ").concat(c4) }, s4);
  }
  function yf(e3) {
    var t2, n3 = e3.documentId, o3 = Md().provides, i3 = Pd(n3), r2 = i3.provides, a3 = i3.state, s4 = ma(n3).translate;
    if (!o3 || !r2) return null;
    var l4 = null !== (t2 = null == o3 ? void 0 : o3.getColorPresets()) && void 0 !== t2 ? t2 : [], c4 = null, d4 = null, u4 = a3.selectedUid ? mc(a3, a3.selectedUid) : null;
    if (u4) c4 = r2.findToolForAnnotation(u4.object), d4 = u4.object.type;
    else if (a3.activeToolId) {
      var m3, g3, p4;
      d4 = null !== (g3 = null === (p4 = c4 = null !== (m3 = r2.getActiveTool()) && void 0 !== m3 ? m3 : null) || void 0 === p4 ? void 0 : p4.defaults.type) && void 0 !== g3 ? g3 : null;
    }
    if (null === d4) return Ue(ff, { documentId: n3 });
    var v2 = vf[d4];
    if (!v2) return Ue(ff, { documentId: n3 });
    var f2 = v2.component, y2 = v2.titleKey, b2 = { documentId: n3, selected: u4, activeTool: c4, colorPresets: l4 }, w2 = "function" == typeof y2 ? y2(b2) : y2, x2 = w2 ? s4(w2) : "", C2 = x2 ? s4(u4 ? "annotation.styles" : "annotation.defaults", { params: { type: x2 } }) : "";
    return Ue("div", { class: "h-full overflow-y-auto p-4", children: [C2 && Ue("h2", { class: "text-md mb-4 font-medium", children: C2 }), Ue(f2, h2({}, b2))] });
  }
  function bf(e3) {
    var t2 = e3.schema, n3 = e3.documentId, o3 = e3.props, i3 = o3.menuWrapperProps, r2 = o3.rect, a3 = o3.placement, s4 = { position: "absolute", pointerEvents: "auto", cursor: "default", left: "50%", transform: "translateX(-50%)" };
    return null != a3 && a3.suggestTop ? s4.top = -48 : s4.top = r2.size.height + 8, j2("div", h2(h2({}, i3), mr(t2)), j2("div", { style: s4, className: "border-border-subtle bg-bg-elevated rounded-lg border shadow-lg" }, j2("div", { className: "flex items-center gap-1 p-1" }, t2.items.map(function(e4) {
      return j2(wf, { key: e4.id, item: e4, documentId: n3, props: o3 });
    }))));
  }
  function wf(e3) {
    var t2, n3 = e3.item, o3 = e3.documentId, i3 = e3.props;
    switch (n3.type) {
      case "command-button":
        return j2("div", h2({}, mr(n3)), j2(kp, { commandId: n3.commandId, documentId: o3, variant: n3.variant }));
      case "divider":
        return j2("div", h2({}, mr(n3)), j2("div", { className: "bg-border-default h-6 w-px", "aria-hidden": "true" }));
      case "group":
        return j2("div", h2({ className: "flex items-center gap-".concat(null !== (t2 = n3.gap) && void 0 !== t2 ? t2 : 1) }, mr(n3)), n3.items.map(function(e4) {
          return j2(wf, { key: e4.id, item: e4, documentId: o3, props: i3 });
        }));
      default:
        return null;
    }
  }
  function xf(e3) {
    var t2, n3, o3 = e3.schema, i3 = e3.documentId, r2 = e3.className, a3 = o3.content, s4 = o3.position, l4 = _r().renderCustomComponent, c4 = (t2 = s4.anchor, (n3 = { "top-left": "top-0 left-0", "top-center": "top-0 left-1/2 -translate-x-1/2", "top-right": "top-0 right-0", "center-left": "top-1/2 left-0 -translate-y-1/2", center: "top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2", "center-right": "top-1/2 right-0 -translate-y-1/2", "bottom-left": "bottom-0 left-0", "bottom-center": "bottom-0 left-1/2 -translate-x-1/2", "bottom-right": "bottom-0 right-0" })[t2] || n3["bottom-center"]), d4 = (function(e4) {
      if (e4) {
        var t3 = {};
        return e4.top && (t3.top = e4.top), e4.right && (t3.right = e4.right), e4.bottom && (t3.bottom = e4.bottom), e4.left && (t3.left = e4.left), Object.keys(t3).length > 0 ? t3 : void 0;
      }
    })(s4.offset);
    return j2("div", { className: "absolute ".concat(c4, " ").concat(r2 || ""), style: d4, "data-overlay-id": o3.id }, l4(a3.componentId, i3, {}));
  }
  function Cf(e3) {
    var t2 = e3.open, n3 = e3.title, o3 = e3.children, i3 = e3.onClose, r2 = e3.onExited, a3 = e3.className, s4 = e3.showCloseButton, l4 = void 0 === s4 || s4;
    e3.maxWidth;
    var c4 = Ae(null), d4 = f(ke(t2), 2), u4 = d4[0], h3 = d4[1], m3 = f(ke(false), 2), g3 = m3[0], p4 = m3[1];
    Me(function() {
      if (t2) h3(true), requestAnimationFrame(function() {
        p4(true);
      });
      else if (u4) {
        p4(false);
        var e4 = setTimeout(function() {
          h3(false), null == r2 || r2();
        }, 200);
        return function() {
          return clearTimeout(e4);
        };
      }
    }, [t2, u4, r2]), Me(function() {
      if (t2) {
        var e4 = function(e5) {
          "Escape" === e5.key && (null == i3 || i3());
        };
        return document.addEventListener("keydown", e4), function() {
          return document.removeEventListener("keydown", e4);
        };
      }
    }, [t2, i3]);
    return Me(function() {
      return document.body.style.overflow = u4 ? "hidden" : "", function() {
        document.body.style.overflow = "";
      };
    }, [u4]), u4 ? Ue("div", { ref: c4, className: "fixed inset-0 z-50 transition-opacity duration-200 md:flex md:items-center md:justify-center ".concat(g3 && t2 ? "bg-bg-overlay" : "bg-transparent"), onClick: function(e4) {
      e4.target === c4.current && (null == i3 || i3());
    }, children: Ue("div", { className: "bg-bg-surface md:border-border-subtle relative flex h-full w-full flex-col transition-all duration-200 md:h-auto md:w-[28rem] md:max-w-[90vw] md:rounded-lg md:border md:shadow-lg ".concat(g3 && t2 ? "scale-100 opacity-100" : "scale-95 opacity-0", " ").concat(a3), onClick: function(e4) {
      return e4.stopPropagation();
    }, children: [(n3 || l4) && Ue("div", { className: "border-border-subtle flex flex-shrink-0 items-center justify-between border-b px-6 py-4", children: [n3 && Ue("h2", { className: "text-fg-primary text-lg font-semibold", children: n3 }), l4 && Ue(Qm, { onClick: i3, className: "hover:bg-interactive-hover p-1", children: Ue(Ym, { icon: "x", className: "h-5 w-5" }) })] }), Ue("div", { className: "flex-1 overflow-y-auto px-6 py-4 md:max-h-[80vh] md:flex-none", children: o3 })] }) }) : null;
  }
  function If(e3) {
    var t2 = e3.documentId, n3 = e3.isOpen, o3 = e3.onClose, i3 = e3.onExited, r2 = ni().provides, a3 = Qd().provides, s4 = f(ke("all"), 2), l4 = s4[0], c4 = s4[1], d4 = f(ke(""), 2), u4 = d4[0], h3 = d4[1], m3 = f(ke(true), 2), g3 = m3[0], p4 = m3[1], v2 = f(ke(false), 2), y2 = v2[0], b2 = v2[1], w2 = f(ke(""), 2), x2 = w2[0], C2 = w2[1], I2 = null == r2 ? void 0 : r2.forDocument(t2).getMetrics(), S2 = (null == I2 ? void 0 : I2.currentPage) || 1, k2 = (null == r2 ? void 0 : r2.forDocument(t2).getTotalPages()) || 0;
    Me(function() {
      n3 && (c4("all"), h3(""), p4(true), b2(false), C2(""));
    }, [n3]);
    var D2 = ("custom" !== l4 || u4.trim().length > 0) && !y2;
    return j2(Cf, { open: null != n3 && n3, title: "Print Settings", onClose: o3, onExited: i3, maxWidth: "32rem" }, j2("div", { className: "space-y-6" }, j2("div", null, j2("label", { className: "text-fg-secondary mb-3 block text-sm font-medium" }, "Pages to print"), j2("div", { className: "space-y-2" }, j2("label", { className: "flex items-center" }, j2("input", { type: "radio", name: "pageRange", value: "all", checked: "all" === l4, onChange: function() {
      return c4("all");
    }, disabled: y2, className: "accent-accent mr-2" }), j2("span", { className: "text-fg-primary text-sm" }, "All pages")), j2("label", { className: "flex items-center" }, j2("input", { type: "radio", name: "pageRange", value: "current", checked: "current" === l4, onChange: function() {
      return c4("current");
    }, disabled: y2, className: "accent-accent mr-2" }), j2("span", { className: "text-fg-primary text-sm" }, "Current page (", S2, ")")), j2("label", { className: "flex items-start" }, j2("input", { type: "radio", name: "pageRange", value: "custom", checked: "custom" === l4, onChange: function() {
      return c4("custom");
    }, disabled: y2, className: "accent-accent mr-2 mt-0.5" }), j2("div", { className: "flex-1" }, j2("span", { className: "text-fg-primary mb-1 block text-sm" }, "Specify pages"), j2("input", { type: "text", placeholder: "e.g., 1-3, 5, 8-10", value: u4, onInput: function(e4) {
      return h3(e4.target.value);
    }, disabled: "custom" !== l4 || y2, className: "w-full rounded-md border px-3 py-1 text-base ".concat("custom" !== l4 || y2 ? "bg-interactive-disabled text-fg-muted" : "border-border-default bg-bg-input text-fg-primary focus:border-accent focus:ring-accent", " focus:outline-none focus:ring-1") }), "custom" === l4 && u4.trim() && k2 > 0 && j2("p", { className: "text-fg-muted mt-1 text-xs" }, "Total pages in document: ", k2))))), j2("div", null, j2("label", { className: "flex items-center" }, j2("input", { type: "checkbox", checked: g3, onChange: function(e4) {
      return p4(e4.target.checked);
    }, disabled: y2, className: "accent-accent mr-2" }), j2("span", { className: "text-fg-secondary text-sm font-medium" }, "Include annotations"))), y2 && j2("div", { className: "bg-state-info-light flex items-center space-x-3 rounded-md p-3" }, j2(Pv, { className: "text-accent" }), j2("span", { className: "text-accent text-sm" }, x2)), j2("div", { className: "border-border-subtle flex justify-end space-x-3 border-t pt-4" }, j2(Qm, { onClick: o3, disabled: y2, className: "border-border-default bg-bg-surface text-fg-secondary hover:bg-interactive-hover rounded-md border px-4 py-2 text-sm disabled:cursor-not-allowed disabled:opacity-50" }, "Cancel"), j2(Qm, { onClick: function() {
      var e4;
      "current" === l4 ? e4 = String(S2) : "custom" === l4 && (e4 = u4.trim() || void 0);
      var n4 = { includeAnnotations: g3, pageRange: e4 };
      try {
        b2(true), C2("Preparing document...");
        var i4 = null == a3 ? void 0 : a3.forDocument(t2).print(n4);
        i4 && (i4.onProgress(function(e5) {
          C2(e5.message);
        }), i4.wait(function() {
          b2(false), C2(""), null == o3 || o3();
        }, function(e5) {
          console.error("Print failed:", e5), b2(false), C2("");
        }));
      } catch (e5) {
        console.error("Print failed:", e5), b2(false), C2("");
      }
    }, disabled: !D2, className: "bg-accent text-fg-on-accent hover:!bg-accent-hover flex items-center space-x-2 rounded-md border border-transparent px-4 py-2 text-sm disabled:cursor-not-allowed disabled:opacity-50" }, y2 && j2(Pv, { size: "sm" }), j2("span", null, y2 ? "Printing..." : "Print")))));
  }
  function Sf(e3) {
    var t2 = e3.documentId, n3 = Fo().provides, o3 = oi(t2), i3 = o3.provides, r2 = o3.state, a3 = r2.currentPage, s4 = r2.totalPages, l4 = f(ke(false), 2), c4 = l4[0], d4 = l4[1], u4 = f(ke(false), 2), h3 = u4[0], m3 = u4[1], g3 = Ae(null), p4 = f(ke(a3.toString()), 2), v2 = p4[0], y2 = p4[1], b2 = Ae(null);
    Me(function() {
      y2(a3.toString());
    }, [a3]);
    var w2 = ze(function() {
      g3.current && clearTimeout(g3.current), g3.current = setTimeout(function() {
        h3 || d4(false);
      }, 4e3);
    }, [h3]);
    Me(function() {
      if (n3) return n3.onScrollActivity(function(e4) {
        e4.documentId === t2 && (d4(true), w2());
      });
    }, [n3, t2, w2]), Me(function() {
      return function() {
        g3.current && clearTimeout(g3.current);
      };
    }, []);
    return s4 <= 1 ? null : j2("div", { onMouseEnter: function() {
      m3(true), d4(true), g3.current && clearTimeout(g3.current);
    }, onMouseLeave: function() {
      m3(false), w2();
    }, className: "pointer-events-auto" }, j2("div", { className: "border-border-default bg-bg-surface flex items-center gap-1 rounded-lg border p-1 shadow-lg transition-opacity duration-300 ".concat(c4 ? "opacity-100" : "opacity-0") }, j2(kp, { commandId: "scroll:previous-page", documentId: t2, variant: "icon" }), j2("div", { className: "flex items-center gap-1 px-1" }, j2("input", { ref: b2, type: "text", inputMode: "numeric", pattern: "[0-9]*", value: v2, onChange: function(e4) {
      var t3 = e4.target.value.replace(/[^0-9]/g, "");
      y2(t3);
    }, onFocus: function() {
      setTimeout(function() {
        var e4;
        return null === (e4 = b2.current) || void 0 === e4 ? void 0 : e4.select();
      }, 0);
    }, onBlur: function() {
      var e4, t3 = parseInt(v2, 10);
      !isNaN(t3) && t3 >= 1 && t3 <= s4 ? null == i3 || null === (e4 = i3.scrollToPage) || void 0 === e4 || e4.call(i3, { pageNumber: t3 }) : y2(a3.toString());
    }, onKeyDown: function(e4) {
      "Enter" === e4.key ? e4.target.blur() : "Escape" === e4.key && (y2(a3.toString()), e4.target.blur());
    }, className: "border-border-default bg-bg-input text-fg-primary focus:border-accent focus:ring-accent h-7 w-10 rounded border px-1 text-center text-base focus:outline-none focus:ring-1" }), j2("span", { className: "text-fg-secondary text-sm" }, "\xA0 ", s4)), j2(kp, { commandId: "scroll:next-page", documentId: t2, variant: "icon" })));
  }
  function Mf(e3, t2) {
    var n3 = h2({}, e3);
    for (var o3 in t2) {
      var i3 = t2[o3];
      i3 && "object" === w(i3) && !Array.isArray(i3) ? n3[o3] = Mf(e3[o3] || {}, i3) : void 0 !== i3 && (n3[o3] = i3);
    }
    return n3;
  }
  function Pf(e3, t2) {
    return { colors: Mf(e3.colors, t2) };
  }
  function Af(e3) {
    return "system" === e3 ? "undefined" == typeof window ? "light" : window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" : e3;
  }
  function Tf(e3) {
    return e3.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function zf(e3) {
    return ":host {\n".concat((function(e4) {
      var t2 = [];
      return (function e5(n3, o3) {
        for (var i3 = 0, r2 = Object.entries(n3); i3 < r2.length; i3++) {
          var a3 = f(r2[i3], 2), s4 = a3[0], l4 = a3[1];
          l4 && "object" === w(l4) ? e5(l4, "".concat(o3, "-").concat(Tf(s4))) : void 0 !== l4 && t2.push("  --ep".concat(o3, "-").concat(Tf(s4), ": ").concat(l4, ";"));
        }
      })(e4.colors, ""), t2.join("\n");
    })(e3), "\n}");
  }
  function Ef(e3) {
    var t2 = e3.documentStates, n3 = e3.activeDocumentId, o3 = e3.visibility, i3 = void 0 === o3 ? "multiple" : o3, r2 = e3.allowOpenFile, a3 = void 0 === r2 || r2, s4 = qr().provides, l4 = ze(function(e4) {
      null == s4 || s4.setActiveDocument(e4);
    }, [s4]), c4 = ze(function(e4) {
      null == s4 || s4.closeDocument(e4);
    }, [s4]), d4 = ze(function() {
      null == s4 || s4.openFileDialog();
    }, [s4]);
    return "always" === i3 || "multiple" === i3 && t2.length > 1 ? j2("div", { className: "bg-bg-surface-alt flex items-end pr-2 pt-2" }, j2("div", { className: "flex flex-1 items-end overflow-x-auto pl-4" }, t2.map(function(e4) {
      var t3, o4, i4 = n3 === e4.id;
      return j2("div", { key: e4.id, onClick: function() {
        return l4(e4.id);
      }, role: "tab", tabIndex: 0, "aria-selected": i4, onKeyDown: function(t4) {
        "Enter" !== t4.key && " " !== t4.key || (t4.preventDefault(), l4(e4.id));
      }, className: "group relative flex min-w-[120px] max-w-[240px] cursor-pointer items-center gap-2 rounded-t-lg px-4 py-2 text-sm font-medium transition-all ".concat(i4 ? "bg-bg-surface text-fg-primary z-10" : "bg-bg-surface-alt text-fg-secondary hover:bg-interactive-hover hover:text-fg-primary") }, j2("span", { className: "min-w-0 flex-1 truncate" }, null !== (t3 = e4.name) && void 0 !== t3 ? t3 : "Document ".concat(e4.id.slice(0, 8))), i4 && j2("button", { onClick: function(t4) {
        t4.stopPropagation(), c4(e4.id);
      }, "aria-label": "Close ".concat(null !== (o4 = e4.name) && void 0 !== o4 ? o4 : "document"), className: "hover:bg-interactive-hover flex-shrink-0 cursor-pointer rounded-full p-1 transition-all ".concat(i4 ? "opacity-100" : "opacity-0 group-hover:opacity-100") }, j2(Ym, { icon: "x", size: 14 })));
    }), a3 && j2("button", { onClick: d4, className: "text-fg-secondary hover:bg-interactive-hover hover:text-fg-primary mb-1.5 ml-1 flex-shrink-0 cursor-pointer rounded p-1.5 transition-colors", "aria-label": "Open File", title: "Open File" }, j2(Ym, { icon: "plus", size: 14 })))) : null;
  }
  function _f() {
    var e3 = qr().provides, t2 = ma().translate;
    return j2("div", { className: "bg-bg-app flex h-full w-full items-center justify-center" }, j2("div", { className: "flex max-w-sm flex-col items-center text-center" }, j2("div", { className: "bg-accent-light mb-6 rounded-full p-5" }, j2(Ym, { icon: "file", size: 48, className: "text-accent" })), j2("h2", { className: "text-fg-primary mb-2 text-xl font-semibold" }, t2("emptyState.title")), j2("p", { className: "text-fg-secondary mb-6 text-sm leading-relaxed" }, t2("emptyState.description"), j2("br", null), t2("emptyState.descriptionMulti")), j2("button", { onClick: function() {
      null == e3 || e3.openFileDialog();
    }, className: "bg-accent hover:bg-accent-hover text-accent-fg inline-flex cursor-pointer items-center gap-2 rounded-md px-5 py-2.5 text-sm font-medium shadow-sm transition-all" }, j2(Ym, { icon: "plus", size: 16 }), t2("emptyState.openButton")), j2("p", { className: "text-fg-muted mt-4 text-xs" }, t2("emptyState.supportedFormats"))));
  }
  function Rf(e3) {
    var t2 = e3.documentState, o3 = qr().provides, i3 = ma().translate, r2 = f(ke(""), 2), a3 = r2[0], s4 = r2[1], l4 = f(ke(false), 2), c4 = l4[0], d4 = l4[1];
    if (!t2) return null;
    var u4 = t2.name, h3 = t2.errorCode, m3 = t2.passwordProvided, p4 = h3 === Ht.Password, v2 = p4 && !m3, y2 = p4 && m3;
    if (!p4) return j2("div", { className: "bg-bg-app flex h-full items-center justify-center p-8" }, j2("div", { className: "bg-bg-surface border-border-default flex max-w-sm flex-col items-center rounded-xl border p-6 text-center shadow-lg" }, j2("div", { className: "bg-state-error-light mb-4 rounded-full p-4" }, j2(Ym, { icon: "alertTriangle", size: 28, className: "text-state-error" })), j2("h3", { className: "text-fg-primary text-lg font-semibold" }, i3("documentError.title")), j2("p", { className: "text-fg-secondary mt-2 text-sm" }, t2.error || i3("documentError.unknown")), h3 && j2("p", { className: "text-fg-muted mt-1 text-xs" }, i3("documentError.errorCode", { params: { code: String(h3) } })), j2("button", { onClick: function() {
      return null == o3 ? void 0 : o3.closeDocument(t2.id);
    }, className: "bg-accent hover:bg-accent-hover text-accent-fg mt-5 w-full cursor-pointer rounded-md px-4 py-2.5 text-sm font-medium transition-colors" }, i3("documentError.close"))));
    var b2 = (function() {
      var e4 = n2(g2().m(function e5() {
        return g2().w(function(e6) {
          for (; ; ) switch (e6.n) {
            case 0:
              if (o3 && a3.trim()) {
                e6.n = 1;
                break;
              }
              return e6.a(2);
            case 1:
              d4(true), o3.retryDocument(t2.id, { password: a3 }).wait(function() {
                s4(""), d4(false);
              }, function(e7) {
                console.error("Retry failed:", e7), d4(false);
              });
            case 2:
              return e6.a(2);
          }
        }, e5);
      }));
      return function() {
        return e4.apply(this, arguments);
      };
    })();
    return j2("div", { className: "bg-bg-app flex h-full items-center justify-center p-8" }, j2("div", { className: "bg-bg-surface border-border-default w-full max-w-sm rounded-xl border p-6 shadow-lg" }, j2("div", { className: "flex flex-col items-center text-center" }, j2("div", { className: "bg-accent-light mb-4 rounded-full p-4" }, j2(Ym, { icon: "lock", size: 28, className: "text-accent" })), j2("h3", { className: "text-fg-primary text-lg font-semibold" }, i3("passwordPrompt.title")), u4 && j2("p", { className: "text-fg-muted mt-1 text-sm" }, u4)), j2("p", { className: "text-fg-secondary mt-4 text-center text-sm" }, v2 && i3("passwordPrompt.required"), y2 && i3("passwordPrompt.incorrect")), j2("div", { className: "mt-5" }, j2("label", { className: "text-fg-primary mb-1.5 block text-sm font-medium" }, i3("passwordPrompt.label")), j2("input", { type: "password", value: a3, onInput: function(e4) {
      return s4(e4.target.value);
    }, onKeyDown: function(e4) {
      return "Enter" === e4.key && !c4 && a3.trim() && b2();
    }, disabled: c4, placeholder: i3("passwordPrompt.placeholder"), className: "bg-bg-input border-border-default focus:border-accent focus:ring-accent text-fg-primary placeholder:text-fg-muted block w-full rounded-md border px-3 py-2.5 text-sm focus:outline-none focus:ring-1 disabled:opacity-50", autoFocus: true })), y2 && j2("div", { className: "bg-state-error-light border-state-error mt-3 flex items-center gap-2 rounded-md border p-3" }, j2(Ym, { icon: "alertTriangle", size: 16, className: "text-state-error flex-shrink-0" }), j2("p", { className: "text-state-error text-sm" }, i3("passwordPrompt.incorrectWarning"))), j2("div", { className: "mt-6 flex gap-3" }, j2("button", { onClick: function() {
      return null == o3 ? void 0 : o3.closeDocument(t2.id);
    }, disabled: c4, className: "border-border-default text-fg-secondary hover:bg-interactive-hover flex-1 cursor-pointer rounded-md border px-4 py-2.5 text-sm font-medium transition-colors disabled:opacity-50" }, i3("passwordPrompt.cancel")), j2("button", { onClick: b2, disabled: c4 || !a3.trim(), className: "bg-accent hover:bg-accent-hover text-accent-fg flex-1 cursor-pointer rounded-md px-4 py-2.5 text-sm font-medium transition-colors disabled:cursor-not-allowed disabled:opacity-50" }, i3(c4 ? "passwordPrompt.opening" : "passwordPrompt.open")))));
  }
  function Nf(e3) {
    var t2 = e3.documentId, n3 = e3.className, o3 = ta("mode:view", t2), i3 = ta("mode:annotate", t2), r2 = ta("mode:shapes", t2), a3 = ta("mode:redact", t2), s4 = ta("tabs:overflow-menu", t2), l4 = Te(function() {
      return [o3, i3, r2, a3].find(function(e4) {
        return null == e4 ? void 0 : e4.active;
      }) || o3;
    }, [o3, i3, r2, a3]), c4 = ze(function(e4) {
      e4.preventDefault(), e4.stopPropagation(), s4 && !s4.disabled && s4.execute();
    }, [s4]);
    if (!s4 || !s4.visible) return null;
    var d4 = s4.active;
    return j2("div", { style: { maxWidth: "100px", width: "100px" }, className: n3 }, j2(Qm, { className: "bg-bg-surface col-start-1 row-start-1 !w-full appearance-none rounded-md py-1.5 pl-3 pr-2 text-[13px] ".concat(d4 ? "bg-interactive-selected ring-accent border-none shadow ring" : "border-border-default outline-border-default hover:bg-interactive-hover hover:ring-accent outline outline-1 -outline-offset-1 hover:ring", " flex flex-row items-center justify-between gap-2"), onClick: c4, disabled: s4.disabled, style: { height: 34 } }, j2("span", { className: "min-w-0 flex-1 truncate text-left ".concat(d4 ? "text-accent" : "text-fg-primary") }, null == l4 ? void 0 : l4.label), j2(Ym, { icon: "chevronDown", className: "h-4 w-4 ".concat(d4 ? "text-accent" : "text-fg-secondary") })));
  }
  function Lf(e3) {
    var t2 = e3.documentId, n3 = e3.tabBarVisibility, o3 = void 0 === n3 ? "multiple" : n3, i3 = (function(e4) {
      const t3 = Or(), { provides: n4 } = Ir(), o4 = null == n4 ? void 0 : n4.getSchema(), i4 = Sr(e4);
      return { renderToolbar: (r3, a4) => {
        const s5 = `${r3}-${a4}`;
        if (!o4 || !n4 || !i4) return null;
        const l5 = i4.activeToolbars[s5], c5 = l5 ? o4.toolbars[l5.toolbarId] : null;
        l5 && !c5 && console.warn(`Toolbar "${l5.toolbarId}" not found in schema`);
        const d5 = c5 && !c5.permanent ? () => n4.forDocument(e4).closeToolbarSlot(r3, a4) : void 0, u5 = t3.toolbar;
        return Ue(U2, { children: l5 && c5 && Ue(u5, { schema: c5, documentId: e4, isOpen: l5.isOpen, onClose: d5 }) }, `toolbar-slot-${s5}`);
      }, renderSidebar: (r3, a4) => {
        var s5;
        const l5 = `${r3}-${a4}`;
        if (!o4 || !n4 || !i4) return null;
        const c5 = i4.activeSidebars[l5], d5 = c5 ? null == (s5 = o4.sidebars) ? void 0 : s5[c5.sidebarId] : null;
        c5 && !d5 && console.warn(`Sidebar "${c5.sidebarId}" not found in schema`);
        const u5 = t3.sidebar;
        return Ue(U2, { children: c5 && d5 && Ue(u5, { schema: d5, documentId: e4, isOpen: c5.isOpen, onClose: () => {
          n4.forDocument(e4).closeSidebarSlot(r3, a4);
        } }) }, `sidebar-slot-${l5}`);
      }, renderModal: () => {
        var r3;
        if (!o4 || !n4 || !i4) return null;
        const a4 = t3.modal;
        if (!a4) return null;
        const s5 = i4.activeModal, l5 = s5 ? null == (r3 = o4.modals) ? void 0 : r3[s5.modalId] : null;
        return s5 && !l5 && console.warn(`Modal "${s5.modalId}" not found in schema`), Ue(U2, { children: s5 && l5 && Ue(a4, { schema: l5, documentId: e4, isOpen: s5.isOpen, onClose: () => {
          n4.forDocument(e4).closeModal();
        }, onExited: () => {
          n4.forDocument(e4).clearModal();
        } }) }, "modal-slot");
      }, getActiveToolbars: () => i4 ? Object.entries(i4.activeToolbars).map(([e5, t4]) => {
        const [n5, o5] = e5.split("-");
        return { placement: n5, slot: o5, toolbarId: t4.toolbarId, isOpen: t4.isOpen };
      }) : [], getActiveSidebars: () => i4 ? Object.entries(i4.activeSidebars).map(([e5, t4]) => {
        const [n5, o5] = e5.split("-");
        return { placement: n5, slot: o5, sidebarId: t4.sidebarId, isOpen: t4.isOpen };
      }) : [], renderOverlays: () => {
        if (!o4 || !n4) return null;
        const i5 = t3.overlay;
        return i5 ? Ue(U2, { children: (o4.overlays ? Object.values(o4.overlays) : []).map((t4) => Ue(i5, { schema: t4, documentId: e4 }, t4.id)) }, "overlays-slot") : null;
      } };
    })(t2), r2 = i3.renderToolbar, a3 = i3.renderSidebar, s4 = i3.renderModal, l4 = i3.renderOverlays, c4 = ma(t2).translate, d4 = Lr("selection", t2), u4 = Lr("annotation", t2), h3 = Lr("redaction", t2), m3 = ((e4) => {
      const t3 = vo();
      return Te(() => t3 ? t3.documentOrder.map((e5) => t3.documents[e5]).filter((e5) => null != e5) : [], [t3, e4]);
    })(), g3 = (() => {
      const e4 = vo();
      return Te(() => {
        if (!e4) return { activeDocumentId: null, activeDocument: null };
        const t3 = e4.activeDocumentId;
        return { activeDocumentId: t3, activeDocument: t3 ? e4.documents[t3] ?? null : null };
      }, [e4]);
    })();
    return j2(U2, null, j2(Ef, { documentStates: m3, activeDocumentId: g3.activeDocumentId, visibility: o3 }), r2("top", "main"), r2("top", "secondary"), j2("div", { id: "document-content", className: "bg-bg-surface flex flex-1 overflow-hidden" }, a3("left", "main"), j2("div", { className: "flex-1 overflow-hidden" }, j2(Br, { documentId: t2 }, function(e4) {
      var n4 = e4.documentState, o4 = e4.isLoading, i4 = e4.isError, r3 = e4.isLoaded;
      return j2(U2, null, o4 && j2("div", { className: "flex h-full items-center justify-center" }, j2(Mv, { size: "lg", text: c4("document.loading") })), i4 && j2(Rf, { documentState: n4 }), r3 && j2("div", { className: "relative h-full w-full" }, j2(Sd, { documentId: t2 }, j2(Ho, { className: "bg-bg-app", documentId: t2 }, j2(Ta, { documentId: t2 }, j2(ii, { documentId: t2, renderPage: function(e5) {
        var n5 = e5.pageIndex;
        return j2(Ga, { documentId: t2, pageIndex: n5, style: { backgroundColor: "#fff" } }, j2(kd, { documentId: t2, pageIndex: n5 }, j2(Oa, { documentId: t2, pageIndex: n5, scale: 0.5, style: { pointerEvents: "none" } }), j2(gl, { documentId: t2, pageIndex: n5, style: { pointerEvents: "none" } }), j2(gs, { documentId: t2, pageIndex: n5 }), j2(za, { documentId: t2, pageIndex: n5 }), j2(Ru, { documentId: t2, pageIndex: n5 }), j2(Xs, { documentId: t2, pageIndex: n5, selectionMenu: d4 }), j2(fh, { documentId: t2, pageIndex: n5, selectionMenu: h3 }), j2(Vd, { documentId: t2, pageIndex: n5, selectionMenu: u4 }), j2(Tv, null)));
      } })))), l4()));
    })), a3("right", "main")), s4());
  }
  function Ff(e3) {
    var t2, o3 = e3.config, i3 = e3.onRegistryReady, r2 = (function(e4) {
      const { wasmUrl: t3 = yo, worker: n3 = true, logger: o4, encoderPoolSize: i4, fontFallback: r3 } = e4 ?? {}, [a4, s5] = ke(null), [l5, c5] = ke(true), [d4, u4] = ke(null), h3 = Ae(null);
      return Me(() => {
        let e5 = false;
        return (async () => {
          try {
            const { createPdfiumEngine: e6 } = n3 ? await Promise.resolve().then(() => (init_worker_engine_BwJuk6Jt(), worker_engine_BwJuk6Jt_exports)) : await Promise.resolve().then(() => (init_direct_engine_Db2HQG7S(), direct_engine_Db2HQG7S_exports)), a5 = await e6(t3, { logger: o4, encoderPoolSize: i4, fontFallback: r3 });
            h3.current = a5, s5(a5), c5(false);
          } catch (t4) {
            e5 || (u4(t4), c5(false));
          }
        })(), () => {
          var t4, n4;
          e5 = true, null == (n4 = null == (t4 = h3.current) ? void 0 : t4.closeAllDocuments) || n4.call(t4).wait(() => {
            var e6, t5;
            null == (t5 = null == (e6 = h3.current) ? void 0 : e6.destroy) || t5.call(e6), h3.current = null;
          }, wn);
        };
      }, [t3, n3, o4, r3]), { engine: a4, isLoading: l5, error: d4 };
    })(h2(h2({}, o3.wasmUrl && { wasmUrl: o3.wasmUrl }), {}, { worker: o3.worker, logger: o3.log ? $f : void 0 })), a3 = r2.engine, s4 = r2.isLoading, l4 = Te(function() {
      return { "thumbnails-sidebar": xv, "annotation-sidebar": yf, "zoom-toolbar": qv, "search-sidebar": kv, "outline-sidebar": Dv, "comment-sidebar": Bv, "print-modal": If, "page-controls": Sf, "mode-select-button": Nf };
    }, []), c4 = Te(function() {
      return { toolbar: Dp, sidebar: dv, modal: wv, overlay: xf, menu: mv, selectionMenu: bf };
    }, []);
    return j2(U2, null, j2("style", null, je), !a3 || s4 ? j2("div", { className: "flex h-full w-full items-center justify-center" }, j2(Mv, { size: "lg", text: "Initializing PDF engine..." })) : j2(mo, { logger: o3.log ? $f : void 0, onInitialized: (t2 = n2(g2().m(function e4(t3) {
      return g2().w(function(e5) {
        for (; ; ) switch (e5.n) {
          case 0:
            i3 && t3 && i3(t3);
          case 1:
            return e5.a(2);
        }
      }, e4);
    })), function(e4) {
      return t2.apply(this, arguments);
    }), engine: a3, plugins: [Zn(Gr, h2(h2(h2({}, Of.documentManager), o3.src && { initialDocuments: [{ url: o3.src }] }), o3.documentManager)), Zn(na, h2(h2(h2({}, Of.commands), o3.disabledCategories && { disabledCategories: o3.disabledCategories }), o3.commands)), Zn(ha, h2(h2({}, Of.i18n), o3.i18n)), Zn(Cr, h2(h2(h2({}, Of.ui), o3.disabledCategories && { disabledCategories: o3.disabledCategories }), o3.ui)), Zn(Lo, h2(h2({}, Of.viewport), o3.viewport)), Zn(ti, h2(h2({}, Of.scroll), o3.scroll)), Zn(Da, h2(h2({}, Of.zoom), o3.zoom)), Zn(vi, h2(h2({}, Of.spread), o3.spread)), Zn(qa, h2(h2({}, Of.rotation), o3.rotation)), Zn(Iu, h2(h2({}, Of.pan), o3.pan)), Zn(Na, h2(h2({}, Of.render), o3.render)), Zn(ul, h2(h2({}, Of.tiling), o3.tiling)), Zn(Dl, h2(h2({}, Of.thumbnails), o3.thumbnails)), Zn(Kc, h2(h2({}, Of.annotations), o3.annotations)), Zn(hs, h2(h2({}, Of.search), o3.search)), Zn(Qs, h2(h2({}, Of.selection), o3.selection)), Zn(hu, h2(h2({}, Of.bookmarks), o3.bookmarks)), Zn(xh, h2(h2({}, Of.attachments), o3.attachments)), Zn(_u, h2(h2({}, Of.capture), o3.capture)), Zn(uh, h2(h2({}, Of.redaction), o3.redaction)), Zn(Jd, h2(h2({}, Of.print), o3.print)), Zn(vu, h2(h2({}, Of.export), o3.export)), Zn(su, h2(h2({}, Of.fullscreen), o3.fullscreen)), Zn(Bu, h2(h2({}, Of.history), o3.history)), Zn(fd, h2(h2({}, Of.interactionManager), o3.interactionManager))] }, function(e4) {
      var t3 = e4.pluginsReady, n3 = e4.activeDocumentId;
      return j2(U2, null, t3 ? j2(U2, null, n3 ? j2(jr, { documentId: n3, components: l4, renderers: c4, className: "relative flex h-full w-full select-none flex-col" }, j2(Lf, { documentId: n3, tabBarVisibility: o3.tabBar })) : j2(_f, null)) : j2("div", { className: "flex h-full items-center justify-center" }, j2(Mv, { size: "lg", text: "Initializing plugins..." })));
    }));
  }
  var C, I, S, k, D, M, P, A, T, z2, E, _, R, N2, O, L2, ue, he, me, ge, pe, ve, fe, ye, be, we, xe, Ce, Ie, Re, je, He, We, at, st, lt, ct, dt, ut, ht, mt, gt, pt, vt, yt, bt, wt, xt, Ct, It, St, kt, Dt, Mt, Pt, At, Tt, zt, Et, _t, Rt, Nt, $t, Ft, jt, Ht, Ut, Kt, Yt, Qt, Jt, en, tn, nn, on, cn, un, hn, gn, vn, bn, xn, Cn, In, Sn, kn, Dn, Mn, Pn, An, Tn, zn, En, _n, Rn, Nn, On, Ln, $n, Fn, jn, Hn, Un, Wn, Bn, Gn, Vn, Yn, Xn, Qn, no, oo, lo, uo, yo, bo, wo, xo, Co, Io, So, ko, Do, Mo, Po, Ao, To, zo, _o, Ro, No, Oo, Lo, $o, Fo, Uo, Wo, Bo, qo, Go, Vo, Zo, Ko, Xo, Qo, Jo, ei, ti, ni, oi, ri, ai, si, li, ci, ui, hi, mi, gi, pi, vi, fi, yi, bi, wi, xi, Ci, Ii, Si, ki, Di, Mi, Pi, Ai, Ti, zi, Ei, _i, Ri, Ni, Oi, Li, $i, Fi, Bi, qi, Gi, Vi, Zi, Ki, Yi, Xi, gr, pr, vr, fr, Cr, Ir, Sr, kr, Mr, zr, Rr, Hr, Ur, Wr, qr, Gr, Vr, Zr, Kr, Yr, Xr, Qr, Jr, ea, ta, na, oa, ia, ra, aa, sa, la, ca, da, ua, ha, ma, ga, pa, va, fa, ya, ba, wa, xa, Ca, Ia, Sa, ka, Da, Ma, za, Ea, _a, Ra, Na, La, $a, Fa, ja, Ha, Ua, Wa, Ba, qa, Va, Za, Ka, Ya, Xa, Qa, Ja, es, ts, ns, as, ss, ls, cs, ds, us, hs, ms, ps, vs, fs, ys, bs, ws, xs, Cs, Is, Ss, ks, Ds, Ms, Ps, Hs, Us, Ws, Bs, Gs, Ys, Qs, Js, el, tl, nl, ol, il, rl, al, sl, cl, dl, ul, hl, pl, vl, fl, yl, bl, wl, Cl, Il, Sl, kl, Dl, Ml, Tl, zl, El, _l, Rl, Nl, Ol, Ll, $l, Fl, jl, Hl, Ul, Wl, Bl, ql, Gl, Vl, Zl, Kl, Yl, Xl, hc, mc, gc, vc, fc, yc, wc, Cc, kc, Dc, Mc, Ac, Tc, zc, Ec, _c, Rc, Nc, Oc, Lc, $c, Fc, jc, Hc, Uc, Wc, qc, Gc, Vc, Zc, Kc, Yc, Xc, Qc, Jc, ed, td, nd, od, id, rd, ad, sd, dd, ud, hd, md, gd, pd, vd, fd, yd, bd, wd, xd, Sd, kd, Dd, Md, Pd, Zd, Kd, Yd, Xd, Qd, Jd, eu, tu, nu, ou, iu, ru, su, lu, cu, du, uu, hu, mu, gu, pu, vu, fu, yu, bu, wu, xu, Cu, Iu, Su, ku, Du, Mu, Pu, Au, Tu, zu, Eu, _u, Ru, Nu, Ou, Lu, $u, Fu, ju, Hu, Uu, Wu, Bu, qu, Gu, Vu, Zu, Ku, Yu, Xu, Qu, Ju, eh, th, nh, oh, ih, rh, ah, sh, lh, ch, dh, uh, hh, mh, fh, yh, bh, wh, xh, Ch, Ih, Sh, kh, Dh, Mh, Ph, Ah, Th, zh, Eh, _h, Rh, Nh, Oh, Lh, $h, Fh, jh, Hh, Uh, Wh, Bh, qh, Gh, Vh, Zh, Kh, Yh, Xh, Qh, Jh, em, tm, nm, om, im, rm, am, sm, lm, cm, dm, um, hm, mm, gm, pm, vm, fm, ym, bm, wm, xm, Cm, Im, Sm, km, Dm, Mm, Pm, Am, Tm, zm, Em, _m, Rm, Nm, Om, $m, Fm, jm, Hm, Um, Wm, Bm, qm, Xm, Jm, eg, tg, ng, og, ig, rg, hg, vg, fg, yg, bg, Dg, Ng, Lg, Fg, Hg, Ug, Wg, Gg, op, lp, pp, yp, bp, wp, xp, Cp, Ip, $p, Fp, jp, Gp, Yp, Xp, Qp, Jp, ev, tv, nv, av, sv, lv, cv, Iv, Sv, Av, Tv, zv, Ev, _v, Rv, Nv, Ov, Lv, $v, Fv, jv, Hv, Uv, Wv, Bv, Gv, Vv, Zv, Kv, Yv, Xv, Qv, Jv, ef, tf, nf, of, rf, af, sf, lf, cf, df, uf, hf, mf, pf, vf, ff, kf, Df, Of, $f, jf, Hf, Uf, Wf, Bf;
  var init_embedpdf_Ob4AJbqq = __esm({
    "node_modules/@embedpdf/snippet/dist/embedpdf-Ob4AJbqq.js"() {
      R = {};
      N2 = [];
      O = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
      L2 = Array.isArray;
      C = N2.slice, I = { __e: function(e3, t2, n3, o3) {
        for (var i3, r2, a3; t2 = t2.__; ) if ((i3 = t2.__c) && !i3.__) try {
          if ((r2 = i3.constructor) && null != r2.getDerivedStateFromError && (i3.setState(r2.getDerivedStateFromError(e3)), a3 = i3.__d), null != i3.componentDidCatch && (i3.componentDidCatch(e3, o3 || {}), a3 = i3.__d), a3) return i3.__E = i3;
        } catch (t3) {
          e3 = t3;
        }
        throw e3;
      } }, S = 0, W2.prototype.setState = function(e3, t2) {
        var n3;
        n3 = null != this.__s && this.__s != this.state ? this.__s : this.__s = $2({}, this.state), "function" == typeof e3 && (e3 = e3($2({}, n3), this.props)), e3 && $2(n3, e3), null != e3 && this.__v && (t2 && this._sb.push(t2), G(this));
      }, W2.prototype.forceUpdate = function(e3) {
        this.__v && (this.__e = true, e3 && this.__h.push(e3), G(this));
      }, W2.prototype.render = U2, k = [], M = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, P = function(e3, t2) {
        return e3.__v.__b - t2.__v.__b;
      }, V2.__r = 0, A = /(PointerCapture)$|Capture$/i, T = 0, z2 = ee2(false), E = ee2(true), _ = 0;
      pe = 0;
      ve = [];
      fe = I;
      ye = fe.__b;
      be = fe.__r;
      we = fe.diffed;
      xe = fe.__c;
      Ce = fe.unmount;
      Ie = fe.__;
      fe.__b = function(e3) {
        he = null, ye && ye(e3);
      }, fe.__ = function(e3, t2) {
        e3 && t2.__k && t2.__k.__m && (e3.__m = t2.__k.__m), Ie && Ie(e3, t2);
      }, fe.__r = function(e3) {
        be && be(e3), ue = 0;
        var t2 = (he = e3.__c).__H;
        t2 && (me === he ? (t2.__h = [], he.__h = [], t2.__.forEach(function(e4) {
          e4.__N && (e4.__ = e4.__N), e4.u = e4.__N = void 0;
        })) : (t2.__h.forEach(Oe), t2.__h.forEach(Le), t2.__h = [], ue = 0)), me = he;
      }, fe.diffed = function(e3) {
        we && we(e3);
        var t2 = e3.__c;
        t2 && t2.__H && (t2.__H.__h.length && (1 !== ve.push(t2) && ge === fe.requestAnimationFrame || ((ge = fe.requestAnimationFrame) || Ne)(_e)), t2.__H.__.forEach(function(e4) {
          e4.u && (e4.__H = e4.u), e4.u = void 0;
        })), me = he = null;
      }, fe.__c = function(e3, t2) {
        t2.some(function(e4) {
          try {
            e4.__h.forEach(Oe), e4.__h = e4.__h.filter(function(e5) {
              return !e5.__ || Le(e5);
            });
          } catch (n3) {
            t2.some(function(e5) {
              e5.__h && (e5.__h = []);
            }), t2 = [], fe.__e(n3, e4.__v);
          }
        }), xe && xe(e3, t2);
      }, fe.unmount = function(e3) {
        Ce && Ce(e3);
        var t2, n3 = e3.__c;
        n3 && n3.__H && (n3.__H.__.forEach(function(e4) {
          try {
            Oe(e4);
          } catch (e5) {
            t2 = e5;
          }
        }), n3.__H = void 0, t2 && fe.__e(t2, n3.__v));
      };
      Re = "function" == typeof requestAnimationFrame;
      je = `/*! tailwindcss v4.1.18 | MIT License | https://tailwindcss.com */
@layer properties;
@layer theme, base, components, utilities;
@layer theme {
  :root, :host {
    --font-sans: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji",
      "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
      "Courier New", monospace;
    --color-red-500: oklch(63.7% 0.237 25.331);
    --color-yellow-500: oklch(79.5% 0.184 86.047);
    --color-green-500: oklch(72.3% 0.219 149.579);
    --color-teal-500: oklch(70.4% 0.14 182.503);
    --color-blue-500: oklch(62.3% 0.214 259.815);
    --color-blue-600: oklch(54.6% 0.245 262.881);
    --color-blue-700: oklch(48.8% 0.243 264.376);
    --color-indigo-500: oklch(58.5% 0.233 277.117);
    --color-purple-500: oklch(62.7% 0.265 303.9);
    --color-pink-500: oklch(65.6% 0.241 354.308);
    --color-gray-50: oklch(98.5% 0.002 247.839);
    --color-gray-200: oklch(92.8% 0.006 264.531);
    --color-gray-300: oklch(87.2% 0.01 258.338);
    --color-gray-700: oklch(37.3% 0.034 259.733);
    --color-white: #fff;
    --spacing: 0.25rem;
    --container-sm: 24rem;
    --text-xs: 0.75rem;
    --text-xs--line-height: calc(1 / 0.75);
    --text-sm: 0.875rem;
    --text-sm--line-height: calc(1.25 / 0.875);
    --text-base: 1rem;
    --text-base--line-height: calc(1.5 / 1);
    --text-lg: 1.125rem;
    --text-lg--line-height: calc(1.75 / 1.125);
    --text-xl: 1.25rem;
    --text-xl--line-height: calc(1.75 / 1.25);
    --font-weight-medium: 500;
    --font-weight-semibold: 600;
    --font-weight-bold: 700;
    --leading-relaxed: 1.625;
    --radius-md: 0.375rem;
    --radius-lg: 0.5rem;
    --radius-xl: 0.75rem;
    --radius-2xl: 1rem;
    --ease-out: cubic-bezier(0, 0, 0.2, 1);
    --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
    --animate-spin: spin 1s linear infinite;
    --animate-pulse: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    --default-transition-duration: 150ms;
    --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    --default-font-family: var(--font-sans);
    --default-mono-font-family: var(--font-mono);
    --color-bg-app: var(--ep-background-app);
    --color-bg-surface: var(--ep-background-surface);
    --color-bg-surface-alt: var(--ep-background-surface-alt);
    --color-bg-elevated: var(--ep-background-elevated);
    --color-bg-overlay: var(--ep-background-overlay);
    --color-bg-input: var(--ep-background-input);
    --color-fg-primary: var(--ep-foreground-primary);
    --color-fg-secondary: var(--ep-foreground-secondary);
    --color-fg-muted: var(--ep-foreground-muted);
    --color-fg-disabled: var(--ep-foreground-disabled);
    --color-fg-on-accent: var(--ep-foreground-on-accent);
    --color-border-default: var(--ep-border-default);
    --color-border-subtle: var(--ep-border-subtle);
    --color-border-strong: var(--ep-border-strong);
    --color-accent: var(--ep-accent-primary);
    --color-accent-hover: var(--ep-accent-primary-hover);
    --color-accent-light: var(--ep-accent-primary-light);
    --color-accent-fg: var(--ep-accent-primary-foreground);
    --color-interactive-hover: var(--ep-interactive-hover);
    --color-interactive-active: var(--ep-interactive-active);
    --color-interactive-selected: var(--ep-interactive-selected);
    --color-interactive-focus-ring: var(--ep-interactive-focus-ring);
    --color-state-error: var(--ep-state-error);
    --color-state-error-light: var(--ep-state-error-light);
    --color-state-info-light: var(--ep-state-info-light);
    --color-tooltip-bg: var(--ep-tooltip-background);
    --color-tooltip-fg: var(--ep-tooltip-foreground);
  }
}
@layer base {
  *, ::after, ::before, ::backdrop, ::file-selector-button {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    border: 0 solid;
  }
  html, :host {
    line-height: 1.5;
    -webkit-text-size-adjust: 100%;
    -moz-tab-size: 4;
      -o-tab-size: 4;
         tab-size: 4;
    font-family: var(--default-font-family, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji");
    font-feature-settings: var(--default-font-feature-settings, normal);
    font-variation-settings: var(--default-font-variation-settings, normal);
    -webkit-tap-highlight-color: transparent;
  }
  hr {
    height: 0;
    color: inherit;
    border-top-width: 1px;
  }
  abbr:where([title]) {
    -webkit-text-decoration: underline dotted;
    text-decoration: underline dotted;
  }
  h1, h2, h3, h4, h5, h6 {
    font-size: inherit;
    font-weight: inherit;
  }
  a {
    color: inherit;
    -webkit-text-decoration: inherit;
    text-decoration: inherit;
  }
  b, strong {
    font-weight: bolder;
  }
  code, kbd, samp, pre {
    font-family: var(--default-mono-font-family, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace);
    font-feature-settings: var(--default-mono-font-feature-settings, normal);
    font-variation-settings: var(--default-mono-font-variation-settings, normal);
    font-size: 1em;
  }
  small {
    font-size: 80%;
  }
  sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }
  sub {
    bottom: -0.25em;
  }
  sup {
    top: -0.5em;
  }
  table {
    text-indent: 0;
    border-color: inherit;
    border-collapse: collapse;
  }
  :-moz-focusring {
    outline: auto;
  }
  progress {
    vertical-align: baseline;
  }
  summary {
    display: list-item;
  }
  ol, ul, menu {
    list-style: none;
  }
  img, svg, video, canvas, audio, iframe, embed, object {
    display: block;
    vertical-align: middle;
  }
  img, video {
    max-width: 100%;
    height: auto;
  }
  button, input, select, optgroup, textarea, ::file-selector-button {
    font: inherit;
    font-feature-settings: inherit;
    font-variation-settings: inherit;
    letter-spacing: inherit;
    color: inherit;
    border-radius: 0;
    background-color: transparent;
    opacity: 1;
  }
  :where(select:is([multiple], [size])) optgroup {
    font-weight: bolder;
  }
  :where(select:is([multiple], [size])) optgroup option {
    padding-inline-start: 20px;
  }
  ::file-selector-button {
    margin-inline-end: 4px;
  }
  ::-moz-placeholder {
    opacity: 1;
  }
  ::placeholder {
    opacity: 1;
  }
  @supports (not (-webkit-appearance: -apple-pay-button))  or (contain-intrinsic-size: 1px) {
    ::-moz-placeholder {
      color: currentcolor;
      @supports (color: color-mix(in lab, red, red)) {
        color: color-mix(in oklab, currentcolor 50%, transparent);
      }
    }
    ::placeholder {
      color: currentcolor;
      @supports (color: color-mix(in lab, red, red)) {
        color: color-mix(in oklab, currentcolor 50%, transparent);
      }
    }
  }
  textarea {
    resize: vertical;
  }
  ::-webkit-search-decoration {
    -webkit-appearance: none;
  }
  ::-webkit-date-and-time-value {
    min-height: 1lh;
    text-align: inherit;
  }
  ::-webkit-datetime-edit {
    display: inline-flex;
  }
  ::-webkit-datetime-edit-fields-wrapper {
    padding: 0;
  }
  ::-webkit-datetime-edit, ::-webkit-datetime-edit-year-field, ::-webkit-datetime-edit-month-field, ::-webkit-datetime-edit-day-field, ::-webkit-datetime-edit-hour-field, ::-webkit-datetime-edit-minute-field, ::-webkit-datetime-edit-second-field, ::-webkit-datetime-edit-millisecond-field, ::-webkit-datetime-edit-meridiem-field {
    padding-block: 0;
  }
  ::-webkit-calendar-picker-indicator {
    line-height: 1;
  }
  :-moz-ui-invalid {
    box-shadow: none;
  }
  button, input:where([type="button"], [type="reset"], [type="submit"]), ::file-selector-button {
    -webkit-appearance: button;
       -moz-appearance: button;
            appearance: button;
  }
  ::-webkit-inner-spin-button, ::-webkit-outer-spin-button {
    height: auto;
  }
  [hidden]:where(:not([hidden="until-found"])) {
    display: none !important;
  }
}
@layer utilities {
  .pointer-events-auto {
    pointer-events: auto;
  }
  .pointer-events-none {
    pointer-events: none;
  }
  .visible {
    visibility: visible;
  }
  .absolute {
    position: absolute;
  }
  .fixed {
    position: fixed;
  }
  .relative {
    position: relative;
  }
  .static {
    position: static;
  }
  .sticky {
    position: sticky;
  }
  .inset-0 {
    inset: calc(var(--spacing) * 0);
  }
  .inset-x-0 {
    inset-inline: calc(var(--spacing) * 0);
  }
  .inset-y-0 {
    inset-block: calc(var(--spacing) * 0);
  }
  .top-0 {
    top: calc(var(--spacing) * 0);
  }
  .top-1\\/2 {
    top: calc(1/2 * 100%);
  }
  .top-4 {
    top: calc(var(--spacing) * 4);
  }
  .top-6 {
    top: calc(var(--spacing) * 6);
  }
  .right-0 {
    right: calc(var(--spacing) * 0);
  }
  .right-1 {
    right: calc(var(--spacing) * 1);
  }
  .right-4 {
    right: calc(var(--spacing) * 4);
  }
  .bottom-0 {
    bottom: calc(var(--spacing) * 0);
  }
  .left-0 {
    left: calc(var(--spacing) * 0);
  }
  .left-1\\/2 {
    left: calc(1/2 * 100%);
  }
  .z-10 {
    z-index: 10;
  }
  .z-40 {
    z-index: 40;
  }
  .z-50 {
    z-index: 50;
  }
  .z-100 {
    z-index: 100;
  }
  .col-start-1 {
    grid-column-start: 1;
  }
  .row-start-1 {
    grid-row-start: 1;
  }
  .container {
    width: 100%;
    @media (width >= 40rem) {
      max-width: 40rem;
    }
    @media (width >= 48rem) {
      max-width: 48rem;
    }
    @media (width >= 64rem) {
      max-width: 64rem;
    }
    @media (width >= 80rem) {
      max-width: 80rem;
    }
    @media (width >= 96rem) {
      max-width: 96rem;
    }
  }
  .mx-4 {
    margin-inline: calc(var(--spacing) * 4);
  }
  .my-2 {
    margin-block: calc(var(--spacing) * 2);
  }
  .my-4 {
    margin-block: calc(var(--spacing) * 4);
  }
  .mt-0\\.5 {
    margin-top: calc(var(--spacing) * 0.5);
  }
  .mt-1 {
    margin-top: calc(var(--spacing) * 1);
  }
  .mt-2 {
    margin-top: calc(var(--spacing) * 2);
  }
  .mt-3 {
    margin-top: calc(var(--spacing) * 3);
  }
  .mt-4 {
    margin-top: calc(var(--spacing) * 4);
  }
  .mt-5 {
    margin-top: calc(var(--spacing) * 5);
  }
  .mt-6 {
    margin-top: calc(var(--spacing) * 6);
  }
  .mr-2 {
    margin-right: calc(var(--spacing) * 2);
  }
  .mb-1 {
    margin-bottom: calc(var(--spacing) * 1);
  }
  .mb-1\\.5 {
    margin-bottom: calc(var(--spacing) * 1.5);
  }
  .mb-2 {
    margin-bottom: calc(var(--spacing) * 2);
  }
  .mb-3 {
    margin-bottom: calc(var(--spacing) * 3);
  }
  .mb-4 {
    margin-bottom: calc(var(--spacing) * 4);
  }
  .mb-6 {
    margin-bottom: calc(var(--spacing) * 6);
  }
  .ml-1 {
    margin-left: calc(var(--spacing) * 1);
  }
  .block {
    display: block;
  }
  .contents {
    display: contents;
  }
  .flex {
    display: flex;
  }
  .grid {
    display: grid;
  }
  .hidden {
    display: none;
  }
  .inline {
    display: inline;
  }
  .inline-block {
    display: inline-block;
  }
  .inline-flex {
    display: inline-flex;
  }
  .h-1 {
    height: calc(var(--spacing) * 1);
  }
  .h-1\\.5 {
    height: calc(var(--spacing) * 1.5);
  }
  .h-2 {
    height: calc(var(--spacing) * 2);
  }
  .h-3 {
    height: calc(var(--spacing) * 3);
  }
  .h-3\\.5 {
    height: calc(var(--spacing) * 3.5);
  }
  .h-4 {
    height: calc(var(--spacing) * 4);
  }
  .h-5 {
    height: calc(var(--spacing) * 5);
  }
  .h-6 {
    height: calc(var(--spacing) * 6);
  }
  .h-7 {
    height: calc(var(--spacing) * 7);
  }
  .h-8 {
    height: calc(var(--spacing) * 8);
  }
  .h-9 {
    height: calc(var(--spacing) * 9);
  }
  .h-10 {
    height: calc(var(--spacing) * 10);
  }
  .h-16 {
    height: calc(var(--spacing) * 16);
  }
  .h-18 {
    height: calc(var(--spacing) * 18);
  }
  .h-\\[32px\\] {
    height: 32px;
  }
  .h-full {
    height: 100%;
  }
  .h-px {
    height: 1px;
  }
  .max-h-48 {
    max-height: calc(var(--spacing) * 48);
  }
  .max-h-60 {
    max-height: calc(var(--spacing) * 60);
  }
  .min-h-0 {
    min-height: calc(var(--spacing) * 0);
  }
  .\\!w-full {
    width: 100% !important;
  }
  .w-2 {
    width: calc(var(--spacing) * 2);
  }
  .w-3 {
    width: calc(var(--spacing) * 3);
  }
  .w-3\\.5 {
    width: calc(var(--spacing) * 3.5);
  }
  .w-4 {
    width: calc(var(--spacing) * 4);
  }
  .w-5 {
    width: calc(var(--spacing) * 5);
  }
  .w-6 {
    width: calc(var(--spacing) * 6);
  }
  .w-8 {
    width: calc(var(--spacing) * 8);
  }
  .w-9 {
    width: calc(var(--spacing) * 9);
  }
  .w-10 {
    width: calc(var(--spacing) * 10);
  }
  .w-12 {
    width: calc(var(--spacing) * 12);
  }
  .w-16 {
    width: calc(var(--spacing) * 16);
  }
  .w-18 {
    width: calc(var(--spacing) * 18);
  }
  .w-32 {
    width: calc(var(--spacing) * 32);
  }
  .w-36 {
    width: calc(var(--spacing) * 36);
  }
  .w-\\[32px\\] {
    width: 32px;
  }
  .w-auto {
    width: auto;
  }
  .w-full {
    width: 100%;
  }
  .w-px {
    width: 1px;
  }
  .max-w-\\[150px\\] {
    max-width: 150px;
  }
  .max-w-\\[240px\\] {
    max-width: 240px;
  }
  .max-w-sm {
    max-width: var(--container-sm);
  }
  .min-w-0 {
    min-width: calc(var(--spacing) * 0);
  }
  .min-w-\\[8rem\\] {
    min-width: 8rem;
  }
  .min-w-\\[32px\\] {
    min-width: 32px;
  }
  .min-w-\\[120px\\] {
    min-width: 120px;
  }
  .min-w-\\[200px\\] {
    min-width: 200px;
  }
  .flex-1 {
    flex: 1;
  }
  .flex-shrink-0 {
    flex-shrink: 0;
  }
  .shrink-0 {
    flex-shrink: 0;
  }
  .-translate-x-1\\/2 {
    --tw-translate-x: calc(calc(1/2 * 100%) * -1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }
  .translate-x-\\[1px\\] {
    --tw-translate-x: 1px;
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }
  .-translate-y-1\\/2 {
    --tw-translate-y: calc(calc(1/2 * 100%) * -1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }
  .translate-y-\\[1px\\] {
    --tw-translate-y: 1px;
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }
  .scale-95 {
    --tw-scale-x: 95%;
    --tw-scale-y: 95%;
    --tw-scale-z: 95%;
    scale: var(--tw-scale-x) var(--tw-scale-y);
  }
  .scale-100 {
    --tw-scale-x: 100%;
    --tw-scale-y: 100%;
    --tw-scale-z: 100%;
    scale: var(--tw-scale-x) var(--tw-scale-y);
  }
  .rotate-45 {
    rotate: 45deg;
  }
  .transform {
    transform: var(--tw-rotate-x,) var(--tw-rotate-y,) var(--tw-rotate-z,) var(--tw-skew-x,) var(--tw-skew-y,);
  }
  .animate-pulse {
    animation: var(--animate-pulse);
  }
  .animate-spin {
    animation: var(--animate-spin);
  }
  .cursor-default {
    cursor: default;
  }
  .cursor-grab {
    cursor: grab;
  }
  .cursor-not-allowed {
    cursor: not-allowed;
  }
  .cursor-pointer {
    cursor: pointer;
  }
  .touch-none {
    touch-action: none;
  }
  .resize {
    resize: both;
  }
  .appearance-none {
    -webkit-appearance: none;
       -moz-appearance: none;
            appearance: none;
  }
  .grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
  .grid-cols-6 {
    grid-template-columns: repeat(6, minmax(0, 1fr));
  }
  .flex-col {
    flex-direction: column;
  }
  .flex-row {
    flex-direction: row;
  }
  .flex-wrap {
    flex-wrap: wrap;
  }
  .items-center {
    align-items: center;
  }
  .items-end {
    align-items: flex-end;
  }
  .items-start {
    align-items: flex-start;
  }
  .justify-between {
    justify-content: space-between;
  }
  .justify-center {
    justify-content: center;
  }
  .justify-end {
    justify-content: flex-end;
  }
  .justify-start {
    justify-content: flex-start;
  }
  .gap-1 {
    gap: calc(var(--spacing) * 1);
  }
  .gap-2 {
    gap: calc(var(--spacing) * 2);
  }
  .gap-3 {
    gap: calc(var(--spacing) * 3);
  }
  .gap-4 {
    gap: calc(var(--spacing) * 4);
  }
  .space-y-2 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 2) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 2) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-3 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 3) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 3) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-4 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 4) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 4) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-6 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 6) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 6) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .gap-x-1 {
    -moz-column-gap: calc(var(--spacing) * 1);
         column-gap: calc(var(--spacing) * 1);
  }
  .space-x-2 {
    :where(& > :not(:last-child)) {
      --tw-space-x-reverse: 0;
      margin-inline-start: calc(calc(var(--spacing) * 2) * var(--tw-space-x-reverse));
      margin-inline-end: calc(calc(var(--spacing) * 2) * calc(1 - var(--tw-space-x-reverse)));
    }
  }
  .space-x-3 {
    :where(& > :not(:last-child)) {
      --tw-space-x-reverse: 0;
      margin-inline-start: calc(calc(var(--spacing) * 3) * var(--tw-space-x-reverse));
      margin-inline-end: calc(calc(var(--spacing) * 3) * calc(1 - var(--tw-space-x-reverse)));
    }
  }
  .gap-y-4 {
    row-gap: calc(var(--spacing) * 4);
  }
  .divide-y {
    :where(& > :not(:last-child)) {
      --tw-divide-y-reverse: 0;
      border-bottom-style: var(--tw-border-style);
      border-top-style: var(--tw-border-style);
      border-top-width: calc(1px * var(--tw-divide-y-reverse));
      border-bottom-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));
    }
  }
  .divide-border-subtle {
    :where(& > :not(:last-child)) {
      border-color: var(--color-border-subtle);
    }
  }
  .truncate {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .overflow-auto {
    overflow: auto;
  }
  .overflow-hidden {
    overflow: hidden;
  }
  .overflow-x-auto {
    overflow-x: auto;
  }
  .overflow-y-auto {
    overflow-y: auto;
  }
  .rounded {
    border-radius: 0.25rem;
  }
  .rounded-\\[3px\\] {
    border-radius: 3px;
  }
  .rounded-full {
    border-radius: calc(infinity * 1px);
  }
  .rounded-lg {
    border-radius: var(--radius-lg);
  }
  .rounded-md {
    border-radius: var(--radius-md);
  }
  .rounded-none {
    border-radius: 0;
  }
  .rounded-xl {
    border-radius: var(--radius-xl);
  }
  .rounded-t-2xl {
    border-top-left-radius: var(--radius-2xl);
    border-top-right-radius: var(--radius-2xl);
  }
  .rounded-t-lg {
    border-top-left-radius: var(--radius-lg);
    border-top-right-radius: var(--radius-lg);
  }
  .rounded-l-md {
    border-top-left-radius: var(--radius-md);
    border-bottom-left-radius: var(--radius-md);
  }
  .rounded-r-md {
    border-top-right-radius: var(--radius-md);
    border-bottom-right-radius: var(--radius-md);
  }
  .border {
    border-style: var(--tw-border-style);
    border-width: 1px;
  }
  .border-0 {
    border-style: var(--tw-border-style);
    border-width: 0px;
  }
  .border-2 {
    border-style: var(--tw-border-style);
    border-width: 2px;
  }
  .border-3 {
    border-style: var(--tw-border-style);
    border-width: 3px;
  }
  .border-4 {
    border-style: var(--tw-border-style);
    border-width: 4px;
  }
  .border-t {
    border-top-style: var(--tw-border-style);
    border-top-width: 1px;
  }
  .border-r {
    border-right-style: var(--tw-border-style);
    border-right-width: 1px;
  }
  .border-r-0 {
    border-right-style: var(--tw-border-style);
    border-right-width: 0px;
  }
  .border-b {
    border-bottom-style: var(--tw-border-style);
    border-bottom-width: 1px;
  }
  .border-b-2 {
    border-bottom-style: var(--tw-border-style);
    border-bottom-width: 2px;
  }
  .border-l {
    border-left-style: var(--tw-border-style);
    border-left-width: 1px;
  }
  .border-none {
    --tw-border-style: none;
    border-style: none;
  }
  .border-\\[\\#cfd4da\\] {
    border-color: #cfd4da;
  }
  .border-accent {
    border-color: var(--color-accent);
  }
  .border-border-default {
    border-color: var(--color-border-default);
  }
  .border-border-strong {
    border-color: var(--color-border-strong);
  }
  .border-border-subtle {
    border-color: var(--color-border-subtle);
  }
  .border-gray-200 {
    border-color: var(--color-gray-200);
  }
  .border-gray-300 {
    border-color: var(--color-gray-300);
  }
  .border-state-error {
    border-color: var(--color-state-error);
  }
  .border-transparent {
    border-color: transparent;
  }
  .border-t-accent {
    border-top-color: var(--color-accent);
  }
  .border-r-accent {
    border-right-color: var(--color-accent);
  }
  .border-b-accent {
    border-bottom-color: var(--color-accent);
  }
  .border-b-transparent {
    border-bottom-color: transparent;
  }
  .bg-\\[\\#f8f9fa\\] {
    background-color: #f8f9fa;
  }
  .bg-accent {
    background-color: var(--color-accent);
  }
  .bg-accent-light {
    background-color: var(--color-accent-light);
  }
  .bg-bg-app {
    background-color: var(--color-bg-app);
  }
  .bg-bg-elevated {
    background-color: var(--color-bg-elevated);
  }
  .bg-bg-input {
    background-color: var(--color-bg-input);
  }
  .bg-bg-overlay {
    background-color: var(--color-bg-overlay);
  }
  .bg-bg-surface {
    background-color: var(--color-bg-surface);
  }
  .bg-bg-surface-alt {
    background-color: var(--color-bg-surface-alt);
  }
  .bg-bg-surface\\/80 {
    background-color: var(--color-bg-surface);
    @supports (color: color-mix(in lab, red, red)) {
      background-color: color-mix(in oklab, var(--color-bg-surface) 80%, transparent);
    }
  }
  .bg-blue-500 {
    background-color: var(--color-blue-500);
  }
  .bg-blue-600 {
    background-color: var(--color-blue-600);
  }
  .bg-border-default {
    background-color: var(--color-border-default);
  }
  .bg-border-subtle {
    background-color: var(--color-border-subtle);
  }
  .bg-green-500 {
    background-color: var(--color-green-500);
  }
  .bg-indigo-500 {
    background-color: var(--color-indigo-500);
  }
  .bg-inherit {
    background-color: inherit;
  }
  .bg-interactive-hover {
    background-color: var(--color-interactive-hover);
  }
  .bg-interactive-selected {
    background-color: var(--color-interactive-selected);
  }
  .bg-pink-500 {
    background-color: var(--color-pink-500);
  }
  .bg-purple-500 {
    background-color: var(--color-purple-500);
  }
  .bg-red-500 {
    background-color: var(--color-red-500);
  }
  .bg-state-error-light {
    background-color: var(--color-state-error-light);
  }
  .bg-state-info-light {
    background-color: var(--color-state-info-light);
  }
  .bg-teal-500 {
    background-color: var(--color-teal-500);
  }
  .bg-tooltip-bg {
    background-color: var(--color-tooltip-bg);
  }
  .bg-transparent {
    background-color: transparent;
  }
  .bg-white {
    background-color: var(--color-white);
  }
  .bg-yellow-500 {
    background-color: var(--color-yellow-500);
  }
  .p-0 {
    padding: calc(var(--spacing) * 0);
  }
  .p-1 {
    padding: calc(var(--spacing) * 1);
  }
  .p-1\\.5 {
    padding: calc(var(--spacing) * 1.5);
  }
  .p-2 {
    padding: calc(var(--spacing) * 2);
  }
  .p-3 {
    padding: calc(var(--spacing) * 3);
  }
  .p-4 {
    padding: calc(var(--spacing) * 4);
  }
  .p-5 {
    padding: calc(var(--spacing) * 5);
  }
  .p-6 {
    padding: calc(var(--spacing) * 6);
  }
  .p-8 {
    padding: calc(var(--spacing) * 8);
  }
  .p-\\[5px\\] {
    padding: 5px;
  }
  .px-1 {
    padding-inline: calc(var(--spacing) * 1);
  }
  .px-2 {
    padding-inline: calc(var(--spacing) * 2);
  }
  .px-3 {
    padding-inline: calc(var(--spacing) * 3);
  }
  .px-4 {
    padding-inline: calc(var(--spacing) * 4);
  }
  .px-5 {
    padding-inline: calc(var(--spacing) * 5);
  }
  .px-6 {
    padding-inline: calc(var(--spacing) * 6);
  }
  .py-1 {
    padding-block: calc(var(--spacing) * 1);
  }
  .py-1\\.5 {
    padding-block: calc(var(--spacing) * 1.5);
  }
  .py-2 {
    padding-block: calc(var(--spacing) * 2);
  }
  .py-2\\.5 {
    padding-block: calc(var(--spacing) * 2.5);
  }
  .py-3 {
    padding-block: calc(var(--spacing) * 3);
  }
  .py-4 {
    padding-block: calc(var(--spacing) * 4);
  }
  .pt-2 {
    padding-top: calc(var(--spacing) * 2);
  }
  .pt-4 {
    padding-top: calc(var(--spacing) * 4);
  }
  .pr-2 {
    padding-right: calc(var(--spacing) * 2);
  }
  .pr-3 {
    padding-right: calc(var(--spacing) * 3);
  }
  .pr-7 {
    padding-right: calc(var(--spacing) * 7);
  }
  .pr-9 {
    padding-right: calc(var(--spacing) * 9);
  }
  .pb-3 {
    padding-bottom: calc(var(--spacing) * 3);
  }
  .pl-2 {
    padding-left: calc(var(--spacing) * 2);
  }
  .pl-3 {
    padding-left: calc(var(--spacing) * 3);
  }
  .pl-4 {
    padding-left: calc(var(--spacing) * 4);
  }
  .pl-8 {
    padding-left: calc(var(--spacing) * 8);
  }
  .text-center {
    text-align: center;
  }
  .text-left {
    text-align: left;
  }
  .text-right {
    text-align: right;
  }
  .text-base {
    font-size: var(--text-base);
    line-height: var(--tw-leading, var(--text-base--line-height));
  }
  .text-lg {
    font-size: var(--text-lg);
    line-height: var(--tw-leading, var(--text-lg--line-height));
  }
  .text-sm {
    font-size: var(--text-sm);
    line-height: var(--tw-leading, var(--text-sm--line-height));
  }
  .text-xl {
    font-size: var(--text-xl);
    line-height: var(--tw-leading, var(--text-xl--line-height));
  }
  .text-xs {
    font-size: var(--text-xs);
    line-height: var(--tw-leading, var(--text-xs--line-height));
  }
  .text-\\[13px\\] {
    font-size: 13px;
  }
  .leading-none {
    --tw-leading: 1;
    line-height: 1;
  }
  .leading-relaxed {
    --tw-leading: var(--leading-relaxed);
    line-height: var(--leading-relaxed);
  }
  .font-bold {
    --tw-font-weight: var(--font-weight-bold);
    font-weight: var(--font-weight-bold);
  }
  .font-medium {
    --tw-font-weight: var(--font-weight-medium);
    font-weight: var(--font-weight-medium);
  }
  .font-semibold {
    --tw-font-weight: var(--font-weight-semibold);
    font-weight: var(--font-weight-semibold);
  }
  .whitespace-nowrap {
    white-space: nowrap;
  }
  .text-accent {
    color: var(--color-accent);
  }
  .text-accent-fg {
    color: var(--color-accent-fg);
  }
  .text-fg-disabled {
    color: var(--color-fg-disabled);
  }
  .text-fg-muted {
    color: var(--color-fg-muted);
  }
  .text-fg-on-accent {
    color: var(--color-fg-on-accent);
  }
  .text-fg-primary {
    color: var(--color-fg-primary);
  }
  .text-fg-secondary {
    color: var(--color-fg-secondary);
  }
  .text-gray-700 {
    color: var(--color-gray-700);
  }
  .text-state-error {
    color: var(--color-state-error);
  }
  .text-tooltip-fg {
    color: var(--color-tooltip-fg);
  }
  .text-white {
    color: var(--color-white);
  }
  .uppercase {
    text-transform: uppercase;
  }
  .italic {
    font-style: italic;
  }
  .underline {
    text-decoration-line: underline;
  }
  .placeholder-fg-muted {
    &::-moz-placeholder {
      color: var(--color-fg-muted);
    }
    &::placeholder {
      color: var(--color-fg-muted);
    }
  }
  .accent-accent {
    accent-color: var(--color-accent);
  }
  .opacity-0 {
    opacity: 0%;
  }
  .opacity-50 {
    opacity: 50%;
  }
  .opacity-100 {
    opacity: 100%;
  }
  .shadow {
    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 1px 2px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .shadow-2xl {
    --tw-shadow: 0 25px 50px -12px var(--tw-shadow-color, rgb(0 0 0 / 0.25));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .shadow-lg {
    --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 4px 6px -4px var(--tw-shadow-color, rgb(0 0 0 / 0.1));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .shadow-md {
    --tw-shadow: 0 4px 6px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 2px 4px -2px var(--tw-shadow-color, rgb(0 0 0 / 0.1));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .shadow-sm {
    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 1px 2px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .ring {
    --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .ring-1 {
    --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .ring-2 {
    --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .ring-accent {
    --tw-ring-color: var(--color-accent);
  }
  .ring-border-default {
    --tw-ring-color: var(--color-border-default);
  }
  .ring-interactive-focus-ring {
    --tw-ring-color: var(--color-interactive-focus-ring);
  }
  .outline {
    outline-style: var(--tw-outline-style);
    outline-width: 1px;
  }
  .outline-1 {
    outline-style: var(--tw-outline-style);
    outline-width: 1px;
  }
  .outline-2 {
    outline-style: var(--tw-outline-style);
    outline-width: 2px;
  }
  .-outline-offset-1 {
    outline-offset: calc(1px * -1);
  }
  .outline-offset-2 {
    outline-offset: 2px;
  }
  .outline-accent {
    outline-color: var(--color-accent);
  }
  .outline-border-default {
    outline-color: var(--color-border-default);
  }
  .backdrop-blur {
    --tw-backdrop-blur: blur(8px);
    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
  }
  .transition {
    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, backdrop-filter, display, content-visibility, overlay, pointer-events;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-\\[height\\] {
    transition-property: height;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-all {
    transition-property: all;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-colors {
    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-opacity {
    transition-property: opacity;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-transform {
    transition-property: transform, translate, scale, rotate;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .duration-150 {
    --tw-duration: 150ms;
    transition-duration: 150ms;
  }
  .duration-200 {
    --tw-duration: 200ms;
    transition-duration: 200ms;
  }
  .duration-300 {
    --tw-duration: 300ms;
    transition-duration: 300ms;
  }
  .ease-in-out {
    --tw-ease: var(--ease-in-out);
    transition-timing-function: var(--ease-in-out);
  }
  .ease-out {
    --tw-ease: var(--ease-out);
    transition-timing-function: var(--ease-out);
  }
  .outline-none {
    --tw-outline-style: none;
    outline-style: none;
  }
  .select-none {
    -webkit-user-select: none;
    -moz-user-select: none;
         user-select: none;
  }
  .group-hover\\:opacity-100 {
    &:is(:where(.group):hover *) {
      @media (hover: hover) {
        opacity: 100%;
      }
    }
  }
  .peer-checked\\:opacity-100 {
    &:is(:where(.peer):checked ~ *) {
      opacity: 100%;
    }
  }
  .placeholder\\:text-fg-muted {
    &::-moz-placeholder {
      color: var(--color-fg-muted);
    }
    &::placeholder {
      color: var(--color-fg-muted);
    }
  }
  .first\\:mt-0 {
    &:first-child {
      margin-top: calc(var(--spacing) * 0);
    }
  }
  .checked\\:border-accent {
    &:checked {
      border-color: var(--color-accent);
    }
  }
  .checked\\:bg-accent {
    &:checked {
      background-color: var(--color-accent);
    }
  }
  .hover\\:border-b-accent {
    &:hover {
      @media (hover: hover) {
        border-bottom-color: var(--color-accent);
      }
    }
  }
  .hover\\:border-b-fg-muted {
    &:hover {
      @media (hover: hover) {
        border-bottom-color: var(--color-fg-muted);
      }
    }
  }
  .hover\\:\\!bg-accent-hover {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-accent-hover) !important;
      }
    }
  }
  .hover\\:\\!bg-blue-700 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-blue-700) !important;
      }
    }
  }
  .hover\\:bg-accent {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-accent);
      }
    }
  }
  .hover\\:bg-accent-hover {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-accent-hover);
      }
    }
  }
  .hover\\:bg-border-default {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-border-default);
      }
    }
  }
  .hover\\:bg-gray-50 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-gray-50);
      }
    }
  }
  .hover\\:bg-interactive-hover {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-interactive-hover);
      }
    }
  }
  .hover\\:bg-transparent {
    &:hover {
      @media (hover: hover) {
        background-color: transparent;
      }
    }
  }
  .hover\\:text-accent-hover {
    &:hover {
      @media (hover: hover) {
        color: var(--color-accent-hover);
      }
    }
  }
  .hover\\:text-fg-on-accent {
    &:hover {
      @media (hover: hover) {
        color: var(--color-fg-on-accent);
      }
    }
  }
  .hover\\:text-fg-primary {
    &:hover {
      @media (hover: hover) {
        color: var(--color-fg-primary);
      }
    }
  }
  .hover\\:text-fg-secondary {
    &:hover {
      @media (hover: hover) {
        color: var(--color-fg-secondary);
      }
    }
  }
  .hover\\:shadow-md {
    &:hover {
      @media (hover: hover) {
        --tw-shadow: 0 4px 6px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 2px 4px -2px var(--tw-shadow-color, rgb(0 0 0 / 0.1));
        box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
      }
    }
  }
  .hover\\:ring {
    &:hover {
      @media (hover: hover) {
        --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
        box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
      }
    }
  }
  .hover\\:ring-0 {
    &:hover {
      @media (hover: hover) {
        --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
        box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
      }
    }
  }
  .hover\\:ring-accent {
    &:hover {
      @media (hover: hover) {
        --tw-ring-color: var(--color-accent);
      }
    }
  }
  .hover\\:ring-transparent {
    &:hover {
      @media (hover: hover) {
        --tw-ring-color: transparent;
      }
    }
  }
  .focus\\:border-accent {
    &:focus {
      border-color: var(--color-accent);
    }
  }
  .focus\\:border-blue-500 {
    &:focus {
      border-color: var(--color-blue-500);
    }
  }
  .focus\\:border-transparent {
    &:focus {
      border-color: transparent;
    }
  }
  .focus\\:ring-1 {
    &:focus {
      --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
      box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
    }
  }
  .focus\\:ring-2 {
    &:focus {
      --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
      box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
    }
  }
  .focus\\:ring-accent {
    &:focus {
      --tw-ring-color: var(--color-accent);
    }
  }
  .focus\\:ring-blue-500 {
    &:focus {
      --tw-ring-color: var(--color-blue-500);
    }
  }
  .focus\\:outline-none {
    &:focus {
      --tw-outline-style: none;
      outline-style: none;
    }
  }
  .active\\:cursor-grabbing {
    &:active {
      cursor: grabbing;
    }
  }
  .active\\:bg-interactive-active {
    &:active {
      background-color: var(--color-interactive-active);
    }
  }
  .disabled\\:cursor-not-allowed {
    &:disabled {
      cursor: not-allowed;
    }
  }
  .disabled\\:opacity-40 {
    &:disabled {
      opacity: 40%;
    }
  }
  .disabled\\:opacity-50 {
    &:disabled {
      opacity: 50%;
    }
  }
  .disabled\\:hover\\:bg-transparent {
    &:disabled {
      &:hover {
        @media (hover: hover) {
          background-color: transparent;
        }
      }
    }
  }
  .disabled\\:hover\\:ring-0 {
    &:disabled {
      &:hover {
        @media (hover: hover) {
          --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
          box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
        }
      }
    }
  }
  .md\\:flex {
    @media (width >= 48rem) {
      display: flex;
    }
  }
  .md\\:h-auto {
    @media (width >= 48rem) {
      height: auto;
    }
  }
  .md\\:max-h-\\[80vh\\] {
    @media (width >= 48rem) {
      max-height: 80vh;
    }
  }
  .md\\:w-\\[28rem\\] {
    @media (width >= 48rem) {
      width: 28rem;
    }
  }
  .md\\:max-w-\\[90vw\\] {
    @media (width >= 48rem) {
      max-width: 90vw;
    }
  }
  .md\\:flex-none {
    @media (width >= 48rem) {
      flex: none;
    }
  }
  .md\\:items-center {
    @media (width >= 48rem) {
      align-items: center;
    }
  }
  .md\\:justify-center {
    @media (width >= 48rem) {
      justify-content: center;
    }
  }
  .md\\:rounded-lg {
    @media (width >= 48rem) {
      border-radius: var(--radius-lg);
    }
  }
  .md\\:border {
    @media (width >= 48rem) {
      border-style: var(--tw-border-style);
      border-width: 1px;
    }
  }
  .md\\:border-border-subtle {
    @media (width >= 48rem) {
      border-color: var(--color-border-subtle);
    }
  }
  .md\\:shadow-lg {
    @media (width >= 48rem) {
      --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 4px 6px -4px var(--tw-shadow-color, rgb(0 0 0 / 0.1));
      box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
    }
  }
}
@import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&display=swap');
:host {
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-translate-z: 0;
  --tw-rotate-x: rotateX(0);
  --tw-rotate-y: rotateY(0);
  --tw-rotate-z: rotateZ(0);
  --tw-skew-x: skewX(0);
  --tw-skew-y: skewY(0);
  --tw-border-style: solid;
  --tw-gradient-from: #0000;
  --tw-gradient-via: #0000;
  --tw-gradient-to: #0000;
  --tw-gradient-from-position: 0%;
  --tw-gradient-via-position: 50%;
  --tw-gradient-to-position: 100%;
  --tw-shadow: 0 0 #0000;
  --tw-inset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-inset-ring-shadow: 0 0 #0000;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-outline-style: solid;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  width: 100%;
  height: 100%;
  font-family: 'Open Sans', system-ui, sans-serif;
  color: var(--ep-foreground-primary);
  background-color: var(--ep-background-surface);
}
:host *::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
:host *::-webkit-scrollbar-track {
  background: var(--ep-scrollbar-track);
}
:host *::-webkit-scrollbar-thumb {
  background: var(--ep-scrollbar-thumb);
  border-radius: 4px;
}
:host *::-webkit-scrollbar-thumb:hover {
  background: var(--ep-scrollbar-thumb-hover);
}
@property --tw-translate-x {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-translate-y {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-translate-z {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-scale-x {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}
@property --tw-scale-y {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}
@property --tw-scale-z {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}
@property --tw-rotate-x {
  syntax: "*";
  inherits: false;
}
@property --tw-rotate-y {
  syntax: "*";
  inherits: false;
}
@property --tw-rotate-z {
  syntax: "*";
  inherits: false;
}
@property --tw-skew-x {
  syntax: "*";
  inherits: false;
}
@property --tw-skew-y {
  syntax: "*";
  inherits: false;
}
@property --tw-space-y-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-space-x-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-divide-y-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-border-style {
  syntax: "*";
  inherits: false;
  initial-value: solid;
}
@property --tw-leading {
  syntax: "*";
  inherits: false;
}
@property --tw-font-weight {
  syntax: "*";
  inherits: false;
}
@property --tw-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-shadow-color {
  syntax: "*";
  inherits: false;
}
@property --tw-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-inset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-inset-shadow-color {
  syntax: "*";
  inherits: false;
}
@property --tw-inset-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-ring-color {
  syntax: "*";
  inherits: false;
}
@property --tw-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-inset-ring-color {
  syntax: "*";
  inherits: false;
}
@property --tw-inset-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-ring-inset {
  syntax: "*";
  inherits: false;
}
@property --tw-ring-offset-width {
  syntax: "<length>";
  inherits: false;
  initial-value: 0px;
}
@property --tw-ring-offset-color {
  syntax: "*";
  inherits: false;
  initial-value: #fff;
}
@property --tw-ring-offset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-outline-style {
  syntax: "*";
  inherits: false;
  initial-value: solid;
}
@property --tw-backdrop-blur {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-brightness {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-contrast {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-grayscale {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-hue-rotate {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-invert {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-opacity {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-saturate {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-sepia {
  syntax: "*";
  inherits: false;
}
@property --tw-duration {
  syntax: "*";
  inherits: false;
}
@property --tw-ease {
  syntax: "*";
  inherits: false;
}
@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}
@keyframes pulse {
  50% {
    opacity: 0.5;
  }
}
@layer properties {
  @supports ((-webkit-hyphens: none) and (not (margin-trim: inline))) or ((-moz-orient: inline) and (not (color:rgb(from red r g b)))) {
    *, ::before, ::after, ::backdrop {
      --tw-translate-x: 0;
      --tw-translate-y: 0;
      --tw-translate-z: 0;
      --tw-scale-x: 1;
      --tw-scale-y: 1;
      --tw-scale-z: 1;
      --tw-rotate-x: initial;
      --tw-rotate-y: initial;
      --tw-rotate-z: initial;
      --tw-skew-x: initial;
      --tw-skew-y: initial;
      --tw-space-y-reverse: 0;
      --tw-space-x-reverse: 0;
      --tw-divide-y-reverse: 0;
      --tw-border-style: solid;
      --tw-leading: initial;
      --tw-font-weight: initial;
      --tw-shadow: 0 0 #0000;
      --tw-shadow-color: initial;
      --tw-shadow-alpha: 100%;
      --tw-inset-shadow: 0 0 #0000;
      --tw-inset-shadow-color: initial;
      --tw-inset-shadow-alpha: 100%;
      --tw-ring-color: initial;
      --tw-ring-shadow: 0 0 #0000;
      --tw-inset-ring-color: initial;
      --tw-inset-ring-shadow: 0 0 #0000;
      --tw-ring-inset: initial;
      --tw-ring-offset-width: 0px;
      --tw-ring-offset-color: #fff;
      --tw-ring-offset-shadow: 0 0 #0000;
      --tw-outline-style: solid;
      --tw-backdrop-blur: initial;
      --tw-backdrop-brightness: initial;
      --tw-backdrop-contrast: initial;
      --tw-backdrop-grayscale: initial;
      --tw-backdrop-hue-rotate: initial;
      --tw-backdrop-invert: initial;
      --tw-backdrop-opacity: initial;
      --tw-backdrop-saturate: initial;
      --tw-backdrop-sepia: initial;
      --tw-duration: initial;
      --tw-ease: initial;
    }
  }
}
`;
      He = 0;
      We = ((e3) => (e3[e3.Degree0 = 0] = "Degree0", e3[e3.Degree90 = 1] = "Degree90", e3[e3.Degree180 = 2] = "Degree180", e3[e3.Degree270 = 3] = "Degree270", e3))(We || {});
      at = class {
        isEnabled() {
          return false;
        }
        debug() {
        }
        info() {
        }
        warn() {
        }
        error() {
        }
        perf() {
        }
      };
      st = class {
        isEnabled() {
          return true;
        }
        debug(e3, t2, ...n3) {
          console.debug(`${e3}.${t2}`, ...n3);
        }
        info(e3, t2, ...n3) {
          console.info(`${e3}.${t2}`, ...n3);
        }
        warn(e3, t2, ...n3) {
          console.warn(`${e3}.${t2}`, ...n3);
        }
        error(e3, t2, ...n3) {
          console.error(`${e3}.${t2}`, ...n3);
        }
        perf(e3, t2, n3, o3, ...i3) {
          console.info(`${e3}.${t2}.${n3}.${o3}`, ...i3);
        }
      };
      lt = class {
        constructor(e3, t2) {
          this.logger = e3, this.level = t2;
        }
        isEnabled(e3) {
          return this.level <= { debug: 0, info: 1, warn: 2, error: 3 }[e3];
        }
        debug(e3, t2, ...n3) {
          this.level <= 0 && this.logger.debug(e3, t2, ...n3);
        }
        info(e3, t2, ...n3) {
          this.level <= 1 && this.logger.info(e3, t2, ...n3);
        }
        warn(e3, t2, ...n3) {
          this.level <= 2 && this.logger.warn(e3, t2, ...n3);
        }
        error(e3, t2, ...n3) {
          this.level <= 3 && this.logger.error(e3, t2, ...n3);
        }
        perf(e3, t2, n3, o3, ...i3) {
          this.logger.perf(e3, t2, n3, o3, ...i3);
        }
      };
      ct = class {
        constructor() {
          this.marks = /* @__PURE__ */ new Map();
        }
        isEnabled() {
          return false;
        }
        debug(e3, t2, ...n3) {
        }
        info(e3, t2, ...n3) {
        }
        warn(e3, t2, ...n3) {
        }
        error(e3, t2, ...n3) {
        }
        perf(e3, t2, n3, o3, i3, ...r2) {
          const a3 = `${e3}.${t2}.${n3}.${o3}.${i3}`;
          switch (o3) {
            case "Begin":
              globalThis.performance.mark(a3, { detail: r2 }), this.marks.set(`${e3}.${t2}.${n3}.${i3}`, Date.now());
              break;
            case "End":
              globalThis.performance.mark(a3, { detail: r2 });
              const o4 = `${e3}.${t2}.${n3}.Measure.${i3}`, s4 = `${e3}.${t2}.${n3}.Begin.${i3}`;
              globalThis.performance.measure(o4, s4, a3);
              const l4 = this.marks.get(`${e3}.${t2}.${n3}.${i3}`);
              if (l4) {
                const o5 = Date.now() - l4;
                console.info(`\u23F1\uFE0F ${e3}.${t2}.${n3}.${i3}: ${o5}ms`), this.marks.delete(`${e3}.${t2}.${n3}.${i3}`);
              }
          }
        }
      };
      dt = class {
        constructor(e3) {
          this.loggers = e3;
        }
        isEnabled(e3) {
          return this.loggers.some((t2) => t2.isEnabled(e3));
        }
        debug(e3, t2, ...n3) {
          for (const o3 of this.loggers) o3.debug(e3, t2, ...n3);
        }
        info(e3, t2, ...n3) {
          for (const o3 of this.loggers) o3.info(e3, t2, ...n3);
        }
        warn(e3, t2, ...n3) {
          for (const o3 of this.loggers) o3.warn(e3, t2, ...n3);
        }
        error(e3, t2, ...n3) {
          for (const o3 of this.loggers) o3.error(e3, t2, ...n3);
        }
        perf(e3, t2, n3, o3, ...i3) {
          for (const r2 of this.loggers) r2.perf(e3, t2, n3, o3, ...i3);
        }
      };
      ut = ((e3) => (e3[e3.Pending = 0] = "Pending", e3[e3.Resolved = 1] = "Resolved", e3[e3.Rejected = 2] = "Rejected", e3[e3.Aborted = 3] = "Aborted", e3))(ut || {});
      ht = class extends Error {
        constructor(e3) {
          super(`Task aborted: ${JSON.stringify(e3)}`), this.name = "TaskAbortedError", this.reason = e3;
        }
      };
      mt = class extends Error {
        constructor(e3) {
          super(`Task rejected: ${JSON.stringify(e3)}`), this.name = "TaskRejectedError", this.reason = e3;
        }
      };
      gt = class _gt {
        constructor() {
          this.state = { stage: 0 }, this.resolvedCallbacks = [], this.rejectedCallbacks = [], this._promise = null, this.progressCbs = [];
        }
        toPromise() {
          return this._promise || (this._promise = new Promise((e3, t2) => {
            this.wait((t3) => e3(t3), (e4) => {
              "abort" === e4.type ? t2(new ht(e4.reason)) : t2(new mt(e4.reason));
            });
          })), this._promise;
        }
        wait(e3, t2) {
          switch (this.state.stage) {
            case 0:
              this.resolvedCallbacks.push(e3), this.rejectedCallbacks.push(t2);
              break;
            case 1:
              e3(this.state.result);
              break;
            case 2:
              t2({ type: "reject", reason: this.state.reason });
              break;
            case 3:
              t2({ type: "abort", reason: this.state.reason });
          }
        }
        resolve(e3) {
          if (0 === this.state.stage) {
            this.state = { stage: 1, result: e3 };
            for (const t2 of this.resolvedCallbacks) try {
              t2(e3);
            } catch (e4) {
            }
            this.resolvedCallbacks = [], this.rejectedCallbacks = [];
          }
        }
        reject(e3) {
          if (0 === this.state.stage) {
            this.state = { stage: 2, reason: e3 };
            for (const t2 of this.rejectedCallbacks) try {
              t2({ type: "reject", reason: e3 });
            } catch (e4) {
            }
            this.resolvedCallbacks = [], this.rejectedCallbacks = [];
          }
        }
        abort(e3) {
          if (0 === this.state.stage) {
            this.state = { stage: 3, reason: e3 };
            for (const t2 of this.rejectedCallbacks) try {
              t2({ type: "abort", reason: e3 });
            } catch (e4) {
            }
            this.resolvedCallbacks = [], this.rejectedCallbacks = [];
          }
        }
        fail(e3) {
          "abort" === e3.type ? this.abort(e3.reason) : this.reject(e3.reason);
        }
        onProgress(e3) {
          this.progressCbs.push(e3);
        }
        progress(e3) {
          for (const t2 of this.progressCbs) t2(e3);
        }
        static all(e3) {
          const t2 = new _gt();
          if (0 === e3.length) return t2.resolve([]), t2;
          const n3 = new Array(e3.length);
          let o3 = 0, i3 = false;
          return e3.forEach((r2, a3) => {
            r2.wait((r3) => {
              i3 || (n3[a3] = r3, o3++, o3 === e3.length && (i3 = true, t2.resolve(n3)));
            }, (e4) => {
              i3 || (i3 = true, "abort" === e4.type ? t2.abort(e4.reason) : t2.reject(e4.reason));
            });
          }), t2;
        }
        static allSettled(e3) {
          const t2 = new _gt();
          if (0 === e3.length) return t2.resolve([]), t2;
          const n3 = new Array(e3.length);
          let o3 = 0;
          return e3.forEach((i3, r2) => {
            i3.wait((i4) => {
              n3[r2] = { status: "resolved", value: i4 }, o3++, o3 === e3.length && t2.resolve(n3);
            }, (i4) => {
              n3[r2] = { status: "abort" === i4.type ? "aborted" : "rejected", reason: i4.reason }, o3++, o3 === e3.length && t2.resolve(n3);
            });
          }), t2;
        }
        static race(e3) {
          const t2 = new _gt();
          if (0 === e3.length) return t2.reject("No tasks provided"), t2;
          let n3 = false;
          return e3.forEach((e4) => {
            e4.wait((e5) => {
              n3 || (n3 = true, t2.resolve(e5));
            }, (e5) => {
              n3 || (n3 = true, "abort" === e5.type ? t2.abort(e5.reason) : t2.reject(e5.reason));
            });
          }), t2;
        }
        static withProgress(e3, t2) {
          const n3 = _gt.all(e3);
          if (t2) {
            let n4 = 0;
            e3.forEach((o3) => {
              o3.wait(() => {
                n4++, t2(n4, e3.length);
              }, () => {
                n4++, t2(n4, e3.length);
              });
            });
          }
          return n3;
        }
      };
      pt = Object.freeze(["\xAD", "\u200B", "\u2060", "\uFEFF", "\uFFFE", "\uFFFF"]);
      vt = new RegExp(`[${pt.join("")}]`, "g");
      yt = ((e3) => (e3[e3.Unknown = 0] = "Unknown", e3[e3.XYZ = 1] = "XYZ", e3[e3.FitPage = 2] = "FitPage", e3[e3.FitHorizontal = 3] = "FitHorizontal", e3[e3.FitVertical = 4] = "FitVertical", e3[e3.FitRectangle = 5] = "FitRectangle", e3[e3.FitBoundingBox = 6] = "FitBoundingBox", e3[e3.FitBoundingBoxHorizontal = 7] = "FitBoundingBoxHorizontal", e3[e3.FitBoundingBoxVertical = 8] = "FitBoundingBoxVertical", e3))(yt || {});
      bt = ((e3) => (e3[e3.NotSet = 0] = "NotSet", e3[e3.True = 1] = "True", e3[e3.False = 2] = "False", e3[e3.Unknown = 3] = "Unknown", e3))(bt || {});
      wt = ((e3) => (e3[e3.Unknown = -1] = "Unknown", e3[e3.Courier = 0] = "Courier", e3[e3.Courier_Bold = 1] = "Courier_Bold", e3[e3.Courier_BoldOblique = 2] = "Courier_BoldOblique", e3[e3.Courier_Oblique = 3] = "Courier_Oblique", e3[e3.Helvetica = 4] = "Helvetica", e3[e3.Helvetica_Bold = 5] = "Helvetica_Bold", e3[e3.Helvetica_BoldOblique = 6] = "Helvetica_BoldOblique", e3[e3.Helvetica_Oblique = 7] = "Helvetica_Oblique", e3[e3.Times_Roman = 8] = "Times_Roman", e3[e3.Times_Bold = 9] = "Times_Bold", e3[e3.Times_BoldItalic = 10] = "Times_BoldItalic", e3[e3.Times_Italic = 11] = "Times_Italic", e3[e3.Symbol = 12] = "Symbol", e3[e3.ZapfDingbats = 13] = "ZapfDingbats", e3))(wt || {});
      xt = ((e3) => (e3[e3.Left = 0] = "Left", e3[e3.Center = 1] = "Center", e3[e3.Right = 2] = "Right", e3))(xt || {});
      Ct = ((e3) => (e3[e3.Top = 0] = "Top", e3[e3.Middle = 1] = "Middle", e3[e3.Bottom = 2] = "Bottom", e3))(Ct || {});
      It = ((e3) => (e3[e3.Normal = 0] = "Normal", e3[e3.Multiply = 1] = "Multiply", e3[e3.Screen = 2] = "Screen", e3[e3.Overlay = 3] = "Overlay", e3[e3.Darken = 4] = "Darken", e3[e3.Lighten = 5] = "Lighten", e3[e3.ColorDodge = 6] = "ColorDodge", e3[e3.ColorBurn = 7] = "ColorBurn", e3[e3.HardLight = 8] = "HardLight", e3[e3.SoftLight = 9] = "SoftLight", e3[e3.Difference = 10] = "Difference", e3[e3.Exclusion = 11] = "Exclusion", e3[e3.Hue = 12] = "Hue", e3[e3.Saturation = 13] = "Saturation", e3[e3.Color = 14] = "Color", e3[e3.Luminosity = 15] = "Luminosity", e3))(It || {});
      St = ((e3) => (e3[e3.Contain = 0] = "Contain", e3[e3.Cover = 1] = "Cover", e3[e3.Stretch = 2] = "Stretch", e3))(St || {});
      kt = ((e3) => (e3[e3.Unsupported = 0] = "Unsupported", e3[e3.Goto = 1] = "Goto", e3[e3.RemoteGoto = 2] = "RemoteGoto", e3[e3.URI = 3] = "URI", e3[e3.LaunchAppOrOpenFile = 4] = "LaunchAppOrOpenFile", e3))(kt || {});
      Dt = ((e3) => (e3[e3.UNKNOWN = 0] = "UNKNOWN", e3[e3.TEXT = 1] = "TEXT", e3[e3.LINK = 2] = "LINK", e3[e3.FREETEXT = 3] = "FREETEXT", e3[e3.LINE = 4] = "LINE", e3[e3.SQUARE = 5] = "SQUARE", e3[e3.CIRCLE = 6] = "CIRCLE", e3[e3.POLYGON = 7] = "POLYGON", e3[e3.POLYLINE = 8] = "POLYLINE", e3[e3.HIGHLIGHT = 9] = "HIGHLIGHT", e3[e3.UNDERLINE = 10] = "UNDERLINE", e3[e3.SQUIGGLY = 11] = "SQUIGGLY", e3[e3.STRIKEOUT = 12] = "STRIKEOUT", e3[e3.STAMP = 13] = "STAMP", e3[e3.CARET = 14] = "CARET", e3[e3.INK = 15] = "INK", e3[e3.POPUP = 16] = "POPUP", e3[e3.FILEATTACHMENT = 17] = "FILEATTACHMENT", e3[e3.SOUND = 18] = "SOUND", e3[e3.MOVIE = 19] = "MOVIE", e3[e3.WIDGET = 20] = "WIDGET", e3[e3.SCREEN = 21] = "SCREEN", e3[e3.PRINTERMARK = 22] = "PRINTERMARK", e3[e3.TRAPNET = 23] = "TRAPNET", e3[e3.WATERMARK = 24] = "WATERMARK", e3[e3.THREED = 25] = "THREED", e3[e3.RICHMEDIA = 26] = "RICHMEDIA", e3[e3.XFAWIDGET = 27] = "XFAWIDGET", e3[e3.REDACT = 28] = "REDACT", e3))(Dt || {});
      Mt = ((e3) => (e3[e3.Normal = 0] = "Normal", e3[e3.Rollover = 1] = "Rollover", e3[e3.Down = 2] = "Down", e3))(Mt || {});
      Pt = ((e3) => (e3[e3.Unknown = -1] = "Unknown", e3[e3.Comment = 0] = "Comment", e3[e3.Key = 1] = "Key", e3[e3.Note = 2] = "Note", e3[e3.Help = 3] = "Help", e3[e3.NewParagraph = 4] = "NewParagraph", e3[e3.Paragraph = 5] = "Paragraph", e3[e3.Insert = 6] = "Insert", e3[e3.Graph = 7] = "Graph", e3[e3.PushPin = 8] = "PushPin", e3[e3.Paperclip = 9] = "Paperclip", e3[e3.Tag = 10] = "Tag", e3[e3.Speaker = 11] = "Speaker", e3[e3.Mic = 12] = "Mic", e3[e3.Approved = 13] = "Approved", e3[e3.Experimental = 14] = "Experimental", e3[e3.NotApproved = 15] = "NotApproved", e3[e3.AsIs = 16] = "AsIs", e3[e3.Expired = 17] = "Expired", e3[e3.NotForPublicRelease = 18] = "NotForPublicRelease", e3[e3.Confidential = 19] = "Confidential", e3[e3.Final = 20] = "Final", e3[e3.Sold = 21] = "Sold", e3[e3.Departmental = 22] = "Departmental", e3[e3.ForComment = 23] = "ForComment", e3[e3.TopSecret = 24] = "TopSecret", e3[e3.Draft = 25] = "Draft", e3[e3.ForPublicRelease = 26] = "ForPublicRelease", e3))(Pt || {});
      At = ((e3) => (e3[e3.None = 0] = "None", e3[e3.Square = 1] = "Square", e3[e3.Circle = 2] = "Circle", e3[e3.Diamond = 3] = "Diamond", e3[e3.OpenArrow = 4] = "OpenArrow", e3[e3.ClosedArrow = 5] = "ClosedArrow", e3[e3.Butt = 6] = "Butt", e3[e3.ROpenArrow = 7] = "ROpenArrow", e3[e3.RClosedArrow = 8] = "RClosedArrow", e3[e3.Slash = 9] = "Slash", e3[e3.Unknown = 10] = "Unknown", e3))(At || {});
      Tt = ((e3) => (e3[e3.UNKNOWN = 0] = "UNKNOWN", e3[e3.PUSHBUTTON = 1] = "PUSHBUTTON", e3[e3.CHECKBOX = 2] = "CHECKBOX", e3[e3.RADIOBUTTON = 3] = "RADIOBUTTON", e3[e3.COMBOBOX = 4] = "COMBOBOX", e3[e3.LISTBOX = 5] = "LISTBOX", e3[e3.TEXTFIELD = 6] = "TEXTFIELD", e3[e3.SIGNATURE = 7] = "SIGNATURE", e3[e3.XFA = 8] = "XFA", e3[e3.XFA_CHECKBOX = 9] = "XFA_CHECKBOX", e3[e3.XFA_COMBOBOX = 10] = "XFA_COMBOBOX", e3[e3.XFA_IMAGEFIELD = 11] = "XFA_IMAGEFIELD", e3[e3.XFA_LISTBOX = 12] = "XFA_LISTBOX", e3[e3.XFA_PUSHBUTTON = 13] = "XFA_PUSHBUTTON", e3[e3.XFA_SIGNATURE = 14] = "XFA_SIGNATURE", e3[e3.XFA_TEXTFIELD = 15] = "XFA_TEXTFIELD", e3))(Tt || {});
      zt = ((e3) => (e3[e3.Color = 0] = "Color", e3[e3.InteriorColor = 1] = "InteriorColor", e3))(zt || {});
      Et = ((e3) => (e3[e3.UNKNOWN = 0] = "UNKNOWN", e3[e3.SOLID = 1] = "SOLID", e3[e3.DASHED = 2] = "DASHED", e3[e3.BEVELED = 3] = "BEVELED", e3[e3.INSET = 4] = "INSET", e3[e3.UNDERLINE = 5] = "UNDERLINE", e3[e3.CLOUDY = 6] = "CLOUDY", e3))(Et || {});
      _t = ((e3) => (e3[e3.UNKNOWN = 0] = "UNKNOWN", e3[e3.TEXT = 1] = "TEXT", e3[e3.PATH = 2] = "PATH", e3[e3.IMAGE = 3] = "IMAGE", e3[e3.SHADING = 4] = "SHADING", e3[e3.FORM = 5] = "FORM", e3))(_t || {});
      Rt = Object.freeze({ 1: "invisible", 2: "hidden", 4: "print", 8: "noZoom", 16: "noRotate", 32: "noView", 64: "readOnly", 128: "locked", 256: "toggleNoView" });
      Nt = Object.entries(Rt).reduce((e3, [t2, n3]) => (e3[n3] = Number(t2), e3), {});
      $t = ((e3) => (e3[e3.Create = 0] = "Create", e3[e3.Read = 1] = "Read", e3[e3.Update = 2] = "Update", e3[e3.Delete = 3] = "Delete", e3))($t || {});
      Ft = ((e3) => (e3[e3.None = 0] = "None", e3[e3.MatchCase = 1] = "MatchCase", e3[e3.MatchWholeWord = 2] = "MatchWholeWord", e3[e3.MatchConsecutive = 4] = "MatchConsecutive", e3))(Ft || {});
      jt = ((e3) => (e3[e3.Display = 0] = "Display", e3[e3.Print = 1] = "Print", e3))(jt || {});
      Ht = ((e3) => (e3[e3.Ok = 0] = "Ok", e3[e3.Unknown = 1] = "Unknown", e3[e3.NotFound = 2] = "NotFound", e3[e3.WrongFormat = 3] = "WrongFormat", e3[e3.Password = 4] = "Password", e3[e3.Security = 5] = "Security", e3[e3.PageError = 6] = "PageError", e3[e3.XFALoad = 7] = "XFALoad", e3[e3.XFALayout = 8] = "XFALayout", e3[e3.Cancelled = 9] = "Cancelled", e3[e3.Initialization = 10] = "Initialization", e3[e3.NotReady = 11] = "NotReady", e3[e3.NotSupport = 12] = "NotSupport", e3[e3.LoadDoc = 13] = "LoadDoc", e3[e3.DocNotOpen = 14] = "DocNotOpen", e3[e3.CantCloseDoc = 15] = "CantCloseDoc", e3[e3.CantCreateNewDoc = 16] = "CantCreateNewDoc", e3[e3.CantImportPages = 17] = "CantImportPages", e3[e3.CantCreateAnnot = 18] = "CantCreateAnnot", e3[e3.CantSetAnnotRect = 19] = "CantSetAnnotRect", e3[e3.CantSetAnnotContent = 20] = "CantSetAnnotContent", e3[e3.CantRemoveInkList = 21] = "CantRemoveInkList", e3[e3.CantAddInkStoke = 22] = "CantAddInkStoke", e3[e3.CantReadAttachmentSize = 23] = "CantReadAttachmentSize", e3[e3.CantReadAttachmentContent = 24] = "CantReadAttachmentContent", e3[e3.CantFocusAnnot = 25] = "CantFocusAnnot", e3[e3.CantSelectText = 26] = "CantSelectText", e3[e3.CantSelectOption = 27] = "CantSelectOption", e3[e3.CantCheckField = 28] = "CantCheckField", e3[e3.CantSetAnnotString = 29] = "CantSetAnnotString", e3))(Ht || {});
      Ut = class {
        static create() {
          return new gt();
        }
        static resolve(e3) {
          const t2 = new gt();
          return t2.resolve(e3), t2;
        }
        static reject(e3) {
          const t2 = new gt();
          return t2.reject(e3), t2;
        }
        static abort(e3) {
          const t2 = new gt();
          return t2.reject(e3), t2;
        }
      };
      Kt = Object.freeze([{ id: xt.Left, label: "Left", css: "left" }, { id: xt.Center, label: "Center", css: "center" }, { id: xt.Right, label: "Right", css: "right" }]);
      Yt = Kt.reduce((e3, t2) => (e3[t2.id] = t2, e3), {});
      Kt.reduce((e3, t2) => (e3[t2.css] = t2.id, e3), {}), Kt.map((e3) => ({ value: e3.id, label: e3.label }));
      Qt = ((e3) => (e3.Courier = "Courier", e3.Helvetica = "Helvetica", e3.Times = "Times", e3.Symbol = "Symbol", e3.ZapfDingbats = "ZapfDingbats", e3.Unknown = "Unknown", e3))(Qt || {});
      Jt = wt.Helvetica;
      en = { id: wt.Helvetica, family: "Helvetica", bold: false, italic: false, label: "Helvetica", css: "Helvetica, Arial, sans-serif" };
      tn = Object.freeze([{ id: wt.Courier, family: "Courier", bold: false, italic: false, label: "Courier", css: "Courier, monospace" }, { id: wt.Courier_Bold, family: "Courier", bold: true, italic: false, label: "Courier Bold", css: '"Courier-Bold", Courier, monospace' }, { id: wt.Courier_BoldOblique, family: "Courier", bold: true, italic: true, label: "Courier Bold Oblique", css: '"Courier-BoldOblique", Courier, monospace' }, { id: wt.Courier_Oblique, family: "Courier", bold: false, italic: true, label: "Courier Oblique", css: '"Courier-Oblique", Courier, monospace' }, en, { id: wt.Helvetica_Bold, family: "Helvetica", bold: true, italic: false, label: "Helvetica Bold", css: '"Helvetica-Bold", Arial, sans-serif' }, { id: wt.Helvetica_BoldOblique, family: "Helvetica", bold: true, italic: true, label: "Helvetica Bold Oblique", css: '"Helvetica-BoldOblique", Arial, sans-serif' }, { id: wt.Helvetica_Oblique, family: "Helvetica", bold: false, italic: true, label: "Helvetica Oblique", css: '"Helvetica-Oblique", Arial, sans-serif' }, { id: wt.Times_Roman, family: "Times", bold: false, italic: false, label: "Times Roman", css: '"Times New Roman", Times, serif' }, { id: wt.Times_Bold, family: "Times", bold: true, italic: false, label: "Times Bold", css: '"Times New Roman Bold", Times, serif' }, { id: wt.Times_BoldItalic, family: "Times", bold: true, italic: true, label: "Times Bold Italic", css: '"Times New Roman Bold Italic", Times, serif' }, { id: wt.Times_Italic, family: "Times", bold: false, italic: true, label: "Times Italic", css: '"Times New Roman Italic", Times, serif' }, { id: wt.Symbol, family: "Symbol", bold: false, italic: false, label: "Symbol", css: "Symbol" }, { id: wt.ZapfDingbats, family: "ZapfDingbats", bold: false, italic: false, label: "Zapf Dingbats", css: "ZapfDingbats" }]);
      nn = tn.reduce((e3, t2) => (e3[t2.id] = t2, e3), {});
      on = /* @__PURE__ */ new Map();
      for (const e3 of tn) on.set(`${e3.family}_${e3.bold}_${e3.italic}`, e3.id);
      Object.values(Qt).filter((e3) => "Unknown" !== e3).map((e3) => ({ value: e3, label: e3 }));
      cn = [...new Set(tn.map((e3) => e3.family))];
      un = Object.freeze([{ id: It.Normal, label: "Normal", css: "normal" }, { id: It.Multiply, label: "Multiply", css: "multiply" }, { id: It.Screen, label: "Screen", css: "screen" }, { id: It.Overlay, label: "Overlay", css: "overlay" }, { id: It.Darken, label: "Darken", css: "darken" }, { id: It.Lighten, label: "Lighten", css: "lighten" }, { id: It.ColorDodge, label: "Color Dodge", css: "color-dodge" }, { id: It.ColorBurn, label: "Color Burn", css: "color-burn" }, { id: It.HardLight, label: "Hard Light", css: "hard-light" }, { id: It.SoftLight, label: "Soft Light", css: "soft-light" }, { id: It.Difference, label: "Difference", css: "difference" }, { id: It.Exclusion, label: "Exclusion", css: "exclusion" }, { id: It.Hue, label: "Hue", css: "hue" }, { id: It.Saturation, label: "Saturation", css: "saturation" }, { id: It.Color, label: "Color", css: "color" }, { id: It.Luminosity, label: "Luminosity", css: "luminosity" }]);
      hn = un.reduce((e3, t2) => (e3[t2.id] = t2, e3), {});
      un.reduce((e3, t2) => (e3[t2.css] = t2.id, e3), {}), un.map((e3) => ({ value: e3.id, label: e3.label }));
      gn = un.map((e3) => e3.id);
      vn = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
      bn = class _bn extends gt {
        constructor(e3 = {}) {
          super(), this.children = /* @__PURE__ */ new Map(), this.childResults = [], this.completedCount = 0, this.expectedCount = 0, this.isFinalized = false, this.config = { aggregate: e3.aggregate ?? ((e4) => e4), onChildComplete: e3.onChildComplete ?? (() => {
          }), failFast: e3.failFast ?? true };
        }
        addChild(e3, t2) {
          if (this.state.stage !== ut.Pending) return this.state.stage === ut.Aborted && e3.abort(this.state.reason), this;
          const n3 = t2 ?? this.expectedCount;
          return this.expectedCount = Math.max(this.expectedCount, n3 + 1), this.children.set(e3, n3), e3.wait((t3) => this.handleChildSuccess(e3, t3, n3), (t3) => this.handleChildError(e3, t3, n3)), this;
        }
        finalize() {
          return this.isFinalized || (this.isFinalized = true, 0 === this.expectedCount && this.resolve(this.config.aggregate([]))), this;
        }
        handleChildSuccess(e3, t2, n3) {
          if (this.state.stage !== ut.Pending) return;
          this.childResults[n3] = t2, this.completedCount++, this.children.delete(e3);
          const o3 = this.config.onChildComplete(this.completedCount, this.expectedCount, t2, n3);
          if (void 0 !== o3 && this.progress(o3), this.completedCount === this.expectedCount) {
            const e4 = this.config.aggregate(this.childResults);
            this.resolve(e4);
          }
        }
        handleChildError(e3, t2, n3) {
          if (this.state.stage === ut.Pending) {
            if (this.children.delete(e3), this.config.failFast) {
              for (const [e4] of this.children) e4.abort("Sibling task failed");
              this.children.clear(), this.fail(t2);
            } else if (this.childResults[n3] = void 0, this.completedCount++, this.completedCount === this.expectedCount) {
              const e4 = this.config.aggregate(this.childResults);
              this.resolve(e4);
            }
          }
        }
        abort(e3) {
          for (const [t2] of this.children) t2.abort(e3);
          this.children.clear(), super.abort(e3);
        }
        reject(e3) {
          for (const [t2] of this.children) t2.abort(e3);
          this.children.clear(), super.reject(e3);
        }
        getPendingCount() {
          return this.children.size;
        }
        getCompletedCount() {
          return this.completedCount;
        }
        static gather(e3) {
          const t2 = new _bn({ aggregate: (e4) => e4, onChildComplete: (e4, t3) => ({ completed: e4, total: t3 }) });
          return e3.forEach((e4, n3) => t2.addChild(e4, n3)), t2.finalize(), t2;
        }
        static gatherIndexed(e3) {
          const t2 = new _bn({ aggregate: (e4) => {
            const t3 = {};
            return e4.forEach((e5, n3) => {
              t3[n3] = e5;
            }), t3;
          }, onChildComplete: (e4, t3, n3, o3) => ({ page: o3, result: n3 }) });
          return e3.forEach((e4, n3) => t2.addChild(e4, n3)), t2.finalize(), t2;
        }
        static gatherFrom(e3, t2) {
          const n3 = new _bn(t2);
          return e3.forEach((e4, t3) => n3.addChild(e4, t3)), n3.finalize(), n3;
        }
        static first(e3) {
          let t2 = false;
          const n3 = new _bn({ aggregate: (e4) => e4[0], failFast: false });
          return n3.handleChildSuccess = (e4, o3) => {
            if (!t2) {
              t2 = true;
              for (const [t3] of n3.children) t3 !== e4 && t3.abort("Race won by sibling");
              n3.resolve(o3);
            }
          }, e3.forEach((e4, t3) => n3.addChild(e4, t3)), n3.finalize(), n3;
        }
      };
      xn = class {
        constructor() {
          this.dependencyGraph = /* @__PURE__ */ new Map();
        }
        addNode(e3, t2 = []) {
          this.dependencyGraph.set(e3, new Set(t2));
        }
        hasCircularDependencies() {
          const e3 = /* @__PURE__ */ new Set(), t2 = /* @__PURE__ */ new Set(), n3 = (o3) => {
            e3.add(o3), t2.add(o3);
            const i3 = this.dependencyGraph.get(o3) || /* @__PURE__ */ new Set();
            for (const o4 of i3) if (e3.has(o4)) {
              if (t2.has(o4)) return true;
            } else if (n3(o4)) return true;
            return t2.delete(o3), false;
          };
          for (const t3 of this.dependencyGraph.keys()) if (!e3.has(t3) && n3(t3)) return true;
          return false;
        }
        resolveLoadOrder() {
          if (this.hasCircularDependencies()) throw new Error("Circular dependencies detected");
          const e3 = [], t2 = /* @__PURE__ */ new Set(), n3 = /* @__PURE__ */ new Set(), o3 = (i3) => {
            if (n3.has(i3)) throw new Error("Circular dependency");
            if (t2.has(i3)) return;
            n3.add(i3);
            const r2 = this.dependencyGraph.get(i3) || /* @__PURE__ */ new Set();
            for (const e4 of r2) o3(e4);
            n3.delete(i3), t2.add(i3), e3.push(i3);
          };
          for (const e4 of this.dependencyGraph.keys()) t2.has(e4) || o3(e4);
          return e3;
        }
      };
      Cn = class extends Error {
        constructor(e3) {
          super(e3), this.name = "PluginRegistrationError";
        }
      };
      In = class extends Error {
        constructor(e3) {
          super(e3), this.name = "PluginNotFoundError";
        }
      };
      Sn = class extends Error {
        constructor(e3) {
          super(e3), this.name = "CircularDependencyError";
        }
      };
      kn = class extends Error {
        constructor(e3) {
          super(e3), this.name = "PluginConfigurationError";
        }
      };
      Dn = class {
        constructor(e3, t2) {
          this.store = e3, this.pluginId = t2;
        }
        getState() {
          return this.store.getState().plugins[this.pluginId];
        }
        dispatch(e3) {
          return this.store.dispatchToPlugin(this.pluginId, e3);
        }
        subscribeToState(e3) {
          return this.store.subscribeToPlugin(this.pluginId, (t2, n3, o3) => {
            e3(t2, n3, o3);
          });
        }
        onAction(e3, t2) {
          return this.store.onAction(e3, (e4, n3, o3) => {
            t2(e4, n3.plugins[this.pluginId], o3.plugins[this.pluginId]);
          });
        }
      };
      Mn = "START_LOADING_DOCUMENT";
      Pn = "UPDATE_DOCUMENT_LOADING_PROGRESS";
      An = "SET_DOCUMENT_LOADED";
      Tn = "SET_DOCUMENT_ERROR";
      zn = "RETRY_LOADING_DOCUMENT";
      En = "CLOSE_DOCUMENT";
      _n = "SET_ACTIVE_DOCUMENT";
      Rn = "REORDER_DOCUMENTS";
      Nn = "MOVE_DOCUMENT";
      On = "REFRESH_PAGES";
      Ln = "SET_SCALE";
      $n = "SET_ROTATION";
      Fn = [Mn, Pn, An, En, _n, Tn, zn, "REFRESH_DOCUMENT", On, "SET_PAGES", Ln, $n, "SET_DEFAULT_SCALE", "SET_DEFAULT_ROTATION", Rn, Nn];
      jn = (e3, t2, n3, o3, i3, r2) => ({ type: Mn, payload: { documentId: e3, name: t2, scale: n3, rotation: o3, passwordProvided: i3, autoActivate: r2 } });
      Hn = (e3, t2) => ({ type: En, payload: { documentId: e3, nextActiveDocumentId: t2 } });
      Un = (e3, t2) => ({ type: On, payload: { documentId: e3, pageIndexes: t2 } });
      Wn = (e3, t2) => ({ type: $n, payload: { rotation: e3, documentId: t2 } });
      Bn = class {
        constructor(e3, t2) {
          this.initialCoreState = t2, this.pluginReducers = {}, this.listeners = [], this.pluginListeners = {}, this.isDispatching = false, this.state = { core: t2, plugins: {} }, this.coreReducer = e3;
        }
        addPluginReducer(e3, t2, n3) {
          this.state.plugins[e3] = n3, this.pluginReducers[e3] = t2;
        }
        dispatchToCore(e3) {
          if (!this.coreReducer) return this.getState();
          if (this.isDispatching) throw new Error("Reducers may not dispatch actions. To trigger cascading actions, dispatch from a listener callback instead.");
          const t2 = this.getState();
          try {
            this.isDispatching = true, this.state.core = this.coreReducer(this.state.core, e3);
          } finally {
            this.isDispatching = false;
          }
          return this.listeners.forEach((n3) => {
            const o3 = this.getState();
            n3(e3, o3, t2);
          }), this.getState();
        }
        dispatchToPlugin(e3, t2, n3 = true) {
          if (this.isDispatching) throw new Error("Reducers may not dispatch actions. To trigger cascading actions, dispatch from a listener callback instead.");
          const o3 = this.getState(), i3 = this.pluginReducers[e3];
          if (!i3) return o3.plugins[e3];
          const r2 = o3.plugins[e3];
          try {
            this.isDispatching = true;
            const n4 = i3(r2, t2);
            this.state.plugins[e3] = n4;
          } finally {
            this.isDispatching = false;
          }
          return n3 && this.listeners.forEach((e4) => {
            const n4 = this.getState();
            e4(t2, n4, o3);
          }), this.pluginListeners[e3] && this.pluginListeners[e3].forEach((n4) => {
            const o4 = this.getState().plugins[e3];
            n4(t2, o4, r2);
          }), this.getState().plugins[e3];
        }
        dispatch(e3) {
          if (this.isDispatching) throw new Error("Reducers may not dispatch actions. To trigger cascading actions, dispatch from a listener callback instead.");
          const t2 = this.getState();
          try {
            this.isDispatching = true, this.isCoreAction(e3) && (this.state.core = this.coreReducer(this.state.core, e3));
            for (const n3 in this.pluginReducers) {
              const o3 = this.pluginReducers[n3], i3 = t2.plugins[n3];
              o3 && (this.state.plugins[n3] = o3(i3, e3));
            }
          } finally {
            this.isDispatching = false;
          }
          return this.listeners.forEach((n3) => {
            const o3 = this.getState();
            n3(e3, o3, t2);
          }), this.getState();
        }
        getState() {
          if (this.isDispatching) throw new Error("You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
          return { core: { ...this.state.core }, plugins: { ...this.state.plugins } };
        }
        subscribe(e3) {
          if (this.isDispatching) throw new Error("You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state.");
          return this.listeners.push(e3), () => {
            if (this.isDispatching) throw new Error("You may not unsubscribe from a store listener while the reducer is executing.");
            this.listeners = this.listeners.filter((t2) => t2 !== e3);
          };
        }
        subscribeToPlugin(e3, t2) {
          if (!(e3 in this.state.plugins)) throw new Error(`Plugin state not found for plugin "${e3}". Did you forget to call addPluginReducer?`);
          if (this.isDispatching) throw new Error("You may not call store.subscribeToPlugin() while the reducer is executing.");
          return this.pluginListeners[e3] || (this.pluginListeners[e3] = []), this.pluginListeners[e3].push(t2), () => {
            if (this.isDispatching) throw new Error("You may not unsubscribe from a store listener while the reducer is executing.");
            this.pluginListeners[e3] = this.pluginListeners[e3].filter((e4) => e4 !== t2), 0 === this.pluginListeners[e3].length && delete this.pluginListeners[e3];
          };
        }
        onAction(e3, t2) {
          return this.subscribe((n3, o3, i3) => {
            n3.type === e3 && t2(n3, o3, i3);
          });
        }
        getPluginStore(e3) {
          if (!(e3 in this.state.plugins)) throw new Error(`Plugin state not found for plugin "${e3}". Did you forget to call addPluginReducer?`);
          return new Dn(this, e3);
        }
        isCoreAction(e3) {
          return Fn.includes(e3.type);
        }
        destroy() {
          var e3, t2;
          this.listeners.length = 0;
          for (const n3 in this.pluginListeners) null == (t2 = null == (e3 = this.pluginListeners[n3]) ? void 0 : e3.splice) || t2.call(e3, 0);
          this.pluginListeners = {}, this.pluginReducers = {}, this.state.plugins = {}, this.state.core = { ...this.initialCoreState };
        }
      };
      Gn = (e3, t2) => {
        switch (t2.type) {
          case Mn: {
            const { documentId: n3, name: o3, scale: i3, rotation: r2, passwordProvided: a3, autoActivate: s4 = true } = t2.payload, l4 = { id: n3, name: o3, status: "loading", loadingProgress: 0, error: null, document: null, scale: i3 ?? e3.defaultScale, rotation: r2 ?? e3.defaultRotation, passwordProvided: a3 ?? false, pageRefreshVersions: {}, loadStartedAt: Date.now() };
            return { ...e3, documents: { ...e3.documents, [n3]: l4 }, documentOrder: [...e3.documentOrder, n3], activeDocumentId: s4 || !e3.activeDocumentId ? n3 : e3.activeDocumentId };
          }
          case Pn: {
            const { documentId: n3, progress: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 && "loading" === i3.status ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, loadingProgress: o3 } } } : e3;
          }
          case An: {
            const { documentId: n3, document: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, status: "loaded", document: o3, error: null, errorCode: void 0, errorDetails: void 0, passwordProvided: void 0, loadedAt: Date.now() } } } : e3;
          }
          case Tn: {
            const { documentId: n3, error: o3, errorCode: i3, errorDetails: r2 } = t2.payload, a3 = e3.documents[n3];
            return a3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...a3, status: "error", error: o3, errorCode: i3, errorDetails: r2 } } } : e3;
          }
          case zn: {
            const { documentId: n3, passwordProvided: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 && "error" === i3.status ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, status: "loading", loadingProgress: 0, error: null, errorCode: void 0, errorDetails: void 0, passwordProvided: o3 ?? false, loadStartedAt: Date.now() } } } : e3;
          }
          case En: {
            const { documentId: n3, nextActiveDocumentId: o3 } = t2.payload, { [n3]: i3, ...r2 } = e3.documents;
            return { ...e3, documents: r2, documentOrder: e3.documentOrder.filter((e4) => e4 !== n3), activeDocumentId: qn(e3, n3, o3) };
          }
          case Nn: {
            const { documentId: n3, toIndex: o3 } = t2.payload, i3 = (function(e4, t3, n4) {
              const o4 = e4.indexOf(t3);
              if (-1 === o4) return null;
              if (n4 < 0 || n4 >= e4.length) return null;
              if (o4 === n4) return null;
              const i4 = [...e4];
              return i4.splice(o4, 1), i4.splice(n4, 0, t3), i4;
            })(e3.documentOrder, n3, o3);
            return i3 ? { ...e3, documentOrder: i3 } : e3;
          }
          case Rn:
            return { ...e3, documentOrder: t2.payload };
          case _n:
            return { ...e3, activeDocumentId: t2.payload };
          case Ln: {
            const { scale: n3, documentId: o3 } = t2.payload, i3 = o3 ?? e3.activeDocumentId;
            if (!i3) return e3;
            const r2 = e3.documents[i3];
            return r2 ? { ...e3, documents: { ...e3.documents, [i3]: { ...r2, scale: n3 } } } : e3;
          }
          case $n: {
            const { rotation: n3, documentId: o3 } = t2.payload, i3 = o3 ?? e3.activeDocumentId;
            if (!i3) return e3;
            const r2 = e3.documents[i3];
            return r2 ? { ...e3, documents: { ...e3.documents, [i3]: { ...r2, rotation: n3 } } } : e3;
          }
          case On: {
            const { documentId: n3, pageIndexes: o3 } = t2.payload, i3 = e3.documents[n3];
            if (!i3) return e3;
            const r2 = { ...i3.pageRefreshVersions };
            for (const e4 of o3) r2[e4] = (r2[e4] || 0) + 1;
            return { ...e3, documents: { ...e3.documents, [n3]: { ...i3, pageRefreshVersions: r2 } } };
          }
          default:
            return e3;
        }
      };
      Vn = class {
        constructor(e3, t2) {
          this.plugins = /* @__PURE__ */ new Map(), this.manifests = /* @__PURE__ */ new Map(), this.capabilities = /* @__PURE__ */ new Map(), this.status = /* @__PURE__ */ new Map(), this.configurations = /* @__PURE__ */ new Map(), this.initPromise = null, this.pendingRegistrations = [], this.processingRegistrations = [], this.initialized = false, this.isInitializing = false, this.pluginsReadyPromise = null, this.destroyed = false, this.resolver = new xn(), this.engine = e3, this.initialCoreState = ((e4) => ({ documents: {}, documentOrder: [], activeDocumentId: null, defaultScale: (null == e4 ? void 0 : e4.defaultScale) ?? 1, defaultRotation: (null == e4 ? void 0 : e4.defaultRotation) ?? We.Degree0 }))(t2), this.store = new Bn(Gn, this.initialCoreState), this.logger = (null == t2 ? void 0 : t2.logger) ?? new at();
        }
        getLogger() {
          return this.logger;
        }
        registerPlugin(e3, t2) {
          if (this.initialized && !this.isInitializing) throw new Cn("Cannot register plugins after initialization");
          this.validateManifest(e3.manifest), this.store.addPluginReducer(e3.manifest.id, e3.reducer, "function" == typeof e3.initialState ? e3.initialState(this.initialCoreState, { ...e3.manifest.defaultConfig, ...t2 }) : e3.initialState), this.pendingRegistrations.push({ package: e3, config: t2 });
        }
        getStore() {
          return this.store;
        }
        getEngine() {
          return this.engine;
        }
        pluginsReady() {
          return this.pluginsReadyPromise || (this.pluginsReadyPromise = (async () => {
            this.initialized || await this.initialize();
            const e3 = Array.from(this.plugins.values()).map((e4) => "function" == typeof e4.ready ? e4.ready() : Promise.resolve());
            await Promise.all(e3);
          })()), this.pluginsReadyPromise;
        }
        async initialize() {
          if (this.destroyed) throw new Cn("Registry has been destroyed");
          return this.initPromise || (this.initPromise = (async () => {
            if (this.initialized) throw new Cn("Registry is already initialized");
            this.isInitializing = true;
            try {
              if (this.destroyed) return;
              for (; this.pendingRegistrations.length > 0; ) {
                if (this.destroyed) return;
                this.processingRegistrations = [...this.pendingRegistrations], this.pendingRegistrations = [];
                for (const e4 of this.processingRegistrations) {
                  const t2 = /* @__PURE__ */ new Set(), n3 = [...e4.package.manifest.requires, ...e4.package.manifest.optional];
                  for (const e5 of n3) {
                    const n4 = this.processingRegistrations.find((t3) => t3.package.manifest.provides.includes(e5));
                    n4 && t2.add(n4.package.manifest.id);
                  }
                  this.resolver.addNode(e4.package.manifest.id, [...t2]);
                }
                const e3 = this.resolver.resolveLoadOrder();
                for (const t2 of e3) {
                  const e4 = this.processingRegistrations.find((e5) => e5.package.manifest.id === t2);
                  this.instantiatePlugin(e4.package.manifest, e4.package.create, e4.config);
                }
                for (const t2 of e3) await this.runPluginInitialization(t2);
                this.processingRegistrations = [], this.resolver = new xn();
              }
              this.initialized = true;
            } catch (e3) {
              if (e3 instanceof Error) throw new Sn(`Failed to resolve plugin dependencies: ${e3.message}`);
              throw e3;
            } finally {
              this.isInitializing = false;
            }
          })()), this.initPromise;
        }
        instantiatePlugin(e3, t2, n3) {
          const o3 = { ...e3.defaultConfig, ...n3 };
          this.validateConfig(e3.id, o3, e3.defaultConfig);
          const i3 = t2(this, o3);
          this.validatePlugin(i3);
          for (const t3 of e3.provides) {
            if (this.capabilities.has(t3)) throw new Cn(`Capability ${t3} is already provided by plugin ${this.capabilities.get(t3)}`);
            this.capabilities.set(t3, e3.id);
          }
          this.plugins.set(e3.id, i3), this.manifests.set(e3.id, e3), this.status.set(e3.id, "registered"), this.configurations.set(e3.id, o3);
        }
        async runPluginInitialization(e3) {
          const t2 = this.plugins.get(e3);
          if (!t2) return;
          const n3 = this.manifests.get(e3), o3 = this.configurations.get(e3);
          for (const t3 of n3.requires) if (!this.capabilities.has(t3)) throw new Cn(`Missing required capability: ${t3} for plugin ${e3}`);
          this.logger.debug("PluginRegistry", "InitializePlugin", `Initializing plugin ${e3}`);
          try {
            t2.initialize && await t2.initialize(o3), this.status.set(e3, "active"), this.logger.info("PluginRegistry", "PluginInitialized", `Plugin ${e3} initialized successfully`);
          } catch (t3) {
            throw this.status.set(e3, "error"), this.logger.error("PluginRegistry", "InitializationFailed", `Plugin ${e3} initialization failed`, { error: t3 }), t3;
          }
        }
        getPluginConfig(e3) {
          const t2 = this.configurations.get(e3);
          if (!t2) throw new In(`Configuration for plugin ${e3} not found`);
          return t2;
        }
        validateConfig(e3, t2, n3) {
          const o3 = Object.keys(n3).filter((e4) => !t2.hasOwnProperty(e4));
          if (o3.length > 0) throw new kn(`Missing required configuration keys for plugin ${e3}: ${o3.join(", ")}`);
        }
        async updatePluginConfig(e3, t2) {
          const n3 = this.getPlugin(e3);
          if (!n3) throw new In(`Plugin ${e3} not found`);
          const o3 = this.manifests.get(e3), i3 = this.configurations.get(e3);
          if (!o3 || !i3) throw new In(`Plugin ${e3} not found`);
          const r2 = { ...i3, ...t2 };
          this.validateConfig(e3, r2, o3.defaultConfig), this.configurations.set(e3, r2), n3.initialize && await n3.initialize(r2);
        }
        registerPluginBatch(e3) {
          for (const t2 of e3) this.registerPlugin(t2.package, t2.config);
        }
        async unregisterPlugin(e3) {
          const t2 = this.plugins.get(e3);
          if (!t2) throw new In(`Plugin ${e3} is not registered`);
          const n3 = this.manifests.get(e3);
          if (!n3) throw new In(`Manifest for plugin ${e3} not found`);
          for (const [t3, o3] of this.manifests.entries()) {
            if (t3 === e3) continue;
            if ([...o3.requires, ...o3.optional].some((e4) => n3.provides.includes(e4))) throw new Cn(`Cannot unregister plugin ${e3}: plugin ${t3} depends on it`);
          }
          try {
            t2.destroy && await t2.destroy();
            for (const e4 of n3.provides) this.capabilities.delete(e4);
            this.plugins.delete(e3), this.manifests.delete(e3), this.status.delete(e3);
          } catch (t3) {
            if (t3 instanceof Error) throw new Error(`Failed to unregister plugin ${e3}: ${t3.message}`);
            throw t3;
          }
        }
        getPlugin(e3) {
          const t2 = this.plugins.get(e3);
          return t2 || null;
        }
        getCapabilityProvider(e3) {
          const t2 = this.capabilities.get(e3);
          return t2 ? this.getPlugin(t2) : null;
        }
        hasCapability(e3) {
          return this.capabilities.has(e3);
        }
        getAllPlugins() {
          return Array.from(this.plugins.values());
        }
        getPluginStatus(e3) {
          const t2 = this.status.get(e3);
          if (!t2) throw new In(`Plugin ${e3} not found`);
          return t2;
        }
        validatePlugin(e3) {
          if (!e3.id) throw new Cn("Plugin must have an id");
        }
        validateManifest(e3) {
          if (!e3.id) throw new Cn("Manifest must have an id");
          if (!e3.name) throw new Cn("Manifest must have a name");
          if (!e3.version) throw new Cn("Manifest must have a version");
          if (!Array.isArray(e3.provides)) throw new Cn("Manifest must have a provides array");
          if (!Array.isArray(e3.requires)) throw new Cn("Manifest must have a requires array");
          if (!Array.isArray(e3.optional)) throw new Cn("Manifest must have an optional array");
        }
        isDestroyed() {
          return this.destroyed;
        }
        async destroy() {
          var e3;
          if (this.destroyed) throw new Cn("Registry has already been destroyed");
          this.destroyed = true;
          try {
            await this.initPromise;
          } catch {
          }
          for (const t2 of Array.from(this.plugins.values()).reverse()) await (null == (e3 = t2.destroy) ? void 0 : e3.call(t2));
          this.store.destroy(), this.plugins.clear(), this.manifests.clear(), this.capabilities.clear(), this.status.clear(), this.pendingRegistrations.length = 0, this.processingRegistrations.length = 0;
        }
      };
      Yn = class {
        constructor(e3, t2) {
          if (this.id = e3, this.registry = t2, this.cooldownActions = {}, this.debouncedTimeouts = {}, this.unsubscribeFromState = null, this.unsubscribeFromCoreStore = null, this.unsubscribeFromStartLoadingDocument = null, this.unsubscribeFromSetDocumentLoaded = null, this.unsubscribeFromCloseDocument = null, this.unsubscribeFromSetScale = null, this.unsubscribeFromSetRotation = null, e3 !== this.constructor.id) throw new Error(`Plugin ID mismatch: ${e3} !== ${this.constructor.id}`);
          this.engine = this.registry.getEngine(), this.logger = this.registry.getLogger(), this.coreStore = this.registry.getStore(), this.pluginStore = this.coreStore.getPluginStore(this.id), this.unsubscribeFromState = this.pluginStore.subscribeToState((e4, t3, n3) => {
            this.onStoreUpdated(n3, t3);
          }), this.unsubscribeFromCoreStore = this.coreStore.subscribe((e4, t3, n3) => {
            this.onCoreStoreUpdated(n3, t3), t3.core.activeDocumentId !== n3.core.activeDocumentId && this.onActiveDocumentChanged(n3.core.activeDocumentId, t3.core.activeDocumentId);
          }), this.unsubscribeFromStartLoadingDocument = this.coreStore.onAction(Mn, (e4) => {
            this.onDocumentLoadingStarted(e4.payload.documentId);
          }), this.unsubscribeFromSetDocumentLoaded = this.coreStore.onAction(An, (e4) => {
            this.onDocumentLoaded(e4.payload.documentId);
          }), this.unsubscribeFromCloseDocument = this.coreStore.onAction(En, (e4) => {
            this.onDocumentClosed(e4.payload.documentId);
          }), this.unsubscribeFromSetScale = this.coreStore.onAction(Ln, (e4, t3) => {
            const n3 = e4.payload.documentId ?? t3.core.activeDocumentId;
            n3 && this.onScaleChanged(n3, e4.payload.scale);
          }), this.unsubscribeFromSetRotation = this.coreStore.onAction($n, (e4, t3) => {
            const n3 = e4.payload.documentId ?? t3.core.activeDocumentId;
            n3 && this.onRotationChanged(n3, e4.payload.rotation);
          }), this.readyPromise = new Promise((e4) => {
            this.readyResolve = e4;
          }), this.readyResolve();
        }
        provides() {
          if (!this._capability) {
            const e3 = this.buildCapability();
            this._capability = Object.freeze(e3);
          }
          return this._capability;
        }
        get state() {
          return this.pluginStore.getState();
        }
        get coreState() {
          return this.coreStore.getState();
        }
        getState() {
          return this.pluginStore.getState();
        }
        getCoreState() {
          return this.coreStore.getState();
        }
        dispatchCoreAction(e3) {
          return this.coreStore.dispatchToCore(e3);
        }
        dispatchToAllPlugins(e3) {
          return this.coreStore.dispatch(e3);
        }
        dispatch(e3) {
          return this.pluginStore.dispatch(e3);
        }
        cooldownDispatch(e3, t2 = 100) {
          const n3 = Date.now();
          return n3 - (this.cooldownActions[e3.type] || 0) >= t2 && (this.cooldownActions[e3.type] = n3, this.dispatch(e3), true);
        }
        debouncedDispatch(e3, t2 = 100) {
          const n3 = e3.type;
          this.debouncedTimeouts[n3] && clearTimeout(this.debouncedTimeouts[n3]), this.debouncedTimeouts[n3] = setTimeout(() => {
            this.dispatch(e3), delete this.debouncedTimeouts[n3];
          }, t2);
        }
        cancelDebouncedDispatch(e3) {
          this.debouncedTimeouts[e3] && (clearTimeout(this.debouncedTimeouts[e3]), delete this.debouncedTimeouts[e3]);
        }
        subscribe(e3) {
          return this.pluginStore.subscribeToState(e3);
        }
        subscribeToCoreStore(e3) {
          return this.coreStore.subscribe(e3);
        }
        onStoreUpdated(e3, t2) {
        }
        onCoreStoreUpdated(e3, t2) {
        }
        onDocumentLoadingStarted(e3) {
        }
        onDocumentLoaded(e3) {
        }
        onDocumentClosed(e3) {
        }
        onActiveDocumentChanged(e3, t2) {
        }
        onScaleChanged(e3, t2) {
        }
        onRotationChanged(e3, t2) {
        }
        destroy() {
          Object.values(this.debouncedTimeouts).forEach((e3) => {
            clearTimeout(e3);
          }), this.debouncedTimeouts = {}, this.unsubscribeFromState && (this.unsubscribeFromState(), this.unsubscribeFromState = null), this.unsubscribeFromCoreStore && (this.unsubscribeFromCoreStore(), this.unsubscribeFromCoreStore = null), this.unsubscribeFromStartLoadingDocument && (this.unsubscribeFromStartLoadingDocument(), this.unsubscribeFromStartLoadingDocument = null), this.unsubscribeFromSetDocumentLoaded && (this.unsubscribeFromSetDocumentLoaded(), this.unsubscribeFromSetDocumentLoaded = null), this.unsubscribeFromCloseDocument && (this.unsubscribeFromCloseDocument(), this.unsubscribeFromCloseDocument = null), this.unsubscribeFromSetScale && (this.unsubscribeFromSetScale(), this.unsubscribeFromSetScale = null), this.unsubscribeFromSetRotation && (this.unsubscribeFromSetRotation(), this.unsubscribeFromSetRotation = null);
        }
        ready() {
          return this.readyPromise;
        }
        markReady() {
          this.readyResolve();
        }
        resetReady() {
          this.readyPromise = new Promise((e3) => {
            this.readyResolve = e3;
          });
        }
        getActiveDocumentId() {
          const e3 = this.coreState.core.activeDocumentId;
          if (!e3) throw new Error("No active document");
          return e3;
        }
        getActiveDocumentIdOrNull() {
          return this.coreState.core.activeDocumentId;
        }
        getCoreDocument(e3) {
          const t2 = e3 ?? this.getActiveDocumentIdOrNull();
          return t2 ? this.coreState.core.documents[t2] ?? null : null;
        }
        getCoreDocumentOrThrow(e3) {
          const t2 = this.getCoreDocument(e3);
          if (!t2) throw new Error(`Document not found: ${e3 ?? "active"}`);
          return t2;
        }
      };
      Xn = class {
        constructor(e3, t2) {
          this.handler = e3, this.options = t2, this.lastRun = 0, this.handle = (e4) => {
            "debounce" === this.options.mode ? this.debounce(e4) : this.throttle(e4);
          };
        }
        debounce(e3) {
          this.timeoutId && window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => {
            this.handler(e3), this.timeoutId = void 0;
          }, this.options.wait);
        }
        throttle(e3) {
          if ("debounce" === this.options.mode) return;
          const t2 = Date.now(), n3 = this.options.throttleMode || "leading-trailing";
          t2 - this.lastRun >= this.options.wait && ("leading-trailing" === n3 && this.handler(e3), this.lastRun = t2), this.timeoutId && window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => {
            this.handler(e3), this.lastRun = Date.now(), this.timeoutId = void 0;
          }, this.options.wait - (t2 - this.lastRun));
        }
        destroy() {
          this.timeoutId && window.clearTimeout(this.timeoutId);
        }
      };
      Qn = class {
        constructor(e3, t2) {
          this.handler = e3, this.options = t2, this.controls = /* @__PURE__ */ new Map(), this.handle = (e4) => {
            const t3 = String(this.options.keyExtractor(e4));
            let n3 = this.controls.get(t3);
            n3 || (n3 = new Xn(this.handler, this.baseOptions), this.controls.set(t3, n3)), n3.handle(e4);
          }, this.baseOptions = { mode: t2.mode, wait: t2.wait, ..."throttle" === t2.mode && "throttleMode" in t2 ? { throttleMode: t2.throttleMode } : {} };
        }
        destroy() {
          for (const e3 of this.controls.values()) e3.destroy();
          this.controls.clear();
        }
      };
      no = 0;
      oo = /* @__PURE__ */ new WeakMap();
      lo = class {
        constructor(e3) {
          this.autoMountElements = [], this.package = e3;
        }
        addUtility(e3) {
          return this.autoMountElements.push({ component: e3, type: "utility" }), this;
        }
        addWrapper(e3) {
          return this.autoMountElements.push({ component: e3, type: "wrapper" }), this;
        }
        build() {
          return { ...this.package, autoMountElements: () => this.autoMountElements };
        }
      };
      uo = de({ registry: null, coreState: null, isInitializing: true, pluginsReady: false, activeDocumentId: null, activeDocument: null, documents: {}, documentStates: [] });
      yo = "https://cdn.jsdelivr.net/npm/@embedpdf/pdfium@2.1.1/dist/pdfium.wasm";
      de(void 0);
      bo = "viewport";
      wo = { id: bo, name: "Viewport Plugin", version: "1.0.0", provides: ["viewport"], requires: [], optional: [], defaultConfig: { viewportGap: 10, scrollEndDelay: 300 } };
      xo = "INIT_VIEWPORT_STATE";
      Co = "CLEANUP_VIEWPORT_STATE";
      Io = "REGISTER_VIEWPORT";
      So = "UNREGISTER_VIEWPORT";
      ko = "SET_VIEWPORT_METRICS";
      Do = "SET_VIEWPORT_SCROLL_METRICS";
      Mo = "SET_VIEWPORT_GAP";
      Po = "SET_SCROLL_ACTIVITY";
      Ao = "SET_SMOOTH_SCROLL_ACTIVITY";
      To = "ADD_VIEWPORT_GATE";
      zo = "REMOVE_VIEWPORT_GATE";
      _o = { viewportMetrics: { width: 0, height: 0, scrollTop: 0, scrollLeft: 0, clientWidth: 0, clientHeight: 0, scrollWidth: 0, scrollHeight: 0, clientLeft: 0, clientTop: 0, relativePosition: { x: 0, y: 0 } }, isScrolling: false, isSmoothScrolling: false, gates: /* @__PURE__ */ new Set() };
      Ro = { viewportGap: 0, documents: {}, activeViewports: /* @__PURE__ */ new Set(), activeDocumentId: null };
      No = class extends Yn {
        constructor(e3, t2, n3) {
          var o3;
          super(e3, t2), this.id = e3, this.viewportResize$ = ao(), this.viewportMetrics$ = ao(), this.scrollMetrics$ = ao(), this.scrollActivity$ = ao(), this.gateState$ = ao(), this.scrollRequests$ = /* @__PURE__ */ new Map(), n3.viewportGap && this.dispatch((o3 = n3.viewportGap, { type: Mo, payload: o3 })), this.scrollEndDelay = n3.scrollEndDelay || 100;
        }
        onDocumentLoadingStarted(e3) {
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: xo, payload: { documentId: e4 } };
          })(e3)), this.scrollRequests$.set(e3, ro()), this.logger.debug("ViewportPlugin", "DocumentOpened", `Initialized viewport state for document: ${e3}`);
        }
        onDocumentClosed(e3) {
          var t2;
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: Co, payload: { documentId: e4 } };
          })(e3)), null == (t2 = this.scrollRequests$.get(e3)) || t2.clear(), this.scrollRequests$.delete(e3), this.logger.debug("ViewportPlugin", "DocumentClosed", `Cleaned up viewport state for document: ${e3}`);
        }
        buildCapability() {
          return { getViewportGap: () => this.state.viewportGap, getMetrics: () => this.getMetrics(), scrollTo: (e3) => this.scrollTo(e3), isScrolling: () => this.isScrolling(), isSmoothScrolling: () => this.isSmoothScrolling(), isGated: (e3) => this.isGated(e3), hasGate: (e3, t2) => this.hasGate(e3, t2), getGates: (e3) => this.getGates(e3), forDocument: (e3) => this.createViewportScope(e3), gate: (e3, t2) => this.gate(e3, t2), releaseGate: (e3, t2) => this.releaseGate(e3, t2), isViewportMounted: (e3) => this.state.activeViewports.has(e3), onViewportChange: this.viewportMetrics$.on, onViewportResize: this.viewportResize$.on, onScrollChange: this.scrollMetrics$.on, onScrollActivity: this.scrollActivity$.on, onGateChange: this.gateState$.on };
        }
        createViewportScope(e3) {
          return { getMetrics: () => this.getMetrics(e3), scrollTo: (t2) => this.scrollTo(t2, e3), isScrolling: () => this.isScrolling(e3), isSmoothScrolling: () => this.isSmoothScrolling(e3), isGated: () => this.isGated(e3), hasGate: (t2) => this.hasGate(t2, e3), getGates: () => this.getGates(e3), gate: (t2) => this.gate(t2, e3), releaseGate: (t2) => this.releaseGate(t2, e3), onViewportChange: (t2) => this.viewportMetrics$.on((n3) => {
            n3.documentId === e3 && t2(n3.metrics);
          }), onScrollChange: (t2) => this.scrollMetrics$.on((n3) => {
            n3.documentId === e3 && t2(n3.scrollMetrics);
          }), onScrollActivity: (t2) => this.scrollActivity$.on((n3) => {
            n3.documentId === e3 && t2(n3.activity);
          }), onGateChange: (t2) => this.gateState$.on((n3) => {
            (null == n3 ? void 0 : n3.documentId) === e3 && t2(n3);
          }) };
        }
        registerViewport(e3) {
          if (!this.state.documents[e3]) throw new Error(`Cannot register viewport for ${e3}: document state not found. Document must be opened before registering viewport.`);
          this.state.activeViewports.has(e3) || (this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: Io, payload: { documentId: e4 } };
          })(e3)), this.logger.debug("ViewportPlugin", "RegisterViewport", `Registered viewport (DOM mounted) for document: ${e3}`));
        }
        unregisterViewport(e3) {
          this.registry.isDestroyed() || this.state.activeViewports.has(e3) && (this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: So, payload: { documentId: e4 } };
          })(e3)), this.logger.debug("ViewportPlugin", "UnregisterViewport", `Unregistered viewport (DOM unmounted) for document: ${e3}. State preserved.`));
        }
        setViewportResizeMetrics(e3, t2) {
          if (this.registry.isDestroyed()) return;
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: ko, payload: { documentId: e4, metrics: t3 } };
          })(e3, t2));
          const n3 = this.state.documents[e3];
          n3 && this.viewportResize$.emit({ documentId: e3, metrics: n3.viewportMetrics });
        }
        setViewportScrollMetrics(e3, t2) {
          if (this.registry.isDestroyed()) return;
          const n3 = this.state.documents[e3];
          n3 && (t2.scrollTop === n3.viewportMetrics.scrollTop && t2.scrollLeft === n3.viewportMetrics.scrollLeft || (this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Do, payload: { documentId: e4, scrollMetrics: t3 } };
          })(e3, t2)), this.bumpScrollActivity(e3), this.scrollMetrics$.emit({ documentId: e3, scrollMetrics: t2 })));
        }
        onScrollRequest(e3, t2) {
          const n3 = this.scrollRequests$.get(e3);
          if (!n3) throw new Error(`Cannot subscribe to scroll requests for ${e3}: document state not initialized`);
          return n3.on(t2);
        }
        gate(e3, t2) {
          const n3 = this.state.documents[t2];
          n3 ? n3.gates.has(e3) || (this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: To, payload: { documentId: e4, key: t3 } };
          })(t2, e3)), this.logger.debug("ViewportPlugin", "GateAdded", `Added gate '${e3}' for document: ${t2}. Total gates: ${n3.gates.size + 1}`)) : this.logger.warn("ViewportPlugin", "GateViewport", `Cannot gate viewport for ${t2}: document not found`);
        }
        releaseGate(e3, t2) {
          const n3 = this.state.documents[t2];
          n3 ? n3.gates.has(e3) && (this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: zo, payload: { documentId: e4, key: t3 } };
          })(t2, e3)), this.logger.debug("ViewportPlugin", "GateReleased", `Released gate '${e3}' for document: ${t2}. Remaining gates: ${n3.gates.size - 1}`)) : this.logger.warn("ViewportPlugin", "ReleaseGate", `Cannot release gate for ${t2}: document not found`);
        }
        getViewportState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.state.documents[t2];
          if (!n3) throw new Error(`Viewport state not found for document: ${t2}`);
          return n3;
        }
        getMetrics(e3) {
          return this.getViewportState(e3).viewportMetrics;
        }
        isScrolling(e3) {
          return this.getViewportState(e3).isScrolling;
        }
        isSmoothScrolling(e3) {
          return this.getViewportState(e3).isSmoothScrolling;
        }
        isGated(e3) {
          return this.getViewportState(e3).gates.size > 0;
        }
        hasGate(e3, t2) {
          return this.getViewportState(t2).gates.has(e3);
        }
        getGates(e3) {
          const t2 = this.getViewportState(e3);
          return Array.from(t2.gates);
        }
        scrollTo(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = this.getViewportState(n3), { x: i3, y: r2, alignX: a3, alignY: s4, behavior: l4 = "auto" } = e3;
          "smooth" === l4 && this.dispatch(Eo(n3, true));
          const c4 = o3.viewportMetrics;
          let d4 = i3, u4 = r2;
          void 0 !== a3 && (d4 = i3 - c4.clientWidth * (a3 / 100)), void 0 !== s4 && (u4 = r2 - c4.clientHeight * (s4 / 100));
          const h3 = this.scrollRequests$.get(n3);
          h3 && h3.emit({ x: d4, y: u4, behavior: l4 });
        }
        bumpScrollActivity(e3) {
          this.debouncedDispatch(/* @__PURE__ */ (function(e4, t2) {
            return { type: Po, payload: { documentId: e4, isScrolling: t2 } };
          })(e3, false), this.scrollEndDelay), this.debouncedDispatch(Eo(e3, false), this.scrollEndDelay);
        }
        onStoreUpdated(e3, t2) {
          for (const n3 in t2.documents) {
            const o3 = e3.documents[n3], i3 = t2.documents[n3];
            if (o3 !== i3 && (this.viewportMetrics$.emit({ documentId: n3, metrics: i3.viewportMetrics }), !o3 || o3.isScrolling === i3.isScrolling && o3.isSmoothScrolling === i3.isSmoothScrolling || this.scrollActivity$.emit({ documentId: n3, activity: { isScrolling: i3.isScrolling, isSmoothScrolling: i3.isSmoothScrolling } }), o3 && o3.gates !== i3.gates)) {
              const e4 = Array.from(o3.gates), t3 = Array.from(i3.gates), r2 = t3.find((t4) => !e4.includes(t4)), a3 = e4.find((e5) => !t3.includes(e5));
              this.gateState$.emit({ documentId: n3, isGated: i3.gates.size > 0, gates: t3, addedGate: r2, removedGate: a3 }), this.logger.debug("ViewportPlugin", "GateStateChanged", `Gate state changed for document ${n3}. Gates: [${t3.join(", ")}], Gated: ${i3.gates.size > 0}`);
            }
          }
        }
        async initialize(e3) {
          this.logger.info("ViewportPlugin", "Initialize", "Viewport plugin initialized");
        }
        async destroy() {
          this.viewportMetrics$.clear(), this.viewportResize$.clear(), this.scrollMetrics$.clear(), this.scrollActivity$.clear(), this.gateState$.clear(), this.scrollRequests$.forEach((e3) => e3.clear()), this.scrollRequests$.clear(), super.destroy();
        }
      };
      No.id = "viewport";
      Oo = No;
      Lo = { manifest: wo, create: (e3, t2) => new Oo(bo, e3, t2), reducer: (e3 = Ro, t2) => {
        switch (t2.type) {
          case xo: {
            const { documentId: n3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: { ..._o, gates: /* @__PURE__ */ new Set() } } };
          }
          case Co: {
            const { documentId: n3 } = t2.payload, { [n3]: o3, ...i3 } = e3.documents, r2 = new Set(e3.activeViewports);
            return r2.delete(n3), { ...e3, documents: i3, activeViewports: r2, activeDocumentId: e3.activeDocumentId === n3 ? null : e3.activeDocumentId };
          }
          case Io: {
            const { documentId: n3 } = t2.payload, o3 = new Set(e3.activeViewports);
            return o3.add(n3), { ...e3, activeViewports: o3, activeDocumentId: e3.activeDocumentId ?? n3 };
          }
          case So: {
            const { documentId: n3 } = t2.payload, o3 = new Set(e3.activeViewports);
            return o3.delete(n3), { ...e3, activeViewports: o3 };
          }
          case "SET_ACTIVE_VIEWPORT_DOCUMENT":
            return { ...e3, activeDocumentId: t2.payload };
          case Mo:
            return { ...e3, viewportGap: t2.payload };
          case ko: {
            const { documentId: n3, metrics: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, viewportMetrics: { width: o3.width, height: o3.height, scrollTop: o3.scrollTop, scrollLeft: o3.scrollLeft, clientWidth: o3.clientWidth, clientHeight: o3.clientHeight, scrollWidth: o3.scrollWidth, scrollHeight: o3.scrollHeight, clientLeft: o3.clientLeft, clientTop: o3.clientTop, relativePosition: { x: o3.scrollWidth <= o3.clientWidth ? 0 : o3.scrollLeft / (o3.scrollWidth - o3.clientWidth), y: o3.scrollHeight <= o3.clientHeight ? 0 : o3.scrollTop / (o3.scrollHeight - o3.clientHeight) } } } } } : e3;
          }
          case Do: {
            const { documentId: n3, scrollMetrics: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, viewportMetrics: { ...i3.viewportMetrics, scrollTop: o3.scrollTop, scrollLeft: o3.scrollLeft }, isScrolling: true } } } : e3;
          }
          case Po: {
            const { documentId: n3, isScrolling: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, isScrolling: o3 } } } : e3;
          }
          case Ao: {
            const { documentId: n3, isSmoothScrolling: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, isSmoothScrolling: o3 } } } : e3;
          }
          case To: {
            const { documentId: n3, key: o3 } = t2.payload, i3 = e3.documents[n3];
            if (!i3) return e3;
            const r2 = new Set(i3.gates);
            return r2.add(o3), { ...e3, documents: { ...e3.documents, [n3]: { ...i3, gates: r2 } } };
          }
          case zo: {
            const { documentId: n3, key: o3 } = t2.payload, i3 = e3.documents[n3];
            if (!i3) return e3;
            const r2 = new Set(i3.gates);
            return r2.delete(o3), { ...e3, documents: { ...e3.documents, [n3]: { ...i3, gates: r2 } } };
          }
          default:
            return e3;
        }
      }, initialState: Ro };
      $o = de(null);
      Fo = () => po(Oo.id);
      Uo = ((e3) => (e3.Vertical = "vertical", e3.Horizontal = "horizontal", e3))(Uo || {});
      Wo = class {
        constructor(e3) {
          this.pageGap = e3.pageGap ?? 20, this.viewportGap = e3.viewportGap ?? 20, this.bufferSize = e3.bufferSize ?? 2;
        }
        getVisibleRange(e3, t2, n3) {
          const o3 = this.getScrollOffset(e3), i3 = o3, r2 = o3 + this.getClientSize(e3);
          let a3 = 0;
          for (; a3 < t2.length && (t2[a3].offset + t2[a3].height) * n3 <= i3; ) a3++;
          let s4 = a3;
          for (; s4 < t2.length && t2[s4].offset * n3 <= r2; ) s4++;
          return { start: Math.max(0, a3 - this.bufferSize), end: Math.min(t2.length - 1, s4 + this.bufferSize - 1) };
        }
        handleScroll(e3, t2, n3) {
          const o3 = this.getVisibleRange(e3, t2, n3), i3 = t2.slice(o3.start, o3.end + 1), r2 = this.calculatePageVisibility(i3, e3, n3), a3 = r2.map((e4) => e4.pageNumber), s4 = t2.slice(o3.start, o3.end + 1).flatMap((e4) => e4.index), l4 = this.determineCurrentPage(r2), c4 = t2[o3.start], d4 = t2[o3.end], u4 = c4 ? c4.offset * n3 : 0, h3 = d4 ? (t2[t2.length - 1].offset + t2[t2.length - 1].height) * n3 - (d4.offset + d4.height) * n3 : 0;
          return { currentPage: l4, visiblePages: a3, pageVisibilityMetrics: r2, renderedPageIndexes: s4, scrollOffset: { x: e3.scrollLeft, y: e3.scrollTop }, startSpacing: u4, endSpacing: h3 };
        }
        calculatePageVisibility(e3, t2, n3) {
          const o3 = [];
          return e3.forEach((e4) => {
            e4.pageLayouts.forEach((i3) => {
              const r2 = e4.x * n3, a3 = e4.y * n3, s4 = r2 + i3.x * n3, l4 = a3 + i3.y * n3, c4 = i3.rotatedWidth * n3, d4 = i3.rotatedHeight * n3, u4 = t2.scrollLeft, h3 = t2.scrollTop, m3 = u4 + t2.clientWidth, g3 = h3 + t2.clientHeight, p4 = Math.max(s4, u4), v2 = Math.max(l4, h3), f2 = Math.min(s4 + c4, m3), y2 = Math.min(l4 + d4, g3);
              if (p4 < f2 && v2 < y2) {
                const e5 = f2 - p4, t3 = y2 - v2, r3 = c4 * d4, a4 = e5 * t3;
                o3.push({ pageNumber: i3.pageNumber, viewportX: p4 - u4, viewportY: v2 - h3, visiblePercentage: a4 / r3 * 100, original: { pageX: (p4 - s4) / n3, pageY: (v2 - l4) / n3, visibleWidth: e5 / n3, visibleHeight: t3 / n3, scale: 1 }, scaled: { pageX: p4 - s4, pageY: v2 - l4, visibleWidth: e5, visibleHeight: t3, scale: n3 } });
              }
            });
          }), o3;
        }
        determineCurrentPage(e3) {
          if (0 === e3.length) return 1;
          const t2 = Math.max(...e3.map((e4) => e4.visiblePercentage)), n3 = e3.filter((e4) => e4.visiblePercentage === t2);
          return 1 === n3.length ? n3[0].pageNumber : n3.sort((e4, t3) => e4.pageNumber - t3.pageNumber)[0].pageNumber;
        }
        getRectLocationForPage(e3, t2, n3) {
          const o3 = t2.find((t3) => t3.pageNumbers.includes(e3));
          if (!o3) return null;
          const i3 = o3.pageLayouts.find((t3) => t3.pageNumber === e3);
          if (!i3) return null;
          let r2 = 0;
          if (n3) {
            const e4 = n3.width;
            o3.width < e4 && (r2 = (e4 - o3.width) / 2);
          }
          return { origin: { x: o3.x + i3.x + r2, y: o3.y + i3.y }, size: { width: i3.width, height: i3.height } };
        }
        getScrollPositionForPage(e3, t2, n3, o3, i3) {
          const r2 = this.getTotalContentSize(t2), a3 = this.getRectLocationForPage(e3, t2, r2);
          if (!a3) return null;
          const s4 = Qe(a3.origin, n3);
          if (i3) {
            const e4 = (function(e5, t3, n4, o4) {
              return Qe(Xe(e5, t3, n4), o4);
            })({ width: a3.size.width, height: a3.size.height }, { x: i3.x, y: i3.y }, o3, n3);
            return { x: s4.x + e4.x + this.viewportGap, y: s4.y + e4.y + this.viewportGap };
          }
          return { x: s4.x + this.viewportGap, y: s4.y + this.viewportGap };
        }
        getRectPositionForPage(e3, t2, n3, o3, i3) {
          const r2 = this.getTotalContentSize(t2), a3 = this.getRectLocationForPage(e3, t2, r2);
          if (!a3) return null;
          const s4 = Qe(a3.origin, n3), l4 = ot({ width: a3.size.width, height: a3.size.height }, i3, o3, n3);
          return { origin: { x: s4.x + l4.origin.x, y: s4.y + l4.origin.y }, size: l4.size };
        }
      };
      Bo = class extends Wo {
        constructor(e3) {
          super(e3);
        }
        createVirtualItems(e3) {
          let t2 = 0;
          return e3.map((e4, n3) => {
            let o3 = 0;
            const i3 = e4.map((e5) => {
              const t3 = { pageNumber: e5.index + 1, pageIndex: e5.index, x: o3, y: 0, width: e5.size.width, height: e5.size.height, rotatedWidth: e5.rotatedSize.width, rotatedHeight: e5.rotatedSize.height };
              return o3 += e5.rotatedSize.width + this.pageGap, t3;
            }), r2 = e4.reduce((t3, n4, o4) => t3 + n4.rotatedSize.width + (o4 < e4.length - 1 ? this.pageGap : 0), 0), a3 = Math.max(...e4.map((e5) => e5.rotatedSize.height)), s4 = { id: `item-${n3}`, x: 0, y: t2, offset: t2, width: r2, height: a3, pageLayouts: i3, pageNumbers: e4.map((e5) => e5.index + 1), index: n3 };
            return t2 += a3 + this.pageGap, s4;
          });
        }
        getTotalContentSize(e3) {
          if (0 === e3.length) return { width: 0, height: 0 };
          return { width: Math.max(...e3.map((e4) => e4.width)), height: e3[e3.length - 1].y + e3[e3.length - 1].height };
        }
        getScrollOffset(e3) {
          return e3.scrollTop;
        }
        getClientSize(e3) {
          return e3.clientHeight;
        }
      };
      qo = class extends Wo {
        constructor(e3) {
          super(e3);
        }
        createVirtualItems(e3) {
          let t2 = 0;
          return e3.map((e4, n3) => {
            let o3 = 0;
            const i3 = e4.map((e5) => {
              const t3 = { pageNumber: e5.index + 1, pageIndex: e5.index, x: o3, y: 0, width: e5.size.width, height: e5.size.height, rotatedWidth: e5.rotatedSize.width, rotatedHeight: e5.rotatedSize.height };
              return o3 += e5.rotatedSize.width + this.pageGap, t3;
            }), r2 = e4.reduce((t3, n4, o4) => t3 + n4.rotatedSize.width + (o4 < e4.length - 1 ? this.pageGap : 0), 0), a3 = Math.max(...e4.map((e5) => e5.rotatedSize.height)), s4 = { id: `item-${n3}`, x: t2, y: 0, offset: t2, width: r2, height: a3, pageLayouts: i3, pageNumbers: e4.map((e5) => e5.index + 1), index: n3 };
            return t2 += r2 + this.pageGap, s4;
          });
        }
        getTotalContentSize(e3) {
          if (0 === e3.length) return { width: 0, height: 0 };
          return { width: e3[e3.length - 1].x + e3[e3.length - 1].width, height: Math.max(...e3.map((e4) => e4.height)) };
        }
        getScrollOffset(e3) {
          return e3.scrollLeft;
        }
        getClientSize(e3) {
          return e3.clientWidth;
        }
      };
      Go = "INIT_SCROLL_STATE";
      Vo = "CLEANUP_SCROLL_STATE";
      Zo = "UPDATE_DOCUMENT_SCROLL_STATE";
      Ko = "SET_SCROLL_STRATEGY";
      Xo = { isChanging: false, targetPage: 1, fromPage: 1, startTime: 0 };
      Qo = class extends Yn {
        constructor(e3, t2, n3) {
          var o3, i3;
          super(e3, t2), this.id = e3, this.config = n3, this.strategies = /* @__PURE__ */ new Map(), this.layoutReady = /* @__PURE__ */ new Set(), this.initialLayoutFired = /* @__PURE__ */ new Set(), this.scrollerLayoutEmitters = /* @__PURE__ */ new Map(), this.pageChange$ = ao(), this.scroll$ = ao(), this.layoutChange$ = ao(), this.pageChangeState$ = ao(), this.layoutReady$ = ao(), this.state$ = ao(), this.viewport = this.registry.getPlugin("viewport").provides(), this.spread = (null == (o3 = this.registry.getPlugin("spread")) ? void 0 : o3.provides()) ?? null, this.viewport.onScrollActivity((e4) => {
            const t3 = this.getDocumentState(e4.documentId);
            (null == t3 ? void 0 : t3.pageChangeState.isChanging) && !e4.activity.isSmoothScrolling && this.completePageChange(e4.documentId);
          }), null == (i3 = this.spread) || i3.onSpreadChange((e4) => {
            this.refreshDocumentLayout(e4.documentId);
          }), this.viewport.onViewportChange((e4) => {
            const t3 = this.getDocumentState(e4.documentId);
            if (!t3) return;
            const n4 = this.computeMetrics(e4.documentId, e4.metrics);
            this.layoutReady.has(e4.documentId) ? this.commitMetrics(e4.documentId, n4) : this.commitMetrics(e4.documentId, { ...n4, scrollOffset: t3.scrollOffset });
          });
        }
        onDocumentLoadingStarted(e3) {
          const t2 = this.getCoreDocument(e3);
          if (!t2) return;
          const n3 = this.createDocumentState(t2);
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Go, payload: { documentId: e4, state: t3 } };
          })(e3, n3));
          const o3 = this.createStrategy(n3.strategy);
          this.strategies.set(e3, o3), this.scrollerLayoutEmitters.set(e3, ao());
        }
        onDocumentLoaded(e3) {
          var t2;
          const n3 = this.getCoreDocument(e3);
          n3 && (this.dispatch(Yo(e3, { totalPages: (null == (t2 = n3.document) ? void 0 : t2.pageCount) ?? 0 })), this.refreshDocumentLayout(e3), this.logger.debug("ScrollPlugin", "DocumentOpened", `Initialized scroll state for document: ${e3}`));
        }
        onDocumentClosed(e3) {
          this.strategies.delete(e3), this.layoutReady.delete(e3), this.initialLayoutFired.delete(e3);
          const t2 = this.scrollerLayoutEmitters.get(e3);
          t2 && (t2.clear(), this.scrollerLayoutEmitters.delete(e3)), this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: Vo, payload: e4 };
          })(e3)), this.logger.debug("ScrollPlugin", "DocumentClosed", `Cleaned up scroll state for document: ${e3}`);
        }
        onScaleChanged(e3) {
          const t2 = this.coreState.core.documents[e3];
          if (!t2 || "loaded" !== t2.status) return;
          const n3 = this.viewport.forDocument(e3), o3 = this.computeMetrics(e3, n3.getMetrics());
          this.commitMetrics(e3, o3);
        }
        onRotationChanged(e3) {
          this.refreshDocumentLayout(e3);
        }
        onScrollerData(e3, t2) {
          const n3 = this.scrollerLayoutEmitters.get(e3);
          if (!n3) throw new Error(`No scroller layout emitter found for document: ${e3}`);
          return n3.on(t2);
        }
        getScrollerLayout(e3) {
          const t2 = this.getDocumentState(e3), n3 = this.getCoreDocumentOrThrow(e3);
          if (!t2 || !n3) throw new Error(`Cannot get scroller layout for document: ${e3}`);
          return o3 = t2, i3 = n3.scale, { startSpacing: o3.startSpacing, endSpacing: o3.endSpacing, totalWidth: o3.totalContentSize.width * i3, totalHeight: o3.totalContentSize.height * i3, pageGap: o3.pageGap * i3, strategy: o3.strategy, items: o3.renderedPageIndexes.map((e4) => ({ ...o3.virtualItems[e4], pageLayouts: o3.virtualItems[e4].pageLayouts.map((e5) => ({ ...e5, rotatedWidth: e5.rotatedWidth * i3, rotatedHeight: e5.rotatedHeight * i3, width: e5.width * i3, height: e5.height * i3 })) })) };
          var o3, i3;
        }
        setLayoutReady(e3) {
          if (this.layoutReady.has(e3)) return;
          const t2 = this.getDocumentState(e3);
          if (!t2) return;
          this.layoutReady.add(e3);
          const n3 = !this.initialLayoutFired.has(e3);
          n3 && this.initialLayoutFired.add(e3);
          this.viewport.forDocument(e3).scrollTo({ ...t2.scrollOffset, behavior: "instant" }), this.layoutReady$.emit({ documentId: e3, isInitial: n3, pageNumber: t2.currentPage, totalPages: t2.totalPages });
        }
        clearLayoutReady(e3) {
          this.layoutReady.delete(e3);
        }
        buildCapability() {
          return { getCurrentPage: () => this.getCurrentPage(), getTotalPages: () => this.getTotalPages(), getPageChangeState: () => this.getPageChangeState(), scrollToPage: (e3) => this.scrollToPage(e3), scrollToNextPage: (e3) => this.scrollToNextPage(e3), scrollToPreviousPage: (e3) => this.scrollToPreviousPage(e3), getMetrics: (e3) => this.getMetrics(e3), getLayout: () => this.getLayout(), getRectPositionForPage: (e3, t2, n3, o3) => this.getRectPositionForPage(e3, t2, n3, o3), forDocument: (e3) => this.createScrollScope(e3), setScrollStrategy: (e3, t2) => this.setScrollStrategyForDocument(e3, t2), getPageGap: () => this.state.defaultPageGap, onPageChange: this.pageChange$.on, onScroll: this.scroll$.on, onLayoutChange: this.layoutChange$.on, onLayoutReady: this.layoutReady$.on, onPageChangeState: this.pageChangeState$.on, onStateChange: this.state$.on };
        }
        createScrollScope(e3) {
          return { getCurrentPage: () => this.getCurrentPage(e3), getTotalPages: () => this.getTotalPages(e3), getPageChangeState: () => this.getPageChangeState(e3), scrollToPage: (t2) => this.scrollToPage(t2, e3), scrollToNextPage: (t2) => this.scrollToNextPage(t2, e3), scrollToPreviousPage: (t2) => this.scrollToPreviousPage(t2, e3), getSpreadPagesWithRotatedSize: () => this.getSpreadPagesWithRotatedSize(e3), getMetrics: (t2) => this.getMetrics(t2, e3), getLayout: () => this.getLayout(e3), getRectPositionForPage: (t2, n3, o3, i3) => this.getRectPositionForPage(t2, n3, o3, i3, e3), setScrollStrategy: (t2) => this.setScrollStrategyForDocument(t2, e3), onPageChange: (t2) => this.pageChange$.on((n3) => {
            n3.documentId === e3 && t2(n3);
          }), onScroll: (t2) => this.scroll$.on((n3) => {
            n3.documentId === e3 && t2(n3.metrics);
          }), onLayoutChange: (t2) => this.layoutChange$.on((n3) => {
            n3.documentId === e3 && t2(n3.layout);
          }) };
        }
        getDocumentState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          return this.state.documents[t2] ?? null;
        }
        getDocumentStateOrThrow(e3) {
          const t2 = this.getDocumentState(e3);
          if (!t2) throw new Error(`Scroll state not found for document: ${e3 ?? "active"}`);
          return t2;
        }
        getStrategy(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.strategies.get(t2);
          if (!n3) throw new Error(`Strategy not found for document: ${t2}`);
          return n3;
        }
        createStrategy(e3) {
          const t2 = { pageGap: this.state.defaultPageGap, viewportGap: this.viewport.getViewportGap(), bufferSize: this.state.defaultBufferSize };
          return e3 === Uo.Horizontal ? new qo(t2) : new Bo(t2);
        }
        createDocumentState(e3) {
          var t2;
          return { virtualItems: [], totalPages: (null == (t2 = e3.document) ? void 0 : t2.pageCount) ?? 0, currentPage: 1, totalContentSize: { width: 0, height: 0 }, strategy: this.state.defaultStrategy, pageGap: this.state.defaultPageGap, visiblePages: [], pageVisibilityMetrics: [], renderedPageIndexes: [], scrollOffset: { x: 0, y: 0 }, startSpacing: 0, endSpacing: 0, pageChangeState: Xo };
        }
        startPageChange(e3, t2, n3 = "smooth") {
          const o3 = this.getDocumentState(e3);
          if (!o3) return;
          const i3 = { isChanging: true, targetPage: t2, fromPage: o3.currentPage, startTime: Date.now() };
          this.dispatch(Yo(e3, { pageChangeState: i3 })), "instant" === n3 && this.completePageChange(e3);
        }
        completePageChange(e3) {
          const t2 = this.getDocumentState(e3);
          if (!t2 || !t2.pageChangeState.isChanging) return;
          const n3 = { isChanging: false, targetPage: t2.pageChangeState.targetPage, fromPage: t2.pageChangeState.fromPage, startTime: t2.pageChangeState.startTime };
          this.dispatch(Yo(e3, { pageChangeState: n3 }));
        }
        computeLayout(e3, t2) {
          const n3 = this.getStrategy(e3), o3 = n3.createVirtualItems(t2);
          return { virtualItems: o3, totalContentSize: n3.getTotalContentSize(o3) };
        }
        computeMetrics(e3, t2, n3) {
          const o3 = this.getCoreDocumentOrThrow(e3), i3 = this.getDocumentState(e3), r2 = this.getStrategy(e3);
          if (!i3) throw new Error(`Document state not found: ${e3}`);
          return r2.handleScroll(t2, n3 ?? i3.virtualItems, o3.scale);
        }
        commitMetrics(e3, t2) {
          const n3 = this.getDocumentState(e3);
          n3 && (this.dispatch(Yo(e3, t2)), this.scroll$.emit({ documentId: e3, metrics: t2 }), t2.currentPage !== n3.currentPage && this.pageChange$.emit({ documentId: e3, pageNumber: t2.currentPage, totalPages: n3.totalPages }), this.pushScrollerLayout(e3));
        }
        pushScrollerLayout(e3) {
          const t2 = this.scrollerLayoutEmitters.get(e3);
          if (t2) try {
            const n3 = this.getScrollerLayout(e3);
            t2.emit(n3);
          } catch (e4) {
          }
        }
        refreshDocumentLayout(e3) {
          const t2 = this.coreState.core.documents[e3], n3 = this.getDocumentState(e3);
          if (!t2 || !n3 || "loaded" !== t2.status) return;
          const o3 = this.getSpreadPagesWithRotatedSize(e3), i3 = this.computeLayout(e3, o3), r2 = this.viewport.forDocument(e3), a3 = this.computeMetrics(e3, r2.getMetrics(), i3.virtualItems);
          this.dispatch(Yo(e3, { ...i3, ...a3 })), this.layoutChange$.emit({ documentId: e3, layout: i3 }), this.pushScrollerLayout(e3);
        }
        getSpreadPagesWithRotatedSize(e3) {
          var t2, n3;
          const o3 = e3 ?? this.getActiveDocumentId(), i3 = this.coreState.core.documents[o3];
          if (!i3) throw new Error(`Document ${o3} not loaded`);
          return ((null == (t2 = this.spread) ? void 0 : t2.forDocument(o3).getSpreadPages()) || (null == (n3 = i3.document) ? void 0 : n3.pages.map((e4) => [e4])) || []).map((e4) => e4.map((e5) => ({ ...e5, rotatedSize: Ze(e5.size, i3.rotation, 1) })));
        }
        getCurrentPage(e3) {
          return this.getDocumentStateOrThrow(e3).currentPage;
        }
        getTotalPages(e3) {
          return this.getDocumentStateOrThrow(e3).totalPages;
        }
        getPageChangeState(e3) {
          return this.getDocumentStateOrThrow(e3).pageChangeState;
        }
        scrollToPage(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = this.getDocumentStateOrThrow(n3), i3 = this.getStrategy(n3), r2 = this.getCoreDocumentOrThrow(n3), { pageNumber: a3, behavior: s4 = "smooth", pageCoordinates: l4, alignX: c4, alignY: d4 } = e3;
          this.startPageChange(n3, a3, s4);
          const u4 = i3.getScrollPositionForPage(a3, o3.virtualItems, r2.scale, r2.rotation, l4);
          if (u4) {
            this.viewport.forDocument(n3).scrollTo({ ...u4, behavior: s4, alignX: c4, alignY: d4 });
          } else this.completePageChange(n3);
        }
        scrollToNextPage(e3 = "smooth", t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = this.getDocumentStateOrThrow(n3), i3 = this.getStrategy(n3), r2 = this.getCoreDocumentOrThrow(n3), a3 = o3.virtualItems.findIndex((e4) => e4.pageNumbers.includes(o3.currentPage));
          if (a3 >= 0 && a3 < o3.virtualItems.length - 1) {
            const t3 = o3.virtualItems[a3 + 1].pageNumbers[0];
            this.startPageChange(n3, t3, e3);
            const s4 = i3.getScrollPositionForPage(t3, o3.virtualItems, r2.scale, r2.rotation);
            if (s4) {
              this.viewport.forDocument(n3).scrollTo({ ...s4, behavior: e3 });
            } else this.completePageChange(n3);
          }
        }
        scrollToPreviousPage(e3 = "smooth", t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = this.getDocumentStateOrThrow(n3), i3 = this.getStrategy(n3), r2 = this.coreState.core.documents[n3], a3 = o3.virtualItems.findIndex((e4) => e4.pageNumbers.includes(o3.currentPage));
          if (a3 > 0) {
            const t3 = o3.virtualItems[a3 - 1].pageNumbers[0];
            this.startPageChange(n3, t3, e3);
            const s4 = i3.getScrollPositionForPage(t3, o3.virtualItems, r2.scale, r2.rotation);
            if (s4) {
              this.viewport.forDocument(n3).scrollTo({ ...s4, behavior: e3 });
            } else this.completePageChange(n3);
          }
        }
        getMetrics(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId();
          if (e3) return this.computeMetrics(n3, e3);
          const o3 = this.viewport.forDocument(n3);
          return this.computeMetrics(n3, o3.getMetrics());
        }
        getLayout(e3) {
          const t2 = this.getDocumentStateOrThrow(e3);
          return { virtualItems: t2.virtualItems, totalContentSize: t2.totalContentSize };
        }
        getRectPositionForPage(e3, t2, n3, o3, i3) {
          const r2 = i3 ?? this.getActiveDocumentId(), a3 = this.getDocumentStateOrThrow(r2), s4 = this.getStrategy(r2), l4 = this.getCoreDocumentOrThrow(r2);
          return s4.getRectPositionForPage(e3 + 1, a3.virtualItems, n3 ?? l4.scale, o3 ?? l4.rotation, t2);
        }
        setScrollStrategyForDocument(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = this.getDocumentState(n3);
          if (!o3 || o3.strategy === e3) return;
          const i3 = this.createStrategy(e3);
          this.strategies.set(n3, i3), this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Ko, payload: { documentId: e4, strategy: t3 } };
          })(n3, e3)), this.refreshDocumentLayout(n3);
        }
        onStoreUpdated(e3, t2) {
          for (const n3 in t2.documents) {
            const o3 = e3.documents[n3], i3 = t2.documents[n3];
            o3 !== i3 && (this.state$.emit(i3), (null == o3 ? void 0 : o3.pageChangeState) !== i3.pageChangeState && this.pageChangeState$.emit({ documentId: n3, state: i3.pageChangeState }), this.pushScrollerLayout(n3));
          }
        }
        async initialize() {
          this.logger.info("ScrollPlugin", "Initialize", "Scroll plugin initialized");
        }
        async destroy() {
          this.strategies.clear(), this.layoutReady.clear(), this.initialLayoutFired.clear();
          for (const e3 of this.scrollerLayoutEmitters.values()) e3.clear();
          this.scrollerLayoutEmitters.clear(), this.pageChange$.clear(), this.scroll$.clear(), this.layoutChange$.clear(), this.pageChangeState$.clear(), this.layoutReady$.clear(), this.state$.clear(), super.destroy();
        }
      };
      Qo.id = "scroll";
      Jo = Qo;
      ei = "scroll";
      ti = { manifest: { id: ei, name: "Scroll Plugin", version: "1.0.0", provides: ["scroll"], requires: ["viewport"], optional: ["spread"], defaultConfig: { defaultPageGap: 10, defaultBufferSize: 4, defaultStrategy: Uo.Vertical } }, create: (e3, t2) => new Jo(ei, e3, t2), reducer: (e3, t2) => {
        switch (t2.type) {
          case Go: {
            const { documentId: n3, state: o3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: o3 } };
          }
          case Vo: {
            const { [t2.payload]: n3, ...o3 } = e3.documents;
            return { ...e3, documents: o3 };
          }
          case Zo: {
            const { documentId: n3, state: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, ...o3 } } } : e3;
          }
          case Ko: {
            const { documentId: n3, strategy: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, strategy: o3 } } } : e3;
          }
          default:
            return e3;
        }
      }, initialState: (e3, t2) => ((e4, t3) => ({ defaultStrategy: t3.defaultStrategy ?? Uo.Vertical, defaultPageGap: t3.defaultPageGap ?? 10, defaultBufferSize: t3.defaultBufferSize ?? 2, documents: {} }))(0, t2) };
      ni = () => po(Jo.id);
      oi = (e3) => {
        const { provides: t2 } = ni(), [n3, o3] = ke(1), [i3, r2] = ke(1);
        return Me(() => {
          if (!t2 || !e3) return;
          const n4 = t2.forDocument(e3);
          return o3(n4.getCurrentPage()), r2(n4.getTotalPages()), t2.onPageChange((t3) => {
            t3.documentId === e3 && (o3(t3.pageNumber), r2(t3.totalPages));
          });
        }, [t2, e3]), { provides: (null == t2 ? void 0 : t2.forDocument(e3)) ?? null, state: { currentPage: n3, totalPages: i3 } };
      };
      ri = ((e3) => (e3.None = "none", e3.Odd = "odd", e3.Even = "even", e3))(ri || {});
      ai = "SPREAD/INIT_STATE";
      si = "SPREAD/CLEANUP_STATE";
      li = "SPREAD/SET_SPREAD_MODE";
      ci = "SPREAD/SET_PAGE_GROUPING";
      ui = class extends Yn {
        constructor(e3, t2, n3) {
          var o3;
          super(e3, t2), this.spreadEmitter$ = ao(), this.defaultSpreadMode = n3.defaultSpreadMode ?? ri.None, this.viewport = (null == (o3 = t2.getPlugin("viewport")) ? void 0 : o3.provides()) ?? null;
        }
        onDocumentLoadingStarted(e3) {
          var t2;
          const n3 = { spreadMode: this.defaultSpreadMode };
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: ai, payload: { documentId: e4, state: t3 } };
          })(e3, n3)), null == (t2 = this.viewport) || t2.gate("spread", e3), this.logger.debug("SpreadPlugin", "DocumentOpened", `Initialized spread state for document: ${e3}`);
        }
        onDocumentLoaded(e3) {
          var t2;
          const n3 = this.coreState.core.documents[e3];
          if (null == n3 ? void 0 : n3.document) {
            const t3 = this.calculatePageGrouping(e3, n3.document.pages.length);
            this.dispatch(di(e3, t3));
          }
          null == (t2 = this.viewport) || t2.releaseGate("spread", e3);
        }
        onDocumentClosed(e3) {
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: si, payload: e4 };
          })(e3)), this.logger.debug("SpreadPlugin", "DocumentClosed", `Cleaned up spread state for document: ${e3}`);
        }
        buildCapability() {
          return { setSpreadMode: (e3) => this.setSpreadModeForDocument(e3), getSpreadMode: () => this.getSpreadModeForDocument(), getSpreadPages: () => this.getSpreadPages(), forDocument: (e3) => this.createSpreadScope(e3), onSpreadChange: this.spreadEmitter$.on };
        }
        createSpreadScope(e3) {
          return { setSpreadMode: (t2) => this.setSpreadModeForDocument(t2, e3), getSpreadMode: () => this.getSpreadModeForDocument(e3), getSpreadPages: () => this.getSpreadPages(e3), onSpreadChange: (t2) => this.spreadEmitter$.on((n3) => {
            n3.documentId === e3 && t2(n3.spreadMode);
          }) };
        }
        getDocumentState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          return this.state.documents[t2] ?? null;
        }
        getDocumentStateOrThrow(e3) {
          const t2 = this.getDocumentState(e3);
          if (!t2) throw new Error(`Spread state not found for document: ${e3 ?? "active"}`);
          return t2;
        }
        setSpreadModeForDocument(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = this.getDocumentStateOrThrow(n3), i3 = this.coreState.core.documents[n3];
          if (!(null == i3 ? void 0 : i3.document)) throw new Error(`Document ${n3} not loaded`);
          if (o3.spreadMode !== e3) {
            this.dispatch(/* @__PURE__ */ (function(e4, t4) {
              return { type: li, payload: { documentId: e4, spreadMode: t4 } };
            })(n3, e3));
            const t3 = this.calculatePageGrouping(n3, i3.document.pages.length);
            this.dispatch(di(n3, t3)), this.spreadEmitter$.emit({ documentId: n3, spreadMode: e3 });
          }
        }
        getSpreadModeForDocument(e3) {
          return this.getDocumentStateOrThrow(e3).spreadMode;
        }
        calculatePageGrouping(e3, t2) {
          switch (this.getDocumentStateOrThrow(e3).spreadMode) {
            case ri.None:
              return Array.from({ length: t2 }, (e4, t3) => [t3]);
            case ri.Odd:
              return Array.from({ length: Math.ceil(t2 / 2) }, (e4, n3) => {
                const o3 = [2 * n3];
                return 2 * n3 + 1 < t2 && o3.push(2 * n3 + 1), o3;
              });
            case ri.Even:
              return [[0], ...Array.from({ length: Math.ceil((t2 - 1) / 2) }, (e4, n3) => {
                const o3 = [1 + 2 * n3];
                return 1 + 2 * n3 + 1 < t2 && o3.push(1 + 2 * n3 + 1), o3;
              })];
            default:
              return Array.from({ length: t2 }, (e4, t3) => [t3]);
          }
        }
        getSpreadPages(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.coreState.core.documents[t2], o3 = this.getDocumentStateOrThrow(t2);
          if (!(null == n3 ? void 0 : n3.document)) throw new Error(`Document ${t2} not loaded`);
          const i3 = o3.pageGrouping ?? [], r2 = n3.document.pages;
          return i3.map((e4) => e4.map((e5) => r2[e5]).filter(Boolean));
        }
        onStoreUpdated(e3, t2) {
          for (const n3 in t2.documents) {
            const o3 = e3.documents[n3], i3 = t2.documents[n3];
            (null == o3 ? void 0 : o3.spreadMode) !== i3.spreadMode && this.logger.debug("SpreadPlugin", "SpreadModeChanged", `Spread mode changed for document ${n3}: ${(null == o3 ? void 0 : o3.spreadMode) ?? ri.None} -> ${i3.spreadMode}`);
          }
        }
        async initialize(e3) {
          this.logger.info("SpreadPlugin", "Initialize", "Spread plugin initialized");
        }
        async destroy() {
          this.spreadEmitter$.clear(), super.destroy();
        }
      };
      ui.id = "spread";
      hi = ui;
      mi = "spread";
      gi = { id: mi, name: "Spread Plugin", version: "1.0.0", provides: ["spread"], requires: [], optional: ["viewport"], defaultConfig: {} };
      ri.None;
      pi = { documents: {}, activeDocumentId: null };
      vi = { manifest: gi, create: (e3, t2) => new hi(mi, e3, t2), reducer: (e3 = pi, t2) => {
        switch (t2.type) {
          case ai: {
            const { documentId: n3, state: o3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: o3 }, activeDocumentId: e3.activeDocumentId ?? n3 };
          }
          case si: {
            const n3 = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3, activeDocumentId: e3.activeDocumentId === n3 ? null : e3.activeDocumentId };
          }
          case "SPREAD/SET_ACTIVE_DOCUMENT":
            return { ...e3, activeDocumentId: t2.payload };
          case li: {
            const { documentId: n3, spreadMode: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, spreadMode: o3 } } } : e3;
          }
          case ci: {
            const { documentId: n3, grouping: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, pageGrouping: o3 } } } : e3;
          }
          default:
            return e3;
        }
      }, initialState: pi };
      fi = "ui";
      yi = { id: fi, name: "UI Plugin", version: "1.0.0", provides: ["ui"], requires: ["commands"], optional: ["i18n"], defaultConfig: { schema: { id: "empty", version: "1.0.0", toolbars: {}, menus: {}, sidebars: {}, modals: {}, selectionMenus: {} } } };
      bi = "UI/INIT_STATE";
      wi = "UI/CLEANUP_STATE";
      xi = "UI/SET_ACTIVE_TOOLBAR";
      Ci = "UI/CLOSE_TOOLBAR_SLOT";
      Ii = "UI/SET_ACTIVE_SIDEBAR";
      Si = "UI/CLOSE_SIDEBAR_SLOT";
      ki = "UI/SET_SIDEBAR_TAB";
      Di = "UI/OPEN_MODAL";
      Mi = "UI/CLOSE_MODAL";
      Pi = "UI/CLEAR_MODAL";
      Ai = "UI/OPEN_MENU";
      Ti = "UI/CLOSE_MENU";
      zi = "UI/CLOSE_ALL_MENUS";
      Ei = "UI/SET_DISABLED_CATEGORIES";
      _i = "UI/SET_HIDDEN_ITEMS";
      Ri = (e3, t2, n3, o3, i3) => ({ type: Ii, payload: { documentId: e3, placement: t2, slot: n3, sidebarId: o3, activeTab: i3 } });
      Ni = (e3, t2, n3) => ({ type: Si, payload: { documentId: e3, placement: t2, slot: n3 } });
      Oi = (e3, t2) => ({ type: Ai, payload: { documentId: e3, menuState: t2 } });
      Li = (e3, t2) => ({ type: Ti, payload: { documentId: e3, menuId: t2 } });
      $i = (e3) => ({ type: Ei, payload: { categories: e3 } });
      Fi = (e3) => ({ type: _i, payload: { hiddenItems: e3 } });
      Bi = "data-epdf";
      qi = "data-epdf-s";
      Gi = "data-epdf-i";
      Vi = "data-epdf-cat";
      Zi = "data-epdf-dis";
      Ki = "data-epdf-hid";
      Yi = { ROOT: `[${Bi}]`, STYLES: `[${qi}]`, ITEM: (e3) => `[${Gi}="${e3}"]`, CATEGORIES: (e3) => `[${Vi}~="${e3}"]`, DISABLED_CATEGORY: (e3) => `[${Zi}~="${e3}"]`, HIDDEN_ITEM: (e3) => `[${Ki}~="${e3}"]` };
      Xi = { useContainerQueries: true };
      gr = class extends Yn {
        constructor(e3, t2, n3) {
          var o3, i3;
          if (super(e3, t2), this.cachedStylesheet = null, this.cachedLocale = null, this.i18n = null, this.i18nCleanup = null, this.categoryChanged$ = ao(), this.stylesheetInvalidated$ = ro(), this.toolbarChanged$ = so((e4, t3) => ({ documentId: e4, ...t3 }), { cache: false }), this.sidebarChanged$ = so((e4, t3) => ({ documentId: e4, ...t3 }), { cache: false }), this.modalChanged$ = so((e4, t3) => ({ documentId: e4, ...t3 }), { cache: false }), this.menuChanged$ = so((e4, t3) => ({ documentId: e4, ...t3 }), { cache: false }), this.schema = n3.schema, this.stylesheetConfig = n3.stylesheetConfig || {}, this.itemCategories = er(this.schema).itemCategories, null == (o3 = n3.disabledCategories) ? void 0 : o3.length) {
            this.dispatch($i(n3.disabledCategories));
            const e4 = Ji(this.itemCategories, n3.disabledCategories);
            this.dispatch(Fi(e4));
          }
          this.i18n = (null == (i3 = t2.getPlugin("i18n")) ? void 0 : i3.provides()) ?? null, this.i18n && (this.i18nCleanup = this.i18n.onLocaleChange(({ currentLocale: e4 }) => {
            this.handleLocaleChange(e4);
          }), this.cachedLocale = this.i18n.getLocale());
        }
        async initialize() {
          this.logger.info("UIPlugin", "Initialize", "UI plugin initialized");
        }
        async destroy() {
          this.i18nCleanup && (this.i18nCleanup(), this.i18nCleanup = null), this.toolbarChanged$.clear(), this.sidebarChanged$.clear(), this.modalChanged$.clear(), this.menuChanged$.clear(), this.stylesheetInvalidated$.clear(), super.destroy();
        }
        onDocumentLoadingStarted(e3) {
          this.dispatch(/* @__PURE__ */ ((e4, t2) => ({ type: bi, payload: { documentId: e4, schema: t2 } }))(e3, this.schema));
        }
        onDocumentClosed(e3) {
          this.dispatch(/* @__PURE__ */ ((e4) => ({ type: wi, payload: { documentId: e4 } }))(e3)), this.toolbarChanged$.clearScope(e3), this.sidebarChanged$.clearScope(e3), this.modalChanged$.clearScope(e3), this.menuChanged$.clearScope(e3);
        }
        handleLocaleChange(e3) {
          this.cachedLocale !== e3 && (this.logger.debug("UIPlugin", "LocaleChange", `Locale changed: ${this.cachedLocale} -> ${e3}`), this.cachedLocale = e3, this.invalidateStylesheet(), this.stylesheetInvalidated$.emit());
        }
        getStylesheet() {
          var e3;
          const t2 = (null == (e3 = this.i18n) ? void 0 : e3.getLocale()) ?? null;
          return this.cachedStylesheet && this.cachedLocale === t2 || (this.cachedStylesheet = Qi(this.schema, { config: this.stylesheetConfig, locale: t2 ?? void 0 }), this.cachedLocale = t2), this.cachedStylesheet;
        }
        getLocale() {
          var e3;
          return (null == (e3 = this.i18n) ? void 0 : e3.getLocale()) ?? null;
        }
        invalidateStylesheet() {
          this.cachedStylesheet = null;
        }
        onStylesheetInvalidated(e3) {
          return this.stylesheetInvalidated$.on(e3);
        }
        disableCategoryImpl(e3) {
          const t2 = new Set(this.state.disabledCategories);
          if (!t2.has(e3)) {
            t2.add(e3);
            const n3 = Array.from(t2);
            this.dispatch($i(n3));
            const o3 = Ji(this.itemCategories, n3);
            this.dispatch(Fi(o3)), this.categoryChanged$.emit({ disabledCategories: n3, hiddenItems: o3 });
          }
        }
        enableCategoryImpl(e3) {
          const t2 = new Set(this.state.disabledCategories);
          if (t2.has(e3)) {
            t2.delete(e3);
            const n3 = Array.from(t2);
            this.dispatch($i(n3));
            const o3 = Ji(this.itemCategories, n3);
            this.dispatch(Fi(o3)), this.categoryChanged$.emit({ disabledCategories: n3, hiddenItems: o3 });
          }
        }
        toggleCategoryImpl(e3) {
          this.state.disabledCategories.includes(e3) ? this.enableCategoryImpl(e3) : this.disableCategoryImpl(e3);
        }
        setDisabledCategoriesImpl(e3) {
          this.dispatch($i(e3));
          const t2 = Ji(this.itemCategories, e3);
          this.dispatch(Fi(t2)), this.categoryChanged$.emit({ disabledCategories: e3, hiddenItems: t2 });
        }
        buildCapability() {
          return { setActiveToolbar: (e3, t2, n3, o3) => this.setToolbarForDocument(e3, t2, n3, o3), setActiveSidebar: (e3, t2, n3, o3, i3) => this.setSidebarForDocument(e3, t2, n3, o3, i3), toggleSidebar: (e3, t2, n3, o3, i3) => this.toggleSidebarForDocument(e3, t2, n3, o3, i3), openModal: (e3, t2) => this.openModalForDocument(e3, t2), openMenu: (e3, t2, n3, o3) => this.openMenuForDocument(e3, t2, n3, o3), toggleMenu: (e3, t2, n3, o3) => this.toggleMenuForDocument(e3, t2, n3, o3), forDocument: (e3) => this.createUIScope(e3), getSchema: () => this.schema, mergeSchema: (e3) => {
            var t2, n3;
            this.schema = (t2 = this.schema, n3 = e3, { ...t2, ...n3, toolbars: ji(t2.toolbars, n3.toolbars), menus: Hi(t2.menus, n3.menus), sidebars: Ui(t2.sidebars, n3.sidebars) });
          }, disableCategory: (e3) => this.disableCategoryImpl(e3), enableCategory: (e3) => this.enableCategoryImpl(e3), toggleCategory: (e3) => this.toggleCategoryImpl(e3), setDisabledCategories: (e3) => this.setDisabledCategoriesImpl(e3), getDisabledCategories: () => this.state.disabledCategories, isCategoryDisabled: (e3) => this.state.disabledCategories.includes(e3), getHiddenItems: () => this.state.hiddenItems, onToolbarChanged: this.toolbarChanged$.onGlobal, onSidebarChanged: this.sidebarChanged$.onGlobal, onModalChanged: this.modalChanged$.onGlobal, onMenuChanged: this.menuChanged$.onGlobal, onCategoryChanged: this.categoryChanged$.on };
        }
        createUIScope(e3) {
          return { setActiveToolbar: (t2, n3, o3) => this.setToolbarForDocument(t2, n3, o3, e3), getActiveToolbar: (t2, n3) => this.getToolbarForDocument(t2, n3, e3), closeToolbarSlot: (t2, n3) => this.closeToolbarForDocument(t2, n3, e3), isToolbarOpen: (t2, n3, o3) => this.isToolbarOpenForDocument(t2, n3, o3, e3), setActiveSidebar: (t2, n3, o3, i3) => this.setSidebarForDocument(t2, n3, o3, e3, i3), getActiveSidebar: (t2, n3) => this.getSidebarForDocument(t2, n3, e3), closeSidebarSlot: (t2, n3) => this.closeSidebarForDocument(t2, n3, e3), toggleSidebar: (t2, n3, o3, i3) => this.toggleSidebarForDocument(t2, n3, o3, e3, i3), isSidebarOpen: (t2, n3, o3) => this.isSidebarOpenForDocument(t2, n3, o3, e3), setSidebarTab: (t2, n3) => this.setSidebarTabForDocument(t2, n3, e3), getSidebarTab: (t2) => this.getSidebarTabForDocument(t2, e3), openModal: (t2) => this.openModalForDocument(t2, e3), closeModal: () => this.closeModalForDocument(e3), clearModal: () => this.clearModalForDocument(e3), getActiveModal: () => this.getActiveModalForDocument(e3), isModalOpen: () => this.isModalOpenForDocument(e3), openMenu: (t2, n3, o3) => this.openMenuForDocument(t2, n3, o3, e3), closeMenu: (t2) => this.closeMenuForDocument(t2, e3), toggleMenu: (t2, n3, o3) => this.toggleMenuForDocument(t2, n3, o3, e3), closeAllMenus: () => this.closeAllMenusForDocument(e3), isMenuOpen: (t2) => this.isMenuOpenForDocument(t2, e3), getOpenMenus: () => this.getOpenMenusForDocument(e3), getSchema: () => this.schema, getState: () => this.getDocumentStateOrThrow(e3), onToolbarChanged: this.toolbarChanged$.forScope(e3), onSidebarChanged: this.sidebarChanged$.forScope(e3), onModalChanged: this.modalChanged$.forScope(e3), onMenuChanged: this.menuChanged$.forScope(e3) };
        }
        getDocumentState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          return this.state.documents[t2] ?? null;
        }
        getDocumentStateOrThrow(e3) {
          const t2 = this.getDocumentState(e3);
          if (!t2) throw new Error(`UI state not found for document: ${e3 ?? "active"}`);
          return t2;
        }
        setToolbarForDocument(e3, t2, n3, o3) {
          const i3 = o3 ?? this.getActiveDocumentId();
          this.dispatch(/* @__PURE__ */ ((e4, t3, n4, o4) => ({ type: xi, payload: { documentId: e4, placement: t3, slot: n4, toolbarId: o4 } }))(i3, e3, t2, n3)), this.toolbarChanged$.emit(i3, { placement: e3, slot: t2, toolbarId: n3 });
        }
        getToolbarForDocument(e3, t2, n3) {
          const o3 = `${e3}-${t2}`, i3 = this.getDocumentStateOrThrow(n3).activeToolbars[o3];
          return (null == i3 ? void 0 : i3.isOpen) ? i3.toolbarId : null;
        }
        closeToolbarForDocument(e3, t2, n3) {
          const o3 = n3 ?? this.getActiveDocumentId();
          this.dispatch(/* @__PURE__ */ ((e4, t3, n4) => ({ type: Ci, payload: { documentId: e4, placement: t3, slot: n4 } }))(o3, e3, t2)), this.toolbarChanged$.emit(o3, { placement: e3, slot: t2, toolbarId: "" });
        }
        isToolbarOpenForDocument(e3, t2, n3, o3) {
          const i3 = `${e3}-${t2}`, r2 = this.getDocumentStateOrThrow(o3).activeToolbars[i3];
          return !(!r2 || !r2.isOpen) && (!n3 || r2.toolbarId === n3);
        }
        setSidebarForDocument(e3, t2, n3, o3, i3) {
          const r2 = o3 ?? this.getActiveDocumentId();
          this.dispatch(Ri(r2, e3, t2, n3, i3)), this.sidebarChanged$.emit(r2, { placement: e3, slot: t2, sidebarId: n3 });
        }
        getSidebarForDocument(e3, t2, n3) {
          const o3 = `${e3}-${t2}`, i3 = this.getDocumentStateOrThrow(n3).activeSidebars[o3];
          return (null == i3 ? void 0 : i3.isOpen) ? i3.sidebarId : null;
        }
        closeSidebarForDocument(e3, t2, n3) {
          const o3 = n3 ?? this.getActiveDocumentId();
          this.dispatch(Ni(o3, e3, t2)), this.sidebarChanged$.emit(o3, { placement: e3, slot: t2, sidebarId: "" });
        }
        toggleSidebarForDocument(e3, t2, n3, o3, i3) {
          const r2 = o3 ?? this.getActiveDocumentId(), a3 = `${e3}-${t2}`, s4 = this.getDocumentStateOrThrow(r2).activeSidebars[a3];
          (null == s4 ? void 0 : s4.sidebarId) === n3 && (null == s4 ? void 0 : s4.isOpen) ? (this.dispatch(Ni(r2, e3, t2)), this.sidebarChanged$.emit(r2, { placement: e3, slot: t2, sidebarId: "" })) : (this.dispatch(Ri(r2, e3, t2, n3, i3)), this.sidebarChanged$.emit(r2, { placement: e3, slot: t2, sidebarId: n3 }));
        }
        isSidebarOpenForDocument(e3, t2, n3, o3) {
          const i3 = `${e3}-${t2}`, r2 = this.getDocumentStateOrThrow(o3).activeSidebars[i3];
          return !(!r2 || !r2.isOpen) && (!n3 || r2.sidebarId === n3);
        }
        setSidebarTabForDocument(e3, t2, n3) {
          const o3 = n3 ?? this.getActiveDocumentId();
          this.dispatch(/* @__PURE__ */ ((e4, t3, n4) => ({ type: ki, payload: { documentId: e4, sidebarId: t3, tabId: n4 } }))(o3, e3, t2));
        }
        getSidebarTabForDocument(e3, t2) {
          return this.getDocumentStateOrThrow(t2).sidebarTabs[e3] ?? null;
        }
        openModalForDocument(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId();
          this.dispatch(/* @__PURE__ */ ((e4, t3) => ({ type: Di, payload: { documentId: e4, modalId: t3 } }))(n3, e3)), this.modalChanged$.emit(n3, { modalId: e3, isOpen: true });
        }
        closeModalForDocument(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.getDocumentStateOrThrow(t2).activeModal;
          this.dispatch(/* @__PURE__ */ ((e4) => ({ type: Mi, payload: { documentId: e4 } }))(t2)), this.modalChanged$.emit(t2, { modalId: (null == n3 ? void 0 : n3.modalId) ?? null, isOpen: false });
        }
        clearModalForDocument(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          this.dispatch(/* @__PURE__ */ ((e4) => ({ type: Pi, payload: { documentId: e4 } }))(t2));
        }
        getActiveModalForDocument(e3) {
          return this.getDocumentStateOrThrow(e3).activeModal;
        }
        isModalOpenForDocument(e3) {
          const t2 = this.getDocumentStateOrThrow(e3).activeModal;
          return (null == t2 ? void 0 : t2.isOpen) ?? false;
        }
        openMenuForDocument(e3, t2, n3, o3) {
          const i3 = o3 ?? this.getActiveDocumentId();
          this.dispatch(Oi(i3, { menuId: e3, triggeredByCommandId: t2, triggeredByItemId: n3 })), this.menuChanged$.emit(i3, { menuId: e3, isOpen: true });
        }
        closeMenuForDocument(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId();
          this.dispatch(Li(n3, e3)), this.menuChanged$.emit(n3, { menuId: e3, isOpen: false });
        }
        toggleMenuForDocument(e3, t2, n3, o3) {
          const i3 = o3 ?? this.getActiveDocumentId();
          !!this.getDocumentStateOrThrow(i3).openMenus[e3] ? (this.dispatch(Li(i3, e3)), this.menuChanged$.emit(i3, { menuId: e3, isOpen: false })) : (this.dispatch(Oi(i3, { menuId: e3, triggeredByCommandId: t2, triggeredByItemId: n3 })), this.menuChanged$.emit(i3, { menuId: e3, isOpen: true }));
        }
        closeAllMenusForDocument(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          this.dispatch(/* @__PURE__ */ ((e4) => ({ type: zi, payload: { documentId: e4 } }))(t2));
        }
        isMenuOpenForDocument(e3, t2) {
          return !!this.getDocumentStateOrThrow(t2).openMenus[e3];
        }
        getOpenMenusForDocument(e3) {
          return Object.values(this.getDocumentStateOrThrow(e3).openMenus);
        }
      };
      gr.id = "ui";
      pr = gr;
      vr = { activeToolbars: {}, activeSidebars: {}, activeModal: null, openMenus: {}, sidebarTabs: {} };
      fr = { documents: {}, disabledCategories: [], hiddenItems: [] };
      Cr = { manifest: yi, create: (e3, t2) => new pr(fi, e3, t2), reducer: (e3 = fr, t2) => {
        var n3;
        switch (t2.type) {
          case bi: {
            const { documentId: n4, schema: o3 } = t2.payload, i3 = {};
            return Object.values(o3.toolbars).forEach((e4) => {
              if (e4.permanent && e4.position) {
                const t3 = `${e4.position.placement}-${e4.position.slot}`;
                i3[t3] = { toolbarId: e4.id, isOpen: true };
              }
            }), { ...e3, documents: { ...e3.documents, [n4]: { ...vr, activeToolbars: i3 } } };
          }
          case wi: {
            const { documentId: n4 } = t2.payload, { [n4]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3 };
          }
          case xi: {
            const { documentId: n4, placement: o3, slot: i3, toolbarId: r2 } = t2.payload, a3 = e3.documents[n4] || vr, s4 = `${o3}-${i3}`;
            return { ...e3, documents: { ...e3.documents, [n4]: { ...a3, activeToolbars: { ...a3.activeToolbars, [s4]: { toolbarId: r2, isOpen: true } } } } };
          }
          case Ci: {
            const { documentId: n4, placement: o3, slot: i3 } = t2.payload, r2 = e3.documents[n4];
            if (!r2) return e3;
            const a3 = `${o3}-${i3}`, s4 = r2.activeToolbars[a3];
            return s4 ? { ...e3, documents: { ...e3.documents, [n4]: { ...r2, activeToolbars: { ...r2.activeToolbars, [a3]: { ...s4, isOpen: false } } } } } : e3;
          }
          case Ii: {
            const { documentId: n4, placement: o3, slot: i3, sidebarId: r2, activeTab: a3 } = t2.payload, s4 = e3.documents[n4] || vr, l4 = `${o3}-${i3}`;
            return { ...e3, documents: { ...e3.documents, [n4]: { ...s4, activeSidebars: { ...s4.activeSidebars, [l4]: { sidebarId: r2, isOpen: true } }, ...a3 && { sidebarTabs: { ...s4.sidebarTabs, [r2]: a3 } } } } };
          }
          case Si: {
            const { documentId: n4, placement: o3, slot: i3 } = t2.payload, r2 = e3.documents[n4];
            if (!r2) return e3;
            const a3 = `${o3}-${i3}`, s4 = r2.activeSidebars[a3];
            return s4 ? { ...e3, documents: { ...e3.documents, [n4]: { ...r2, activeSidebars: { ...r2.activeSidebars, [a3]: { ...s4, isOpen: false } } } } } : e3;
          }
          case ki: {
            const { documentId: n4, sidebarId: o3, tabId: i3 } = t2.payload, r2 = e3.documents[n4] || vr;
            return { ...e3, documents: { ...e3.documents, [n4]: { ...r2, sidebarTabs: { ...r2.sidebarTabs, [o3]: i3 } } } };
          }
          case Di: {
            const { documentId: n4, modalId: o3 } = t2.payload, i3 = e3.documents[n4] || vr;
            return { ...e3, documents: { ...e3.documents, [n4]: { ...i3, activeModal: { modalId: o3, isOpen: true }, openMenus: {} } } };
          }
          case Mi: {
            const { documentId: n4 } = t2.payload, o3 = e3.documents[n4];
            return (null == o3 ? void 0 : o3.activeModal) ? { ...e3, documents: { ...e3.documents, [n4]: { ...o3, activeModal: { ...o3.activeModal, isOpen: false } } } } : e3;
          }
          case Pi: {
            const { documentId: o3 } = t2.payload, i3 = e3.documents[o3];
            return i3 ? (null == (n3 = i3.activeModal) ? void 0 : n3.isOpen) ? e3 : { ...e3, documents: { ...e3.documents, [o3]: { ...i3, activeModal: null } } } : e3;
          }
          case Ai: {
            const { documentId: n4, menuState: o3 } = t2.payload, i3 = e3.documents[n4] || vr;
            return { ...e3, documents: { ...e3.documents, [n4]: { ...i3, openMenus: { [o3.menuId]: o3 } } } };
          }
          case Ti: {
            const { documentId: n4, menuId: o3 } = t2.payload, i3 = e3.documents[n4];
            if (!i3) return e3;
            const { [o3]: r2, ...a3 } = i3.openMenus;
            return { ...e3, documents: { ...e3.documents, [n4]: { ...i3, openMenus: a3 } } };
          }
          case zi: {
            const { documentId: n4 } = t2.payload, o3 = e3.documents[n4];
            return o3 ? { ...e3, documents: { ...e3.documents, [n4]: { ...o3, openMenus: {} } } } : e3;
          }
          case Ei:
            return { ...e3, disabledCategories: t2.payload.categories };
          case _i:
            return { ...e3, hiddenItems: t2.payload.hiddenItems };
          default:
            return e3;
        }
      }, initialState: fr };
      Ir = () => po(pr.id);
      Sr = (e3) => {
        const { provides: t2 } = Ir(), [n3, o3] = ke(null);
        return Me(() => {
          if (!t2) return;
          const n4 = t2.forDocument(e3);
          o3(n4.getState());
          const i3 = n4.onToolbarChanged(() => o3(n4.getState())), r2 = n4.onSidebarChanged(() => o3(n4.getState())), a3 = n4.onModalChanged(() => o3(n4.getState())), s4 = n4.onMenuChanged(() => o3(n4.getState()));
          return () => {
            i3(), r2(), a3(), s4();
          };
        }, [t2, e3]), n3;
      };
      kr = de(null);
      Mr = de(null);
      zr = de(null);
      Rr = de(null);
      Hr = class extends Yn {
        constructor(e3, t2, n3) {
          super(e3, t2), this.id = e3, this.documentOpened$ = ao(), this.documentClosed$ = ao(), this.activeDocumentChanged$ = ao(), this.documentError$ = ao(), this.documentOrderChanged$ = ao(), this.openFileRequest$ = ro(), this.loadOptions = /* @__PURE__ */ new Map(), this.maxDocuments = null == n3 ? void 0 : n3.maxDocuments;
        }
        buildCapability() {
          return { openFileDialog: (e3) => this.openFileDialog(e3), openDocumentUrl: (e3) => this.openDocumentUrl(e3), openDocumentBuffer: (e3) => this.openDocumentBuffer(e3), retryDocument: (e3, t2) => this.retryDocument(e3, t2), closeDocument: (e3) => this.closeDocument(e3), closeAllDocuments: () => this.closeAllDocuments(), setActiveDocument: (e3) => {
            if (!this.isDocumentOpen(e3)) throw new Error(`Cannot set active document: ${e3} is not open`);
            this.dispatchCoreAction(/* @__PURE__ */ ((e4) => ({ type: _n, payload: e4 }))(e3));
          }, getActiveDocumentId: () => this.coreState.core.activeDocumentId, getActiveDocument: () => {
            var e3;
            const t2 = this.coreState.core.activeDocumentId;
            return t2 ? (null == (e3 = this.coreState.core.documents[t2]) ? void 0 : e3.document) ?? null : null;
          }, getDocumentOrder: () => this.coreState.core.documentOrder, moveDocument: (e3, t2) => {
            this.dispatchCoreAction(/* @__PURE__ */ ((e4, t3) => ({ type: Nn, payload: { documentId: e4, toIndex: t3 } }))(e3, t2));
          }, swapDocuments: (e3, t2) => {
            const n3 = this.coreState.core.documentOrder, o3 = n3.indexOf(e3), i3 = n3.indexOf(t2);
            if (-1 === o3 || -1 === i3) throw new Error("One or both documents not found in order");
            const r2 = [...n3];
            [r2[o3], r2[i3]] = [r2[i3], r2[o3]], this.dispatchCoreAction(/* @__PURE__ */ ((e4) => ({ type: Rn, payload: e4 }))(r2));
          }, getDocument: (e3) => {
            var t2;
            return (null == (t2 = this.coreState.core.documents[e3]) ? void 0 : t2.document) ?? null;
          }, getDocumentState: (e3) => this.coreState.core.documents[e3] ?? null, getOpenDocuments: () => this.coreState.core.documentOrder.map((e3) => this.coreState.core.documents[e3]).filter((e3) => null !== e3), isDocumentOpen: (e3) => this.isDocumentOpen(e3), getDocumentCount: () => Object.keys(this.coreState.core.documents).length, getDocumentIndex: (e3) => this.coreState.core.documentOrder.indexOf(e3), onDocumentOpened: this.documentOpened$.on, onDocumentClosed: this.documentClosed$.on, onDocumentError: this.documentError$.on, onActiveDocumentChanged: this.activeDocumentChanged$.on, onDocumentOrderChanged: this.documentOrderChanged$.on };
        }
        isDocumentOpen(e3) {
          return !!this.coreState.core.documents[e3];
        }
        onDocumentLoaded(e3) {
          const t2 = this.coreState.core.documents[e3];
          t2 && "loaded" === t2.status && (this.loadOptions.delete(e3), this.documentOpened$.emit(t2), this.logger.info("DocumentManagerPlugin", "DocumentOpened", `Document ${e3} opened successfully`, { name: t2.name }));
        }
        onDocumentClosed(e3) {
          this.loadOptions.delete(e3), this.documentClosed$.emit(e3), this.logger.info("DocumentManagerPlugin", "DocumentClosed", `Document ${e3} closed`);
        }
        onActiveDocumentChanged(e3, t2) {
          this.activeDocumentChanged$.emit({ previousDocumentId: e3, currentDocumentId: t2 }), this.logger.info("DocumentManagerPlugin", "ActiveDocumentChanged", `Active document changed from ${e3} to ${t2}`);
        }
        onCoreStoreUpdated(e3, t2) {
          e3.core.documentOrder !== t2.core.documentOrder && this.documentOrderChanged$.emit({ order: t2.core.documentOrder });
        }
        onOpenFileRequest(e3) {
          return this.openFileRequest$.on(e3);
        }
        openDocumentUrl(e3) {
          const t2 = new gt(), n3 = e3.documentId || this.generateDocumentId(), o3 = this.checkDocumentLimit();
          if (o3) return t2.reject(o3), t2;
          const i3 = e3.name ?? this.extractNameFromUrl(e3.url);
          this.loadOptions.set(n3, e3), this.dispatchCoreAction(jn(n3, i3, e3.scale, e3.rotation, !!e3.password, e3.autoActivate)), this.logger.info("DocumentManagerPlugin", "OpenDocumentUrl", `Starting to load document from URL: ${e3.url}`, { documentId: n3, passwordProvided: !!e3.password });
          const r2 = { id: n3, url: e3.url }, a3 = this.engine.openDocumentUrl(r2, { password: e3.password, mode: e3.mode, requestOptions: e3.requestOptions });
          return t2.resolve({ documentId: n3, task: a3 }), this.handleLoadTask(n3, a3, "OpenDocumentUrl"), t2;
        }
        openDocumentBuffer(e3) {
          const t2 = new gt(), n3 = this.checkDocumentLimit();
          if (n3) return t2.reject(n3), t2;
          const o3 = e3.documentId || this.generateDocumentId();
          this.loadOptions.set(o3, e3), this.dispatchCoreAction(jn(o3, e3.name, e3.scale, e3.rotation, !!e3.password, e3.autoActivate)), this.logger.info("DocumentManagerPlugin", "OpenDocumentBuffer", `Starting to load document from buffer: ${e3.name}`, { documentId: o3, passwordProvided: !!e3.password });
          const i3 = { id: o3, content: e3.buffer }, r2 = this.engine.openDocumentBuffer(i3, { password: e3.password });
          return t2.resolve({ documentId: o3, task: r2 }), this.handleLoadTask(o3, r2, "OpenDocumentBuffer"), t2;
        }
        retryDocument(e3, t2) {
          const n3 = new gt(), o3 = this.validateRetry(e3);
          if (!o3.valid) return n3.reject(o3.error), n3;
          const i3 = { ...this.loadOptions.get(e3), ...(null == t2 ? void 0 : t2.password) && { password: t2.password } };
          this.loadOptions.set(e3, i3), this.dispatchCoreAction(/* @__PURE__ */ ((e4, t3) => ({ type: zn, payload: { documentId: e4, passwordProvided: t3 } }))(e3, !!(null == t2 ? void 0 : t2.password))), this.logger.info("DocumentManagerPlugin", "RetryDocument", `Retrying to load document ${e3}`, { passwordProvided: !!(null == t2 ? void 0 : t2.password) });
          const r2 = "url" in i3 ? this.retryUrlDocument(e3, i3) : this.retryBufferDocument(e3, i3);
          return n3.resolve({ documentId: e3, task: r2 }), this.handleLoadTask(e3, r2, "RetryDocument"), n3;
        }
        openFileDialog(e3) {
          const t2 = new gt();
          return this.openFileRequest$.emit({ task: t2, options: e3 }), t2;
        }
        closeDocument(e3) {
          const t2 = new gt(), n3 = this.coreState.core.documents[e3];
          return n3 ? ("loaded" === n3.status && n3.document ? this.engine.closeDocument(n3.document).wait(() => {
            this.dispatchCoreAction(Hn(e3)), t2.resolve();
          }, (n4) => {
            this.logger.error("DocumentManagerPlugin", "CloseDocument", `Failed to close document ${e3}`, n4), t2.fail(n4);
          }) : (this.logger.info("DocumentManagerPlugin", "CloseDocument", `Closing document ${e3} in ${n3.status} state (skipping engine close)`), this.dispatchCoreAction(Hn(e3)), t2.resolve()), t2) : (this.logger.warn("DocumentManagerPlugin", "CloseDocument", `Cannot close document ${e3}: not found in state`), t2.resolve(), t2);
        }
        closeAllDocuments() {
          const e3 = Object.keys(this.coreState.core.documents), t2 = e3.map((e4) => this.closeDocument(e4));
          return this.logger.info("DocumentManagerPlugin", "CloseAllDocuments", `Closing ${e3.length} documents`), gt.all(t2);
        }
        checkDocumentLimit() {
          return this.maxDocuments && Object.keys(this.coreState.core.documents).length >= this.maxDocuments ? { code: Ht.Unknown, message: `Maximum number of documents (${this.maxDocuments}) reached` } : null;
        }
        validateRetry(e3) {
          const t2 = this.coreState.core.documents[e3];
          return t2 ? "loaded" === t2.status ? { valid: false, error: { code: Ht.Unknown, message: `Document ${e3} is already loaded successfully` } } : "error" !== t2.status ? { valid: false, error: { code: Ht.Unknown, message: `Document ${e3} is not in error state (current state: ${t2.status})` } } : this.loadOptions.has(e3) ? { valid: true } : { valid: false, error: { code: Ht.Unknown, message: `No retry information available for document ${e3}` } } : { valid: false, error: { code: Ht.NotFound, message: `Document ${e3} not found` } };
        }
        retryUrlDocument(e3, t2) {
          const n3 = { id: e3, url: t2.url };
          return this.engine.openDocumentUrl(n3, { password: t2.password, mode: t2.mode, requestOptions: t2.requestOptions });
        }
        retryBufferDocument(e3, t2) {
          const n3 = { id: e3, content: t2.buffer };
          return this.engine.openDocumentBuffer(n3, { password: t2.password });
        }
        handleLoadTask(e3, t2, n3) {
          t2.wait((t3) => {
            this.dispatchCoreAction(/* @__PURE__ */ ((e4, t4) => ({ type: An, payload: { documentId: e4, document: t4 } }))(e3, t3));
          }, (t3) => {
            this.handleLoadError(e3, t3, n3);
          });
        }
        handleLoadError(e3, t2, n3) {
          var o3, i3, r2;
          const a3 = (null == (o3 = t2.reason) ? void 0 : o3.message) || "Failed to load document";
          this.logger.error("DocumentManagerPlugin", n3, "Failed to load document", t2), this.dispatchCoreAction(/* @__PURE__ */ ((e4, t3, n4, o4) => ({ type: Tn, payload: { documentId: e4, error: t3, errorCode: n4, errorDetails: o4 } }))(e3, a3, null == (i3 = t2.reason) ? void 0 : i3.code, t2.reason)), this.documentError$.emit({ documentId: e3, message: a3, code: null == (r2 = t2.reason) ? void 0 : r2.code, reason: t2.reason });
        }
        generateDocumentId() {
          return `doc-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        }
        extractNameFromUrl(e3) {
          try {
            const t2 = new URL(e3), n3 = t2.pathname.split("/").pop();
            if (!n3) return;
            let o3 = decodeURIComponent(n3);
            return o3.toLowerCase().endsWith(".pdf") || (o3 += ".pdf"), o3;
          } catch {
            return;
          }
        }
        async initialize(e3) {
          var t2;
          if (this.logger.info("DocumentManagerPlugin", "Initialize", "Document Manager Plugin initialized", { maxDocuments: this.maxDocuments, initialDocumentsCount: (null == (t2 = e3.initialDocuments) ? void 0 : t2.length) ?? 0 }), e3.initialDocuments && e3.initialDocuments.length > 0) for (const t3 of e3.initialDocuments) try {
            "buffer" in t3 ? this.openDocumentBuffer(t3) : "url" in t3 && this.openDocumentUrl(t3);
          } catch (e4) {
            this.logger.error("DocumentManagerPlugin", "Initialize", "Failed to initiate initial document load", e4);
          }
        }
        async destroy() {
          await this.closeAllDocuments().toPromise(), this.loadOptions.clear(), this.documentOpened$.clear(), this.documentClosed$.clear(), this.activeDocumentChanged$.clear(), this.documentOrderChanged$.clear(), this.documentError$.clear(), super.destroy();
        }
      };
      Hr.id = "document-manager";
      Ur = Hr;
      Wr = "document-manager";
      qr = () => po(Ur.id);
      Gr = co({ manifest: { id: Wr, name: "Document Manager Plugin", version: "1.0.0", provides: ["document-manager"], requires: [], optional: [], defaultConfig: { maxDocuments: 10 } }, create: (e3, t2) => new Ur(Wr, e3, t2), reducer: (e3) => e3, initialState: {} }).addUtility(function() {
        const { plugin: e3 } = go(Ur.id), { provides: t2 } = qr(), n3 = Ae(null), o3 = Ae(null), i3 = Ae(void 0);
        return Me(() => {
          if (!(null == e3 ? void 0 : e3.onOpenFileRequest)) return;
          return e3.onOpenFileRequest(({ task: e4, options: t3 }) => {
            var r2;
            o3.current = e4, i3.current = t3, null == (r2 = n3.current) || r2.click();
          });
        }, [e3]), Ue("input", { ref: n3, type: "file", accept: "application/pdf", style: { display: "none" }, onChange: async (e4) => {
          var n4, r2, a3, s4, l4;
          const c4 = null == (n4 = e4.currentTarget.files) ? void 0 : n4[0];
          if (!c4 || !t2) return;
          const d4 = await c4.arrayBuffer();
          t2.openDocumentBuffer({ name: c4.name, buffer: d4, documentId: null == (r2 = i3.current) ? void 0 : r2.documentId, scale: null == (a3 = i3.current) ? void 0 : a3.scale, rotation: null == (s4 = i3.current) ? void 0 : s4.rotation, autoActivate: null == (l4 = i3.current) ? void 0 : l4.autoActivate }).wait((e5) => {
            var t3;
            null == (t3 = o3.current) || t3.resolve(e5);
          }, (e5) => {
            var t3;
            null == (t3 = o3.current) || t3.fail(e5);
          });
        } });
      }).build();
      Vr = "commands";
      Zr = { id: Vr, name: "Commands Plugin", version: "1.0.0", provides: ["commands"], requires: [], optional: ["i18n"], defaultConfig: { commands: {} } };
      Kr = "COMMANDS/SET_DISABLED_CATEGORIES";
      Yr = (e3) => ({ type: Kr, payload: e3 });
      Xr = class extends Yn {
        constructor(e3, t2, n3) {
          var o3;
          super(e3, t2), this.commands = /* @__PURE__ */ new Map(), this.i18n = null, this.shortcutMap = /* @__PURE__ */ new Map(), this.commandExecuted$ = ro(), this.commandStateChanged$ = ro(), this.shortcutExecuted$ = ro(), this.categoryChanged$ = ao(), this.previousStates = /* @__PURE__ */ new Map();
          const i3 = t2.getPlugin("i18n");
          this.i18n = (null == i3 ? void 0 : i3.provides()) ?? null, (null == (o3 = n3.disabledCategories) ? void 0 : o3.length) && this.dispatch(Yr(n3.disabledCategories)), Object.values(n3.commands).forEach((e4) => {
            this.registerCommand(e4);
          }), this.registry.getStore().subscribe((e4, t3) => {
            this.onGlobalStoreChange(t3);
          });
        }
        onDocumentClosed(e3) {
          this.previousStates.delete(e3), this.logger.debug("CommandsPlugin", "DocumentClosed", `Cleaned up command state cache for document: ${e3}`);
        }
        async initialize() {
          this.logger.info("CommandsPlugin", "Initialize", "Commands plugin initialized");
        }
        async destroy() {
          this.commandExecuted$.clear(), this.commandStateChanged$.clear(), this.shortcutExecuted$.clear(), this.categoryChanged$.clear(), this.commands.clear(), this.shortcutMap.clear(), this.previousStates.clear(), super.destroy();
        }
        disableCategoryImpl(e3) {
          const t2 = new Set(this.state.disabledCategories);
          t2.has(e3) || (t2.add(e3), this.dispatch(Yr(Array.from(t2))), this.categoryChanged$.emit({ disabledCategories: Array.from(t2) }));
        }
        enableCategoryImpl(e3) {
          const t2 = new Set(this.state.disabledCategories);
          t2.has(e3) && (t2.delete(e3), this.dispatch(Yr(Array.from(t2))), this.categoryChanged$.emit({ disabledCategories: Array.from(t2) }));
        }
        toggleCategoryImpl(e3) {
          this.state.disabledCategories.includes(e3) ? this.enableCategoryImpl(e3) : this.disableCategoryImpl(e3);
        }
        setDisabledCategoriesImpl(e3) {
          this.dispatch(Yr(e3)), this.categoryChanged$.emit({ disabledCategories: e3 });
        }
        isCommandCategoryDisabled(e3) {
          var t2;
          return !!(null == (t2 = e3.categories) ? void 0 : t2.length) && e3.categories.some((e4) => this.state.disabledCategories.includes(e4));
        }
        buildCapability() {
          return { resolve: (e3, t2) => this.resolve(e3, t2), execute: (e3, t2, n3 = "ui") => this.execute(e3, t2, n3), getAllCommands: (e3) => this.getAllCommands(e3), getCommandsByCategory: (e3, t2) => this.getCommandsByCategory(e3, t2), getCommandByShortcut: (e3) => this.getCommandByShortcut(e3), getAllShortcuts: () => new Map(this.shortcutMap), forDocument: (e3) => this.createCommandScope(e3), registerCommand: (e3) => this.registerCommand(e3), unregisterCommand: (e3) => this.unregisterCommand(e3), disableCategory: (e3) => this.disableCategoryImpl(e3), enableCategory: (e3) => this.enableCategoryImpl(e3), toggleCategory: (e3) => this.toggleCategoryImpl(e3), setDisabledCategories: (e3) => this.setDisabledCategoriesImpl(e3), getDisabledCategories: () => this.state.disabledCategories, isCategoryDisabled: (e3) => this.state.disabledCategories.includes(e3), onCommandExecuted: this.commandExecuted$.on, onCommandStateChanged: this.commandStateChanged$.on, onShortcutExecuted: this.shortcutExecuted$.on, onCategoryChanged: this.categoryChanged$.on };
        }
        createCommandScope(e3) {
          return { resolve: (t2) => this.resolve(t2, e3), execute: (t2, n3 = "ui") => this.execute(t2, e3, n3), getAllCommands: () => this.getAllCommands(e3), getCommandsByCategory: (t2) => this.getCommandsByCategory(t2, e3), onCommandStateChanged: (t2) => this.commandStateChanged$.on((n3) => {
            if (n3.documentId === e3) {
              const { documentId: e4, ...o3 } = n3;
              t2(o3);
            }
          }) };
        }
        resolve(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = this.commands.get(e3);
          if (!o3) throw new Error(`Command not found: ${e3}`);
          const i3 = this.registry.getStore().getState(), r2 = this.resolveLabel(o3, i3, n3), a3 = o3.shortcuts ? Array.isArray(o3.shortcuts) ? o3.shortcuts : [o3.shortcuts] : void 0, s4 = this.resolveDynamic(o3.disabled, i3, n3) ?? false, l4 = this.isCommandCategoryDisabled(o3), c4 = s4 || l4;
          return { id: o3.id, label: r2, icon: this.resolveDynamic(o3.icon, i3, n3), iconProps: this.resolveDynamic(o3.iconProps, i3, n3), active: this.resolveDynamic(o3.active, i3, n3) ?? false, disabled: c4, visible: this.resolveDynamic(o3.visible, i3, n3) ?? true, shortcuts: a3, shortcutLabel: o3.shortcutLabel, categories: o3.categories, description: o3.description, execute: () => o3.action({ registry: this.registry, state: i3, documentId: n3 }) };
        }
        resolveLabel(e3, t2, n3) {
          if (e3.labelKey && this.i18n) {
            const o3 = this.resolveDynamic(e3.labelParams, t2, n3);
            return this.i18n.t(e3.labelKey, { params: o3, documentId: n3 });
          }
          return e3.label ? e3.label : e3.id;
        }
        resolveDynamic(e3, t2, n3) {
          if (void 0 !== e3) return "function" == typeof e3 ? e3({ state: t2, documentId: n3 }) : e3;
        }
        execute(e3, t2, n3 = "ui") {
          const o3 = t2 ?? this.getActiveDocumentId(), i3 = this.resolve(e3, o3);
          i3.disabled ? this.logger.warn("CommandsPlugin", "ExecutionBlocked", `Command '${e3}' is disabled for document '${o3}'`) : i3.visible ? (i3.execute(), this.commandExecuted$.emit({ commandId: e3, documentId: o3, source: n3 }), this.logger.debug("CommandsPlugin", "CommandExecuted", `Command '${e3}' executed for document '${o3}' (source: ${n3})`)) : this.logger.warn("CommandsPlugin", "ExecutionBlocked", `Command '${e3}' is not visible for document '${o3}'`);
        }
        registerCommand(e3) {
          if (this.commands.has(e3.id) && this.logger.warn("CommandsPlugin", "CommandOverwrite", `Command '${e3.id}' already exists and will be overwritten`), this.commands.set(e3.id, e3), e3.shortcuts) {
            (Array.isArray(e3.shortcuts) ? e3.shortcuts : [e3.shortcuts]).forEach((t2) => {
              const n3 = this.normalizeShortcut(t2);
              this.shortcutMap.set(n3, e3.id);
            });
          }
          this.logger.debug("CommandsPlugin", "CommandRegistered", `Command '${e3.id}' registered`);
        }
        unregisterCommand(e3) {
          const t2 = this.commands.get(e3);
          if (t2) {
            if (t2.shortcuts) {
              (Array.isArray(t2.shortcuts) ? t2.shortcuts : [t2.shortcuts]).forEach((e4) => {
                const t3 = this.normalizeShortcut(e4);
                this.shortcutMap.delete(t3);
              });
            }
            this.commands.delete(e3), this.logger.debug("CommandsPlugin", "CommandUnregistered", `Command '${e3}' unregistered`);
          }
        }
        getCommandByShortcut(e3) {
          const t2 = this.normalizeShortcut(e3), n3 = this.shortcutMap.get(t2);
          return n3 ? this.commands.get(n3) ?? null : null;
        }
        normalizeShortcut(e3) {
          return e3.toLowerCase().split("+").sort().join("+");
        }
        getAllCommands(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          return Array.from(this.commands.keys()).map((e4) => this.resolve(e4, t2));
        }
        getCommandsByCategory(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId();
          return Array.from(this.commands.values()).filter((t3) => {
            var n4;
            return null == (n4 = t3.categories) ? void 0 : n4.includes(e3);
          }).map((e4) => this.resolve(e4.id, n3));
        }
        onGlobalStoreChange(e3) {
          Object.keys(e3.core.documents).forEach((t2) => {
            this.detectCommandChanges(t2, e3);
          });
        }
        detectCommandChanges(e3, t2) {
          const n3 = this.previousStates.get(e3) ?? /* @__PURE__ */ new Map();
          this.commands.forEach((t3, o3) => {
            const i3 = this.resolve(o3, e3), r2 = n3.get(o3);
            if (!r2) return void n3.set(o3, i3);
            const a3 = {};
            r2.active !== i3.active && (a3.active = i3.active), r2.disabled !== i3.disabled && (a3.disabled = i3.disabled), r2.visible !== i3.visible && (a3.visible = i3.visible), r2.label !== i3.label && (a3.label = i3.label), to(r2.iconProps, i3.iconProps) || (a3.iconProps = i3.iconProps), Object.keys(a3).length > 0 && (n3.set(o3, i3), this.commandStateChanged$.emit({ commandId: o3, documentId: e3, changes: a3 }));
          }), this.previousStates.set(e3, n3);
        }
      };
      Xr.id = "commands";
      Qr = Xr;
      Jr = { disabledCategories: [] };
      ea = () => po(Qr.id);
      ta = (e3, t2) => {
        const { provides: n3 } = ea(), [o3, i3] = ke(() => n3 ? n3.resolve(e3, t2) : null);
        return Me(() => {
          if (!n3) return void i3(null);
          i3(n3.resolve(e3, t2));
          return n3.onCommandStateChanged((o4) => {
            o4.commandId === e3 && o4.documentId === t2 && i3(n3.resolve(e3, t2));
          });
        }, [n3, e3, t2]), o3;
      };
      na = co({ manifest: Zr, create: (e3, t2) => new Qr(Vr, e3, t2), reducer: (e3 = Jr, t2) => t2.type === Kr ? { ...e3, disabledCategories: t2.payload } : e3, initialState: Jr }).addUtility(function() {
        const { provides: e3 } = ea();
        return Me(() => {
          if (!e3) return;
          const t2 = /* @__PURE__ */ (function(e4) {
            return (t3) => {
              const n3 = t3.composedPath()[0] || t3.target;
              if ("INPUT" === n3.tagName || "TEXTAREA" === n3.tagName || n3.isContentEditable) return;
              const o3 = (function(e5) {
                const t4 = [];
                e5.ctrlKey && t4.push("ctrl"), e5.shiftKey && t4.push("shift"), e5.altKey && t4.push("alt"), e5.metaKey && t4.push("meta");
                const n4 = e5.key.toLowerCase();
                return ["control", "shift", "alt", "meta"].includes(n4) ? null : [...t4, n4].sort().join("+");
              })(t3);
              if (!o3) return;
              const i3 = e4.getCommandByShortcut(o3);
              if (!i3) return;
              const r2 = e4.resolve(i3.id);
              !r2.disabled && r2.visible && (t3.preventDefault(), t3.stopPropagation(), e4.execute(i3.id, void 0, "keyboard"));
            };
          })(e3);
          return document.addEventListener("keydown", t2), () => document.removeEventListener("keydown", t2);
        }, [e3]), null;
      }).build();
      oa = "i18n";
      ia = { id: oa, name: "I18n Plugin", version: "1.0.0", provides: ["i18n"], requires: [], optional: [], defaultConfig: { defaultLocale: "en", locales: [{ code: "en", name: "English", translations: { commands: { zoom: { in: "Zoom In", out: "Zoom Out", fitWidth: "Fit to Width", fitPage: "Fit to Page", automatic: "Automatic", level: "Zoom Level ({level}%)", inArea: "Zoom In Area" }, fullscreen: { enter: "Enter Full Screen", exit: "Exit Full Screen" }, rotate: { clockwise: "Rotate Clockwise", counterclockwise: "Rotate Counter-Clockwise" }, menu: "Menu", sidebar: "Sidebar", search: "Search", comment: "Comment", download: "Download", print: "Print", openFile: "Open PDF", save: "Save", settings: "Settings", view: "View", annotate: "Annotate", shapes: "Shapes", redact: "Redact", fillAndSign: "Fill and Sign", form: "Form", pan: "Pan", pointer: "Pointer", undo: "Undo", redo: "Redo", copy: "Copy", screenshot: "Screenshot", nextPage: "Next Page", previousPage: "Previous Page" } } }, { code: "es", name: "Espa\xF1ol", translations: { commands: { zoom: { in: "Acercar", out: "Alejar", fitWidth: "Ajustar al ancho", fitPage: "Ajustar a la p\xE1gina", automatic: "Autom\xE1tico", level: "Nivel de zoom ({level}%)", inArea: "Acercar \xE1rea" }, fullscreen: { enter: "Pantalla completa", exit: "Salir de pantalla completa" }, rotate: { clockwise: "Girar a la derecha", counterclockwise: "Girar a la izquierda" }, menu: "Men\xFA", sidebar: "Barra lateral", search: "Buscar", comment: "Comentario", download: "Descargar", print: "Imprimir", openFile: "Abrir PDF", save: "Guardar", settings: "Configuraci\xF3n", view: "Ver", annotate: "Anotar", shapes: "Formas", redact: "Redactar", fillAndSign: "Rellenar y firmar", form: "Formulario", pan: "Desplazar", pointer: "Puntero", undo: "Deshacer", redo: "Rehacer", copy: "Copiar", screenshot: "Captura de pantalla", nextPage: "P\xE1gina siguiente", previousPage: "P\xE1gina anterior" } } }] } };
      ra = "I18N/SET_LOCALE";
      aa = "I18N/REGISTER_LOCALE";
      sa = (e3) => ({ type: ra, payload: e3 });
      la = (e3) => ({ type: aa, payload: e3 });
      ca = class extends Yn {
        constructor(e3, t2, n3) {
          super(e3, t2), this.locales = /* @__PURE__ */ new Map(), this.paramResolvers = /* @__PURE__ */ new Map(), this.paramsCache = /* @__PURE__ */ new Map(), this.localeChange$ = ro(), this.paramsChanged$ = so((e4, t3) => ({ documentId: e4, ...t3 }), { cache: false }), this.config = n3, n3.locales.forEach((e4) => {
            this.locales.set(e4.code, e4), this.dispatch(la(e4.code));
          }), n3.paramResolvers && Object.entries(n3.paramResolvers).forEach(([e4, t3]) => {
            this.paramResolvers.set(e4, t3);
          }), this.dispatch(sa(n3.defaultLocale)), this.registry.getStore().subscribe((e4, t3) => {
            this.detectParamChanges(t3);
          });
        }
        async initialize() {
          this.logger.info("I18nPlugin", "Initialize", "I18n plugin initialized");
        }
        async destroy() {
          this.localeChange$.clear(), this.paramsChanged$.clear(), this.paramResolvers.clear(), this.paramsCache.clear(), super.destroy();
        }
        onDocumentClosed(e3) {
          this.paramsCache.delete(e3), this.paramsChanged$.clearScope(e3), this.logger.debug("I18nPlugin", "DocumentClosed", `Cleaned up params cache for document: ${e3}`);
        }
        buildCapability() {
          return { t: (e3, t2) => this.translate(e3, t2), forDocument: (e3) => this.createI18nScope(e3), registerParamResolver: (e3, t2) => this.registerParamResolver(e3, t2), unregisterParamResolver: (e3) => this.unregisterParamResolver(e3), setLocale: (e3) => this.setLocale(e3), getLocale: () => this.state.currentLocale, getAvailableLocales: () => [...this.state.availableLocales], getLocaleInfo: (e3) => this.locales.get(e3) ?? null, registerLocale: (e3) => this.registerLocale(e3), hasLocale: (e3) => this.locales.has(e3), onLocaleChange: this.localeChange$.on, onParamsChanged: this.paramsChanged$.onGlobal };
        }
        createI18nScope(e3) {
          return { t: (t2, n3) => this.translate(t2, { documentId: e3, ...n3 }), onParamsChanged: this.paramsChanged$.forScope(e3) };
        }
        translate(e3, t2) {
          const n3 = this.locales.get(this.state.currentLocale), o3 = this.config.fallbackLocale ? this.locales.get(this.config.fallbackLocale) : null;
          let i3 = this.getNestedValue(null == n3 ? void 0 : n3.translations, e3);
          if (!i3 && o3 && (i3 = this.getNestedValue(o3.translations, e3)), !i3) {
            if (!(null == t2 ? void 0 : t2.fallback)) return this.logger.warn("I18nPlugin", "MissingTranslation", `Translation not found for key: ${e3}`), e3;
            i3 = t2.fallback;
          }
          let r2 = null == t2 ? void 0 : t2.params;
          return !r2 && this.paramResolvers.has(e3) && (r2 = this.resolveParams(e3, null == t2 ? void 0 : t2.documentId)), this.interpolate(i3, r2);
        }
        resolveParams(e3, t2) {
          const n3 = this.paramResolvers.get(e3);
          if (!n3) return;
          const o3 = this.registry.getStore().getState();
          try {
            return n3({ state: o3, documentId: t2 });
          } catch (t3) {
            return void this.logger.error("I18nPlugin", "ParamResolverError", `Error resolving params for key "${e3}":`, t3);
          }
        }
        getNestedValue(e3, t2) {
          if (!e3) return;
          const n3 = t2.split(".");
          let o3 = e3;
          for (const e4 of n3) {
            if (null == o3) return;
            o3 = o3[e4];
          }
          return "string" == typeof o3 ? o3 : void 0;
        }
        interpolate(e3, t2) {
          return t2 ? e3.replace(/\{(\w+)\}/g, (e4, n3) => {
            const o3 = t2[n3];
            return void 0 !== o3 ? String(o3) : e4;
          }) : e3;
        }
        detectParamChanges(e3) {
          Object.keys(e3.core.documents).forEach((t2) => {
            this.detectDocumentParamChanges(t2, e3);
          });
        }
        detectDocumentParamChanges(e3, t2) {
          const n3 = this.paramsCache.get(e3), o3 = [];
          this.paramResolvers.forEach((i3, r2) => {
            try {
              const a3 = i3({ state: t2, documentId: e3 });
              to(null == n3 ? void 0 : n3.get(r2), a3) || (o3.push(r2), this.paramsCache.has(e3) || this.paramsCache.set(e3, /* @__PURE__ */ new Map()), this.paramsCache.get(e3).set(r2, a3));
            } catch (e4) {
              this.logger.error("I18nPlugin", "ParamDetectionError", `Error detecting param changes for key "${r2}":`, e4);
            }
          }), o3.length > 0 && (this.paramsChanged$.emit(e3, { changedKeys: o3 }), this.logger.debug("I18nPlugin", "ParamsChanged", `Translation params changed for document ${e3}:`, o3));
        }
        registerParamResolver(e3, t2) {
          this.paramResolvers.has(e3) && this.logger.warn("I18nPlugin", "ResolverOverwrite", `Param resolver for "${e3}" already exists and will be overwritten`), this.paramResolvers.set(e3, t2), this.paramsCache.forEach((t3) => {
            t3.delete(e3);
          }), this.logger.debug("I18nPlugin", "ResolverRegistered", `Param resolver registered for: ${e3}`);
        }
        unregisterParamResolver(e3) {
          this.paramResolvers.delete(e3) && (this.paramsCache.forEach((t2) => {
            t2.delete(e3);
          }), this.logger.debug("I18nPlugin", "ResolverUnregistered", `Param resolver unregistered for: ${e3}`));
        }
        setLocale(e3) {
          if (!this.locales.has(e3)) return void this.logger.warn("I18nPlugin", "LocaleNotFound", `Locale '${e3}' is not registered`);
          const t2 = this.state.currentLocale;
          t2 !== e3 && (this.dispatch(sa(e3)), this.localeChange$.emit({ previousLocale: t2, currentLocale: e3 }), this.logger.info("I18nPlugin", "LocaleChanged", `Locale changed to: ${e3}`));
        }
        registerLocale(e3) {
          this.locales.has(e3.code) ? this.logger.warn("I18nPlugin", "LocaleAlreadyRegistered", `Locale '${e3.code}' is already registered`) : (this.locales.set(e3.code, e3), this.dispatch(la(e3.code)), this.logger.info("I18nPlugin", "LocaleRegistered", `Locale registered: ${e3.code}`));
        }
      };
      ca.id = "i18n";
      da = ca;
      ua = { currentLocale: "en", availableLocales: [] };
      ha = { manifest: ia, create: (e3, t2) => new da(oa, e3, t2), reducer: (e3 = ua, t2) => {
        switch (t2.type) {
          case ra: {
            const n3 = t2.payload;
            return e3.availableLocales.includes(n3) ? { ...e3, currentLocale: n3 } : (console.warn(`I18nPlugin: Locale '${n3}' not available`), e3);
          }
          case aa: {
            const n3 = t2.payload;
            return e3.availableLocales.includes(n3) ? e3 : { ...e3, availableLocales: [...e3.availableLocales, n3] };
          }
          default:
            return e3;
        }
      }, initialState: ua };
      ma = (e3) => {
        const { provides: t2 } = po(da.id), [, n3] = De((e4) => e4 + 1, 0), o3 = ze((n4, o4) => t2 ? t2.t(n4, { documentId: e3, params: null == o4 ? void 0 : o4.params, fallback: null == o4 ? void 0 : o4.fallback }) : (null == o4 ? void 0 : o4.fallback) ?? n4, [t2, e3]);
        return Me(() => {
          if (!t2) return;
          const o4 = t2.onLocaleChange(() => {
            n3();
          }), i3 = e3 ? t2.forDocument(e3).onParamsChanged(() => {
            n3();
          }) : t2.onParamsChanged(() => {
            n3();
          });
          return () => {
            o4(), i3();
          };
        }, [t2, e3]), { translate: o3, locale: (null == t2 ? void 0 : t2.getLocale()) ?? "en" };
      };
      ga = ((e3) => (e3.Automatic = "automatic", e3.FitPage = "fit-page", e3.FitWidth = "fit-width", e3))(ga || {});
      pa = ((e3) => (e3[e3.Center = 0] = "Center", e3[e3.Top = 1] = "Top", e3))(pa || {});
      va = "zoom";
      fa = { id: va, name: "Zoom Plugin", version: "1.0.0", provides: ["zoom"], requires: ["viewport", "scroll"], optional: ["interaction-manager", "spread"], defaultConfig: { defaultZoomLevel: ga.Automatic, minZoom: 0.2, maxZoom: 60, zoomStep: 0.1, zoomRanges: [{ min: 0.2, max: 0.5, step: 0.05 }, { min: 0.5, max: 1, step: 0.1 }, { min: 1, max: 2, step: 0.2 }, { min: 2, max: 4, step: 0.4 }, { min: 4, max: 10, step: 0.8 }, { min: 10, max: 20, step: 1.6 }, { min: 20, max: 40, step: 3.2 }, { min: 40, max: 60, step: 6.4 }], presets: [{ name: "Fit Page", value: ga.FitPage }, { name: "Fit Width", value: ga.FitWidth }, { name: "Automatic", value: ga.Automatic }, { name: "25%", value: 0.25 }, { name: "50%", value: 0.5 }, { name: "100%", value: 1 }, { name: "125%", value: 1.25 }, { name: "150%", value: 1.5 }, { name: "200%", value: 2 }, { name: "400%", value: 4 }, { name: "800%", value: 8 }, { name: "1600%", value: 16 }] } };
      ya = "ZOOM/INIT_STATE";
      ba = "ZOOM/CLEANUP_STATE";
      wa = "ZOOM/SET_ZOOM_LEVEL";
      xa = "ZOOM/SET_MARQUEE_ZOOM_ACTIVE";
      Ca = { zoomLevel: ga.Automatic, currentZoomLevel: 1, isMarqueeZoomActive: false };
      Ia = { documents: {}, activeDocumentId: null };
      Sa = class extends Yn {
        constructor(e3, t2, n3) {
          var o3, i3, r2;
          super(e3, t2), this.zoom$ = ro(), this.state$ = ao(), this.viewportPlugin = t2.getPlugin("viewport"), this.viewport = this.viewportPlugin.provides(), this.scroll = t2.getPlugin("scroll").provides();
          const a3 = t2.getPlugin("interaction-manager");
          this.interactionManager = (null == a3 ? void 0 : a3.provides()) ?? null;
          const s4 = t2.getPlugin("spread");
          this.spread = (null == s4 ? void 0 : s4.provides()) ?? null, this.minZoom = n3.minZoom ?? 0.25, this.maxZoom = n3.maxZoom ?? 10, this.zoomStep = n3.zoomStep ?? 0.1, this.defaultZoomLevel = n3.defaultZoomLevel, this.presets = n3.presets ?? [], this.zoomRanges = this.normalizeRanges(n3.zoomRanges ?? []), this.viewport.onViewportResize((e4) => this.recalcAuto(e4.documentId, pa.Top), { mode: "debounce", wait: 150, keyExtractor: (e4) => e4.documentId }), null == (o3 = this.spread) || o3.onSpreadChange((e4) => {
            this.recalcAuto(e4.documentId, pa.Top);
          }), null == (i3 = this.interactionManager) || i3.registerMode({ id: "marqueeZoom", scope: "page", exclusive: true, cursor: "zoom-in" }), null == (r2 = this.interactionManager) || r2.onModeChange((e4) => {
            const t3 = "marqueeZoom" === e4.activeMode, n4 = this.getDocumentState(e4.documentId);
            var o4;
            n4 && n4.isMarqueeZoomActive !== t3 && this.dispatch((o4 = e4.documentId, { type: xa, payload: { documentId: o4, isActive: t3 } }));
          });
        }
        onDocumentLoadingStarted(e3) {
          this.viewport.gate("zoom", e3);
          const t2 = { ...Ca, zoomLevel: this.defaultZoomLevel };
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: ya, payload: { documentId: e4, state: t3 } };
          })(e3, t2)), this.logger.debug("ZoomPlugin", "DocumentOpened", `Initialized zoom state for document: ${e3}`);
        }
        onDocumentLoaded(e3) {
          this.recalcAuto(e3, pa.Top);
        }
        onDocumentClosed(e3) {
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: ba, payload: e4 };
          })(e3)), this.logger.debug("ZoomPlugin", "DocumentClosed", `Cleaned up zoom state for document: ${e3}`);
        }
        onRotationChanged(e3) {
          this.recalcAuto(e3, pa.Top);
        }
        buildCapability() {
          return { requestZoom: (e3, t2) => this.requestZoom(e3, t2), requestZoomBy: (e3, t2) => this.requestZoomBy(e3, t2), zoomIn: () => this.zoomIn(), zoomOut: () => this.zoomOut(), zoomToArea: (e3, t2) => this.zoomToArea(e3, t2), enableMarqueeZoom: () => this.enableMarqueeZoom(), disableMarqueeZoom: () => this.disableMarqueeZoom(), toggleMarqueeZoom: () => this.toggleMarqueeZoom(), isMarqueeZoomActive: () => this.isMarqueeZoomActive(), getState: () => this.getDocumentStateOrThrow(), forDocument: (e3) => this.createZoomScope(e3), registerMarqueeOnPage: (e3) => this.registerMarqueeOnPage(e3), getPresets: () => this.presets, onZoomChange: this.zoom$.on, onStateChange: this.state$.on };
        }
        createZoomScope(e3) {
          return { requestZoom: (t2, n3) => this.requestZoom(t2, n3, e3), requestZoomBy: (t2, n3) => this.requestZoomBy(t2, n3, e3), zoomIn: () => this.zoomIn(e3), zoomOut: () => this.zoomOut(e3), zoomToArea: (t2, n3) => this.zoomToArea(t2, n3, e3), enableMarqueeZoom: () => this.enableMarqueeZoom(e3), disableMarqueeZoom: () => this.disableMarqueeZoom(e3), toggleMarqueeZoom: () => this.toggleMarqueeZoom(e3), isMarqueeZoomActive: () => this.isMarqueeZoomActive(e3), getState: () => this.getDocumentStateOrThrow(e3), onZoomChange: (t2) => this.zoom$.on((n3) => {
            n3.documentId === e3 && t2(n3);
          }), onStateChange: (t2) => this.state$.on((n3) => {
            n3.documentId === e3 && t2(n3.state);
          }) };
        }
        getDocumentState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          return this.state.documents[t2] ?? null;
        }
        getDocumentStateOrThrow(e3) {
          const t2 = this.getDocumentState(e3);
          if (!t2) throw new Error(`Zoom state not found for document: ${e3 ?? "active"}`);
          return t2;
        }
        requestZoom(e3, t2, n3) {
          this.handleRequest({ level: e3, center: t2 }, n3);
        }
        requestZoomBy(e3, t2, n3) {
          const o3 = n3 ?? this.getActiveDocumentId(), i3 = this.getDocumentStateOrThrow(o3).currentZoomLevel, r2 = this.toZoom(i3 + e3);
          this.handleRequest({ level: r2, center: t2 }, o3);
        }
        zoomIn(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.getDocumentStateOrThrow(t2).currentZoomLevel;
          this.handleRequest({ level: n3, delta: this.stepFor(n3) }, t2);
        }
        zoomOut(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.getDocumentStateOrThrow(t2).currentZoomLevel;
          this.handleRequest({ level: n3, delta: -this.stepFor(n3) }, t2);
        }
        zoomToArea(e3, t2, n3) {
          const o3 = n3 ?? this.getActiveDocumentId();
          this.handleZoomToArea(o3, e3, t2);
        }
        enableMarqueeZoom(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          null == (t2 = this.interactionManager) || t2.forDocument(n3).activate("marqueeZoom");
        }
        disableMarqueeZoom(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          null == (t2 = this.interactionManager) || t2.forDocument(n3).activateDefaultMode();
        }
        toggleMarqueeZoom(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId(), o3 = null == (t2 = this.interactionManager) ? void 0 : t2.forDocument(n3);
          "marqueeZoom" === (null == o3 ? void 0 : o3.getActiveMode()) ? o3.activateDefaultMode() : null == o3 || o3.activate("marqueeZoom");
        }
        isMarqueeZoomActive(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          return "marqueeZoom" === (null == (t2 = this.interactionManager) ? void 0 : t2.forDocument(n3).getActiveMode());
        }
        handleRequest({ level: e3, delta: t2 = 0, center: n3, focus: o3 = pa.Center, align: i3 = "keep" }, r2) {
          const a3 = r2 ?? this.getActiveDocumentId(), s4 = this.getDocumentStateOrThrow(a3);
          if (!this.coreState.core.documents[a3]) return;
          const l4 = this.viewport.forDocument(a3), c4 = l4.getMetrics(), d4 = s4.currentZoomLevel;
          if (0 === c4.clientWidth || 0 === c4.clientHeight) return;
          const u4 = "number" == typeof e3 ? e3 : this.computeZoomForMode(a3, e3, c4);
          if (false === u4) return;
          const h3 = eo(u4 + t2, this.minZoom, this.maxZoom), m3 = Math.floor(1e3 * h3) / 1e3, g3 = n3 ?? { vx: c4.clientWidth / 2, vy: o3 === pa.Top ? 0 : c4.clientHeight / 2 }, { desiredScrollLeft: p4, desiredScrollTop: v2 } = this.computeScrollForZoomChange(a3, c4, d4, m3, g3, i3);
          isNaN(p4) || isNaN(v2) || this.viewportPlugin.setViewportScrollMetrics(a3, { scrollLeft: p4, scrollTop: v2 }), this.dispatch(/* @__PURE__ */ (function(e4, t3, n4) {
            return { type: wa, payload: { documentId: e4, zoomLevel: t3, currentZoomLevel: n4 } };
          })(a3, "number" == typeof e3 ? m3 : e3, m3)), this.dispatchCoreAction(/* @__PURE__ */ ((e4, t3) => ({ type: Ln, payload: { scale: e4, documentId: t3 } }))(m3, a3)), this.viewport.isGated(a3) && this.viewport.releaseGate("zoom", a3), l4.scrollTo({ x: p4, y: v2, behavior: "instant" });
          const f2 = { documentId: a3, oldZoom: d4, newZoom: m3, level: e3, center: g3, desiredScrollLeft: p4, desiredScrollTop: v2, viewport: c4 };
          this.zoom$.emit(f2);
        }
        computeZoomForMode(e3, t2, n3) {
          if (!this.coreState.core.documents[e3]) return false;
          const o3 = this.scroll.forDocument(e3), i3 = o3 ? this.scroll.getPageGap() : 0, r2 = this.viewport.getViewportGap(), a3 = o3.getSpreadPagesWithRotatedSize();
          if (!a3.length) return false;
          if (0 === n3.clientWidth || 0 === n3.clientHeight) return false;
          const s4 = n3.clientWidth - 2 * r2, l4 = n3.clientHeight - 2 * r2;
          if (s4 <= 0 || l4 <= 0) return false;
          let c4 = 0, d4 = 0;
          switch (a3.forEach((e4) => {
            const t3 = e4.reduce((e5, t4, n5) => e5 + t4.rotatedSize.width + (n5 ? i3 : 0), 0), n4 = Math.max(...e4.map((e5) => e5.rotatedSize.height));
            c4 = Math.max(c4, t3), d4 = Math.max(d4, n4);
          }), t2) {
            case ga.FitWidth:
              return s4 / c4;
            case ga.FitPage:
              return Math.min(s4 / c4, l4 / d4);
            case ga.Automatic:
              return Math.min(s4 / c4, 1);
            default:
              return 1;
          }
        }
        computeScrollForZoomChange(e3, t2, n3, o3, i3, r2 = "keep") {
          const a3 = this.scroll.forDocument(e3).getLayout(), s4 = this.viewport.getViewportGap(), l4 = a3.totalContentSize.width, c4 = a3.totalContentSize.height, d4 = t2.clientWidth - 2 * s4, u4 = t2.clientHeight - 2 * s4, h3 = (e4, t3, n4) => t3 * n4 < e4 ? (e4 - t3 * n4) / 2 : 0, m3 = h3(d4, l4, n3), g3 = h3(u4, c4, n3), p4 = h3(d4, l4, o3), v2 = h3(u4, c4, o3), f2 = (t2.scrollLeft + i3.vx - s4 - m3) / n3 * o3 + s4 + p4, y2 = (t2.scrollTop + i3.vy - s4 - g3) / n3 * o3 + s4 + v2, b2 = "center" === r2 ? f2 - t2.clientWidth / 2 : f2 - i3.vx, w2 = "center" === r2 ? y2 - t2.clientHeight / 2 : y2 - i3.vy;
          return { desiredScrollLeft: Math.max(0, b2), desiredScrollTop: Math.max(0, w2) };
        }
        handleZoomToArea(e3, t2, n3) {
          const o3 = this.coreState.core.documents[e3];
          if (!o3) return;
          const i3 = o3.rotation, r2 = this.viewport.forDocument(e3).getMetrics(), a3 = this.viewport.getViewportGap(), s4 = this.getDocumentStateOrThrow(e3).currentZoomLevel, l4 = r2.clientWidth - 2 * a3, c4 = r2.clientHeight - 2 * a3, d4 = this.scroll.forDocument(e3).getLayout(), u4 = d4.virtualItems.find((e4) => e4.pageLayouts.some((e5) => e5.pageIndex === t2));
          if (!u4) return;
          const h3 = u4.pageLayouts.find((e4) => e4.pageIndex === t2), m3 = tt({ width: h3.width, height: h3.height }, n3, i3), g3 = this.toZoom(Math.min(l4 / m3.size.width, c4 / m3.size.height)), p4 = u4.x + h3.x, v2 = u4.y + h3.y, f2 = p4 + m3.origin.x + m3.size.width / 2, y2 = v2 + m3.origin.y + m3.size.height / 2, b2 = (e4, t3, n4) => t3 * n4 < e4 ? (e4 - t3 * n4) / 2 : 0, w2 = b2(l4, d4.totalContentSize.width, s4), x2 = b2(c4, d4.totalContentSize.height, s4), C2 = a3 + w2 + f2 * s4 - r2.scrollLeft, I2 = a3 + x2 + y2 * s4 - r2.scrollTop;
          this.handleRequest({ level: g3, center: { vx: C2, vy: I2 }, align: "center" }, e3);
        }
        recalcAuto(e3, t2) {
          const n3 = this.getDocumentState(e3);
          n3 && (n3.zoomLevel !== ga.Automatic && n3.zoomLevel !== ga.FitPage && n3.zoomLevel !== ga.FitWidth || this.handleRequest({ level: n3.zoomLevel, focus: t2 }, e3));
        }
        normalizeRanges(e3) {
          return [...e3].filter((e4) => e4.step > 0 && e4.max > e4.min).sort((e4, t2) => e4.min - t2.min);
        }
        stepFor(e3) {
          const t2 = this.zoomRanges.find((t3) => e3 >= t3.min && e3 < t3.max);
          return t2 ? t2.step : this.zoomStep;
        }
        toZoom(e3) {
          return parseFloat(eo(e3, this.minZoom, this.maxZoom).toFixed(2));
        }
        registerMarqueeOnPage(e3) {
          if (!this.interactionManager) return this.logger.warn("ZoomPlugin", "MissingDependency", "Interaction manager plugin not loaded, marquee zoom disabled"), () => {
          };
          const t2 = this.coreState.core.documents[e3.documentId];
          if (!t2 || !t2.document) return this.logger.warn("ZoomPlugin", "DocumentNotFound", "Document not found"), () => {
          };
          const n3 = t2.document.pages[e3.pageIndex];
          if (!n3) return this.logger.warn("ZoomPlugin", "PageNotFound", `Page ${e3.pageIndex} not found`), () => {
          };
          const o3 = (function(e4) {
            const { pageSize: t3, scale: n4, minDragPx: o4 = 5, onPreview: i3, onCommit: r2, onSmallDrag: a3 } = e4;
            let s4 = null, l4 = null;
            return { onPointerDown: (e5, t4) => {
              var n5;
              s4 = e5, l4 = { origin: { x: e5.x, y: e5.y }, size: { width: 0, height: 0 } }, null == i3 || i3(l4), null == (n5 = t4.setPointerCapture) || n5.call(t4);
            }, onPointerMove: (e5) => {
              if (!s4) return;
              const n5 = eo(e5.x, 0, t3.width), o5 = eo(e5.y, 0, t3.height);
              l4 = { origin: { x: Math.min(s4.x, n5), y: Math.min(s4.y, o5) }, size: { width: Math.abs(n5 - s4.x), height: Math.abs(o5 - s4.y) } }, null == i3 || i3(l4);
            }, onPointerUp: (e5, t4) => {
              var c4;
              l4 && (Math.max(l4.size.width, l4.size.height) * n4 > o4 ? null == r2 || r2(l4) : null == a3 || a3()), s4 = null, l4 = null, null == i3 || i3(null), null == (c4 = t4.releasePointerCapture) || c4.call(t4);
            }, onPointerCancel: (e5, t4) => {
              var n5;
              s4 = null, l4 = null, null == i3 || i3(null), null == (n5 = t4.releasePointerCapture) || n5.call(t4);
            } };
          })({ pageSize: n3.size, scale: e3.scale, onPreview: e3.callback.onPreview, onCommit: (t3) => {
            var n4, o4;
            this.zoomToArea(e3.pageIndex, t3, e3.documentId), null == (o4 = (n4 = e3.callback).onCommit) || o4.call(n4, t3);
          }, onSmallDrag: () => {
            var t3, n4;
            this.zoomIn(e3.documentId), null == (n4 = (t3 = e3.callback).onSmallDrag) || n4.call(t3);
          } });
          return this.interactionManager.registerHandlers({ documentId: e3.documentId, modeId: "marqueeZoom", handlers: o3, pageIndex: e3.pageIndex });
        }
        onStoreUpdated(e3, t2) {
          for (const n3 in t2.documents) {
            const o3 = e3.documents[n3], i3 = t2.documents[n3];
            o3 && i3 && (o3.currentZoomLevel !== i3.currentZoomLevel || o3.zoomLevel !== i3.zoomLevel || o3.isMarqueeZoomActive !== i3.isMarqueeZoomActive) && this.state$.emit({ documentId: n3, state: i3 });
          }
        }
        async initialize() {
          this.logger.info("ZoomPlugin", "Initialize", "Zoom plugin initialized");
        }
        async destroy() {
          this.zoom$.clear(), this.state$.clear(), super.destroy();
        }
      };
      Sa.id = "zoom";
      ka = Sa;
      Da = { manifest: fa, create: (e3, t2) => new ka(va, e3, t2), reducer: (e3 = Ia, t2) => {
        switch (t2.type) {
          case ya: {
            const { documentId: n3, state: o3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: o3 }, activeDocumentId: e3.activeDocumentId ?? n3 };
          }
          case ba: {
            const n3 = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3, activeDocumentId: e3.activeDocumentId === n3 ? null : e3.activeDocumentId };
          }
          case "ZOOM/SET_ACTIVE_DOCUMENT":
            return { ...e3, activeDocumentId: t2.payload };
          case wa: {
            const { documentId: n3, zoomLevel: o3, currentZoomLevel: i3 } = t2.payload, r2 = e3.documents[n3];
            return r2 ? { ...e3, documents: { ...e3.documents, [n3]: { ...r2, zoomLevel: o3, currentZoomLevel: i3 } } } : e3;
          }
          case xa: {
            const { documentId: n3, isActive: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, isMarqueeZoomActive: o3 } } } : e3;
          }
          default:
            return e3;
        }
      }, initialState: Ia };
      Ma = () => po(ka.id);
      za = ({ documentId: e3, pageIndex: t2, scale: n3, className: o3, stroke: i3 = "rgba(33,150,243,0.8)", fill: r2 = "rgba(33,150,243,0.15)" }) => {
        const { provides: a3 } = Ma(), s4 = fo(e3), [l4, c4] = ke(null), d4 = Te(() => void 0 !== n3 ? n3 : (null == s4 ? void 0 : s4.scale) ?? 1, [n3, null == s4 ? void 0 : s4.scale]);
        return Me(() => {
          if (a3) return a3.registerMarqueeOnPage({ documentId: e3, pageIndex: t2, scale: d4, callback: { onPreview: c4 } });
        }, [a3, e3, t2, d4]), l4 ? Ue("div", { style: { position: "absolute", pointerEvents: "none", left: l4.origin.x * d4, top: l4.origin.y * d4, width: l4.size.width * d4, height: l4.size.height * d4, border: `1px solid ${i3}`, background: r2, boxSizing: "border-box" }, className: o3 }) : null;
      };
      Ea = class extends Yn {
        constructor(e3, t2, n3) {
          super(e3, t2), this.config = n3;
        }
        buildCapability() {
          return { renderPage: (e3) => this.renderPage(e3), renderPageRect: (e3) => this.renderPageRect(e3), forDocument: (e3) => this.createRenderScope(e3) };
        }
        createRenderScope(e3) {
          return { renderPage: (t2) => this.renderPage(t2, e3), renderPageRect: (t2) => this.renderPageRect(t2, e3) };
        }
        renderPage({ pageIndex: e3, options: t2 }, n3) {
          const o3 = n3 ?? this.getActiveDocumentId(), i3 = this.coreState.core.documents[o3];
          if (!(null == i3 ? void 0 : i3.document)) throw new Error(`Document ${o3} not loaded`);
          const r2 = i3.document.pages.find((t3) => t3.index === e3);
          if (!r2) throw new Error(`Page ${e3} not found in document ${o3}`);
          const a3 = { ...t2 ?? {}, withForms: (null == t2 ? void 0 : t2.withForms) ?? this.config.withForms ?? false, withAnnotations: (null == t2 ? void 0 : t2.withAnnotations) ?? this.config.withAnnotations ?? false, imageType: (null == t2 ? void 0 : t2.imageType) ?? this.config.defaultImageType ?? "image/png", imageQuality: (null == t2 ? void 0 : t2.imageQuality) ?? this.config.defaultImageQuality ?? 0.92 };
          return this.engine.renderPage(i3.document, r2, a3);
        }
        renderPageRect({ pageIndex: e3, rect: t2, options: n3 }, o3) {
          const i3 = o3 ?? this.getActiveDocumentId(), r2 = this.coreState.core.documents[i3];
          if (!(null == r2 ? void 0 : r2.document)) throw new Error(`Document ${i3} not loaded`);
          const a3 = r2.document.pages.find((t3) => t3.index === e3);
          if (!a3) throw new Error(`Page ${e3} not found in document ${i3}`);
          const s4 = { ...n3 ?? {}, withForms: (null == n3 ? void 0 : n3.withForms) ?? this.config.withForms ?? false, withAnnotations: (null == n3 ? void 0 : n3.withAnnotations) ?? this.config.withAnnotations ?? false, imageType: (null == n3 ? void 0 : n3.imageType) ?? this.config.defaultImageType ?? "image/png", imageQuality: (null == n3 ? void 0 : n3.imageQuality) ?? this.config.defaultImageQuality ?? 0.92 };
          return this.engine.renderPageRect(r2.document, a3, t2, s4);
        }
        async initialize(e3) {
          this.logger.info("RenderPlugin", "Initialize", "Render plugin initialized");
        }
        async destroy() {
          super.destroy();
        }
      };
      Ea.id = "render";
      _a = Ea;
      Ra = "render";
      Na = { manifest: { id: Ra, name: "Render Plugin", version: "1.0.0", provides: ["render"], requires: [], optional: [], defaultConfig: {} }, create: (e3, t2) => new _a(Ra, e3, t2), reducer: () => {
      }, initialState: {} };
      La = "rotate";
      $a = { id: La, name: "Rotate Plugin", version: "1.0.0", provides: ["rotate"], requires: [], optional: [], defaultConfig: {} };
      Fa = "ROTATE/INIT_STATE";
      ja = "ROTATE/CLEANUP_STATE";
      Ha = "ROTATE/SET_ROTATION";
      Ua = class extends Yn {
        constructor(e3, t2, n3) {
          super(e3, t2), this.rotate$ = ao(), this.defaultRotation = n3.defaultRotation ?? 0;
        }
        onDocumentLoadingStarted(e3) {
          const t2 = { rotation: this.defaultRotation };
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Fa, payload: { documentId: e4, state: t3 } };
          })(e3, t2)), this.dispatchCoreAction(Wn(this.defaultRotation, e3)), this.logger.debug("RotatePlugin", "DocumentOpened", `Initialized rotation state for document: ${e3}`);
        }
        onDocumentClosed(e3) {
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: ja, payload: e4 };
          })(e3)), this.logger.debug("RotatePlugin", "DocumentClosed", `Cleaned up rotation state for document: ${e3}`);
        }
        buildCapability() {
          return { setRotation: (e3) => this.setRotationForDocument(e3), getRotation: () => this.getRotationForDocument(), rotateForward: () => this.rotateForward(), rotateBackward: () => this.rotateBackward(), forDocument: (e3) => this.createRotateScope(e3), onRotateChange: this.rotate$.on };
        }
        createRotateScope(e3) {
          return { setRotation: (t2) => this.setRotationForDocument(t2, e3), getRotation: () => this.getRotationForDocument(e3), rotateForward: () => this.rotateForward(e3), rotateBackward: () => this.rotateBackward(e3), onRotateChange: (t2) => this.rotate$.on((n3) => {
            n3.documentId === e3 && t2(n3.rotation);
          }) };
        }
        getDocumentState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          return this.state.documents[t2] ?? null;
        }
        getDocumentStateOrThrow(e3) {
          const t2 = this.getDocumentState(e3);
          if (!t2) throw new Error(`Rotation state not found for document: ${e3 ?? "active"}`);
          return t2;
        }
        setRotationForDocument(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = this.coreState.core.documents[n3];
          if (!(null == o3 ? void 0 : o3.document)) throw new Error(`Document ${n3} not loaded`);
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Ha, payload: { documentId: e4, rotation: t3 } };
          })(n3, e3)), this.dispatchCoreAction(Wn(e3, n3)), this.rotate$.emit({ documentId: n3, rotation: e3 });
        }
        getRotationForDocument(e3) {
          return this.getDocumentStateOrThrow(e3).rotation;
        }
        rotateForward(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.getRotationForDocument(t2), o3 = (n3 + 1) % 4;
          this.setRotationForDocument(o3, t2);
        }
        rotateBackward(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.getRotationForDocument(t2), o3 = (n3 + 3) % 4;
          this.setRotationForDocument(o3, t2);
        }
        getMatrixAsString(e3) {
          return (function(e4, t2, n3) {
            const [o3, i3, r2, a3, s4, l4] = (function(e5, t3, n4) {
              let o4 = 1, i4 = 0, r3 = 0, a4 = 1, s5 = 0, l5 = 0;
              switch (e5) {
                case 1:
                  o4 = 0, i4 = 1, r3 = -1, a4 = 0, s5 = n4;
                  break;
                case 2:
                  o4 = -1, i4 = 0, r3 = 0, a4 = -1, s5 = t3, l5 = n4;
                  break;
                case 3:
                  o4 = 0, i4 = -1, r3 = 1, a4 = 0, l5 = t3;
              }
              return [o4, i4, r3, a4, s5, l5];
            })(e4, t2, n3);
            return `matrix(${o3},${i3},${r2},${a3},${s4},${l4})`;
          })(e3.rotation, e3.width, e3.height);
        }
        onStoreUpdated(e3, t2) {
          for (const n3 in t2.documents) {
            const o3 = e3.documents[n3], i3 = t2.documents[n3];
            (null == o3 ? void 0 : o3.rotation) !== i3.rotation && this.logger.debug("RotatePlugin", "RotationChanged", `Rotation changed for document ${n3}: ${(null == o3 ? void 0 : o3.rotation) ?? 0} -> ${i3.rotation}`);
          }
        }
        async initialize(e3) {
          this.logger.info("RotatePlugin", "Initialize", "Rotate plugin initialized");
        }
        async destroy() {
          this.rotate$.clear(), super.destroy();
        }
      };
      Ua.id = "rotate";
      Wa = Ua;
      Ba = { documents: {}, activeDocumentId: null };
      qa = { manifest: $a, create: (e3, t2) => new Wa(La, e3, t2), reducer: (e3 = Ba, t2) => {
        switch (t2.type) {
          case Fa: {
            const { documentId: n3, state: o3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: o3 }, activeDocumentId: e3.activeDocumentId ?? n3 };
          }
          case ja: {
            const n3 = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3, activeDocumentId: e3.activeDocumentId === n3 ? null : e3.activeDocumentId };
          }
          case "ROTATE/SET_ACTIVE_DOCUMENT":
            return { ...e3, activeDocumentId: t2.payload };
          case Ha: {
            const { documentId: n3, rotation: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, rotation: o3 } } } : e3;
          }
          default:
            return e3;
        }
      }, initialState: Ba };
      Va = "SEARCH/INIT_STATE";
      Za = "SEARCH/CLEANUP_STATE";
      Ka = "SEARCH/START_SEARCH_SESSION";
      Ya = "SEARCH/STOP_SEARCH_SESSION";
      Xa = "SEARCH/SET_SEARCH_FLAGS";
      Qa = "SEARCH/SET_SHOW_ALL_RESULTS";
      Ja = "SEARCH/START_SEARCH";
      es = "SEARCH/SET_SEARCH_RESULTS";
      ts = "SEARCH/APPEND_SEARCH_RESULTS";
      ns = "SEARCH/SET_ACTIVE_RESULT_INDEX";
      as = { flags: [], results: [], total: 0, activeResultIndex: -1, showAllResults: true, query: "", loading: false, active: false };
      ss = { documents: {} };
      ls = (e3, t2, n3) => {
        const o3 = e3.documents[t2] || as;
        return { ...e3, documents: { ...e3.documents, [t2]: { ...o3, ...n3 } } };
      };
      cs = class extends Yn {
        constructor(e3, t2, n3) {
          super(e3, t2), this.searchStop$ = ao(), this.searchStart$ = ao(), this.searchResult$ = ao(), this.searchActiveResultChange$ = ao(), this.searchResultState$ = ao(), this.searchState$ = ao(), this.currentTask = /* @__PURE__ */ new Map(), this.pluginConfig = n3;
        }
        onDocumentLoadingStarted(e3) {
          const t2 = { ...as, flags: this.pluginConfig.flags || [], showAllResults: this.pluginConfig.showAllResults ?? true };
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Va, payload: { documentId: e4, state: t3 } };
          })(e3, t2));
        }
        onDocumentClosed(e3) {
          this.stopSearchSession(e3), this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: Za, payload: e4 };
          })(e3)), this.currentTask.delete(e3);
        }
        async initialize() {
        }
        onStoreUpdated(e3, t2) {
          for (const n3 in t2.documents) {
            const o3 = e3.documents[n3], i3 = t2.documents[n3];
            o3 !== i3 && (this.searchState$.emit({ documentId: n3, state: i3 }), o3 && o3.results === i3.results && o3.activeResultIndex === i3.activeResultIndex && o3.showAllResults === i3.showAllResults && o3.active === i3.active || this.searchResultState$.emit({ documentId: n3, state: { results: i3.results, activeResultIndex: i3.activeResultIndex, showAllResults: i3.showAllResults, active: i3.active } }));
          }
        }
        buildCapability() {
          const e3 = (e4) => e4 ?? this.getActiveDocumentId(), t2 = (t3) => {
            const n3 = e3(t3), o3 = this.state.documents[n3];
            if (!o3) throw new Error(`Search state not found for document ${n3}`);
            return o3;
          };
          return { startSearch: (t3) => this.startSearchSession(e3(t3)), stopSearch: (t3) => this.stopSearchSession(e3(t3)), searchAllPages: (t3, n3) => this.searchAllPages(t3, e3(n3)), nextResult: (t3) => this.nextResult(e3(t3)), previousResult: (t3) => this.previousResult(e3(t3)), goToResult: (t3, n3) => this.goToResult(t3, e3(n3)), setShowAllResults: (t3, n3) => this.dispatch(os(e3(n3), t3)), getShowAllResults: (e4) => t2(e4).showAllResults, getFlags: (e4) => t2(e4).flags, setFlags: (t3, n3) => this.setFlags(t3, e3(n3)), getState: (e4) => t2(e4), forDocument: this.createSearchScope.bind(this), onSearchResult: this.searchResult$.on, onSearchStart: this.searchStart$.on, onSearchStop: this.searchStop$.on, onActiveResultChange: this.searchActiveResultChange$.on, onSearchResultStateChange: this.searchResultState$.on, onStateChange: this.searchState$.on };
        }
        createSearchScope(e3) {
          const t2 = () => {
            const t3 = this.state.documents[e3];
            if (!t3) throw new Error(`Search state not found for document ${e3}`);
            return t3;
          };
          return { startSearch: () => this.startSearchSession(e3), stopSearch: () => this.stopSearchSession(e3), searchAllPages: (t3) => this.searchAllPages(t3, e3), nextResult: () => this.nextResult(e3), previousResult: () => this.previousResult(e3), goToResult: (t3) => this.goToResult(t3, e3), setShowAllResults: (t3) => this.dispatch(os(e3, t3)), getShowAllResults: () => t2().showAllResults, getFlags: () => t2().flags, setFlags: (t3) => this.setFlags(t3, e3), getState: t2, onSearchResult: (t3) => this.searchResult$.on((n3) => {
            n3.documentId === e3 && t3(n3.results);
          }), onSearchStart: (t3) => this.searchStart$.on((n3) => {
            n3.documentId === e3 && t3();
          }), onSearchStop: (t3) => this.searchStop$.on((n3) => {
            n3.documentId === e3 && t3();
          }), onActiveResultChange: (t3) => this.searchActiveResultChange$.on((n3) => {
            n3.documentId === e3 && t3(n3.index);
          }), onSearchResultStateChange: (t3) => this.searchResultState$.on((n3) => {
            n3.documentId === e3 && t3(n3.state);
          }), onStateChange: (t3) => this.searchState$.on((n3) => {
            n3.documentId === e3 && t3(n3.state);
          }) };
        }
        setFlags(e3, t2) {
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Xa, payload: { documentId: e4, flags: t3 } };
          })(t2, e3));
          const n3 = this.state.documents[t2];
          (null == n3 ? void 0 : n3.active) && this.searchAllPages(n3.query, t2, true);
        }
        notifySearchStart(e3) {
          this.searchStart$.emit({ documentId: e3 });
        }
        notifySearchStop(e3) {
          this.searchStop$.emit({ documentId: e3 });
        }
        notifyActiveResultChange(e3, t2) {
          this.searchActiveResultChange$.emit({ documentId: e3, index: t2 });
        }
        startSearchSession(e3) {
          this.getCoreDocument(e3) && (this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: Ka, payload: { documentId: e4 } };
          })(e3)), this.notifySearchStart(e3));
        }
        stopSearchSession(e3) {
          var t2;
          const n3 = this.state.documents[e3];
          if (!(null == n3 ? void 0 : n3.active)) return;
          const o3 = this.currentTask.get(e3);
          if (o3) {
            try {
              null == (t2 = o3.abort) || t2.call(o3, { code: Ht.Cancelled, message: "search stopped" });
            } catch {
            }
            this.currentTask.delete(e3);
          }
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: Ya, payload: { documentId: e4 } };
          })(e3)), this.notifySearchStop(e3);
        }
        searchAllPages(e3, t2, n3 = false) {
          var o3;
          const i3 = this.state.documents[t2];
          if (!i3) return Ut.reject({ code: Ht.NotFound, message: "Search state not initialized" });
          const r2 = this.getCoreDocument(t2);
          if (!(null == r2 ? void 0 : r2.document)) return Ut.reject({ code: Ht.NotFound, message: "Document not loaded" });
          const a3 = e3.trim();
          if (i3.query === a3 && !n3) return Ut.resolve({ results: i3.results, total: i3.total });
          const s4 = this.currentTask.get(t2);
          if (s4) {
            try {
              null == (o3 = s4.abort) || o3.call(s4, { code: Ht.Cancelled, message: "new search" });
            } catch {
            }
            this.currentTask.delete(t2);
          }
          if (this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Ja, payload: { documentId: e4, query: t3 } };
          })(t2, a3)), !a3) return this.dispatch(is(t2, [], 0, -1)), Ut.resolve({ results: [], total: 0 });
          i3.active || this.startSearchSession(t2);
          const l4 = this.engine.searchAllPages(r2.document, a3, { flags: i3.flags });
          return this.currentTask.set(t2, l4), l4.onProgress((e4) => {
            var n4;
            (null == (n4 = null == e4 ? void 0 : e4.results) ? void 0 : n4.length) && this.currentTask.get(t2) === l4 && (this.dispatch(/* @__PURE__ */ (function(e5, t3) {
              return { type: ts, payload: { documentId: e5, results: t3 } };
            })(t2, e4.results)), -1 === this.state.documents[t2].activeResultIndex && (this.dispatch(rs(t2, 0)), this.notifyActiveResultChange(t2, 0)));
          }), l4.wait((e4) => {
            this.currentTask.delete(t2);
            const n4 = e4.total > 0 ? 0 : -1;
            this.dispatch(is(t2, e4.results, e4.total, n4)), this.searchResult$.emit({ documentId: t2, results: e4 }), e4.total > 0 && this.notifyActiveResultChange(t2, 0);
          }, (e4) => {
            var n4;
            (null == (n4 = null == e4 ? void 0 : e4.reason) ? void 0 : n4.code) !== Ht.Cancelled && (console.error("Error during search:", e4), this.dispatch(is(t2, [], 0, -1))), this.currentTask.delete(t2);
          }), l4;
        }
        nextResult(e3) {
          const t2 = this.state.documents[e3];
          if (!t2 || 0 === t2.results.length) return -1;
          const n3 = t2.activeResultIndex >= t2.results.length - 1 ? 0 : t2.activeResultIndex + 1;
          return this.goToResult(n3, e3);
        }
        previousResult(e3) {
          const t2 = this.state.documents[e3];
          if (!t2 || 0 === t2.results.length) return -1;
          const n3 = t2.activeResultIndex <= 0 ? t2.results.length - 1 : t2.activeResultIndex - 1;
          return this.goToResult(n3, e3);
        }
        goToResult(e3, t2) {
          const n3 = this.state.documents[t2];
          return !n3 || 0 === n3.results.length || e3 < 0 || e3 >= n3.results.length ? -1 : (this.dispatch(rs(t2, e3)), this.notifyActiveResultChange(t2, e3), e3);
        }
        async destroy() {
          for (const e3 of Object.keys(this.state.documents)) this.stopSearchSession(e3);
          this.searchResult$.clear(), this.searchStart$.clear(), this.searchStop$.clear(), this.searchActiveResultChange$.clear(), this.searchResultState$.clear(), this.searchState$.clear(), super.destroy();
        }
      };
      cs.id = "search";
      ds = cs;
      us = "search";
      hs = { manifest: { id: us, name: "Search Plugin", version: "1.0.0", provides: ["search"], requires: [], optional: [], defaultConfig: { flags: [] } }, create: (e3, t2) => new ds(us, e3, t2), reducer: (e3 = ss, t2) => {
        switch (t2.type) {
          case Va:
            return { ...e3, documents: { ...e3.documents, [t2.payload.documentId]: t2.payload.state } };
          case Za: {
            const n3 = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3 };
          }
          case Ka:
            return ls(e3, t2.payload.documentId, { active: true });
          case Ya:
            return ls(e3, t2.payload.documentId, { results: [], total: 0, activeResultIndex: -1, query: "", loading: false, active: false });
          case Xa:
            return ls(e3, t2.payload.documentId, { flags: t2.payload.flags });
          case Qa:
            return ls(e3, t2.payload.documentId, { showAllResults: t2.payload.showAll });
          case Ja:
            return ls(e3, t2.payload.documentId, { loading: true, query: t2.payload.query, results: [], total: 0, activeResultIndex: -1 });
          case ts: {
            const { documentId: n3, results: o3 } = t2.payload, i3 = e3.documents[n3];
            if (!i3) return e3;
            const r2 = [...i3.results, ...o3], a3 = -1 === i3.activeResultIndex && r2.length > 0 ? 0 : i3.activeResultIndex;
            return ls(e3, n3, { results: r2, total: r2.length, activeResultIndex: a3, loading: true });
          }
          case es: {
            const { documentId: n3, results: o3, total: i3, activeResultIndex: r2 } = t2.payload;
            return ls(e3, n3, { results: o3, total: i3, activeResultIndex: r2, loading: false });
          }
          case ns:
            return ls(e3, t2.payload.documentId, { activeResultIndex: t2.payload.index });
          default:
            return e3;
        }
      }, initialState: ss };
      ms = () => po(ds.id);
      ps = "selection";
      vs = { id: ps, name: "Selection Plugin", version: "1.0.0", provides: ["selection"], requires: ["interaction-manager"], optional: ["viewport", "scroll"], defaultConfig: { menuHeight: 40 } };
      fs = "SELECTION/INIT_STATE";
      ys = "SELECTION/CLEANUP_STATE";
      bs = "SELECTION/CACHE_PAGE_GEOMETRY";
      ws = "SELECTION/SET_SELECTION";
      xs = "SELECTION/START_SELECTION";
      Cs = "SELECTION/END_SELECTION";
      Is = "SELECTION/CLEAR_SELECTION";
      Ss = "SELECTION/SET_RECTS";
      ks = "SELECTION/SET_SLICES";
      Ds = { geometry: {}, rects: {}, slices: {}, selection: null, active: false, selecting: false };
      Ms = { documents: {} };
      Ps = (e3, t2, n3) => ({ ...e3, documents: { ...e3.documents, [t2]: n3 } });
      Hs = class extends Yn {
        constructor(e3, t2, n3) {
          var o3, i3, r2;
          super(e3, t2), this.enabledModesPerDoc = /* @__PURE__ */ new Map(), this.selecting = /* @__PURE__ */ new Map(), this.anchor = /* @__PURE__ */ new Map(), this.pageCallbacks = /* @__PURE__ */ new Map(), this.menuPlacement$ = so((e4, t3) => ({ documentId: e4, placement: t3 })), this.selChange$ = so((e4, t3) => ({ documentId: e4, selection: t3 })), this.textRetrieved$ = so((e4, t3) => ({ documentId: e4, text: t3 })), this.copyToClipboard$ = so((e4, t3) => ({ documentId: e4, text: t3 }), { cache: false }), this.beginSelection$ = so((e4, t3) => ({ documentId: e4, page: t3.page, index: t3.index }), { cache: false }), this.endSelection$ = so((e4) => ({ documentId: e4 }), { cache: false }), this.viewportCapability = null, this.scrollCapability = null, this.menuHeight = n3.menuHeight ?? 40;
          const a3 = t2.getPlugin("interaction-manager");
          if (!a3) throw new Error("SelectionPlugin: InteractionManagerPlugin is required.");
          this.interactionManagerCapability = a3.provides(), this.viewportCapability = (null == (o3 = t2.getPlugin("viewport")) ? void 0 : o3.provides()) ?? null, this.scrollCapability = (null == (i3 = t2.getPlugin("scroll")) ? void 0 : i3.provides()) ?? null, this.coreStore.onAction(On, (e4) => {
            const { documentId: t3, pageIndexes: n4 } = e4.payload, o4 = n4.map((e5) => this.getNewPageGeometryAndCache(t3, e5));
            gt.all(o4).wait(() => {
              n4.forEach((e5) => {
                this.notifyPage(t3, e5);
              });
            }, wn);
          }), null == (r2 = this.viewportCapability) || r2.onViewportChange((e4) => {
            this.recalculateMenuPlacement(e4.documentId);
          }, { mode: "throttle", wait: 100 });
        }
        onDocumentLoadingStarted(e3) {
          this.dispatch(/* @__PURE__ */ ((e4, t2) => ({ type: fs, payload: { documentId: e4, state: t2 } }))(e3, Ds)), this.enabledModesPerDoc.set(e3, /* @__PURE__ */ new Set(["pointerMode"])), this.pageCallbacks.set(e3, /* @__PURE__ */ new Map()), this.selecting.set(e3, false), this.anchor.set(e3, void 0);
        }
        onDocumentClosed(e3) {
          this.dispatch(/* @__PURE__ */ ((e4) => ({ type: ys, payload: e4 }))(e3)), this.enabledModesPerDoc.delete(e3), this.pageCallbacks.delete(e3), this.selecting.delete(e3), this.anchor.delete(e3), this.selChange$.clearScope(e3), this.textRetrieved$.clearScope(e3), this.copyToClipboard$.clearScope(e3), this.beginSelection$.clearScope(e3), this.endSelection$.clearScope(e3), this.menuPlacement$.clearScope(e3);
        }
        async initialize() {
        }
        async destroy() {
          this.selChange$.clear(), this.textRetrieved$.clear(), this.copyToClipboard$.clear(), this.beginSelection$.clear(), this.endSelection$.clear(), this.menuPlacement$.clear(), super.destroy();
        }
        buildCapability() {
          const e3 = (e4) => e4 ?? this.getActiveDocumentId();
          return { getFormattedSelection: (t2) => _s(this.getDocumentState(e3(t2))), getFormattedSelectionForPage: (t2, n3) => Es(this.getDocumentState(e3(n3)), t2), getHighlightRectsForPage: (t2, n3) => As(this.getDocumentState(e3(n3)), t2), getHighlightRects: (t2) => this.getDocumentState(e3(t2)).rects, getBoundingRectForPage: (t2, n3) => Ts(this.getDocumentState(e3(n3)), t2), getBoundingRects: (t2) => zs(this.getDocumentState(e3(t2))), getSelectedText: (t2) => this.getSelectedText(e3(t2)), clear: (t2) => this.clearSelection(e3(t2)), copyToClipboard: (t2) => this.copyToClipboard(e3(t2)), getState: (t2) => this.getDocumentState(e3(t2)), enableForMode: (t2, n3) => {
            var o3;
            return null == (o3 = this.enabledModesPerDoc.get(e3(n3))) ? void 0 : o3.add(t2);
          }, isEnabledForMode: (t2, n3) => {
            var o3;
            return (null == (o3 = this.enabledModesPerDoc.get(e3(n3))) ? void 0 : o3.has(t2)) ?? false;
          }, forDocument: this.createSelectionScope.bind(this), onCopyToClipboard: this.copyToClipboard$.onGlobal, onSelectionChange: this.selChange$.onGlobal, onTextRetrieved: this.textRetrieved$.onGlobal, onBeginSelection: this.beginSelection$.onGlobal, onEndSelection: this.endSelection$.onGlobal };
        }
        createSelectionScope(e3) {
          return { getFormattedSelection: () => _s(this.getDocumentState(e3)), getFormattedSelectionForPage: (t2) => Es(this.getDocumentState(e3), t2), getHighlightRectsForPage: (t2) => As(this.getDocumentState(e3), t2), getHighlightRects: () => this.getDocumentState(e3).rects, getBoundingRectForPage: (t2) => Ts(this.getDocumentState(e3), t2), getBoundingRects: () => zs(this.getDocumentState(e3)), getSelectedText: () => this.getSelectedText(e3), clear: () => this.clearSelection(e3), copyToClipboard: () => this.copyToClipboard(e3), getState: () => this.getDocumentState(e3), onSelectionChange: this.selChange$.forScope(e3), onTextRetrieved: this.textRetrieved$.forScope(e3), onCopyToClipboard: this.copyToClipboard$.forScope(e3), onBeginSelection: this.beginSelection$.forScope(e3), onEndSelection: this.endSelection$.forScope(e3) };
        }
        getDocumentState(e3) {
          const t2 = this.state.documents[e3];
          if (!t2) throw new Error(`Selection state not found for document: ${e3}`);
          return t2;
        }
        onMenuPlacement(e3, t2) {
          return this.menuPlacement$.forScope(e3)(t2);
        }
        registerSelectionOnPage(e3) {
          var t2;
          const { documentId: n3, pageIndex: o3, onRectsChange: i3 } = e3, r2 = this.state.documents[n3];
          if (!r2) return this.logger.warn("SelectionPlugin", "RegisterFailed", `Cannot register selection on page ${o3} for document ${n3}: document state not initialized.`), () => {
          };
          null == (t2 = this.pageCallbacks.get(n3)) || t2.set(o3, i3);
          const a3 = this.getOrLoadGeometry(n3, o3), s4 = this.interactionManagerCapability.forDocument(n3), l4 = this.enabledModesPerDoc.get(n3);
          i3({ rects: As(r2, o3), boundingRect: Ts(r2, o3) });
          const c4 = { onPointerDown: (e4, t3, i4) => {
            if (!(null == l4 ? void 0 : l4.has(i4))) return;
            this.clearSelection(n3);
            const r3 = this.getDocumentState(n3).geometry[o3];
            if (r3) {
              const t4 = Rs(r3, e4);
              -1 !== t4 && this.beginSelection(n3, o3, t4);
            }
          }, onPointerMove: (e4, t3, i4) => {
            if (!(null == l4 ? void 0 : l4.has(i4))) return;
            const r3 = this.getDocumentState(n3).geometry[o3];
            if (r3) {
              const t4 = Rs(r3, e4);
              -1 !== t4 ? s4.setCursor("selection-text", "text", 10) : s4.removeCursor("selection-text"), this.selecting.get(n3) && -1 !== t4 && this.updateSelection(n3, o3, t4);
            }
          }, onPointerUp: (e4, t3, o4) => {
            (null == l4 ? void 0 : l4.has(o4)) && this.endSelection(n3);
          }, onHandlerActiveEnd: (e4) => {
            (null == l4 ? void 0 : l4.has(e4)) && this.clearSelection(n3);
          } }, d4 = this.interactionManagerCapability.registerAlways({ scope: { type: "page", documentId: n3, pageIndex: o3 }, handlers: c4 });
          return () => {
            var e4;
            d4(), null == (e4 = this.pageCallbacks.get(n3)) || e4.delete(o3), a3.abort({ code: Ht.Cancelled, message: "Cleanup" });
          };
        }
        getPlacementMetrics(e3, t2, n3, o3) {
          var i3;
          const r2 = null == (i3 = this.scrollCapability) ? void 0 : i3.forDocument(e3), a3 = null == r2 ? void 0 : r2.getRectPositionForPage(t2, n3);
          if (!a3) return null;
          const s4 = a3.origin.y - o3.scrollTop, l4 = a3.origin.y + a3.size.height - o3.scrollTop;
          return { pageIndex: t2, rect: n3, spaceAbove: s4, spaceBelow: o3.clientHeight - l4, isBottomVisible: l4 > 0 && l4 <= o3.clientHeight, isTopVisible: s4 >= 0 && s4 < o3.clientHeight };
        }
        recalculateMenuPlacement(e3) {
          const t2 = this.state.documents[e3];
          if (!t2) return;
          if (t2.selecting || null === t2.selection) return void this.menuPlacement$.emit(e3, null);
          const n3 = zs(t2);
          if (0 === n3.length) return void this.menuPlacement$.emit(e3, null);
          const o3 = n3[n3.length - 1];
          if (!this.viewportCapability || !this.scrollCapability) return void this.menuPlacement$.emit(e3, { pageIndex: o3.page, rect: o3.rect, spaceAbove: 0, spaceBelow: 1 / 0, suggestTop: false, isVisible: true });
          const i3 = this.viewportCapability.forDocument(e3).getMetrics(), r2 = n3[0], a3 = this.getPlacementMetrics(e3, o3.page, o3.rect, i3), s4 = this.getPlacementMetrics(e3, r2.page, r2.rect, i3);
          a3 && a3.isBottomVisible && a3.spaceBelow > this.menuHeight ? this.menuPlacement$.emit(e3, { ...a3, suggestTop: false, isVisible: true }) : s4 && s4.isTopVisible ? this.menuPlacement$.emit(e3, { ...s4, suggestTop: true, isVisible: true }) : a3 && a3.isBottomVisible ? this.menuPlacement$.emit(e3, { ...a3, suggestTop: false, isVisible: true }) : this.menuPlacement$.emit(e3, null);
        }
        notifyPage(e3, t2) {
          var n3;
          const o3 = null == (n3 = this.pageCallbacks.get(e3)) ? void 0 : n3.get(t2);
          if (o3) {
            const n4 = this.getDocumentState(e3);
            o3("pointerMode" === this.interactionManagerCapability.forDocument(e3).getActiveMode() ? { rects: As(n4, t2), boundingRect: Ts(n4, t2) } : { rects: [], boundingRect: null });
          }
        }
        notifyAllPages(e3) {
          var t2;
          null == (t2 = this.pageCallbacks.get(e3)) || t2.forEach((t3, n3) => {
            this.notifyPage(e3, n3);
          });
        }
        getNewPageGeometryAndCache(e3, t2) {
          const n3 = this.getCoreDocument(e3);
          if (!n3 || !n3.document) return Ut.reject({ code: Ht.NotFound, message: "Doc Not Found" });
          const o3 = n3.document.pages.find((e4) => e4.index === t2), i3 = this.engine.getPageGeometry(n3.document, o3);
          return i3.wait((n4) => {
            this.dispatch(/* @__PURE__ */ ((e4, t3, n5) => ({ type: bs, payload: { documentId: e4, page: t3, geo: n5 } }))(e3, t2, n4));
          }, wn), i3;
        }
        getOrLoadGeometry(e3, t2) {
          const n3 = this.getDocumentState(e3).geometry[t2];
          return n3 ? Ut.resolve(n3) : this.getNewPageGeometryAndCache(e3, t2);
        }
        beginSelection(e3, t2, n3) {
          this.selecting.set(e3, true), this.anchor.set(e3, { page: t2, index: n3 }), this.dispatch(/* @__PURE__ */ ((e4) => ({ type: xs, payload: { documentId: e4 } }))(e3)), this.beginSelection$.emit(e3, { page: t2, index: n3 }), this.recalculateMenuPlacement(e3);
        }
        endSelection(e3) {
          this.selecting.set(e3, false), this.anchor.set(e3, void 0), this.dispatch(/* @__PURE__ */ ((e4) => ({ type: Cs, payload: { documentId: e4 } }))(e3)), this.endSelection$.emit(e3), this.recalculateMenuPlacement(e3);
        }
        clearSelection(e3) {
          this.selecting.set(e3, false), this.anchor.set(e3, void 0), this.dispatch(/* @__PURE__ */ ((e4) => ({ type: Is, payload: { documentId: e4 } }))(e3)), this.selChange$.emit(e3, null), this.menuPlacement$.emit(e3, null), this.notifyAllPages(e3);
        }
        updateSelection(e3, t2, n3) {
          if (!this.selecting.get(e3) || !this.anchor.get(e3)) return;
          const o3 = this.anchor.get(e3), i3 = t2 > o3.page || t2 === o3.page && n3 >= o3.index, r2 = { start: i3 ? o3 : { page: t2, index: n3 }, end: i3 ? { page: t2, index: n3 } : o3 };
          this.dispatch(/* @__PURE__ */ ((e4, t3) => ({ type: ws, payload: { documentId: e4, selection: t3 } }))(e3, r2)), this.updateRectsAndSlices(e3, r2), this.selChange$.emit(e3, r2);
          for (let t3 = r2.start.page; t3 <= r2.end.page; t3++) this.notifyPage(e3, t3);
        }
        updateRectsAndSlices(e3, t2) {
          const n3 = this.getDocumentState(e3), o3 = {}, i3 = {};
          for (let e4 = t2.start.page; e4 <= t2.end.page; e4++) {
            const r2 = n3.geometry[e4], a3 = Ns(t2, r2, e4);
            a3 && (o3[e4] = Os(r2, a3.from, a3.to), i3[e4] = { start: a3.from, count: a3.to - a3.from + 1 });
          }
          this.dispatch(/* @__PURE__ */ ((e4, t3) => ({ type: Ss, payload: { documentId: e4, rects: t3 } }))(e3, o3)), this.dispatch(/* @__PURE__ */ ((e4, t3) => ({ type: ks, payload: { documentId: e4, slices: t3 } }))(e3, i3));
        }
        getSelectedText(e3) {
          const t2 = this.getCoreDocument(e3), n3 = this.getDocumentState(e3);
          if (!(null == t2 ? void 0 : t2.document) || !n3.selection) return Ut.reject({ code: Ht.NotFound, message: "Doc Not Found or No Selection" });
          const o3 = n3.selection, i3 = [];
          for (let e4 = o3.start.page; e4 <= o3.end.page; e4++) {
            const t3 = n3.slices[e4];
            t3 && i3.push({ pageIndex: e4, charIndex: t3.start, charCount: t3.count });
          }
          if (0 === i3.length) return Ut.resolve([]);
          const r2 = this.engine.getTextSlices(t2.document, i3);
          return r2.wait((t3) => {
            this.textRetrieved$.emit(e3, t3);
          }, wn), r2;
        }
        copyToClipboard(e3) {
          this.getSelectedText(e3).wait((t2) => {
            this.copyToClipboard$.emit(e3, t2.join("\n"));
          }, wn);
        }
      };
      Hs.id = "selection";
      Us = Hs;
      Ws = { manifest: vs, create: (e3, t2) => new Us(ps, e3, t2), reducer: (e3 = Ms, t2) => {
        switch (t2.type) {
          case fs: {
            const { documentId: n3, state: o3 } = t2.payload;
            return Ps(e3, n3, o3);
          }
          case ys: {
            const n3 = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3 };
          }
          case bs: {
            const { documentId: n3, page: o3, geo: i3 } = t2.payload, r2 = e3.documents[n3];
            return r2 ? Ps(e3, n3, { ...r2, geometry: { ...r2.geometry, [o3]: i3 } }) : e3;
          }
          case ws: {
            const { documentId: n3, selection: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? Ps(e3, n3, { ...i3, selection: o3, active: true }) : e3;
          }
          case xs: {
            const { documentId: n3 } = t2.payload, o3 = e3.documents[n3];
            return o3 ? Ps(e3, n3, { ...o3, selecting: true, selection: null, rects: {} }) : e3;
          }
          case Cs: {
            const { documentId: n3 } = t2.payload, o3 = e3.documents[n3];
            return o3 ? Ps(e3, n3, { ...o3, selecting: false }) : e3;
          }
          case Is: {
            const { documentId: n3 } = t2.payload, o3 = e3.documents[n3];
            return o3 ? Ps(e3, n3, { ...o3, selecting: false, selection: null, rects: {}, active: false }) : e3;
          }
          case Ss: {
            const { documentId: n3, rects: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? Ps(e3, n3, { ...i3, rects: o3 }) : e3;
          }
          case ks: {
            const { documentId: n3, slices: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? Ps(e3, n3, { ...i3, slices: o3 }) : e3;
          }
          case "SELECTION/RESET": {
            const { documentId: n3 } = t2.payload;
            return e3.documents[n3] ? Ps(e3, n3, Ds) : e3;
          }
          default:
            return e3;
        }
      }, initialState: Ms };
      Bs = "onDblClick";
      Gs = class {
        constructor(e3, t2) {
          this.config = e3, this.onUpdate = t2, this.state = "idle", this.startPoint = null, this.startElement = null, this.activeHandle = null, this.currentPosition = null, this.activeVertexIndex = null, this.startVertices = [], this.currentVertices = [], this.currentVertices = e3.vertices || [];
        }
        updateConfig(e3) {
          this.config = { ...this.config, ...e3 }, this.currentVertices = e3.vertices || [];
        }
        startDrag(e3, t2) {
          this.state = "dragging", this.startPoint = { x: e3, y: t2 }, this.startElement = { ...this.config.element }, this.currentPosition = { ...this.config.element }, this.onUpdate({ state: "start", transformData: { type: "move", changes: { rect: this.startElement } } });
        }
        startResize(e3, t2, n3) {
          this.state = "resizing", this.activeHandle = e3, this.startPoint = { x: t2, y: n3 }, this.startElement = { ...this.config.element }, this.currentPosition = { ...this.config.element }, this.onUpdate({ state: "start", transformData: { type: "resize", changes: { rect: this.startElement }, metadata: { handle: this.activeHandle, maintainAspectRatio: this.config.maintainAspectRatio } } });
        }
        startVertexEdit(e3, t2, n3) {
          this.currentVertices = [...this.config.vertices ?? this.currentVertices], e3 < 0 || e3 >= this.currentVertices.length || (this.state = "vertex-editing", this.activeVertexIndex = e3, this.startPoint = { x: t2, y: n3 }, this.startVertices = [...this.currentVertices], this.onUpdate({ state: "start", transformData: { type: "vertex-edit", changes: { vertices: this.startVertices }, metadata: { vertexIndex: e3 } } }));
        }
        move(e3, t2) {
          if ("idle" !== this.state && this.startPoint) {
            if ("dragging" === this.state && this.startElement) {
              const n3 = this.calculateDelta(e3, t2), o3 = this.calculateDragPosition(n3);
              this.currentPosition = o3, this.onUpdate({ state: "move", transformData: { type: "move", changes: { rect: o3 } } });
            } else if ("resizing" === this.state && this.activeHandle && this.startElement) {
              const n3 = this.calculateDelta(e3, t2), o3 = this.calculateResizePosition(n3, this.activeHandle);
              this.currentPosition = o3, this.onUpdate({ state: "move", transformData: { type: "resize", changes: { rect: o3 }, metadata: { handle: this.activeHandle, maintainAspectRatio: this.config.maintainAspectRatio } } });
            } else if ("vertex-editing" === this.state && null !== this.activeVertexIndex) {
              const n3 = this.calculateVertexPosition(e3, t2);
              this.currentVertices = n3, this.onUpdate({ state: "move", transformData: { type: "vertex-edit", changes: { vertices: n3 }, metadata: { vertexIndex: this.activeVertexIndex } } });
            }
          }
        }
        end() {
          if ("idle" === this.state) return;
          const e3 = this.state, t2 = this.activeHandle, n3 = this.activeVertexIndex;
          if ("vertex-editing" === e3) this.onUpdate({ state: "end", transformData: { type: "vertex-edit", changes: { vertices: this.currentVertices }, metadata: { vertexIndex: n3 || void 0 } } });
          else {
            const n4 = this.getCurrentPosition();
            this.onUpdate({ state: "end", transformData: { type: "dragging" === e3 ? "move" : "resize", changes: { rect: n4 }, metadata: "dragging" === e3 ? void 0 : { handle: t2 || void 0, maintainAspectRatio: this.config.maintainAspectRatio } } });
          }
          this.reset();
        }
        cancel() {
          "idle" !== this.state && ("vertex-editing" === this.state ? this.onUpdate({ state: "end", transformData: { type: "vertex-edit", changes: { vertices: this.startVertices }, metadata: { vertexIndex: this.activeVertexIndex || void 0 } } }) : this.startElement && this.onUpdate({ state: "end", transformData: { type: "dragging" === this.state ? "move" : "resize", changes: { rect: this.startElement }, metadata: "dragging" === this.state ? void 0 : { handle: this.activeHandle || void 0, maintainAspectRatio: this.config.maintainAspectRatio } } }), this.reset());
        }
        reset() {
          this.state = "idle", this.startPoint = null, this.startElement = null, this.activeHandle = null, this.currentPosition = null, this.activeVertexIndex = null, this.startVertices = [];
        }
        getCurrentPosition() {
          return this.currentPosition || this.config.element;
        }
        calculateDelta(e3, t2) {
          if (!this.startPoint) return { x: 0, y: 0 };
          const n3 = { x: e3 - this.startPoint.x, y: t2 - this.startPoint.y };
          return this.transformDelta(n3);
        }
        transformDelta(e3) {
          const { pageRotation: t2 = 0, scale: n3 = 1 } = this.config, o3 = t2 * Math.PI / 2, i3 = Math.cos(o3), r2 = Math.sin(o3), a3 = e3.x / n3, s4 = e3.y / n3;
          return { x: i3 * a3 + r2 * s4, y: -r2 * a3 + i3 * s4 };
        }
        clampPoint(e3) {
          var t2;
          const n3 = null == (t2 = this.config.constraints) ? void 0 : t2.boundingBox;
          return n3 ? { x: Math.max(0, Math.min(e3.x, n3.width)), y: Math.max(0, Math.min(e3.y, n3.height)) } : e3;
        }
        calculateVertexPosition(e3, t2) {
          if (null === this.activeVertexIndex) return this.startVertices;
          const n3 = this.calculateDelta(e3, t2), o3 = [...this.startVertices], i3 = o3[this.activeVertexIndex], r2 = { x: i3.x + n3.x, y: i3.y + n3.y };
          return o3[this.activeVertexIndex] = this.clampPoint(r2), o3;
        }
        calculateDragPosition(e3) {
          if (!this.startElement) return this.config.element;
          const t2 = { origin: { x: this.startElement.origin.x + e3.x, y: this.startElement.origin.y + e3.y }, size: { width: this.startElement.size.width, height: this.startElement.size.height } };
          return this.applyConstraints(t2);
        }
        calculateResizePosition(e3, t2) {
          if (!this.startElement) return this.config.element;
          const n3 = (function(e4) {
            return { x: e4.includes("e") ? "left" : e4.includes("w") ? "right" : "center", y: e4.includes("s") ? "top" : e4.includes("n") ? "bottom" : "center" };
          })(t2), o3 = this.startElement.size.width / this.startElement.size.height || 1;
          let i3 = this.applyResizeDelta(e3, n3);
          return this.config.maintainAspectRatio && (i3 = this.enforceAspectRatio(i3, n3, o3)), i3 = this.clampToBounds(i3, n3, o3), this.applyConstraints(i3);
        }
        applyResizeDelta(e3, t2) {
          const n3 = this.startElement;
          let o3 = n3.origin.x, i3 = n3.origin.y, r2 = n3.size.width, a3 = n3.size.height;
          return "left" === t2.x ? r2 += e3.x : "right" === t2.x && (o3 += e3.x, r2 -= e3.x), "top" === t2.y ? a3 += e3.y : "bottom" === t2.y && (i3 += e3.y, a3 -= e3.y), { origin: { x: o3, y: i3 }, size: { width: r2, height: a3 } };
        }
        enforceAspectRatio(e3, t2, n3) {
          const o3 = this.startElement;
          let { x: i3, y: r2 } = e3.origin, { width: a3, height: s4 } = e3.size;
          if ("center" === t2.x || "center" === t2.y) "center" === t2.y ? (s4 = a3 / n3, r2 = o3.origin.y + (o3.size.height - s4) / 2) : (a3 = s4 * n3, i3 = o3.origin.x + (o3.size.width - a3) / 2);
          else {
            Math.abs(a3 - o3.size.width) >= Math.abs(s4 - o3.size.height) ? s4 = a3 / n3 : a3 = s4 * n3;
          }
          return "right" === t2.x && (i3 = o3.origin.x + o3.size.width - a3), "bottom" === t2.y && (r2 = o3.origin.y + o3.size.height - s4), { origin: { x: i3, y: r2 }, size: { width: a3, height: s4 } };
        }
        clampToBounds(e3, t2, n3) {
          var o3;
          const i3 = null == (o3 = this.config.constraints) ? void 0 : o3.boundingBox;
          if (!i3) return e3;
          const r2 = this.startElement;
          let { x: a3, y: s4 } = e3.origin, { width: l4, height: c4 } = e3.size;
          l4 = Math.max(1, l4), c4 = Math.max(1, c4);
          const d4 = "left" === t2.x ? r2.origin.x : r2.origin.x + r2.size.width, u4 = "top" === t2.y ? r2.origin.y : r2.origin.y + r2.size.height, h3 = "left" === t2.x ? i3.width - d4 : "right" === t2.x ? d4 : 2 * Math.min(r2.origin.x, i3.width - r2.origin.x - r2.size.width) + r2.size.width, m3 = "top" === t2.y ? i3.height - u4 : "bottom" === t2.y ? u4 : 2 * Math.min(r2.origin.y, i3.height - r2.origin.y - r2.size.height) + r2.size.height;
          if (this.config.maintainAspectRatio) {
            const e4 = l4 > h3 ? h3 / l4 : 1, t3 = c4 > m3 ? m3 / c4 : 1, n4 = Math.min(e4, t3);
            n4 < 1 && (l4 *= n4, c4 *= n4);
          } else l4 = Math.min(l4, h3), c4 = Math.min(c4, m3);
          return a3 = "left" === t2.x ? d4 : "right" === t2.x ? d4 - l4 : r2.origin.x + (r2.size.width - l4) / 2, s4 = "top" === t2.y ? u4 : "bottom" === t2.y ? u4 - c4 : r2.origin.y + (r2.size.height - c4) / 2, a3 = Math.max(0, Math.min(a3, i3.width - l4)), s4 = Math.max(0, Math.min(s4, i3.height - c4)), { origin: { x: a3, y: s4 }, size: { width: l4, height: c4 } };
        }
        applyConstraints(e3) {
          const { constraints: t2 } = this.config;
          if (!t2) return e3;
          let { origin: { x: n3, y: o3 }, size: { width: i3, height: r2 } } = e3;
          const a3 = t2.minWidth ?? 1, s4 = t2.minHeight ?? 1, l4 = t2.maxWidth, c4 = t2.maxHeight;
          if (this.config.maintainAspectRatio && i3 > 0 && r2 > 0) {
            const e4 = i3 / r2;
            i3 < a3 && (i3 = a3, r2 = i3 / e4), r2 < s4 && (r2 = s4, i3 = r2 * e4), void 0 !== l4 && i3 > l4 && (i3 = l4, r2 = i3 / e4), void 0 !== c4 && r2 > c4 && (r2 = c4, i3 = r2 * e4);
          } else i3 = Math.max(a3, i3), r2 = Math.max(s4, r2), void 0 !== l4 && (i3 = Math.min(l4, i3)), void 0 !== c4 && (r2 = Math.min(c4, r2));
          return t2.boundingBox && (n3 = Math.max(0, Math.min(n3, t2.boundingBox.width - i3)), o3 = Math.max(0, Math.min(o3, t2.boundingBox.height - r2))), { origin: { x: n3, y: o3 }, size: { width: i3, height: r2 } };
        }
      };
      Ys = () => po(Us.id);
      Qs = co(Ws).addUtility(function() {
        const { provides: e3 } = Ys();
        return Me(() => {
          if (e3) return e3.onCopyToClipboard(({ text: e4 }) => {
            navigator.clipboard.writeText(e4);
          });
        }, [e3]), null;
      }).build();
      Js = "tiling";
      el = { id: Js, name: "Tiling Plugin", version: "1.0.0", provides: ["tiling"], requires: ["render", "scroll", "viewport"], optional: [], defaultConfig: { tileSize: 768, overlapPx: 2.5, extraRings: 0 } };
      tl = "TILING/INIT_STATE";
      nl = "TILING/CLEANUP_STATE";
      ol = "TILING/UPDATE_VISIBLE_TILES";
      il = "TILING/MARK_TILE_STATUS";
      rl = (e3, t2) => ({ type: ol, payload: { documentId: e3, tiles: t2 } });
      al = (e3, t2, n3, o3) => ({ type: il, payload: { documentId: e3, pageIndex: t2, tileId: n3, status: o3 } });
      sl = { visibleTiles: {} };
      cl = class extends Yn {
        constructor(e3, t2, n3) {
          super(e3, t2), this.tileRendering$ = ao(), this.config = n3, this.renderCapability = this.registry.getPlugin("render").provides(), this.scrollCapability = this.registry.getPlugin("scroll").provides(), this.viewportCapability = this.registry.getPlugin("viewport").provides(), this.scrollCapability.onScroll((e4) => this.calculateVisibleTiles(e4.documentId, e4.metrics), { mode: "throttle", wait: 50, throttleMode: "trailing" }), this.coreStore.onAction(On, (e4) => this.recalculateTiles(e4.payload));
        }
        onDocumentLoadingStarted(e3) {
          this.dispatch(/* @__PURE__ */ ((e4, t2) => ({ type: tl, payload: { documentId: e4, state: t2 } }))(e3, sl));
        }
        onDocumentClosed(e3) {
          this.dispatch(/* @__PURE__ */ ((e4) => ({ type: nl, payload: e4 }))(e3));
        }
        onScaleChanged(e3) {
          this.recalculateTilesForDocument(e3);
        }
        onRotationChanged(e3) {
          this.recalculateTilesForDocument(e3);
        }
        recalculateTilesForDocument(e3) {
          const t2 = this.scrollCapability.forDocument(e3), n3 = this.viewportCapability.forDocument(e3), o3 = t2.getMetrics(n3.getMetrics());
          this.calculateVisibleTiles(e3, o3);
        }
        async recalculateTiles(e3) {
          const { documentId: t2, pageIndexes: n3 } = e3, o3 = this.getCoreDocument(t2);
          if (!o3 || !o3.document) return;
          const i3 = this.scrollCapability.forDocument(t2), r2 = this.viewportCapability.forDocument(t2), a3 = i3.getMetrics(r2.getMetrics()), s4 = {}, l4 = Date.now(), c4 = o3.scale, d4 = o3.rotation;
          for (const e4 of n3) {
            const t3 = a3.pageVisibilityMetrics.find((t4) => t4.pageNumber === e4 + 1);
            if (!t3) continue;
            const n4 = o3.document.pages[e4];
            n4 && (s4[e4] = ll({ page: n4, metric: t3, scale: c4, rotation: d4, tileSize: this.config.tileSize, overlapPx: this.config.overlapPx, extraRings: this.config.extraRings }).map((e5) => ({ ...e5, id: `${e5.id}-r${l4}` })));
          }
          Object.keys(s4).length > 0 && this.dispatch(rl(t2, s4));
        }
        async initialize() {
        }
        calculateVisibleTiles(e3, t2) {
          const n3 = this.getCoreDocument(e3);
          if (!n3 || !n3.document) return;
          const o3 = n3.scale, i3 = n3.rotation, r2 = {};
          for (const e4 of t2.pageVisibilityMetrics) {
            const t3 = e4.pageNumber - 1, a3 = n3.document.pages[t3];
            if (!a3) continue;
            const s4 = ll({ page: a3, metric: e4, scale: o3, rotation: i3, tileSize: this.config.tileSize, overlapPx: this.config.overlapPx, extraRings: this.config.extraRings });
            r2[t3] = s4;
          }
          this.dispatch(rl(e3, r2));
        }
        onStoreUpdated(e3, t2) {
          for (const n3 in t2.documents) {
            const o3 = e3.documents[n3], i3 = t2.documents[n3];
            o3 !== i3 && this.tileRendering$.emit({ documentId: n3, tiles: i3.visibleTiles });
          }
        }
        buildCapability() {
          return { renderTile: this.renderTile.bind(this), forDocument: this.createTilingScope.bind(this), onTileRendering: this.tileRendering$.on };
        }
        createTilingScope(e3) {
          return { renderTile: (t2) => this.renderTile(t2, e3), onTileRendering: (t2) => this.tileRendering$.on((n3) => {
            n3.documentId === e3 && t2(n3.tiles);
          }) };
        }
        renderTile(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId();
          if (!this.renderCapability) throw new Error("Render capability not available.");
          this.dispatch(al(n3, e3.pageIndex, e3.tile.id, "rendering"));
          const o3 = this.renderCapability.forDocument(n3).renderPageRect({ pageIndex: e3.pageIndex, rect: e3.tile.pageRect, options: { scaleFactor: e3.tile.srcScale, dpr: e3.dpr } });
          return o3.wait(() => {
            this.dispatch(al(n3, e3.pageIndex, e3.tile.id, "ready"));
          }, wn), o3;
        }
      };
      cl.id = "tiling";
      dl = cl;
      ul = { manifest: el, create: (e3, t2) => new dl(Js, e3, t2), reducer: (e3, t2) => ((e4, t3) => {
        var n3, o3;
        switch (t3.type) {
          case tl: {
            const { documentId: n4, state: o4 } = t3.payload;
            return { ...e4, documents: { ...e4.documents, [n4]: o4 } };
          }
          case nl: {
            const n4 = t3.payload, { [n4]: o4, ...i3 } = e4.documents;
            return { ...e4, documents: i3 };
          }
          case ol: {
            const { documentId: o4, tiles: i3 } = t3.payload, r2 = e4.documents[o4];
            if (!r2) return e4;
            const a3 = { ...r2.visibleTiles };
            for (const e5 in i3) {
              const t4 = Number(e5), o5 = i3[t4], r3 = a3[t4] ?? [], s4 = null == (n3 = r3.find((e6) => !e6.isFallback)) ? void 0 : n3.srcScale, l4 = o5.length > 0 ? o5[0].srcScale : s4;
              if (void 0 !== s4 && s4 !== l4) {
                const e6 = r3.filter((e7) => !e7.isFallback && "ready" === e7.status).map((e7) => ({ ...e7, isFallback: true })), n4 = e6.length > 0 ? [] : r3.filter((e7) => e7.isFallback);
                a3[t4] = [...n4, ...e6, ...o5];
              } else {
                const e6 = new Set(o5.map((e7) => e7.id)), n4 = [], i4 = /* @__PURE__ */ new Set();
                for (const t5 of r3) (t5.isFallback || e6.has(t5.id)) && (n4.push(t5), i4.add(t5.id));
                for (const e7 of o5) i4.has(e7.id) || n4.push(e7);
                a3[t4] = n4;
              }
            }
            return { ...e4, documents: { ...e4.documents, [o4]: { ...r2, visibleTiles: a3 } } };
          }
          case il: {
            const { documentId: n4, pageIndex: i3, tileId: r2, status: a3 } = t3.payload, s4 = e4.documents[n4];
            if (!s4) return e4;
            const l4 = (null == (o3 = s4.visibleTiles[i3]) ? void 0 : o3.map((e5) => e5.id === r2 ? { ...e5, status: a3 } : e5)) ?? [], c4 = l4.filter((e5) => !e5.isFallback), d4 = c4.length > 0 && c4.every((e5) => "ready" === e5.status), u4 = d4 ? c4 : l4;
            return { ...e4, documents: { ...e4.documents, [n4]: { ...s4, visibleTiles: { ...s4.visibleTiles, [i3]: u4 } } } };
          }
          default:
            return e4;
        }
      })(e3, t2), initialState: { documents: {} } };
      hl = () => po(dl.id);
      pl = "thumbnail";
      vl = { id: pl, name: "Thumbnail Plugin", version: "1.0.0", provides: ["thumbnail"], requires: ["render"], optional: ["scroll"], defaultConfig: { width: 150, gap: 10, buffer: 3, labelHeight: 16, autoScroll: true, scrollBehavior: "smooth", imagePadding: 0, paddingY: 0 } };
      fl = "THUMBNAIL/INIT_STATE";
      yl = "THUMBNAIL/CLEANUP_STATE";
      bl = "THUMBNAIL/SET_WINDOW_STATE";
      wl = "THUMBNAIL/UPDATE_VIEWPORT_METRICS";
      Cl = { thumbs: [], window: null, viewportH: 0, scrollY: 0 };
      Il = { documents: {}, activeDocumentId: null };
      Sl = class extends Yn {
        constructor(e3, t2, n3) {
          var o3;
          super(e3, t2), this.cfg = n3, this.scrollCapability = null, this.taskCaches = /* @__PURE__ */ new Map(), this.canAutoScroll = /* @__PURE__ */ new Map(), this.window$ = so((e4, t3) => ({ documentId: e4, window: t3 })), this.scrollTo$ = so((e4, t3) => ({ documentId: e4, options: t3 })), this.refreshPages$ = so((e4, t3) => ({ documentId: e4, pages: t3 }), { cache: false }), this.renderCapability = this.registry.getPlugin("render").provides(), this.scrollCapability = (null == (o3 = this.registry.getPlugin("scroll")) ? void 0 : o3.provides()) ?? null, this.coreStore.onAction(On, (e4) => {
            const t3 = e4.payload.documentId ?? this.getActiveDocumentId(), n4 = e4.payload.pageIndexes;
            this.refreshPages$.emit(t3, n4);
            const o4 = this.taskCaches.get(t3);
            if (o4) for (const e5 of n4) o4.delete(e5);
          }), this.scrollCapability && false !== this.cfg.autoScroll && (this.scrollCapability.onPageChangeState(({ documentId: e4, state: t3 }) => {
            this.canAutoScroll.set(e4, !t3.isChanging), t3.isChanging || this.scrollToThumb(t3.targetPage - 1, e4);
          }), this.scrollCapability.onPageChange(({ documentId: e4, pageNumber: t3 }) => {
            false !== this.canAutoScroll.get(e4) && this.scrollToThumb(t3 - 1, e4);
          }));
        }
        onDocumentLoadingStarted(e3) {
          this.dispatch(xl(e3, { ...Cl })), this.taskCaches.set(e3, /* @__PURE__ */ new Map()), this.canAutoScroll.set(e3, true), this.logger.debug("ThumbnailPlugin", "DocumentOpened", `Initialized thumbnail state for document: ${e3}`);
        }
        onDocumentLoaded(e3) {
          this.calculateWindowState(e3);
        }
        onDocumentClosed(e3) {
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: yl, payload: e4 };
          })(e3));
          const t2 = this.taskCaches.get(e3);
          t2 && (t2.forEach((e4) => {
            e4.abort({ code: "cancelled", message: "Document closed" });
          }), t2.clear(), this.taskCaches.delete(e3)), this.canAutoScroll.delete(e3), this.window$.clearScope(e3), this.scrollTo$.clearScope(e3), this.refreshPages$.clearScope(e3), this.logger.debug("ThumbnailPlugin", "DocumentClosed", `Cleaned up thumbnail state for document: ${e3}`);
        }
        onRotationChanged(e3) {
          this.calculateWindowState(e3);
        }
        buildCapability() {
          return { scrollToThumb: (e3) => this.scrollToThumb(e3), renderThumb: (e3, t2) => this.renderThumb(e3, t2), updateWindow: (e3, t2) => this.updateWindow(e3, t2), getWindow: () => this.getWindow(), forDocument: (e3) => this.createThumbnailScope(e3), onWindow: this.window$.onGlobal, onScrollTo: this.scrollTo$.onGlobal, onRefreshPages: this.refreshPages$.onGlobal };
        }
        createThumbnailScope(e3) {
          return { scrollToThumb: (t2) => this.scrollToThumb(t2, e3), renderThumb: (t2, n3) => this.renderThumb(t2, n3, e3), updateWindow: (t2, n3) => this.updateWindow(t2, n3, e3), getWindow: () => this.getWindow(e3), onWindow: this.window$.forScope(e3), onScrollTo: this.scrollTo$.forScope(e3), onRefreshPages: this.refreshPages$.forScope(e3) };
        }
        getDocumentState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          return this.state.documents[t2] ?? null;
        }
        calculateWindowState(e3) {
          const t2 = this.coreState.core.documents[e3];
          if (!(null == t2 ? void 0 : t2.document)) return;
          const n3 = this.cfg.width ?? 120, o3 = this.cfg.labelHeight ?? 16, i3 = this.cfg.gap ?? 8, r2 = this.cfg.imagePadding ?? 0, a3 = this.cfg.paddingY ?? 0, s4 = Math.max(1, n3 - 2 * r2);
          let l4 = a3;
          const c4 = t2.document.pages.map((e4) => {
            const t3 = e4.size.height / e4.size.width, n4 = Math.round(s4 * t3), a4 = r2 + n4 + r2 + o3, c5 = { pageIndex: e4.index, width: s4, height: n4, wrapperHeight: a4, top: l4, labelHeight: o3, padding: r2 };
            return l4 += a4 + i3, c5;
          }), d4 = { start: -1, end: -1, items: [], totalHeight: l4 - i3 + a3 }, u4 = this.getDocumentState(e3);
          u4 && (this.dispatch(xl(e3, { ...u4, thumbs: c4, window: d4 })), u4.viewportH > 0 ? this.updateWindow(u4.scrollY, u4.viewportH, e3) : this.window$.emit(e3, d4));
        }
        updateWindow(e3, t2, n3) {
          const o3 = n3 ?? this.getActiveDocumentId(), i3 = this.getDocumentState(o3);
          if (!i3 || !i3.window || 0 === i3.thumbs.length) return;
          const r2 = this.cfg.buffer ?? 3;
          this.dispatch(/* @__PURE__ */ (function(e4, t3, n4) {
            return { type: wl, payload: { documentId: e4, scrollY: t3, viewportH: n4 } };
          })(o3, e3, t2));
          let a3 = 0, s4 = i3.thumbs.length - 1, l4 = 0;
          for (; a3 <= s4; ) {
            const t3 = a3 + s4 >> 1, n4 = i3.thumbs[t3];
            n4.top + n4.wrapperHeight < e3 ? a3 = t3 + 1 : (l4 = t3, s4 = t3 - 1);
          }
          let c4 = l4;
          const d4 = e3 + t2;
          for (; c4 + 1 < i3.thumbs.length && i3.thumbs[c4].top < d4; ) c4++;
          c4 = Math.min(i3.thumbs.length - 1, c4 + r2);
          const u4 = Math.max(0, l4 - r2);
          if (u4 === i3.window.start && c4 === i3.window.end) return;
          const h3 = { start: u4, end: c4, items: i3.thumbs.slice(u4, c4 + 1), totalHeight: i3.window.totalHeight };
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: bl, payload: { documentId: e4, window: t3 } };
          })(o3, h3)), this.window$.emit(o3, h3);
        }
        getWindow(e3) {
          const t2 = this.getDocumentState(e3);
          return (null == t2 ? void 0 : t2.window) ?? null;
        }
        scrollToThumb(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = this.getDocumentState(n3);
          if (!o3 || !o3.window) return;
          const i3 = o3.thumbs[e3];
          if (!i3) return;
          const r2 = this.cfg.scrollBehavior ?? "smooth", a3 = this.cfg.paddingY ?? 0;
          if (o3.viewportH <= 0) {
            const e4 = Math.max(a3, i3.top - i3.wrapperHeight);
            return void this.scrollTo$.emit(n3, { top: e4, behavior: r2 });
          }
          const s4 = i3.top, l4 = i3.top + i3.wrapperHeight, c4 = s4 < o3.scrollY + 8 + a3, d4 = l4 > o3.scrollY + o3.viewportH - 8;
          c4 ? this.scrollTo$.emit(n3, { top: Math.max(0, s4 - a3), behavior: r2 }) : d4 && this.scrollTo$.emit(n3, { top: Math.max(0, l4 - o3.viewportH + a3), behavior: r2 });
        }
        renderThumb(e3, t2, n3) {
          const o3 = n3 ?? this.getActiveDocumentId(), i3 = this.taskCaches.get(o3);
          if (!i3) throw new Error(`Task cache not found for document: ${o3}`);
          if (i3.has(e3)) return i3.get(e3);
          const r2 = this.coreState.core.documents[o3];
          if (!(null == r2 ? void 0 : r2.document)) throw new Error(`Document not found: ${o3}`);
          const a3 = r2.document.pages[e3];
          if (!a3) throw new Error(`Page ${e3} not found in document: ${o3}`);
          const s4 = this.cfg.width ?? 120, l4 = this.cfg.imagePadding ?? 0, c4 = Math.max(1, s4 - 2 * l4) / a3.size.width, d4 = this.renderCapability.forDocument(o3).renderPageRect({ pageIndex: e3, rect: { origin: { x: 0, y: 0 }, size: a3.size }, options: { scaleFactor: c4, dpr: t2 } });
          return i3.set(e3, d4), d4.wait(wn, () => i3.delete(e3)), d4;
        }
        async initialize() {
          this.logger.info("ThumbnailPlugin", "Initialize", "Thumbnail plugin initialized");
        }
        async destroy() {
          this.window$.clear(), this.refreshPages$.clear(), this.scrollTo$.clear(), this.taskCaches.forEach((e3) => {
            e3.forEach((e4) => {
              e4.abort({ code: "cancelled", message: "Plugin destroyed" });
            }), e3.clear();
          }), this.taskCaches.clear(), this.canAutoScroll.clear(), super.destroy();
        }
      };
      Sl.id = "thumbnail";
      kl = Sl;
      Dl = { manifest: vl, create: (e3, t2) => new kl(pl, e3, t2), reducer: (e3 = Il, t2) => {
        switch (t2.type) {
          case fl: {
            const { documentId: n3, state: o3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: o3 }, activeDocumentId: e3.activeDocumentId ?? n3 };
          }
          case yl: {
            const n3 = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3, activeDocumentId: e3.activeDocumentId === n3 ? null : e3.activeDocumentId };
          }
          case "THUMBNAIL/SET_ACTIVE_DOCUMENT":
            return { ...e3, activeDocumentId: t2.payload };
          case bl: {
            const { documentId: n3, window: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, window: o3 } } } : e3;
          }
          case wl: {
            const { documentId: n3, scrollY: o3, viewportH: i3 } = t2.payload, r2 = e3.documents[n3];
            return r2 ? { ...e3, documents: { ...e3.documents, [n3]: { ...r2, scrollY: o3, viewportH: i3 } } } : e3;
          }
          default:
            return e3;
        }
      }, initialState: Il };
      Ml = () => go(kl.id);
      Tl = "annotation";
      zl = { id: Tl, name: "Annotation Plugin", version: "1.0.0", provides: ["annotation"], requires: ["interaction-manager", "selection"], optional: ["history"], defaultConfig: { autoCommit: true, annotationAuthor: "Guest", deactivateToolAfterCreate: false, selectAfterCreate: true } };
      El = "ANNOTATION/INIT_STATE";
      _l = "ANNOTATION/CLEANUP_STATE";
      Rl = "ANNOTATION/SET_ANNOTATIONS";
      Nl = "ANNOTATION/SELECT_ANNOTATION";
      Ol = "ANNOTATION/DESELECT_ANNOTATION";
      Ll = "ANNOTATION/SET_ACTIVE_TOOL_ID";
      $l = "ANNOTATION/CREATE_ANNOTATION";
      Fl = "ANNOTATION/PATCH_ANNOTATION";
      jl = "ANNOTATION/DELETE_ANNOTATION";
      Hl = "ANNOTATION/COMMIT";
      Ul = "ANNOTATION/PURGE_ANNOTATION";
      Wl = "ANNOTATION/ADD_COLOR_PRESET";
      Bl = "ANNOTATION/SET_TOOL_DEFAULTS";
      ql = "ANNOTATION/ADD_TOOL";
      Gl = (e3) => ({ type: Ol, payload: { documentId: e3 } });
      Vl = (e3, t2) => ({ type: Ll, payload: { documentId: e3, toolId: t2 } });
      Zl = (e3, t2, n3) => ({ type: $l, payload: { documentId: e3, pageIndex: t2, annotation: n3 } });
      Kl = (e3, t2, n3, o3) => ({ type: Fl, payload: { documentId: e3, pageIndex: t2, id: n3, patch: o3 } });
      Yl = (e3, t2, n3) => ({ type: jl, payload: { documentId: e3, pageIndex: t2, id: n3 } });
      Xl = (e3, t2) => ({ type: Ul, payload: { documentId: e3, uid: t2 } });
      hc = (e3, t2) => (e3.pages[t2] ?? []).map((t3) => e3.byUid[t3]);
      mc = (e3, t2) => e3.byUid[t2] ?? null;
      gc = (e3, t2) => {
        if (!e3.selectedUid) return null;
        return (e3.pages[t2] ?? []).includes(e3.selectedUid) ? e3.byUid[e3.selectedUid] : null;
      };
      vc = [{ id: "highlight", name: "Highlight", matchScore: (e3) => e3.type === Dt.HIGHLIGHT ? 1 : 0, interaction: { exclusive: false, textSelection: true, isDraggable: false, isResizable: false }, defaults: { type: Dt.HIGHLIGHT, color: "#FFCD45", opacity: 1, blendMode: It.Multiply } }, { id: "underline", name: "Underline", matchScore: (e3) => e3.type === Dt.UNDERLINE ? 1 : 0, interaction: { exclusive: false, textSelection: true, isDraggable: false, isResizable: false }, defaults: { type: Dt.UNDERLINE, color: "#E44234", opacity: 1 } }, { id: "strikeout", name: "Strikeout", matchScore: (e3) => e3.type === Dt.STRIKEOUT ? 1 : 0, interaction: { exclusive: false, textSelection: true }, defaults: { type: Dt.STRIKEOUT, color: "#E44234", opacity: 1 } }, { id: "squiggly", name: "Squiggly", matchScore: (e3) => e3.type === Dt.SQUIGGLY ? 1 : 0, interaction: { exclusive: false, textSelection: true, isDraggable: false, isResizable: false }, defaults: { type: Dt.SQUIGGLY, color: "#E44234", opacity: 1 } }, { id: "ink", name: "Pen", matchScore: (e3) => e3.type === Dt.INK && "InkHighlight" !== e3.intent ? 5 : 0, interaction: { exclusive: false, cursor: "crosshair", isDraggable: true, isResizable: true, lockAspectRatio: false }, defaults: { type: Dt.INK, color: "#E44234", opacity: 1, strokeWidth: 6 } }, { id: "inkHighlighter", name: "Ink Highlighter", matchScore: (e3) => e3.type === Dt.INK && "InkHighlight" === e3.intent ? 10 : 0, interaction: { exclusive: false, cursor: "crosshair", isDraggable: true, isResizable: true, lockAspectRatio: false }, defaults: { type: Dt.INK, intent: "InkHighlight", color: "#FFCD45", opacity: 1, strokeWidth: 14, blendMode: It.Multiply } }, { id: "circle", name: "Circle", matchScore: (e3) => e3.type === Dt.CIRCLE ? 1 : 0, interaction: { exclusive: false, cursor: "crosshair", isDraggable: true, isResizable: true, lockAspectRatio: false }, defaults: { type: Dt.CIRCLE, color: "transparent", opacity: 1, strokeWidth: 6, strokeColor: "#E44234", strokeStyle: Et.SOLID }, clickBehavior: { enabled: true, defaultSize: { width: 100, height: 100 } } }, { id: "square", name: "Square", matchScore: (e3) => e3.type === Dt.SQUARE ? 1 : 0, interaction: { exclusive: false, cursor: "crosshair", isDraggable: true, isResizable: true, lockAspectRatio: false }, defaults: { type: Dt.SQUARE, color: "transparent", opacity: 1, strokeWidth: 6, strokeColor: "#E44234", strokeStyle: Et.SOLID }, clickBehavior: { enabled: true, defaultSize: { width: 100, height: 100 } } }, { id: "line", name: "Line", matchScore: (e3) => e3.type === Dt.LINE && "LineArrow" !== e3.intent ? 5 : 0, interaction: { exclusive: false, cursor: "crosshair", isDraggable: true, isResizable: false, lockAspectRatio: false }, defaults: { type: Dt.LINE, color: "transparent", opacity: 1, strokeWidth: 6, strokeColor: "#E44234" }, clickBehavior: { enabled: true, defaultLength: 100, defaultAngle: 0 } }, { id: "lineArrow", name: "Arrow", matchScore: (e3) => e3.type === Dt.LINE && "LineArrow" === e3.intent ? 10 : 0, interaction: { exclusive: false, cursor: "crosshair", isDraggable: true, isResizable: false, lockAspectRatio: false }, defaults: { type: Dt.LINE, intent: "LineArrow", color: "transparent", opacity: 1, strokeWidth: 6, strokeColor: "#E44234", lineEndings: { start: At.None, end: At.OpenArrow } }, clickBehavior: { enabled: true, defaultLength: 100, defaultAngle: 0 } }, { id: "polyline", name: "Polyline", matchScore: (e3) => e3.type === Dt.POLYLINE ? 1 : 0, interaction: { exclusive: false, cursor: "crosshair", isDraggable: true, isResizable: false, lockAspectRatio: false }, defaults: { type: Dt.POLYLINE, color: "transparent", opacity: 1, strokeWidth: 6, strokeColor: "#E44234" } }, { id: "polygon", name: "Polygon", matchScore: (e3) => e3.type === Dt.POLYGON ? 1 : 0, interaction: { exclusive: false, cursor: "crosshair", isDraggable: true, isResizable: false, lockAspectRatio: false }, defaults: { type: Dt.POLYGON, color: "transparent", opacity: 1, strokeWidth: 6, strokeColor: "#E44234" } }, { id: "freeText", name: "Free Text", matchScore: (e3) => e3.type === Dt.FREETEXT ? 1 : 0, interaction: { exclusive: false, cursor: "crosshair", isDraggable: true, isResizable: true, lockAspectRatio: false }, defaults: { type: Dt.FREETEXT, contents: "Insert text", fontSize: 14, fontColor: "#E44234", fontFamily: wt.Helvetica, textAlign: xt.Left, verticalAlign: Ct.Top, backgroundColor: "transparent", opacity: 1 }, clickBehavior: { enabled: true, defaultSize: { width: 100, height: 20 }, defaultContent: "Insert text" } }, { id: "stamp", name: "Image", matchScore: (e3) => e3.type === Dt.STAMP ? 1 : 0, interaction: { exclusive: false, cursor: "copy", isDraggable: true, isResizable: true, lockAspectRatio: true }, defaults: { type: Dt.STAMP } }];
      fc = ["#E44234", "#FF8D00", "#FFCD45", "#5CC96E", "#25D2D1", "#597CE2", "#C544CE", "#7D2E25", "#000000", "#FFFFFF"];
      yc = (e3, t2, n3) => {
        const o3 = e3.byUid[t2];
        return o3 ? { ...e3, byUid: { ...e3.byUid, [t2]: { ...o3, commitState: "synced" === o3.commitState ? "dirty" : o3.commitState, object: { ...o3.object, ...n3 } } }, hasPendingChanges: true } : e3;
      };
      wc = { annotationType: Dt.INK, create(e3) {
        const { onCommit: t2, onPreview: n3, getTool: o3, pageSize: i3 } = e3, [r2, a3] = bc([]), [s4, l4] = bc(false), c4 = { current: null }, d4 = (e4) => ({ x: eo(e4.x, 0, i3.width), y: eo(e4.y, 0, i3.height) }), u4 = () => {
          const e4 = o3();
          return e4 ? { ...e4.defaults, strokeWidth: e4.defaults.strokeWidth ?? 1, color: e4.defaults.color ?? "#000000", opacity: e4.defaults.opacity ?? 1, flags: e4.defaults.flags ?? ["print"] } : null;
        }, h3 = () => {
          const e4 = r2();
          if (0 === e4.length || 0 === e4[0].points.length) return null;
          const t3 = u4();
          if (!t3) return null;
          const n4 = e4.flatMap((e5) => e5.points), o4 = et(Je(n4), t3.strokeWidth / 2);
          return { type: Dt.INK, bounds: o4, data: { ...t3, rect: o4, inkList: e4 } };
        };
        return { onPointerDown: (e4, t3) => {
          var o4;
          const i4 = d4(e4);
          l4(true), c4.current && clearTimeout(c4.current);
          const s5 = [...r2(), { points: [i4] }];
          a3(s5), n3(h3()), null == (o4 = t3.setPointerCapture) || o4.call(t3);
        }, onPointerMove: (e4) => {
          if (!s4()) return;
          const t3 = r2();
          if (0 === t3.length) return;
          const o4 = d4(e4);
          t3[t3.length - 1].points.push(o4), a3(t3), n3(h3());
        }, onPointerUp: (o4, i4) => {
          var s5;
          l4(false), null == (s5 = i4.releasePointerCapture) || s5.call(i4), c4.current && clearTimeout(c4.current), c4.current = setTimeout(() => {
            const o5 = r2();
            if (o5.length > 0 && o5[0].points.length > 1) {
              const n4 = u4();
              if (!n4) return;
              const i5 = o5.flatMap((e4) => e4.points), r3 = et(Je(i5), n4.strokeWidth / 2);
              t2({ ...n4, inkList: o5, rect: r3, type: Dt.INK, pageIndex: e3.pageIndex, id: yn(), created: /* @__PURE__ */ new Date() });
            }
            a3([]), n3(null);
          }, 800);
        }, onPointerCancel: (e4, t3) => {
          var o4;
          a3([]), l4(false), n3(null), c4.current && clearTimeout(c4.current), null == (o4 = t3.releasePointerCapture) || o4.call(t3);
        } };
      } };
      Cc = { annotationType: Dt.FREETEXT, create(e3) {
        const { onCommit: t2, onPreview: n3, getTool: o3, pageSize: i3, pageIndex: r2 } = e3, [a3, s4] = bc(null), l4 = (e4) => ({ x: eo(e4.x, 0, i3.width), y: eo(e4.y, 0, i3.height) }), c4 = () => {
          const e4 = o3();
          return e4 ? { ...e4.defaults, fontColor: e4.defaults.fontColor ?? "#000000", opacity: e4.defaults.opacity ?? 1, fontSize: e4.defaults.fontSize ?? 12, fontFamily: e4.defaults.fontFamily ?? wt.Helvetica, backgroundColor: e4.defaults.backgroundColor ?? "transparent", textAlign: e4.defaults.textAlign ?? xt.Left, verticalAlign: e4.defaults.verticalAlign ?? Ct.Top, contents: e4.defaults.contents ?? "Insert text here", flags: e4.defaults.flags ?? ["print"] } : null;
        }, d4 = xc({ threshold: 5, getTool: o3, onClickDetected: (e4, n4) => {
          const o4 = c4();
          if (!o4) return;
          const a4 = n4.clickBehavior;
          if (!(null == a4 ? void 0 : a4.enabled)) return;
          const { width: s5, height: l5 } = a4.defaultSize, d5 = s5 / 2, u5 = l5 / 2, h3 = { origin: { x: eo(e4.x - d5, 0, i3.width - s5), y: eo(e4.y - u5, 0, i3.height - l5) }, size: { width: s5, height: l5 } }, m3 = a4.defaultContent ?? o4.contents, g3 = { ...o4, contents: m3, type: Dt.FREETEXT, rect: h3, pageIndex: r2, id: yn(), created: /* @__PURE__ */ new Date() };
          t2(g3);
        } }), u4 = (e4) => {
          const t3 = a3();
          if (!t3) return null;
          const n4 = c4();
          if (!n4) return null;
          const o4 = { origin: { x: Math.min(t3.x, e4.x), y: Math.min(t3.y, e4.y) }, size: { width: Math.abs(t3.x - e4.x), height: Math.abs(t3.y - e4.y) } };
          return { type: Dt.FREETEXT, bounds: o4, data: { ...n4, rect: o4 } };
        };
        return { onPointerDown: (e4, t3) => {
          var o4;
          const i4 = l4(e4);
          s4(i4), d4.onStart(i4), n3(u4(i4)), null == (o4 = t3.setPointerCapture) || o4.call(t3);
        }, onPointerMove: (e4) => {
          const t3 = l4(e4);
          d4.onMove(t3), a3() && d4.hasMoved() && n3(u4(t3));
        }, onPointerUp: (o4, i4) => {
          var r3;
          const u5 = a3();
          if (!u5) return;
          const h3 = c4();
          if (!h3) return;
          const m3 = l4(o4);
          if (d4.hasMoved()) {
            const n4 = { origin: { x: Math.min(u5.x, m3.x), y: Math.min(u5.y, m3.y) }, size: { width: Math.abs(u5.x - m3.x), height: Math.abs(u5.y - m3.y) } }, o5 = { ...h3, type: Dt.FREETEXT, rect: n4, pageIndex: e3.pageIndex, id: yn(), created: /* @__PURE__ */ new Date() };
            t2(o5);
          } else d4.onEnd(m3);
          s4(null), n3(null), d4.reset(), null == (r3 = i4.releasePointerCapture) || r3.call(i4);
        }, onPointerLeave: (e4, t3) => {
          var o4;
          s4(null), n3(null), d4.reset(), null == (o4 = t3.releasePointerCapture) || o4.call(t3);
        }, onPointerCancel: (e4, t3) => {
          var o4;
          s4(null), n3(null), d4.reset(), null == (o4 = t3.releasePointerCapture) || o4.call(t3);
        } };
      } };
      kc = Ic(false);
      Dc = Ic(true);
      Mc = { [At.OpenArrow]: kc, [At.ClosedArrow]: Dc, [At.ROpenArrow]: { ...kc, getRotation: (e3) => e3 + Math.PI }, [At.RClosedArrow]: { ...Dc, getRotation: (e3) => e3 + Math.PI }, [At.Circle]: { getSvgPath: (e3) => {
        const t2 = 5 * e3 / 2;
        return `M ${t2} 0 A ${t2} ${t2} 0 1 1 ${-t2} 0 A ${t2} ${t2} 0 1 1 ${t2} 0`;
      }, getLocalPoints: (e3) => {
        const t2 = 5 * e3 / 2;
        return [{ x: -t2, y: -t2 }, { x: t2, y: t2 }];
      }, getRotation: () => 0, filled: true }, [At.Square]: { getSvgPath: (e3) => {
        const t2 = 6 * e3 / 2;
        return `M ${-t2} ${-t2} L ${t2} ${-t2} L ${t2} ${t2} L ${-t2} ${t2} Z`;
      }, getLocalPoints: (e3) => {
        const t2 = 6 * e3 / 2;
        return [{ x: -t2, y: -t2 }, { x: t2, y: -t2 }, { x: t2, y: t2 }, { x: -t2, y: t2 }];
      }, getRotation: (e3) => e3, filled: true }, [At.Diamond]: { getSvgPath: (e3) => {
        const t2 = 6 * e3 / 2;
        return `M 0 ${-t2} L ${t2} 0 L 0 ${t2} L ${-t2} 0 Z`;
      }, getLocalPoints: (e3) => {
        const t2 = 6 * e3 / 2;
        return [{ x: 0, y: -t2 }, { x: t2, y: 0 }, { x: 0, y: t2 }, { x: -t2, y: 0 }];
      }, getRotation: (e3) => e3, filled: true }, [At.Butt]: Sc(6, (e3) => e3 + Math.PI / 2), [At.Slash]: Sc(18, (e3) => e3 + Math.PI / 1.5) };
      Ac = class {
        constructor() {
          this.patches = /* @__PURE__ */ new Map();
        }
        register(e3, t2) {
          this.patches.set(e3, t2);
        }
        transform(e3, t2) {
          const n3 = this.patches.get(e3.type);
          return n3 ? n3(e3, t2) : t2.changes;
        }
      };
      Tc = new Ac();
      zc = Object.freeze(Object.defineProperty({ __proto__: null, LINE_ENDING_HANDLERS: Mc, PatchRegistry: Ac, createEnding: function(e3, t2, n3, o3, i3) {
        if (!e3) return null;
        const r2 = Mc[e3];
        if (!r2) return null;
        const a3 = r2.getRotation(n3);
        return { d: r2.getSvgPath(t2), transform: `translate(${o3} ${i3}) rotate(${((e4) => 180 * e4 / Math.PI)(a3)})`, filled: r2.filled };
      }, lineRectWithEndings: Pc, patchRegistry: Tc }, Symbol.toStringTag, { value: "Module" }));
      Ec = { annotationType: Dt.LINE, create(e3) {
        const { pageIndex: t2, onCommit: n3, onPreview: o3, getTool: i3, pageSize: r2 } = e3, [a3, s4] = bc(null), l4 = (e4) => ({ x: eo(e4.x, 0, r2.width), y: eo(e4.y, 0, r2.height) }), c4 = () => {
          const e4 = i3();
          return e4 ? { ...e4.defaults, strokeWidth: e4.defaults.strokeWidth ?? 1, lineEndings: e4.defaults.lineEndings ?? { start: At.None, end: At.None }, color: e4.defaults.color ?? "#000000", opacity: e4.defaults.opacity ?? 1, strokeStyle: e4.defaults.strokeStyle ?? Et.SOLID, strokeDashArray: e4.defaults.strokeDashArray ?? [], strokeColor: e4.defaults.strokeColor ?? "#000000", flags: e4.defaults.flags ?? ["print"] } : null;
        }, d4 = xc({ threshold: 5, getTool: i3, onClickDetected: (e4, o4) => {
          const i4 = c4();
          if (!i4) return;
          const r3 = o4.clickBehavior;
          if (!(null == r3 ? void 0 : r3.enabled)) return;
          const a4 = r3.defaultAngle ?? 0, s5 = r3.defaultLength / 2, d5 = e4.x - s5 * Math.cos(a4), u5 = e4.y - s5 * Math.sin(a4), h3 = e4.x + s5 * Math.cos(a4), m3 = e4.y + s5 * Math.sin(a4), g3 = l4({ x: d5, y: u5 }), p4 = l4({ x: h3, y: m3 }), v2 = Pc([g3, p4], i4.strokeWidth, i4.lineEndings);
          n3({ ...i4, rect: v2, linePoints: { start: g3, end: p4 }, pageIndex: t2, id: yn(), created: /* @__PURE__ */ new Date(), type: Dt.LINE });
        } }), u4 = (e4) => {
          const t3 = a3();
          if (!t3) return null;
          const n4 = c4();
          if (!n4) return null;
          const o4 = Pc([t3, e4], n4.strokeWidth, n4.lineEndings);
          return { type: Dt.LINE, bounds: o4, data: { ...n4, rect: o4, linePoints: { start: t3, end: e4 } } };
        };
        return { onPointerDown: (e4, t3) => {
          var n4;
          const i4 = l4(e4);
          s4(i4), d4.onStart(i4), o3(u4(i4)), null == (n4 = t3.setPointerCapture) || n4.call(t3);
        }, onPointerMove: (e4) => {
          const t3 = l4(e4);
          d4.onMove(t3), a3() && d4.hasMoved() && o3(u4(t3));
        }, onPointerUp: (e4, i4) => {
          var r3;
          const u5 = a3();
          if (!u5) return;
          const h3 = l4(e4);
          if (d4.hasMoved()) {
            const e5 = c4();
            if (!e5) return;
            if (Math.abs(h3.x - u5.x) > 2 || Math.abs(h3.y - u5.y) > 2) {
              const o4 = Pc([u5, h3], e5.strokeWidth, e5.lineEndings);
              n3({ ...e5, rect: o4, linePoints: { start: u5, end: h3 }, pageIndex: t2, id: yn(), flags: ["print"], created: /* @__PURE__ */ new Date(), type: Dt.LINE });
            }
          } else d4.onEnd(h3);
          s4(null), o3(null), d4.reset(), null == (r3 = i4.releasePointerCapture) || r3.call(i4);
        }, onPointerLeave: (e4, t3) => {
          var n4;
          s4(null), o3(null), d4.reset(), null == (n4 = t3.releasePointerCapture) || n4.call(t3);
        }, onPointerCancel: (e4, t3) => {
          var n4;
          s4(null), o3(null), d4.reset(), null == (n4 = t3.releasePointerCapture) || n4.call(t3);
        } };
      } };
      _c = { annotationType: Dt.POLYLINE, create(e3) {
        const { onCommit: t2, onPreview: n3, getTool: o3, pageSize: i3 } = e3, [r2, a3] = bc([]), [s4, l4] = bc(null), c4 = (e4) => ({ x: eo(e4.x, 0, i3.width), y: eo(e4.y, 0, i3.height) }), d4 = () => {
          const e4 = o3();
          return e4 ? { ...e4.defaults, strokeWidth: e4.defaults.strokeWidth ?? 1, lineEndings: e4.defaults.lineEndings ?? { start: At.None, end: At.None }, color: e4.defaults.color ?? "#000000", opacity: e4.defaults.opacity ?? 1, strokeColor: e4.defaults.strokeColor ?? "#000000", strokeStyle: e4.defaults.strokeStyle ?? Et.SOLID, strokeDashArray: e4.defaults.strokeDashArray ?? [], flags: e4.defaults.flags ?? ["print"] } : null;
        }, u4 = () => {
          const e4 = r2(), t3 = s4();
          if (0 === e4.length || !t3) return null;
          const n4 = d4();
          if (!n4) return null;
          const o4 = [...e4, t3], i4 = Pc(o4, n4.strokeWidth, n4.lineEndings);
          return { type: Dt.POLYLINE, bounds: i4, data: { ...n4, rect: i4, vertices: o4, currentVertex: t3 } };
        };
        return { onClick: (e4) => {
          const t3 = c4(e4), o4 = r2(), i4 = o4[o4.length - 1];
          i4 && Math.abs(i4.x - t3.x) < 1 && Math.abs(i4.y - t3.y) < 1 || (a3([...o4, t3]), l4(t3), n3(u4()));
        }, onDoubleClick: () => {
          (() => {
            const o4 = r2();
            if (o4.length < 2) return;
            const i4 = d4();
            if (!i4) return;
            const s5 = Pc(o4, i4.strokeWidth, i4.lineEndings), c5 = { ...i4, vertices: o4, rect: s5, type: Dt.POLYLINE, pageIndex: e3.pageIndex, id: yn(), created: /* @__PURE__ */ new Date() };
            t2(c5), a3([]), l4(null), n3(null);
          })();
        }, onPointerMove: (e4) => {
          if (r2().length > 0) {
            const t3 = c4(e4);
            l4(t3), n3(u4());
          }
        }, onPointerCancel: () => {
          a3([]), l4(null), n3(null);
        } };
      } };
      Rc = { annotationType: Dt.POLYGON, create(e3) {
        const { onCommit: t2, onPreview: n3, getTool: o3, scale: i3, pageSize: r2 } = e3, [a3, s4] = bc([]), [l4, c4] = bc(null), d4 = (e4) => ({ x: eo(e4.x, 0, r2.width), y: eo(e4.y, 0, r2.height) }), u4 = () => {
          const e4 = o3();
          return e4 ? { ...e4.defaults, color: e4.defaults.color ?? "#000000", opacity: e4.defaults.opacity ?? 1, strokeWidth: e4.defaults.strokeWidth ?? 1, strokeColor: e4.defaults.strokeColor ?? "#000000", strokeStyle: e4.defaults.strokeStyle ?? Et.SOLID, strokeDashArray: e4.defaults.strokeDashArray ?? [], flags: e4.defaults.flags ?? ["print"] } : null;
        }, h3 = () => {
          const o4 = a3();
          if (o4.length < 3) return;
          const i4 = u4();
          if (!i4) return;
          const r3 = et(Je(o4), i4.strokeWidth / 2), l5 = { ...i4, vertices: o4, rect: r3, type: Dt.POLYGON, pageIndex: e3.pageIndex, id: yn(), created: /* @__PURE__ */ new Date() };
          t2(l5), s4([]), c4(null), n3(null);
        }, m3 = () => {
          const e4 = a3(), t3 = l4();
          if (0 === e4.length || !t3) return null;
          const n4 = u4();
          if (!n4) return null;
          const o4 = et(Je([...e4, t3]), n4.strokeWidth / 2);
          return { type: Dt.POLYGON, bounds: o4, data: { ...n4, rect: o4, vertices: e4, currentVertex: t3 } };
        };
        return { onClick: (e4) => {
          const t3 = d4(e4);
          if (((e5) => {
            const t4 = a3();
            if (t4.length < 2) return false;
            const n4 = 14 / i3 / 2, o5 = t4[0];
            return e5.x >= o5.x - n4 && e5.x <= o5.x + n4 && e5.y >= o5.y - n4 && e5.y <= o5.y + n4;
          })(t3) && a3().length >= 3) return void h3();
          const o4 = a3(), r3 = o4[o4.length - 1];
          r3 && Math.abs(r3.x - t3.x) < 1 && Math.abs(r3.y - t3.y) < 1 || (s4([...o4, t3]), c4(t3), n3(m3()));
        }, onDoubleClick: (e4) => {
          h3();
        }, onPointerMove: (e4) => {
          if (a3().length > 0) {
            const t3 = d4(e4);
            c4(t3), n3(m3());
          }
        }, onPointerCancel: (e4) => {
          s4([]), c4(null), n3(null);
        } };
      } };
      Nc = { annotationType: Dt.SQUARE, create(e3) {
        const { pageIndex: t2, onCommit: n3, onPreview: o3, getTool: i3, pageSize: r2 } = e3, [a3, s4] = bc(null), l4 = (e4) => ({ x: eo(e4.x, 0, r2.width), y: eo(e4.y, 0, r2.height) }), c4 = () => {
          const e4 = i3();
          return e4 ? { ...e4.defaults, flags: e4.defaults.flags ?? ["print"], strokeWidth: e4.defaults.strokeWidth ?? 2, strokeColor: e4.defaults.strokeColor ?? "#000000", strokeStyle: e4.defaults.strokeStyle ?? Et.SOLID, strokeDashArray: e4.defaults.strokeDashArray ?? [], color: e4.defaults.color ?? "#000000", opacity: e4.defaults.opacity ?? 1 } : null;
        }, d4 = xc({ threshold: 5, getTool: i3, onClickDetected: (e4, o4) => {
          const i4 = c4();
          if (!i4) return;
          const a4 = o4.clickBehavior;
          if (!(null == a4 ? void 0 : a4.enabled)) return;
          const { width: s5, height: l5 } = a4.defaultSize, d5 = s5 / 2, u5 = l5 / 2, h3 = eo(e4.x - d5, 0, r2.width - s5), m3 = eo(e4.y - u5, 0, r2.height - l5), g3 = i4.strokeWidth, p4 = g3 / 2, v2 = { origin: { x: h3 - p4, y: m3 - p4 }, size: { width: s5 + g3, height: l5 + g3 } }, f2 = { ...i4, type: Dt.SQUARE, created: /* @__PURE__ */ new Date(), id: yn(), pageIndex: t2, rect: v2 };
          n3(f2);
        } }), u4 = (e4) => {
          const t3 = a3();
          if (!t3) return null;
          const n4 = Math.min(t3.x, e4.x), o4 = Math.min(t3.y, e4.y), i4 = Math.abs(t3.x - e4.x), r3 = Math.abs(t3.y - e4.y), s5 = c4();
          if (!s5) return null;
          const l5 = s5.strokeWidth, d5 = l5 / 2, u5 = { origin: { x: n4 - d5, y: o4 - d5 }, size: { width: i4 + l5, height: r3 + l5 } };
          return { type: Dt.SQUARE, bounds: u5, data: { rect: u5, ...s5 } };
        };
        return { onPointerDown: (e4, t3) => {
          var n4;
          const i4 = l4(e4);
          s4(i4), d4.onStart(i4), o3(u4(i4)), null == (n4 = t3.setPointerCapture) || n4.call(t3);
        }, onPointerMove: (e4) => {
          const t3 = l4(e4);
          d4.onMove(t3), a3() && d4.hasMoved() && o3(u4(t3));
        }, onPointerUp: (e4, i4) => {
          var r3;
          if (!a3()) return;
          if (!c4()) return;
          const h3 = l4(e4);
          if (d4.hasMoved()) {
            const e5 = c4();
            if (!e5) return;
            const o4 = u4(h3);
            if (o4) {
              const i5 = { ...e5, type: Dt.SQUARE, created: /* @__PURE__ */ new Date(), id: yn(), pageIndex: t2, rect: o4.data.rect };
              n3(i5);
            }
          } else d4.onEnd(h3);
          s4(null), o3(null), d4.reset(), null == (r3 = i4.releasePointerCapture) || r3.call(i4);
        }, onPointerLeave: (e4, t3) => {
          var n4;
          s4(null), o3(null), d4.reset(), null == (n4 = t3.releasePointerCapture) || n4.call(t3);
        }, onPointerCancel: (e4, t3) => {
          var n4;
          s4(null), o3(null), d4.reset(), null == (n4 = t3.releasePointerCapture) || n4.call(t3);
        } };
      } };
      Oc = { annotationType: Dt.STAMP, create(e3) {
        const { services: t2, onCommit: n3, getTool: o3, pageSize: i3 } = e3;
        return { onPointerDown: (r2) => {
          const a3 = o3();
          if (!a3) return;
          const { imageSrc: s4, imageSize: l4 } = a3.defaults, c4 = (t3, o4, s5) => {
            const l5 = r2.x - o4 / 2, c5 = r2.y - s5 / 2, d4 = { origin: { x: eo(l5, 0, i3.width - o4), y: eo(c5, 0, i3.height - s5) }, size: { width: o4, height: s5 } }, u4 = { ...a3.defaults, rect: d4, type: Dt.STAMP, icon: a3.defaults.icon ?? Pt.Draft, subject: a3.defaults.subject ?? "Stamp", flags: a3.defaults.flags ?? ["print"], pageIndex: e3.pageIndex, id: yn(), created: /* @__PURE__ */ new Date() };
            n3(u4, { imageData: t3 });
          };
          s4 ? t2.processImage({ source: s4, maxWidth: i3.width, maxHeight: i3.height, onComplete: (e4) => c4(e4.imageData, (null == l4 ? void 0 : l4.width) ?? e4.width, (null == l4 ? void 0 : l4.height) ?? e4.height) }) : t2.requestFile({ accept: "image/png,image/jpeg", onFile: (e4) => {
            t2.processImage({ source: e4, maxWidth: i3.width, maxHeight: i3.height, onComplete: (e5) => c4(e5.imageData, e5.width, e5.height) });
          } });
        } };
      } };
      Lc = { annotationType: Dt.CIRCLE, create(e3) {
        const { pageIndex: t2, onCommit: n3, onPreview: o3, getTool: i3, pageSize: r2 } = e3, [a3, s4] = bc(null), l4 = (e4) => ({ x: eo(e4.x, 0, r2.width), y: eo(e4.y, 0, r2.height) }), c4 = () => {
          const e4 = i3();
          return e4 ? { ...e4.defaults, strokeWidth: e4.defaults.strokeWidth ?? 2, strokeColor: e4.defaults.strokeColor ?? "#000000", strokeStyle: e4.defaults.strokeStyle ?? Et.SOLID, strokeDashArray: e4.defaults.strokeDashArray ?? [], color: e4.defaults.color ?? "#000000", opacity: e4.defaults.opacity ?? 1, flags: e4.defaults.flags ?? ["print"] } : null;
        }, d4 = xc({ threshold: 5, getTool: i3, onClickDetected: (e4, o4) => {
          const i4 = c4();
          if (!i4) return;
          const a4 = o4.clickBehavior;
          if (!(null == a4 ? void 0 : a4.enabled)) return;
          const { width: s5, height: l5 } = a4.defaultSize, d5 = s5 / 2, u5 = l5 / 2, h3 = eo(e4.x - d5, 0, r2.width - s5), m3 = eo(e4.y - u5, 0, r2.height - l5), g3 = i4.strokeWidth, p4 = g3 / 2, v2 = { origin: { x: h3 - p4, y: m3 - p4 }, size: { width: s5 + g3, height: l5 + g3 } }, f2 = { ...i4, type: Dt.CIRCLE, created: /* @__PURE__ */ new Date(), id: yn(), pageIndex: t2, rect: v2 };
          n3(f2);
        } }), u4 = (e4) => {
          const t3 = a3();
          if (!t3) return null;
          const n4 = Math.min(t3.x, e4.x), o4 = Math.min(t3.y, e4.y), i4 = Math.abs(t3.x - e4.x), r3 = Math.abs(t3.y - e4.y), s5 = c4();
          if (!s5) return null;
          const l5 = s5.strokeWidth, d5 = l5 / 2, u5 = { origin: { x: n4 - d5, y: o4 - d5 }, size: { width: i4 + l5, height: r3 + l5 } };
          return { type: Dt.CIRCLE, bounds: u5, data: { rect: u5, ...s5 } };
        };
        return { onPointerDown: (e4, t3) => {
          var n4;
          const i4 = l4(e4);
          s4(i4), d4.onStart(i4), o3(u4(i4)), null == (n4 = t3.setPointerCapture) || n4.call(t3);
        }, onPointerMove: (e4) => {
          const t3 = l4(e4);
          d4.onMove(t3), a3() && d4.hasMoved() && o3(u4(t3));
        }, onPointerUp: (e4, i4) => {
          var r3;
          if (!a3()) return;
          if (!c4()) return;
          const h3 = l4(e4);
          if (d4.hasMoved()) {
            const e5 = c4();
            if (!e5) return;
            const o4 = u4(h3);
            if (o4) {
              const i5 = { ...e5, type: Dt.CIRCLE, flags: ["print"], created: /* @__PURE__ */ new Date(), id: yn(), pageIndex: t2, rect: o4.data.rect };
              n3(i5);
            }
          } else d4.onEnd(h3);
          s4(null), o3(null), d4.reset(), null == (r3 = i4.releasePointerCapture) || r3.call(i4);
        }, onPointerLeave: (e4, t3) => {
          var n4;
          s4(null), o3(null), d4.reset(), null == (n4 = t3.releasePointerCapture) || n4.call(t3);
        }, onPointerCancel: (e4, t3) => {
          var n4;
          s4(null), o3(null), d4.reset(), null == (n4 = t3.releasePointerCapture) || n4.call(t3);
        } };
      } };
      $c = (e3, t2) => {
        var n3;
        switch (t2.type) {
          case "vertex-edit":
          default:
            return t2.changes;
          case "move":
            if (t2.changes.rect) {
              const n4 = t2.changes.rect.origin.x - e3.rect.origin.x, o3 = t2.changes.rect.origin.y - e3.rect.origin.y, i3 = e3.inkList.map((e4) => ({ points: e4.points.map((e5) => ({ x: e5.x + n4, y: e5.y + o3 })) }));
              return { rect: t2.changes.rect, inkList: i3 };
            }
            return t2.changes;
          case "resize":
            if (t2.changes.rect) {
              const o3 = e3.rect, i3 = t2.changes.rect;
              let r2 = i3.size.width / o3.size.width, a3 = i3.size.height / o3.size.height;
              const s4 = 10;
              if ((i3.size.width < s4 || i3.size.height < s4) && (r2 = Math.max(r2, s4 / o3.size.width), a3 = Math.max(a3, s4 / o3.size.height), t2.changes.rect = { origin: i3.origin, size: { width: o3.size.width * r2, height: o3.size.height * a3 } }), null == (n3 = t2.metadata) ? void 0 : n3.maintainAspectRatio) {
                const e4 = Math.min(r2, a3);
                r2 = e4, a3 = e4, t2.changes.rect.size = { width: o3.size.width * e4, height: o3.size.height * e4 };
              }
              const l4 = (e4, t3) => ({ origin: { x: e4.origin.x + t3, y: e4.origin.y + t3 }, size: { width: Math.max(1, e4.size.width - 2 * t3), height: Math.max(1, e4.size.height - 2 * t3) } }), c4 = Math.min(t2.changes.rect.size.width / o3.size.width, t2.changes.rect.size.height / o3.size.height), d4 = Math.max(1, Math.round(e3.strokeWidth * c4)), u4 = l4(o3, e3.strokeWidth / 2), h3 = l4(t2.changes.rect, d4 / 2), m3 = h3.size.width / Math.max(u4.size.width, 1e-6), g3 = h3.size.height / Math.max(u4.size.height, 1e-6), p4 = e3.inkList.map((e4) => ({ points: e4.points.map((e5) => ({ x: h3.origin.x + (e5.x - u4.origin.x) * m3, y: h3.origin.y + (e5.y - u4.origin.y) * g3 })) }));
              return { rect: t2.changes.rect, inkList: p4, strokeWidth: d4 };
            }
            return t2.changes;
          case "property-update":
            if (void 0 !== t2.changes.strokeWidth) {
              const n4 = { ...e3, ...t2.changes }, o3 = n4.inkList.flatMap((e4) => e4.points), i3 = et(Je(o3), n4.strokeWidth / 2);
              return { ...t2.changes, rect: i3 };
            }
            return t2.changes;
        }
      };
      Fc = (e3, t2) => {
        var n3;
        switch (t2.type) {
          case "vertex-edit":
            if (t2.changes.linePoints) {
              const { start: n4, end: o3 } = t2.changes.linePoints;
              return { rect: Pc([n4, o3], e3.strokeWidth, e3.lineEndings), linePoints: { start: n4, end: o3 } };
            }
            return t2.changes;
          case "move":
            if (t2.changes.rect) {
              const n4 = t2.changes.rect.origin.x - e3.rect.origin.x, o3 = t2.changes.rect.origin.y - e3.rect.origin.y;
              return { rect: t2.changes.rect, linePoints: { start: { x: e3.linePoints.start.x + n4, y: e3.linePoints.start.y + o3 }, end: { x: e3.linePoints.end.x + n4, y: e3.linePoints.end.y + o3 } } };
            }
            return t2.changes;
          case "resize":
            if (t2.changes.rect) {
              const o3 = e3.rect, i3 = t2.changes.rect;
              let r2 = i3.size.width / o3.size.width, a3 = i3.size.height / o3.size.height;
              const s4 = 10;
              if ((i3.size.width < s4 || i3.size.height < s4) && (r2 = Math.max(r2, s4 / o3.size.width), a3 = Math.max(a3, s4 / o3.size.height), t2.changes.rect = { origin: i3.origin, size: { width: o3.size.width * r2, height: o3.size.height * a3 } }), null == (n3 = t2.metadata) ? void 0 : n3.maintainAspectRatio) {
                const e4 = Math.min(r2, a3);
                r2 = e4, a3 = e4, t2.changes.rect.size = { width: o3.size.width * e4, height: o3.size.height * e4 };
              }
              const l4 = { start: { x: t2.changes.rect.origin.x + (e3.linePoints.start.x - o3.origin.x) * r2, y: t2.changes.rect.origin.y + (e3.linePoints.start.y - o3.origin.y) * a3 }, end: { x: t2.changes.rect.origin.x + (e3.linePoints.end.x - o3.origin.x) * r2, y: t2.changes.rect.origin.y + (e3.linePoints.end.y - o3.origin.y) * a3 } };
              return { rect: t2.changes.rect, linePoints: l4 };
            }
            return t2.changes;
          case "property-update":
            if (t2.changes.strokeWidth || t2.changes.lineEndings) {
              const n4 = { ...e3, ...t2.changes }, o3 = Pc([n4.linePoints.start, n4.linePoints.end], n4.strokeWidth, n4.lineEndings);
              return { ...t2.changes, rect: o3 };
            }
            return t2.changes;
          default:
            return t2.changes;
        }
      };
      jc = (e3, t2) => {
        var n3;
        switch (t2.type) {
          case "vertex-edit":
            return t2.changes.vertices && t2.changes.vertices.length ? { rect: Pc(t2.changes.vertices, e3.strokeWidth, e3.lineEndings), vertices: t2.changes.vertices } : t2.changes;
          case "move":
            if (t2.changes.rect) {
              const n4 = t2.changes.rect.origin.x - e3.rect.origin.x, o3 = t2.changes.rect.origin.y - e3.rect.origin.y, i3 = e3.vertices.map((e4) => ({ x: e4.x + n4, y: e4.y + o3 }));
              return { rect: t2.changes.rect, vertices: i3 };
            }
            return t2.changes;
          case "resize":
            if (t2.changes.rect) {
              const o3 = e3.rect, i3 = t2.changes.rect;
              let r2 = i3.size.width / o3.size.width, a3 = i3.size.height / o3.size.height;
              const s4 = 10;
              if ((i3.size.width < s4 || i3.size.height < s4) && (r2 = Math.max(r2, s4 / o3.size.width), a3 = Math.max(a3, s4 / o3.size.height), t2.changes.rect = { origin: i3.origin, size: { width: o3.size.width * r2, height: o3.size.height * a3 } }), null == (n3 = t2.metadata) ? void 0 : n3.maintainAspectRatio) {
                const e4 = Math.min(r2, a3);
                r2 = e4, a3 = e4, t2.changes.rect.size = { width: o3.size.width * e4, height: o3.size.height * e4 };
              }
              const l4 = e3.vertices.map((e4) => ({ x: t2.changes.rect.origin.x + (e4.x - o3.origin.x) * r2, y: t2.changes.rect.origin.y + (e4.y - o3.origin.y) * a3 }));
              return { rect: t2.changes.rect, vertices: l4 };
            }
            return t2.changes;
          case "property-update":
            if (void 0 !== t2.changes.strokeWidth || void 0 !== t2.changes.lineEndings) {
              const n4 = { ...e3, ...t2.changes }, o3 = Pc(n4.vertices, n4.strokeWidth, n4.lineEndings);
              return { ...t2.changes, rect: o3 };
            }
            return t2.changes;
          default:
            return t2.changes;
        }
      };
      Hc = (e3, t2) => {
        var n3;
        switch (t2.type) {
          case "vertex-edit":
            if (t2.changes.vertices && t2.changes.vertices.length) {
              const n4 = e3.strokeWidth / 2;
              return { rect: et(Je(t2.changes.vertices), n4), vertices: t2.changes.vertices };
            }
            return t2.changes;
          case "move":
            if (t2.changes.rect) {
              const n4 = t2.changes.rect.origin.x - e3.rect.origin.x, o3 = t2.changes.rect.origin.y - e3.rect.origin.y, i3 = e3.vertices.map((e4) => ({ x: e4.x + n4, y: e4.y + o3 }));
              return { rect: t2.changes.rect, vertices: i3 };
            }
            return t2.changes;
          case "resize":
            if (t2.changes.rect) {
              const o3 = e3.rect, i3 = t2.changes.rect;
              let r2 = i3.size.width / o3.size.width, a3 = i3.size.height / o3.size.height;
              const s4 = 10;
              if ((i3.size.width < s4 || i3.size.height < s4) && (r2 = Math.max(r2, s4 / o3.size.width), a3 = Math.max(a3, s4 / o3.size.height), t2.changes.rect = { origin: i3.origin, size: { width: o3.size.width * r2, height: o3.size.height * a3 } }), null == (n3 = t2.metadata) ? void 0 : n3.maintainAspectRatio) {
                const e4 = Math.min(r2, a3);
                r2 = e4, a3 = e4, t2.changes.rect.size = { width: o3.size.width * e4, height: o3.size.height * e4 };
              }
              const l4 = e3.vertices.map((e4) => ({ x: t2.changes.rect.origin.x + (e4.x - o3.origin.x) * r2, y: t2.changes.rect.origin.y + (e4.y - o3.origin.y) * a3 }));
              return { rect: t2.changes.rect, vertices: l4 };
            }
            return t2.changes;
          case "property-update":
            if (void 0 !== t2.changes.strokeWidth) {
              const n4 = { ...e3, ...t2.changes }, o3 = n4.strokeWidth / 2, i3 = et(Je(n4.vertices), o3);
              return { ...t2.changes, rect: i3 };
            }
            return t2.changes;
          default:
            return t2.changes;
        }
      };
      Uc = class extends Yn {
        constructor(e3, t2, n3) {
          var o3, i3, r2;
          super(e3, t2), this.ANNOTATION_HISTORY_TOPIC = "annotations", this.state$ = ao(), this.pendingContexts = /* @__PURE__ */ new Map(), this.isInitialLoadComplete = /* @__PURE__ */ new Map(), this.importQueue = /* @__PURE__ */ new Map(), this.handlerFactories = /* @__PURE__ */ new Map(), this.activeTool$ = ao(), this.events$ = ao(), this.toolsChange$ = ao(), this.patchRegistry = new Ac(), this.config = n3, this.selection = (null == (o3 = t2.getPlugin("selection")) ? void 0 : o3.provides()) ?? null, this.history = (null == (i3 = t2.getPlugin("history")) ? void 0 : i3.provides()) ?? null, this.interactionManager = (null == (r2 = t2.getPlugin("interaction-manager")) ? void 0 : r2.provides()) ?? null, this.registerHandlerFactories(), this.registerBuiltInPatches();
        }
        onDocumentLoadingStarted(e3) {
          this.dispatch(/* @__PURE__ */ (function(e4, t2) {
            return { type: El, payload: { documentId: e4, state: t2 } };
          })(e3, { pages: {}, byUid: {}, selectedUid: null, activeToolId: null, hasPendingChanges: false })), this.pendingContexts.set(e3, /* @__PURE__ */ new Map()), this.isInitialLoadComplete.set(e3, false), this.importQueue.set(e3, []), this.logger.debug("AnnotationPlugin", "DocumentOpened", `Initialized annotation state for document: ${e3}`);
        }
        onDocumentLoaded(e3) {
          const t2 = this.getCoreDocument(e3);
          if ((null == t2 ? void 0 : t2.document) && this.getAllAnnotations(e3, t2.document), this.selection) for (const e4 of this.state.tools) e4.interaction.textSelection && this.selection.enableForMode(e4.interaction.mode ?? e4.id);
        }
        onDocumentClosed(e3) {
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: _l, payload: e4 };
          })(e3)), this.pendingContexts.delete(e3), this.isInitialLoadComplete.delete(e3), this.importQueue.delete(e3), this.logger.debug("AnnotationPlugin", "DocumentClosed", `Cleaned up annotation state for document: ${e3}`);
        }
        registerHandlerFactories() {
          this.handlerFactories.set(Dt.CIRCLE, Lc), this.handlerFactories.set(Dt.SQUARE, Nc), this.handlerFactories.set(Dt.STAMP, Oc), this.handlerFactories.set(Dt.POLYGON, Rc), this.handlerFactories.set(Dt.POLYLINE, _c), this.handlerFactories.set(Dt.LINE, Ec), this.handlerFactories.set(Dt.INK, wc), this.handlerFactories.set(Dt.FREETEXT, Cc);
        }
        registerBuiltInPatches() {
          this.patchRegistry.register(Dt.INK, $c), this.patchRegistry.register(Dt.LINE, Fc), this.patchRegistry.register(Dt.POLYLINE, jc), this.patchRegistry.register(Dt.POLYGON, Hc);
        }
        async initialize() {
          var e3, t2;
          this.state.tools.forEach((e4) => this.registerInteractionForTool(e4)), this.history && this.history.onHistoryChange((e4) => {
            e4.topic === this.ANNOTATION_HISTORY_TOPIC && false !== this.config.autoCommit && this.commit(e4.documentId);
          }), null == (e3 = this.interactionManager) || e3.onModeChange((e4) => {
            var t3, n3;
            const o3 = (null == (t3 = this.state.tools.find((t4) => (t4.interaction.mode ?? t4.id) === e4.activeMode)) ? void 0 : t3.id) ?? null;
            o3 !== ((null == (n3 = this.state.documents[e4.documentId]) ? void 0 : n3.activeToolId) ?? null) && e4.documentId && this.dispatch(Vl(e4.documentId, o3));
          }), null == (t2 = this.selection) || t2.onEndSelection(({ documentId: e4 }) => {
            var t3, n3, o3;
            const i3 = this.getActiveTool(e4);
            if (!i3 || !i3.interaction.textSelection) return;
            const r2 = null == (t3 = this.selection) ? void 0 : t3.getFormattedSelection(), a3 = null == (n3 = this.selection) ? void 0 : n3.getSelectedText();
            if (r2 && a3) {
              for (const t4 of r2) a3.wait((n4) => {
                const o4 = yn();
                this.createAnnotation(t4.pageIndex, { ...i3.defaults, rect: t4.rect, segmentRects: t4.segmentRects, pageIndex: t4.pageIndex, created: /* @__PURE__ */ new Date(), id: o4, custom: { text: n4.join("\n") } }, void 0, e4), this.getToolBehavior(i3, "deactivateToolAfterCreate") && this.setActiveTool(null, e4), this.getToolBehavior(i3, "selectAfterCreate") && this.selectAnnotation(t4.pageIndex, o4, e4);
              }, wn);
              null == (o3 = this.selection) || o3.clear();
            }
          });
        }
        registerInteractionForTool(e3) {
          var t2;
          null == (t2 = this.interactionManager) || t2.registerMode({ id: e3.interaction.mode ?? e3.id, scope: "page", exclusive: e3.interaction.exclusive, cursor: e3.interaction.cursor });
        }
        buildCapability() {
          return { getActiveTool: () => this.getActiveTool(), setActiveTool: (e3) => this.setActiveTool(e3), getState: () => this.getDocumentState(), getPageAnnotations: (e3) => this.getPageAnnotations(e3), getSelectedAnnotation: () => this.getSelectedAnnotation(), getAnnotationById: (e3) => this.getAnnotationById(e3), selectAnnotation: (e3, t2) => this.selectAnnotation(e3, t2), deselectAnnotation: () => this.deselectAnnotation(), importAnnotations: (e3) => this.importAnnotations(e3), createAnnotation: (e3, t2, n3) => this.createAnnotation(e3, t2, n3), updateAnnotation: (e3, t2, n3) => this.updateAnnotation(e3, t2, n3), deleteAnnotation: (e3, t2) => this.deleteAnnotation(e3, t2), renderAnnotation: (e3) => this.renderAnnotation(e3), commit: () => this.commit(), forDocument: (e3) => this.createAnnotationScope(e3), getTools: () => this.state.tools, getTool: (e3) => this.getTool(e3), addTool: (e3) => {
            this.dispatch(/* @__PURE__ */ ((e4) => ({ type: ql, payload: e4 }))(e3)), this.registerInteractionForTool(e3);
          }, findToolForAnnotation: (e3) => this.findToolForAnnotation(e3), setToolDefaults: (e3, t2) => this.dispatch(/* @__PURE__ */ ((e4, t3) => ({ type: Bl, payload: { toolId: e4, patch: t3 } }))(e3, t2)), getColorPresets: () => [...this.state.colorPresets], addColorPreset: (e3) => this.dispatch(/* @__PURE__ */ ((e4) => ({ type: Wl, payload: e4 }))(e3)), transformAnnotation: (e3, t2) => this.transformAnnotation(e3, t2), registerPatchFunction: (e3, t2) => this.registerPatchFunction(e3, t2), onStateChange: this.state$.on, onActiveToolChange: this.activeTool$.on, onAnnotationEvent: this.events$.on, onToolsChange: this.toolsChange$.on };
        }
        createAnnotationScope(e3) {
          return { getState: () => this.getDocumentState(e3), getPageAnnotations: (t2) => this.getPageAnnotations(t2, e3), getSelectedAnnotation: () => this.getSelectedAnnotation(e3), getAnnotationById: (t2) => this.getAnnotationById(t2, e3), selectAnnotation: (t2, n3) => this.selectAnnotation(t2, n3, e3), deselectAnnotation: () => this.deselectAnnotation(e3), getActiveTool: () => this.getActiveTool(e3), setActiveTool: (t2) => this.setActiveTool(t2, e3), findToolForAnnotation: (e4) => this.findToolForAnnotation(e4), importAnnotations: (t2) => this.importAnnotations(t2, e3), createAnnotation: (t2, n3, o3) => this.createAnnotation(t2, n3, o3, e3), updateAnnotation: (t2, n3, o3) => this.updateAnnotation(t2, n3, o3, e3), deleteAnnotation: (t2, n3) => this.deleteAnnotation(t2, n3, e3), renderAnnotation: (t2) => this.renderAnnotation(t2, e3), commit: () => this.commit(e3), onStateChange: (t2) => this.state$.on((n3) => {
            n3.documentId === e3 && t2(n3.state);
          }), onAnnotationEvent: (t2) => this.events$.on((n3) => {
            n3.documentId === e3 && t2(n3);
          }), onActiveToolChange: (t2) => this.activeTool$.on((n3) => {
            n3.documentId === e3 && t2(n3.tool);
          }) };
        }
        onStoreUpdated(e3, t2) {
          for (const n3 in t2.documents) {
            const o3 = e3.documents[n3], i3 = t2.documents[n3];
            o3 !== i3 && (this.state$.emit({ documentId: n3, state: i3 }), o3 && o3.activeToolId !== i3.activeToolId && this.activeTool$.emit({ documentId: n3, tool: this.getActiveTool(n3) }));
          }
          if (e3.tools !== t2.tools) {
            for (const e4 in t2.documents) this.activeTool$.emit({ documentId: e4, tool: this.getActiveTool(e4) });
            this.toolsChange$.emit({ tools: t2.tools });
          }
        }
        registerPatchFunction(e3, t2) {
          this.patchRegistry.register(e3, t2);
        }
        transformAnnotation(e3, t2) {
          const n3 = { type: t2.type, changes: t2.changes, metadata: t2.metadata };
          return this.patchRegistry.transform(e3, n3);
        }
        registerPageHandlers(e3, t2, n3, o3) {
          var i3;
          const r2 = this.getCoreDocument(e3), a3 = null == (i3 = null == r2 ? void 0 : r2.document) ? void 0 : i3.pages[t2];
          if (!a3) return () => {
          };
          if (!this.interactionManager) return () => {
          };
          const s4 = [];
          for (const i4 of this.state.tools) {
            if (!i4.defaults.type) continue;
            const r3 = this.handlerFactories.get(i4.defaults.type);
            if (!r3) continue;
            const l4 = { pageIndex: t2, pageSize: a3.size, scale: n3, services: o3.services, onPreview: (e4) => o3.onPreview(i4.id, e4), onCommit: (n4, o4) => {
              this.createAnnotation(t2, n4, o4, e3), this.getToolBehavior(i4, "deactivateToolAfterCreate") && this.setActiveTool(null, e3), this.getToolBehavior(i4, "selectAfterCreate") && this.selectAnnotation(t2, n4.id, e3);
            }, getTool: () => this.state.tools.find((e4) => e4.id === i4.id) }, c4 = this.interactionManager.registerHandlers({ documentId: e3, modeId: i4.interaction.mode ?? i4.id, handlers: r3.create(l4), pageIndex: t2 });
            s4.push(c4);
          }
          return () => s4.forEach((e4) => e4());
        }
        getDocumentState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.state.documents[t2];
          if (!n3) throw new Error(`Annotation state not found for document: ${t2}`);
          return n3;
        }
        getAllAnnotations(e3, t2) {
          this.engine.getAllAnnotations(t2).wait((t3) => {
            this.dispatch(/* @__PURE__ */ ((e4, t4) => ({ type: Rl, payload: { documentId: e4, annotations: t4 } }))(e3, t3)), this.isInitialLoadComplete.set(e3, true);
            const n3 = this.importQueue.get(e3);
            n3 && n3.length > 0 && this.processImportQueue(e3), this.events$.emit({ type: "loaded", documentId: e3, total: Object.values(t3).reduce((e4, t4) => e4 + t4.length, 0) });
          }, wn);
        }
        getPageAnnotations(e3, t2) {
          const { pageIndex: n3 } = e3, o3 = t2 ?? this.getActiveDocumentId(), i3 = this.getCoreDocument(o3), r2 = null == i3 ? void 0 : i3.document;
          if (!r2) return Ut.reject({ code: Ht.NotFound, message: "Document not found" });
          const a3 = r2.pages.find((e4) => e4.index === n3);
          return a3 ? this.engine.getPageAnnotations(r2, a3) : Ut.reject({ code: Ht.NotFound, message: "Page not found" });
        }
        getSelectedAnnotation(e3) {
          return ((e4) => e4.selectedUid ? e4.byUid[e4.selectedUid] : null)(this.getDocumentState(e3));
        }
        getAnnotationById(e3, t2) {
          const n3 = this.getDocumentState(t2);
          return mc(n3, e3);
        }
        renderAnnotation({ pageIndex: e3, annotation: t2, options: n3 }, o3) {
          const i3 = o3 ?? this.getActiveDocumentId(), r2 = this.getCoreDocument(i3), a3 = null == r2 ? void 0 : r2.document;
          if (!a3) return Ut.reject({ code: Ht.NotFound, message: "Document not found" });
          const s4 = a3.pages.find((t3) => t3.index === e3);
          return s4 ? this.engine.renderPageAnnotation(a3, s4, t2, n3) : Ut.reject({ code: Ht.NotFound, message: "Page not found" });
        }
        importAnnotations(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId();
          if (!this.isInitialLoadComplete.get(n3)) {
            const t3 = this.importQueue.get(n3) || [];
            return t3.push(...e3), void this.importQueue.set(n3, t3);
          }
          this.processImportItems(n3, e3);
        }
        processImportQueue(e3) {
          const t2 = this.importQueue.get(e3);
          if (!t2 || 0 === t2.length) return;
          const n3 = [...t2];
          this.importQueue.set(e3, []), this.processImportItems(e3, n3);
        }
        processImportItems(e3, t2) {
          const n3 = this.pendingContexts.get(e3);
          if (n3) {
            for (const o3 of t2) {
              const { annotation: t3, ctx: i3 } = o3, r2 = t3.pageIndex, a3 = t3.id;
              this.dispatch(Zl(e3, r2, t3)), i3 && n3.set(a3, i3);
            }
            false !== this.config.autoCommit && this.commit(e3);
          }
        }
        createAnnotation(e3, t2, n3, o3) {
          const i3 = t2.id, r2 = o3 ?? this.getActiveDocumentId(), a3 = this.pendingContexts.get(r2);
          if (!a3) return;
          const s4 = { ...t2, author: t2.author ?? this.config.annotationAuthor }, l4 = () => {
            this.dispatch(Zl(r2, e3, s4)), n3 && a3.set(i3, n3), this.events$.emit({ type: "create", documentId: r2, annotation: s4, pageIndex: e3, ctx: n3, committed: false });
          };
          if (!this.history) return l4(), void (this.config.autoCommit && this.commit(r2));
          const c4 = { execute: l4, undo: () => {
            a3.delete(i3), this.dispatch(Gl(r2)), this.dispatch(Yl(r2, e3, i3)), this.events$.emit({ type: "delete", documentId: r2, annotation: s4, pageIndex: e3, committed: false });
          } };
          this.history.forDocument(r2).register(c4, this.ANNOTATION_HISTORY_TOPIC);
        }
        buildPatch(e3, t2) {
          return "rect" in t2 ? t2 : this.transformAnnotation(e3, { type: "property-update", changes: t2 });
        }
        updateAnnotation(e3, t2, n3, o3) {
          const i3 = o3 ?? this.getActiveDocumentId(), r2 = this.getDocumentState(i3).byUid[t2].object, a3 = this.buildPatch(r2, { ...n3, author: n3.author ?? this.config.annotationAuthor }), s4 = () => {
            this.dispatch(Kl(i3, e3, t2, a3)), this.events$.emit({ type: "update", documentId: i3, annotation: r2, pageIndex: e3, patch: a3, committed: false });
          };
          if (!this.history) return s4(), void (false !== this.config.autoCommit && this.commit(i3));
          const l4 = Object.fromEntries(Object.keys(n3).map((e4) => [e4, r2[e4]])), c4 = { execute: s4, undo: () => {
            this.dispatch(Kl(i3, e3, t2, l4)), this.events$.emit({ type: "update", documentId: i3, annotation: r2, pageIndex: e3, patch: l4, committed: false });
          } };
          this.history.forDocument(i3).register(c4, this.ANNOTATION_HISTORY_TOPIC);
        }
        deleteAnnotation(e3, t2, n3) {
          var o3;
          const i3 = n3 ?? this.getActiveDocumentId(), r2 = null == (o3 = this.getDocumentState(i3).byUid[t2]) ? void 0 : o3.object;
          if (!r2) return;
          const a3 = () => {
            this.dispatch(Gl(i3)), this.dispatch(Yl(i3, e3, t2)), this.events$.emit({ type: "delete", documentId: i3, annotation: r2, pageIndex: e3, committed: false });
          };
          if (!this.history) return a3(), void (false !== this.config.autoCommit && this.commit(i3));
          const s4 = { execute: a3, undo: () => {
            this.dispatch(Zl(i3, e3, r2)), this.events$.emit({ type: "create", documentId: i3, annotation: r2, pageIndex: e3, committed: false });
          } };
          this.history.forDocument(i3).register(s4, this.ANNOTATION_HISTORY_TOPIC);
        }
        selectAnnotation(e3, t2, n3) {
          const o3 = n3 ?? this.getActiveDocumentId();
          this.dispatch(/* @__PURE__ */ ((e4, t3, n4) => ({ type: Nl, payload: { documentId: e4, pageIndex: t3, id: n4 } }))(o3, e3, t2));
        }
        deselectAnnotation(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          this.dispatch(Gl(t2));
        }
        getActiveTool(e3) {
          const t2 = this.getDocumentState(e3);
          return t2.activeToolId ? this.state.tools.find((e4) => e4.id === t2.activeToolId) ?? null : null;
        }
        setActiveTool(e3, t2) {
          var n3, o3;
          const i3 = t2 ?? this.getActiveDocumentId(), r2 = this.getDocumentState(i3);
          if (e3 === r2.activeToolId) return;
          this.dispatch(Vl(i3, e3));
          const a3 = this.state.tools.find((t3) => t3.id === e3);
          a3 ? null == (n3 = this.interactionManager) || n3.forDocument(i3).activate(a3.interaction.mode ?? a3.id) : null == (o3 = this.interactionManager) || o3.forDocument(i3).activateDefaultMode();
        }
        getTool(e3) {
          return this.state.tools.find((t2) => t2.id === e3);
        }
        findToolForAnnotation(e3) {
          let t2 = null, n3 = 0;
          for (const o3 of this.state.tools) {
            const i3 = o3.matchScore(e3);
            i3 > n3 && (n3 = i3, t2 = o3);
          }
          return t2;
        }
        commit(e3) {
          const t2 = new gt(), n3 = e3 ?? this.getActiveDocumentId(), o3 = this.getDocumentState(n3);
          if (!o3.hasPendingChanges) return Ut.resolve(true);
          const i3 = this.getCoreDocument(n3), r2 = null == i3 ? void 0 : i3.document;
          if (!r2) return Ut.reject({ code: Ht.NotFound, message: "Document not found" });
          const a3 = this.pendingContexts.get(n3);
          if (!a3) return Ut.resolve(true);
          const s4 = [], l4 = [], c4 = [];
          for (const [e4, t3] of Object.entries(o3.byUid)) {
            if ("synced" === t3.commitState) continue;
            const o4 = r2.pages.find((e5) => e5.index === t3.object.pageIndex);
            if (o4) switch (t3.commitState) {
              case "new":
                const i4 = a3.get(t3.object.id), d5 = this.engine.createPageAnnotation(r2, o4, t3.object, i4);
                d5.wait(() => {
                  this.events$.emit({ type: "create", documentId: n3, annotation: t3.object, pageIndex: t3.object.pageIndex, ctx: i4, committed: true }), a3.delete(t3.object.id);
                }, wn), s4.push(d5);
                break;
              case "dirty":
                const u5 = this.engine.updatePageAnnotation(r2, o4, t3.object);
                u5.wait(() => {
                  this.events$.emit({ type: "update", documentId: n3, annotation: t3.object, pageIndex: t3.object.pageIndex, patch: t3.object, committed: true });
                }, wn), l4.push(u5);
                break;
              case "deleted":
                c4.push({ ta: t3, uid: e4 });
            }
          }
          const d4 = [];
          for (const { ta: e4, uid: t3 } of c4) {
            const o4 = r2.pages.find((t4) => t4.index === e4.object.pageIndex);
            if ("deleted" === e4.commitState && e4.object.id) {
              const i4 = new gt();
              this.engine.removePageAnnotation(r2, o4, e4.object).wait(() => {
                this.dispatch(Xl(n3, t3)), this.events$.emit({ type: "delete", documentId: n3, annotation: e4.object, pageIndex: e4.object.pageIndex, committed: true }), i4.resolve(true);
              }, i4.fail), d4.push(i4);
            } else this.dispatch(Xl(n3, t3));
          }
          const u4 = [...s4, ...l4, ...d4];
          return gt.allSettled(u4).wait(() => {
            this.dispatch(/* @__PURE__ */ ((e4) => ({ type: Hl, payload: { documentId: e4 } }))(n3)), t2.resolve(true);
          }, t2.fail), t2;
        }
        getToolBehavior(e3, t2) {
          var n3;
          return void 0 !== (null == (n3 = e3.behavior) ? void 0 : n3[t2]) ? e3.behavior[t2] : false !== this.config[t2];
        }
      };
      Uc.id = "annotation";
      Wc = Uc;
      qc = Bc("highlight");
      Gc = Bc("squiggly");
      Vc = Bc("underline");
      Zc = Bc("strikeout");
      Kc = { manifest: zl, create: (e3, t2) => new Wc(Tl, e3, t2), reducer: (e3, t2) => {
        switch (t2.type) {
          case El: {
            const { documentId: n3, state: o3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: o3 }, activeDocumentId: e3.activeDocumentId ?? n3 };
          }
          case _l: {
            const n3 = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3, activeDocumentId: e3.activeDocumentId === n3 ? null : e3.activeDocumentId };
          }
          case "ANNOTATION/SET_ACTIVE_DOCUMENT":
            return { ...e3, activeDocumentId: t2.payload };
          case Rl: {
            const { documentId: n3, annotations: o3 } = t2.payload, i3 = e3.documents[n3];
            if (!i3) return e3;
            const r2 = {}, a3 = {};
            for (const [e4, t3] of Object.entries(o3)) {
              const n4 = Number(e4), o4 = i3.pages[n4] || [];
              for (const e5 of o4) delete a3[e5];
              const s4 = t3.map((e5) => {
                const t4 = e5.id;
                return a3[t4] = { commitState: "synced", object: e5 }, t4;
              });
              r2[n4] = s4;
            }
            return { ...e3, documents: { ...e3.documents, [n3]: { ...i3, pages: r2, byUid: a3 } } };
          }
          case Nl: {
            const { documentId: n3, id: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, selectedUid: o3 } } } : e3;
          }
          case Ol: {
            const { documentId: n3 } = t2.payload, o3 = e3.documents[n3];
            return o3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...o3, selectedUid: null } } } : e3;
          }
          case Ll: {
            const { documentId: n3, toolId: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, activeToolId: o3 } } } : e3;
          }
          case $l: {
            const { documentId: n3, pageIndex: o3, annotation: i3 } = t2.payload, r2 = e3.documents[n3];
            if (!r2) return e3;
            const a3 = i3.id;
            return { ...e3, documents: { ...e3.documents, [n3]: { ...r2, pages: { ...r2.pages, [o3]: [...r2.pages[o3] ?? [], a3] }, byUid: { ...r2.byUid, [a3]: { commitState: "new", object: i3 } }, hasPendingChanges: true } } };
          }
          case jl: {
            const { documentId: n3, pageIndex: o3, id: i3 } = t2.payload, r2 = e3.documents[n3];
            return r2 && r2.byUid[i3] ? { ...e3, documents: { ...e3.documents, [n3]: { ...r2, pages: { ...r2.pages, [o3]: (r2.pages[o3] ?? []).filter((e4) => e4 !== i3) }, byUid: { ...r2.byUid, [i3]: { ...r2.byUid[i3], commitState: "deleted" } }, hasPendingChanges: true } } } : e3;
          }
          case Fl: {
            const { documentId: n3, id: o3, patch: i3 } = t2.payload, r2 = e3.documents[n3];
            return r2 ? { ...e3, documents: { ...e3.documents, [n3]: yc(r2, o3, i3) } } : e3;
          }
          case Hl: {
            const { documentId: n3 } = t2.payload, o3 = e3.documents[n3];
            if (!o3) return e3;
            const i3 = {};
            for (const [e4, t3] of Object.entries(o3.byUid)) i3[e4] = { ...t3, commitState: "dirty" === t3.commitState || "new" === t3.commitState ? "synced" : t3.commitState };
            return { ...e3, documents: { ...e3.documents, [n3]: { ...o3, byUid: i3, hasPendingChanges: false } } };
          }
          case Ul: {
            const { documentId: n3, uid: o3 } = t2.payload, i3 = e3.documents[n3];
            if (!i3) return e3;
            const { [o3]: r2, ...a3 } = i3.byUid;
            return { ...e3, documents: { ...e3.documents, [n3]: { ...i3, byUid: a3 } } };
          }
          case ql: {
            const n3 = new Map(e3.tools.map((e4) => [e4.id, e4]));
            return n3.set(t2.payload.id, t2.payload), { ...e3, tools: Array.from(n3.values()) };
          }
          case Bl: {
            const { toolId: n3, patch: o3 } = t2.payload;
            return { ...e3, tools: e3.tools.map((e4) => e4.id === n3 ? { ...e4, defaults: { ...e4.defaults, ...o3 } } : e4) };
          }
          case Wl:
            return e3.colorPresets.includes(t2.payload) ? e3 : { ...e3, colorPresets: [...e3.colorPresets, t2.payload] };
          default:
            return e3;
        }
      }, initialState: (e3, t2) => ((e4) => {
        const t3 = /* @__PURE__ */ new Map();
        return vc.forEach((e5) => t3.set(e5.id, e5)), (e4.tools || []).forEach((e5) => t3.set(e5.id, e5)), { documents: {}, activeDocumentId: null, tools: Array.from(t3.values()), colorPresets: e4.colorPresets ?? fc };
      })(t2) };
      Yc = "INTERACTION/INIT_STATE";
      Xc = "INTERACTION/CLEANUP_STATE";
      Qc = "INTERACTION/ACTIVATE_MODE";
      Jc = "INTERACTION/PAUSE";
      ed = "INTERACTION/RESUME";
      td = "INTERACTION/SET_CURSOR";
      nd = "INTERACTION/SET_DEFAULT_MODE";
      od = "INTERACTION/SET_EXCLUSION_RULES";
      id = "INTERACTION/ADD_EXCLUSION_CLASS";
      rd = "INTERACTION/REMOVE_EXCLUSION_CLASS";
      ad = "INTERACTION/ADD_EXCLUSION_ATTRIBUTE";
      sd = "INTERACTION/REMOVE_EXCLUSION_ATTRIBUTE";
      dd = "pointerMode";
      ud = class extends Yn {
        constructor(e3, t2, n3) {
          super(e3, t2), this.modes = /* @__PURE__ */ new Map(), this.cursorClaims = /* @__PURE__ */ new Map(), this.buckets = /* @__PURE__ */ new Map(), this.alwaysGlobal = /* @__PURE__ */ new Map(), this.alwaysPage = /* @__PURE__ */ new Map(), this.onModeChange$ = ro(), this.onHandlerChange$ = ro(), this.onCursorChange$ = ro(), this.onStateChange$ = ao(), this.registerMode({ id: dd, scope: "page", exclusive: false, cursor: "auto" }), this.dispatch(ld(dd)), n3.exclusionRules && this.dispatch(cd(n3.exclusionRules));
        }
        onDocumentLoadingStarted(e3) {
          const t2 = { activeMode: this.state.defaultMode, cursor: "auto", paused: false };
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Yc, payload: { documentId: e4, state: t3 } };
          })(e3, t2)), this.cursorClaims.set(e3, /* @__PURE__ */ new Map()), this.buckets.set(e3, /* @__PURE__ */ new Map()), this.alwaysGlobal.set(e3, /* @__PURE__ */ new Set()), this.alwaysPage.set(e3, /* @__PURE__ */ new Map());
          const n3 = this.buckets.get(e3);
          for (const e4 of this.modes.keys()) n3.set(e4, { global: /* @__PURE__ */ new Set(), page: /* @__PURE__ */ new Map() });
          this.logger.debug("InteractionManagerPlugin", "DocumentOpened", `Initialized interaction state for document: ${e3}`);
        }
        onDocumentClosed(e3) {
          this.cursorClaims.delete(e3), this.buckets.delete(e3), this.alwaysGlobal.delete(e3), this.alwaysPage.delete(e3), this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: Xc, payload: e4 };
          })(e3)), this.logger.debug("InteractionManagerPlugin", "DocumentClosed", `Cleaned up interaction state for document: ${e3}`);
        }
        buildCapability() {
          return { getActiveMode: () => this.getActiveMode(), getActiveInteractionMode: () => this.getActiveInteractionMode(), activate: (e3) => this.activate(e3), activateDefaultMode: () => this.activateDefaultMode(), setCursor: (e3, t2, n3) => this.setCursor(e3, t2, n3), getCurrentCursor: () => this.getCurrentCursor(), removeCursor: (e3) => this.removeCursor(e3), getHandlersForScope: (e3) => this.getHandlersForScope(e3), activeModeIsExclusive: () => this.activeModeIsExclusive(), pause: () => this.pause(), resume: () => this.resume(), isPaused: () => this.registry.isDestroyed() || this.isPaused(), getState: () => this.getDocumentStateOrThrow(), forDocument: (e3) => this.createInteractionScope(e3), registerMode: (e3) => this.registerMode(e3), registerHandlers: (e3) => this.registerHandlers(e3), registerAlways: (e3) => this.registerAlways(e3), setDefaultMode: (e3) => this.setDefaultMode(e3), getDefaultMode: () => this.state.defaultMode, getExclusionRules: () => this.state.exclusionRules, setExclusionRules: (e3) => this.dispatch(cd(e3)), addExclusionClass: (e3) => this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: id, payload: { className: e4 } };
          })(e3)), removeExclusionClass: (e3) => this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: rd, payload: { className: e4 } };
          })(e3)), addExclusionAttribute: (e3) => this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: ad, payload: { attribute: e4 } };
          })(e3)), removeExclusionAttribute: (e3) => this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: sd, payload: { attribute: e4 } };
          })(e3)), onModeChange: this.onModeChange$.on, onCursorChange: this.onCursorChange$.on, onHandlerChange: this.onHandlerChange$.on, onStateChange: this.onStateChange$.on };
        }
        createInteractionScope(e3) {
          return { getActiveMode: () => this.getActiveMode(e3), getActiveInteractionMode: () => this.getActiveInteractionMode(e3), activate: (t2) => this.activate(t2, e3), activateDefaultMode: () => this.activateDefaultMode(e3), setCursor: (t2, n3, o3) => this.setCursor(t2, n3, o3, e3), getCurrentCursor: () => this.getCurrentCursor(e3), removeCursor: (t2) => this.removeCursor(t2, e3), getHandlersForScope: (e4) => this.getHandlersForScope(e4), activeModeIsExclusive: () => this.activeModeIsExclusive(e3), pause: () => this.pause(e3), resume: () => this.resume(e3), isPaused: () => this.isPaused(e3), getState: () => this.getDocumentStateOrThrow(e3), onModeChange: (t2) => this.onModeChange$.on((n3) => {
            n3.documentId === e3 && t2(n3.activeMode);
          }), onCursorChange: (t2) => this.onCursorChange$.on((n3) => {
            n3.documentId === e3 && t2(n3.cursor);
          }), onStateChange: (t2) => this.onStateChange$.on((n3) => {
            n3.documentId === e3 && t2(n3.state);
          }) };
        }
        getDocumentState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          return this.state.documents[t2] ?? null;
        }
        getDocumentStateOrThrow(e3) {
          const t2 = this.getDocumentState(e3);
          if (!t2) throw new Error(`Interaction state not found for document: ${e3 ?? "active"}`);
          return t2;
        }
        activate(e3, t2) {
          var n3;
          const o3 = t2 ?? this.getActiveDocumentId(), i3 = this.getDocumentStateOrThrow(o3);
          if (!this.modes.has(e3)) throw new Error(`[interaction] unknown mode '${e3}'`);
          if (e3 === i3.activeMode) return;
          const r2 = i3.activeMode;
          null == (n3 = this.cursorClaims.get(o3)) || n3.clear(), this.notifyHandlersInactive(o3, r2), this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Qc, payload: { documentId: e4, mode: t3 } };
          })(o3, e3)), this.emitCursor(o3), this.notifyHandlersActive(o3, e3), this.onModeChange$.emit({ documentId: o3, activeMode: e3, previousMode: r2 });
        }
        activateDefaultMode(e3) {
          const t2 = e3 ?? this.getActiveDocumentIdOrNull();
          t2 && this.activate(this.state.defaultMode, t2);
        }
        setDefaultMode(e3) {
          if (!this.modes.has(e3)) throw new Error(`[interaction] cannot set unknown mode '${e3}' as default`);
          this.dispatch(ld(e3));
        }
        getActiveMode(e3) {
          return this.getDocumentStateOrThrow(e3).activeMode;
        }
        getActiveInteractionMode(e3) {
          const t2 = this.getDocumentState(e3);
          return t2 ? this.modes.get(t2.activeMode) ?? null : null;
        }
        activeModeIsExclusive(e3) {
          const t2 = this.getActiveInteractionMode(e3);
          return !!(null == t2 ? void 0 : t2.exclusive);
        }
        pause(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: Jc, payload: e4 };
          })(t2));
        }
        resume(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: ed, payload: e4 };
          })(t2));
        }
        isPaused(e3) {
          return this.getDocumentStateOrThrow(e3).paused;
        }
        registerMode(e3) {
          this.modes.set(e3.id, e3);
          for (const t2 of this.buckets.keys()) {
            const n3 = this.buckets.get(t2);
            n3.has(e3.id) || n3.set(e3.id, { global: /* @__PURE__ */ new Set(), page: /* @__PURE__ */ new Map() });
          }
        }
        registerHandlers({ documentId: e3, modeId: t2, handlers: n3, pageIndex: o3 }) {
          const i3 = Array.isArray(t2) ? t2 : [t2], r2 = [], a3 = this.buckets.get(e3);
          if (!a3) throw new Error(`No buckets found for document: ${e3}`);
          for (const e4 of i3) {
            const t3 = a3.get(e4);
            if (!t3) throw new Error(`unknown mode '${e4}'`);
            if (null == o3) t3.global.add(n3);
            else {
              const e5 = t3.page.get(o3) ?? /* @__PURE__ */ new Set();
              e5.add(n3), t3.page.set(o3, e5);
            }
            r2.push(() => {
              if (null == o3) t3.global.delete(n3);
              else {
                const e5 = t3.page.get(o3);
                e5 && (e5.delete(n3), 0 === e5.size && t3.page.delete(o3));
              }
            });
          }
          return this.onHandlerChange$.emit({ ...this.state }), () => {
            r2.forEach((e4) => e4()), this.onHandlerChange$.emit({ ...this.state });
          };
        }
        registerAlways({ scope: e3, handlers: t2 }) {
          if ("global" === e3.type) {
            const n4 = this.alwaysGlobal.get(e3.documentId) ?? /* @__PURE__ */ new Set();
            return n4.add(t2), this.alwaysGlobal.set(e3.documentId, n4), this.onHandlerChange$.emit({ ...this.state }), () => {
              n4.delete(t2), this.onHandlerChange$.emit({ ...this.state });
            };
          }
          const n3 = this.alwaysPage.get(e3.documentId) ?? /* @__PURE__ */ new Map(), o3 = n3.get(e3.pageIndex) ?? /* @__PURE__ */ new Set();
          return o3.add(t2), n3.set(e3.pageIndex, o3), this.alwaysPage.set(e3.documentId, n3), this.onHandlerChange$.emit({ ...this.state }), () => {
            o3.delete(t2), this.onHandlerChange$.emit({ ...this.state });
          };
        }
        getHandlersForScope(e3) {
          var t2;
          const n3 = this.getDocumentState(e3.documentId);
          if (!n3) return null;
          const o3 = this.modes.get(n3.activeMode);
          if (!o3) return null;
          const i3 = this.buckets.get(e3.documentId);
          if (!i3) return null;
          const r2 = i3.get(o3.id);
          if (!r2) return null;
          const a3 = (e4, t3) => e4.size || t3.size ? (function(e5) {
            const t4 = ["onPointerDown", "onPointerUp", "onPointerMove", "onPointerEnter", "onPointerLeave", "onPointerCancel", "onMouseDown", "onMouseUp", "onMouseMove", "onMouseEnter", "onMouseLeave", "onMouseCancel", "onClick", "onDoubleClick"], n4 = {};
            for (const o4 of t4) n4[o4] = (t5, n5, i4) => {
              var r3;
              for (const a4 of e5) null == (r3 = a4[o4]) || r3.call(a4, t5, n5, i4);
            };
            return n4;
          })([...e4, ...t3]) : null;
          if ("global" === e3.type) {
            return a3(this.alwaysGlobal.get(e3.documentId) ?? /* @__PURE__ */ new Set(), "global" === o3.scope ? r2.global : /* @__PURE__ */ new Set());
          }
          return a3((null == (t2 = this.alwaysPage.get(e3.documentId)) ? void 0 : t2.get(e3.pageIndex)) ?? /* @__PURE__ */ new Set(), "page" === o3.scope ? r2.page.get(e3.pageIndex) ?? /* @__PURE__ */ new Set() : /* @__PURE__ */ new Set());
        }
        setCursor(e3, t2, n3 = 0, o3) {
          const i3 = o3 ?? this.getActiveDocumentId(), r2 = this.cursorClaims.get(i3);
          r2 && (r2.set(e3, { cursor: t2, priority: n3 }), this.emitCursor(i3));
        }
        removeCursor(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = this.cursorClaims.get(n3);
          o3 && (o3.delete(e3), this.emitCursor(n3));
        }
        getCurrentCursor(e3) {
          return this.getDocumentStateOrThrow(e3).cursor;
        }
        emitCursor(e3) {
          var t2;
          const n3 = this.cursorClaims.get(e3);
          if (!n3) return;
          const o3 = this.getDocumentState(e3);
          if (!o3) return;
          const i3 = [...n3.values()].sort((e4, t3) => t3.priority - e4.priority)[0] ?? { cursor: (null == (t2 = this.modes.get(o3.activeMode)) ? void 0 : t2.cursor) ?? "auto" };
          i3.cursor !== o3.cursor && (this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: td, payload: { documentId: e4, cursor: t3 } };
          })(e3, i3.cursor)), this.onCursorChange$.emit({ documentId: e3, cursor: i3.cursor }));
        }
        notifyHandlersActive(e3, t2) {
          var n3, o3;
          null == (n3 = this.alwaysGlobal.get(e3)) || n3.forEach((e4) => {
            var n4;
            null == (n4 = e4.onHandlerActiveStart) || n4.call(e4, t2);
          }), null == (o3 = this.alwaysPage.get(e3)) || o3.forEach((e4) => {
            e4.forEach((e5) => {
              var n4;
              null == (n4 = e5.onHandlerActiveStart) || n4.call(e5, t2);
            });
          });
          const i3 = this.modes.get(t2);
          if (!i3) return;
          const r2 = this.buckets.get(e3);
          if (!r2) return;
          const a3 = r2.get(t2);
          a3 && ("global" === i3.scope && a3.global.forEach((e4) => {
            var n4;
            null == (n4 = e4.onHandlerActiveStart) || n4.call(e4, t2);
          }), "page" === i3.scope && a3.page.forEach((e4) => {
            e4.forEach((e5) => {
              var n4;
              null == (n4 = e5.onHandlerActiveStart) || n4.call(e5, t2);
            });
          }));
        }
        notifyHandlersInactive(e3, t2) {
          var n3, o3;
          null == (n3 = this.alwaysGlobal.get(e3)) || n3.forEach((e4) => {
            var n4;
            null == (n4 = e4.onHandlerActiveEnd) || n4.call(e4, t2);
          }), null == (o3 = this.alwaysPage.get(e3)) || o3.forEach((e4) => {
            e4.forEach((e5) => {
              var n4;
              null == (n4 = e5.onHandlerActiveEnd) || n4.call(e5, t2);
            });
          });
          const i3 = this.modes.get(t2);
          if (!i3) return;
          const r2 = this.buckets.get(e3);
          if (!r2) return;
          const a3 = r2.get(t2);
          a3 && ("global" === i3.scope && a3.global.forEach((e4) => {
            var n4;
            null == (n4 = e4.onHandlerActiveEnd) || n4.call(e4, t2);
          }), "page" === i3.scope && a3.page.forEach((e4) => {
            e4.forEach((e5) => {
              var n4;
              null == (n4 = e5.onHandlerActiveEnd) || n4.call(e5, t2);
            });
          }));
        }
        onStoreUpdated(e3, t2) {
          for (const n3 in t2.documents) {
            const o3 = e3.documents[n3], i3 = t2.documents[n3];
            o3 !== i3 && this.onStateChange$.emit({ documentId: n3, state: i3 });
          }
        }
        async initialize(e3) {
          this.logger.info("InteractionManagerPlugin", "Initialize", "Interaction Manager Plugin initialized");
        }
        async destroy() {
          this.onModeChange$.clear(), this.onCursorChange$.clear(), this.onHandlerChange$.clear(), this.onStateChange$.clear(), await super.destroy();
        }
      };
      ud.id = "interaction-manager";
      hd = ud;
      md = "interaction-manager";
      gd = "pointerMode";
      pd = { activeMode: gd, cursor: "auto", paused: false };
      vd = { defaultMode: gd, exclusionRules: { classes: [], dataAttributes: ["data-no-interaction"] }, documents: {}, activeDocumentId: null };
      fd = { manifest: { id: md, name: "Interaction Manager Plugin", version: "1.0.0", provides: ["interaction-manager"], requires: [], optional: [], defaultConfig: { exclusionRules: { classes: [], dataAttributes: ["data-no-interaction"] } } }, create: (e3, t2) => new hd(md, e3, t2), reducer: (e3 = vd, t2) => {
        switch (t2.type) {
          case Yc: {
            const { documentId: n3, state: o3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: o3 }, activeDocumentId: e3.activeDocumentId ?? n3 };
          }
          case Xc: {
            const n3 = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3, activeDocumentId: e3.activeDocumentId === n3 ? null : e3.activeDocumentId };
          }
          case "INTERACTION/SET_ACTIVE_DOCUMENT":
            return { ...e3, activeDocumentId: t2.payload };
          case Qc: {
            const { documentId: n3, mode: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, activeMode: o3 } } } : e3;
          }
          case td: {
            const { documentId: n3, cursor: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, cursor: o3 } } } : e3;
          }
          case Jc: {
            const n3 = t2.payload, o3 = e3.documents[n3];
            return o3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...o3, paused: true } } } : e3;
          }
          case ed: {
            const n3 = t2.payload, o3 = e3.documents[n3];
            return o3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...o3, paused: false } } } : e3;
          }
          case nd:
            return { ...e3, defaultMode: t2.payload.mode };
          case od:
            return { ...e3, exclusionRules: t2.payload.rules };
          case id:
            return { ...e3, exclusionRules: { ...e3.exclusionRules, classes: [...e3.exclusionRules.classes || [], t2.payload.className].filter((e4, t3, n3) => n3.indexOf(e4) === t3) } };
          case rd:
            return { ...e3, exclusionRules: { ...e3.exclusionRules, classes: (e3.exclusionRules.classes || []).filter((e4) => e4 !== t2.payload.className) } };
          case ad:
            return { ...e3, exclusionRules: { ...e3.exclusionRules, dataAttributes: [...e3.exclusionRules.dataAttributes || [], t2.payload.attribute].filter((e4, t3, n3) => n3.indexOf(e4) === t3) } };
          case sd:
            return { ...e3, exclusionRules: { ...e3.exclusionRules, dataAttributes: (e3.exclusionRules.dataAttributes || []).filter((e4) => e4 !== t2.payload.attribute) } };
          default:
            return e3;
        }
      }, initialState: vd };
      yd = () => po(hd.id);
      bd = { pointerdown: "onPointerDown", pointerup: "onPointerUp", pointermove: "onPointerMove", pointerenter: "onPointerEnter", pointerleave: "onPointerLeave", pointercancel: "onPointerCancel", mousedown: "onMouseDown", mouseup: "onMouseUp", mousemove: "onMouseMove", mouseenter: "onMouseEnter", mouseleave: "onMouseLeave", mousecancel: "onMouseCancel", click: "onClick", dblclick: "onDoubleClick", touchstart: "onPointerDown", touchend: "onPointerUp", touchmove: "onPointerMove", touchcancel: "onPointerCancel" };
      wd = ["pointerdown", "pointerup", "pointermove", "pointerenter", "pointerleave", "pointercancel", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mousecancel", "click", "dblclick"];
      xd = "undefined" != typeof PointerEvent ? wd : [...wd, "touchstart", "touchend", "touchmove", "touchcancel"];
      Sd = ({ children: e3, documentId: t2, style: n3, ...o3 }) => {
        const i3 = Ae(null), { provides: r2 } = yd();
        return Me(() => {
          if (r2 && i3.current) return Id(r2, { type: "global", documentId: t2 }, i3.current);
        }, [r2, t2]), Ue("div", { ref: i3, style: { width: "100%", height: "100%", ...n3 }, ...o3, children: e3 });
      };
      kd = ({ documentId: e3, pageIndex: t2, children: n3, rotation: o3, scale: i3, convertEventToPoint: r2, style: a3, ...s4 }) => {
        var l4, c4;
        const d4 = Ae(null), { provides: u4 } = yd(), h3 = (function(e4) {
          const { provides: t3 } = yd(), [n4, o4] = ke(() => {
            if (!t3) return false;
            const n5 = t3.forDocument(e4).getActiveInteractionMode();
            return "page" === (null == n5 ? void 0 : n5.scope) && !!n5.exclusive;
          });
          return Me(() => {
            if (!t3) return;
            const n5 = t3.forDocument(e4);
            return n5.onModeChange(() => {
              const e5 = n5.getActiveInteractionMode();
              o4("page" === (null == e5 ? void 0 : e5.scope) && !!(null == e5 ? void 0 : e5.exclusive));
            });
          }, [t3, e4]), n4;
        })(e3), m3 = fo(e3), g3 = null == (c4 = null == (l4 = null == m3 ? void 0 : m3.document) ? void 0 : l4.pages) ? void 0 : c4[t2], p4 = (null == g3 ? void 0 : g3.size) ?? { width: 0, height: 0 }, v2 = o3 ?? (null == m3 ? void 0 : m3.rotation) ?? 0, f2 = i3 ?? (null == m3 ? void 0 : m3.scale) ?? 1, y2 = Ze(p4, 0, f2), b2 = ze((e4, t3) => {
          const n4 = t3.getBoundingClientRect(), o4 = { x: e4.clientX - n4.left, y: e4.clientY - n4.top };
          return (function(e5, t4, n5, o5) {
            return Qe(Xe(e5, t4, (4 - n5) % 4), 1 / o5);
          })(Ze({ width: y2.width, height: y2.height }, v2, 1), o4, v2, f2);
        }, [p4, v2, f2]);
        return Me(() => {
          if (u4 && d4.current) return Id(u4, { type: "page", documentId: e3, pageIndex: t2 }, d4.current, r2 || b2);
        }, [u4, e3, t2, r2, b2]), Ue("div", { ref: d4, style: { position: "relative", width: y2.width, height: y2.height, ...a3 }, ...s4, children: [n3, h3 && Ue("div", { style: { position: "absolute", top: 0, left: 0, right: 0, bottom: 0, zIndex: 10 } })] });
      };
      Dd = {};
      Md = () => po(Wc.id);
      Pd = (e3) => {
        var t2;
        const { provides: n3 } = Md(), [o3, i3] = ke((null == (t2 = null == n3 ? void 0 : n3.forDocument(e3)) ? void 0 : t2.getState()) ?? { pages: {}, byUid: {}, selectedUid: null, activeToolId: null, hasPendingChanges: false });
        return Me(() => {
          if (!n3) return;
          const t3 = n3.forDocument(e3);
          return i3(t3.getState()), t3.onStateChange((e4) => {
            i3(e4);
          });
        }, [n3, e3]), { state: o3, provides: (null == n3 ? void 0 : n3.forDocument(e3)) ?? null };
      };
      Zd = "print";
      Kd = { id: Zd, name: "Print Plugin", version: "1.0.0", provides: ["print"], requires: [], optional: [], defaultConfig: {} };
      Yd = class extends Yn {
        constructor(e3, t2, n3) {
          super(e3, t2), this.printReady$ = ro();
        }
        buildCapability() {
          return { print: (e3) => this.print(e3), forDocument: (e3) => this.createPrintScope(e3) };
        }
        createPrintScope(e3) {
          return { print: (t2) => this.print(t2, e3) };
        }
        print(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = e3 ?? {}, i3 = new gt();
          i3.progress({ stage: "preparing", message: "Preparing document..." });
          return this.preparePrintDocument(o3, n3).wait((e4) => {
            i3.progress({ stage: "document-ready", message: "Document prepared successfully" }), this.printReady$.emit({ documentId: n3, options: o3, buffer: e4, task: i3 });
          }, (e4) => i3.fail(e4)), i3;
        }
        preparePrintDocument(e3, t2) {
          const n3 = this.coreState.core.documents[t2];
          return (null == n3 ? void 0 : n3.document) ? this.engine.preparePrintDocument(n3.document, e3) : Ut.reject({ code: Ht.DocNotOpen, message: `Document ${t2} not found` });
        }
        onPrintRequest(e3) {
          return this.printReady$.on(e3);
        }
        async initialize(e3) {
          this.logger.info("PrintPlugin", "Initialize", "Print plugin initialized");
        }
        async destroy() {
          this.printReady$.clear(), await super.destroy();
        }
      };
      Yd.id = "print";
      Xd = Yd;
      Qd = () => po(Xd.id);
      Jd = co({ manifest: Kd, create: (e3, t2) => new Xd(Zd, e3, t2), reducer: () => {
      }, initialState: {} }).addUtility(function() {
        const { provides: e3 } = Qd(), { plugin: t2 } = go(Xd.id), n3 = Ae(null), o3 = Ae(null);
        return Me(() => {
          if (!e3 || !t2) return;
          const i3 = t2.onPrintRequest(({ buffer: e4, task: t3 }) => {
            const i4 = n3.current;
            if (!i4) return;
            o3.current && (URL.revokeObjectURL(o3.current), o3.current = null);
            const r2 = URL.createObjectURL(new Blob([e4], { type: "application/pdf" }));
            o3.current = r2, i4.onload = () => {
              var n4, o4;
              i4.src === r2 && (t3.progress({ stage: "iframe-ready", message: "Ready to print" }), null == (n4 = i4.contentWindow) || n4.focus(), null == (o4 = i4.contentWindow) || o4.print(), t3.progress({ stage: "printing", message: "Print dialog opened" }), t3.resolve(e4));
            }, i4.src = r2;
          });
          return () => {
            i3(), o3.current && URL.revokeObjectURL(o3.current);
          };
        }, [e3, t2]), Ue("iframe", { ref: n3, style: { position: "absolute", display: "none" }, title: "Print Document", src: "about:blank" });
      }).build();
      eu = "fullscreen";
      tu = { id: eu, name: "Fullscreen Plugin", version: "1.0.0", provides: ["fullscreen"], requires: [], optional: [], defaultConfig: {} };
      nu = "SET_FULLSCREEN";
      ou = class extends Yn {
        constructor(e3, t2, n3) {
          super(e3, t2), this.onStateChange$ = ao(), this.fullscreenRequest$ = ro(), this.config = n3;
        }
        async initialize(e3) {
        }
        buildCapability() {
          return { isFullscreen: () => this.state.isFullscreen, enableFullscreen: (e3) => this.enableFullscreen(e3), exitFullscreen: () => this.exitFullscreen(), toggleFullscreen: (e3) => this.toggleFullscreen(e3), onRequest: this.fullscreenRequest$.on, onStateChange: this.onStateChange$.on };
        }
        getTargetSelector() {
          return this.currentTargetElement ?? this.config.targetElement;
        }
        toggleFullscreen(e3) {
          this.state.isFullscreen ? this.exitFullscreen() : this.enableFullscreen(e3);
        }
        enableFullscreen(e3) {
          this.currentTargetElement = e3 ?? this.config.targetElement, this.fullscreenRequest$.emit({ action: "enter", targetElement: this.currentTargetElement });
        }
        exitFullscreen() {
          this.fullscreenRequest$.emit({ action: "exit" }), this.currentTargetElement = void 0;
        }
        onStoreUpdated(e3, t2) {
          this.onStateChange$.emit(t2);
        }
        setFullscreenState(e3) {
          this.dispatch({ type: nu, payload: e3 });
        }
        async destroy() {
          this.fullscreenRequest$.clear(), super.destroy();
        }
      };
      ou.id = "fullscreen";
      iu = ou;
      ru = () => go(iu.id);
      su = co({ manifest: tu, create: (e3, t2) => new iu(eu, e3, t2), reducer: (e3, t2) => t2.type === nu ? { ...e3, isFullscreen: t2.payload } : e3, initialState: { isFullscreen: false } }).addWrapper(function({ children: e3, ...t2 }) {
        const { provides: n3 } = po(iu.id), { plugin: o3 } = ru(), { plugin: i3 } = ru(), r2 = Ae(null);
        return Me(() => {
          if (!n3 || !o3) return;
          return n3.onRequest(async (e4) => {
            const t3 = o3.getTargetSelector();
            await au(e4, r2.current, t3);
          });
        }, [n3, o3]), Me(() => {
          if (!i3) return;
          const e4 = () => i3.setFullscreenState(!!document.fullscreenElement);
          return document.addEventListener("fullscreenchange", e4), () => document.removeEventListener("fullscreenchange", e4);
        }, [i3]), Ue("div", { ...t2, style: { position: "relative", width: "100%", height: "100%", ...t2.style }, ref: r2, children: e3 });
      }).build();
      lu = "bookmark";
      cu = { id: lu, name: "Bookmark Plugin", version: "1.0.0", provides: ["bookmark"], requires: [], optional: [], defaultConfig: {} };
      du = class extends Yn {
        constructor(e3, t2) {
          super(e3, t2);
        }
        async initialize(e3) {
        }
        buildCapability() {
          return { getBookmarks: () => this.getBookmarks(), forDocument: (e3) => this.createBookmarkScope(e3) };
        }
        createBookmarkScope(e3) {
          return { getBookmarks: () => this.getBookmarks(e3) };
        }
        getBookmarks(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.coreState.core.documents[t2];
          if (!(null == n3 ? void 0 : n3.document)) throw new Error(`Document ${t2} not loaded`);
          return this.engine.getBookmarks(n3.document);
        }
      };
      du.id = "bookmark";
      uu = du;
      hu = { manifest: cu, create: (e3) => new uu(lu, e3), reducer: () => {
      }, initialState: {} };
      mu = class extends Yn {
        constructor(e3, t2, n3) {
          super(e3, t2), this.downloadRequest$ = ro(), this.config = n3;
        }
        buildCapability() {
          return { saveAsCopy: () => this.saveAsCopy(), download: () => this.download(), forDocument: (e3) => this.createExportScope(e3) };
        }
        createExportScope(e3) {
          return { saveAsCopy: () => this.saveAsCopy(e3), download: () => this.download(e3) };
        }
        download(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          this.downloadRequest$.emit({ documentId: t2 });
        }
        saveAsCopy(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.coreState.core.documents[t2];
          return (null == n3 ? void 0 : n3.document) ? this.engine.saveAsCopy(n3.document) : Ut.reject({ code: Ht.DocNotOpen, message: `Document ${t2} not found` });
        }
        saveAsCopyAndGetBufferAndName(e3) {
          const t2 = new gt(), n3 = this.coreState.core.documents[e3];
          return (null == n3 ? void 0 : n3.document) ? (this.saveAsCopy(e3).wait((e4) => {
            t2.resolve({ buffer: e4, name: n3.name ?? this.config.defaultFileName });
          }, (e4) => t2.fail(e4)), t2) : Ut.reject({ code: Ht.DocNotOpen, message: `Document ${e3} not found` });
        }
        onRequest(e3) {
          return this.downloadRequest$.on(e3);
        }
        async initialize(e3) {
          this.logger.info("ExportPlugin", "Initialize", "Export plugin initialized");
        }
        async destroy() {
          this.downloadRequest$.clear(), await super.destroy();
        }
      };
      mu.id = "export";
      gu = mu;
      pu = "export";
      vu = co({ manifest: { id: pu, name: "Export Plugin", version: "1.0.0", provides: ["export"], requires: [], optional: [], defaultConfig: { defaultFileName: "document.pdf" } }, create: (e3, t2) => new gu(pu, e3, t2), reducer: () => {
      }, initialState: {} }).addUtility(function() {
        const { plugin: e3 } = go(gu.id), t2 = Ae(null);
        return Me(() => {
          if (!e3) return;
          return e3.onRequest((n3) => {
            const o3 = t2.current;
            if (!o3) return;
            e3.saveAsCopyAndGetBufferAndName(n3.documentId).wait(({ buffer: e4, name: t3 }) => {
              const n4 = URL.createObjectURL(new Blob([e4]));
              o3.href = n4, o3.download = t3, o3.click(), URL.revokeObjectURL(n4);
            }, wn);
          });
        }, [e3]), Ue("a", { style: { display: "none" }, ref: t2 });
      }).build();
      fu = "PAN/INIT_STATE";
      yu = "PAN/CLEANUP_STATE";
      bu = "PAN/SET_PAN_MODE";
      wu = class extends Yn {
        constructor(e3, t2, n3) {
          var o3, i3, r2;
          super(e3, t2), this.panMode$ = ao(), this.documentHandlers = /* @__PURE__ */ new Map(), this.config = n3, this.interactionManager = null == (o3 = t2.getPlugin(hd.id)) ? void 0 : o3.provides(), this.viewport = null == (i3 = t2.getPlugin(Oo.id)) ? void 0 : i3.provides(), this.interactionManager && (this.interactionManager.registerMode({ id: "panMode", scope: "global", exclusive: false, cursor: "grab", wantsRawTouch: false }), null == (r2 = this.interactionManager) || r2.onModeChange((e4) => {
            const t3 = "panMode" === e4.activeMode, n4 = this.getDocumentState(e4.documentId);
            n4 && n4.isPanMode !== t3 && this.dispatch(/* @__PURE__ */ (function(e5, t4) {
              return { type: bu, payload: { documentId: e5, isPanMode: t4 } };
            })(e4.documentId, t3));
          }));
        }
        onDocumentLoadingStarted(e3) {
          this.dispatch(/* @__PURE__ */ (function(e4, t2) {
            return { type: fu, payload: { documentId: e4, state: t2 } };
          })(e3, { isPanMode: false })), this.registerPanHandlersForDocument(e3), "always" === this.config.defaultMode && this.makePanDefault(true), this.logger.debug("PanPlugin", "DocumentOpened", `Initialized pan state for document: ${e3}`);
        }
        onDocumentClosed(e3) {
          const t2 = this.documentHandlers.get(e3);
          t2 && (t2(), this.documentHandlers.delete(e3)), this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: yu, payload: e4 };
          })(e3)), this.logger.debug("PanPlugin", "DocumentClosed", `Cleaned up pan state for document: ${e3}`);
        }
        buildCapability() {
          return { enablePan: () => this.enablePan(), disablePan: () => this.disablePan(), togglePan: () => this.togglePan(), makePanDefault: (e3) => this.makePanDefault(e3), isPanMode: () => this.isPanMode(), forDocument: (e3) => this.createPanScope(e3), onPanModeChange: this.panMode$.on };
        }
        createPanScope(e3) {
          return { enablePan: () => this.enablePan(e3), disablePan: () => this.disablePan(e3), togglePan: () => this.togglePan(e3), isPanMode: () => this.isPanMode(e3), onPanModeChange: (t2) => this.panMode$.on((n3) => {
            n3.documentId === e3 && t2(n3.isPanMode);
          }) };
        }
        getDocumentState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          return this.state.documents[t2] ?? null;
        }
        getDocumentStateOrThrow(e3) {
          const t2 = this.getDocumentState(e3);
          if (!t2) throw new Error(`Pan state not found for document: ${e3 ?? "active"}`);
          return t2;
        }
        enablePan(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          this.interactionManager.forDocument(t2).activate("panMode");
        }
        disablePan(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          this.interactionManager.forDocument(t2).activateDefaultMode();
        }
        togglePan(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.interactionManager.forDocument(t2);
          "panMode" === n3.getActiveMode() ? n3.activateDefaultMode() : n3.activate("panMode");
        }
        makePanDefault(e3 = true) {
          this.interactionManager && (this.interactionManager.setDefaultMode("panMode"), e3 && this.interactionManager.activateDefaultMode());
        }
        isPanMode(e3) {
          return this.getDocumentStateOrThrow(e3).isPanMode;
        }
        registerPanHandlersForDocument(e3) {
          if (!this.interactionManager || !this.viewport) return;
          let t2 = null;
          const n3 = this.interactionManager.forDocument(e3), o3 = this.viewport.forDocument(e3), i3 = { onMouseDown: (e4, i4) => {
            const r3 = o3.getMetrics();
            t2 = { startX: i4.clientX, startY: i4.clientY, startLeft: r3.scrollLeft, startTop: r3.scrollTop }, n3.setCursor("panMode", "grabbing", 10);
          }, onMouseMove: (e4, n4) => {
            if (!t2) return;
            const i4 = n4.clientX - t2.startX, r3 = n4.clientY - t2.startY;
            o3.scrollTo({ x: t2.startLeft - i4, y: t2.startTop - r3 });
          }, onMouseUp: () => {
            t2 && (t2 = null, n3.removeCursor("panMode"));
          }, onMouseLeave: () => {
            t2 && (t2 = null, n3.removeCursor("panMode"));
          }, onMouseCancel: () => {
            t2 && (t2 = null, n3.removeCursor("panMode"));
          } }, r2 = this.interactionManager.registerHandlers({ documentId: e3, modeId: "panMode", handlers: i3 });
          this.documentHandlers.set(e3, r2);
        }
        onStoreUpdated(e3, t2) {
          for (const n3 in t2.documents) {
            const o3 = e3.documents[n3], i3 = t2.documents[n3];
            (null == o3 ? void 0 : o3.isPanMode) !== i3.isPanMode && (this.panMode$.emit({ documentId: n3, isPanMode: i3.isPanMode }), this.logger.debug("PanPlugin", "PanModeChanged", `Pan mode changed for document ${n3}: ${(null == o3 ? void 0 : o3.isPanMode) ?? false} -> ${i3.isPanMode}`));
          }
        }
        async initialize(e3) {
          this.logger.info("PanPlugin", "Initialize", "Pan plugin initialized");
        }
        async destroy() {
          this.documentHandlers.forEach((e3) => e3()), this.documentHandlers.clear(), this.panMode$.clear(), await super.destroy();
        }
      };
      wu.id = "pan";
      xu = wu;
      Cu = { documents: {}, activeDocumentId: null };
      Iu = co({ manifest: { id: "pan", name: "Pan Plugin", version: "1.0.0", provides: ["pan"], requires: ["interaction-manager", "viewport"], optional: [], defaultConfig: { defaultMode: "mobile" } }, create: (e3, t2) => new xu("pan", e3, t2), reducer: (e3 = Cu, t2) => {
        switch (t2.type) {
          case fu: {
            const { documentId: n3, state: o3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: o3 }, activeDocumentId: e3.activeDocumentId ?? n3 };
          }
          case yu: {
            const n3 = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3, activeDocumentId: e3.activeDocumentId === n3 ? null : e3.activeDocumentId };
          }
          case "PAN/SET_ACTIVE_DOCUMENT":
            return { ...e3, activeDocumentId: t2.payload };
          case bu: {
            const { documentId: n3, isPanMode: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, isPanMode: o3 } } } : e3;
          }
          default:
            return e3;
        }
      }, initialState: Cu }).addUtility(() => {
        const { provides: e3 } = po(xu.id), { plugin: t2 } = go(xu.id);
        return Me(() => {
          var n3;
          if (!e3 || !t2) return;
          const o3 = (null == (n3 = t2.config) ? void 0 : n3.defaultMode) ?? "never", i3 = "undefined" != typeof window && ("ontouchstart" in window || navigator.maxTouchPoints > 0);
          "mobile" === o3 && i3 && e3.makePanDefault();
        }, [e3, t2]), null;
      }).build();
      Su = "capture";
      ku = { id: Su, name: "Capture Plugin", version: "1.0.0", provides: ["capture"], requires: ["render"], optional: ["interaction-manager"], defaultConfig: { scale: 1, imageType: "image/png", withAnnotations: false } };
      Du = "CAPTURE/INIT_STATE";
      Mu = "CAPTURE/CLEANUP_STATE";
      Pu = "CAPTURE/SET_MARQUEE_CAPTURE_ACTIVE";
      Au = { isMarqueeCaptureActive: false };
      Tu = { documents: {}, activeDocumentId: null };
      zu = class extends Yn {
        constructor(e3, t2, n3) {
          var o3;
          super(e3, t2), this.captureArea$ = ro(), this.state$ = ao(), this.config = n3, this.renderCapability = this.registry.getPlugin("render").provides(), this.interactionManagerCapability = null == (o3 = this.registry.getPlugin("interaction-manager")) ? void 0 : o3.provides(), this.interactionManagerCapability && (this.interactionManagerCapability.registerMode({ id: "marqueeCapture", scope: "page", exclusive: true, cursor: "crosshair" }), this.interactionManagerCapability.onModeChange((e4) => {
            const t3 = "marqueeCapture" === e4.activeMode, n4 = this.getDocumentState(e4.documentId);
            var o4;
            n4 && n4.isMarqueeCaptureActive !== t3 && this.dispatch((o4 = e4.documentId, { type: Pu, payload: { documentId: o4, isActive: t3 } }));
          }));
        }
        onDocumentLoadingStarted(e3) {
          const t2 = { ...Au };
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Du, payload: { documentId: e4, state: t3 } };
          })(e3, t2)), this.logger.debug("CapturePlugin", "DocumentOpened", `Initialized capture state for document: ${e3}`);
        }
        onDocumentClosed(e3) {
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: Mu, payload: e4 };
          })(e3)), this.logger.debug("CapturePlugin", "DocumentClosed", `Cleaned up capture state for document: ${e3}`);
        }
        async initialize(e3) {
        }
        buildCapability() {
          return { captureArea: (e3, t2) => this.captureArea(e3, t2), enableMarqueeCapture: () => this.enableMarqueeCapture(), disableMarqueeCapture: () => this.disableMarqueeCapture(), toggleMarqueeCapture: () => this.toggleMarqueeCapture(), isMarqueeCaptureActive: () => this.isMarqueeCaptureActive(), getState: () => this.getDocumentStateOrThrow(), forDocument: (e3) => this.createCaptureScope(e3), registerMarqueeOnPage: (e3) => this.registerMarqueeOnPage(e3), onCaptureArea: this.captureArea$.on, onStateChange: this.state$.on };
        }
        createCaptureScope(e3) {
          return { captureArea: (t2, n3) => this.captureArea(t2, n3, e3), enableMarqueeCapture: () => this.enableMarqueeCapture(e3), disableMarqueeCapture: () => this.disableMarqueeCapture(e3), toggleMarqueeCapture: () => this.toggleMarqueeCapture(e3), isMarqueeCaptureActive: () => this.isMarqueeCaptureActive(e3), getState: () => this.getDocumentStateOrThrow(e3), onCaptureArea: (t2) => this.captureArea$.on((n3) => {
            n3.documentId === e3 && t2(n3);
          }), onStateChange: (t2) => this.state$.on((n3) => {
            n3.documentId === e3 && t2(n3.state);
          }) };
        }
        getDocumentState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          return this.state.documents[t2] ?? null;
        }
        getDocumentStateOrThrow(e3) {
          const t2 = this.getDocumentState(e3);
          if (!t2) throw new Error(`Capture state not found for document: ${e3 ?? "active"}`);
          return t2;
        }
        registerMarqueeOnPage(e3) {
          if (!this.interactionManagerCapability) return this.logger.warn("CapturePlugin", "MissingDependency", "Interaction manager plugin not loaded, marquee capture disabled"), () => {
          };
          const t2 = this.coreState.core.documents[e3.documentId];
          if (!t2 || !t2.document) return this.logger.warn("CapturePlugin", "DocumentNotFound", "Document not found"), () => {
          };
          const n3 = t2.document.pages[e3.pageIndex];
          if (!n3) return this.logger.warn("CapturePlugin", "PageNotFound", `Page ${e3.pageIndex} not found`), () => {
          };
          const o3 = (function(e4) {
            const { pageSize: t3, scale: n4, minDragPx: o4 = 5, onPreview: i3, onCommit: r2 } = e4;
            let a3 = null, s4 = null;
            return { onPointerDown: (e5, t4) => {
              var n5;
              a3 = e5, s4 = { origin: { x: e5.x, y: e5.y }, size: { width: 0, height: 0 } }, null == i3 || i3(s4), null == (n5 = t4.setPointerCapture) || n5.call(t4);
            }, onPointerMove: (e5) => {
              if (!a3) return;
              const n5 = eo(e5.x, 0, t3.width), o5 = eo(e5.y, 0, t3.height);
              s4 = { origin: { x: Math.min(a3.x, n5), y: Math.min(a3.y, o5) }, size: { width: Math.abs(n5 - a3.x), height: Math.abs(o5 - a3.y) } }, null == i3 || i3(s4);
            }, onPointerUp: (e5, t4) => {
              var l4;
              s4 && Math.max(s4.size.width, s4.size.height) * n4 > o4 && (null == r2 || r2(s4)), a3 = null, s4 = null, null == i3 || i3(null), null == (l4 = t4.releasePointerCapture) || l4.call(t4);
            }, onPointerCancel: (e5, t4) => {
              var n5;
              a3 = null, s4 = null, null == i3 || i3(null), null == (n5 = t4.releasePointerCapture) || n5.call(t4);
            } };
          })({ pageSize: n3.size, scale: e3.scale, onPreview: e3.callback.onPreview, onCommit: (t3) => {
            var n4, o4;
            this.captureArea(e3.pageIndex, t3, e3.documentId), null == (o4 = (n4 = e3.callback).onCommit) || o4.call(n4, t3);
          } });
          return this.interactionManagerCapability.registerHandlers({ documentId: e3.documentId, modeId: "marqueeCapture", handlers: o3, pageIndex: e3.pageIndex });
        }
        captureArea(e3, t2, n3) {
          const o3 = n3 ?? this.getActiveDocumentId();
          this.disableMarqueeCapture(o3);
          this.renderCapability.forDocument(o3).renderPageRect({ pageIndex: e3, rect: t2, options: { imageType: this.config.imageType, scaleFactor: this.config.scale, withAnnotations: this.config.withAnnotations || false } }).wait((n4) => {
            this.captureArea$.emit({ documentId: o3, pageIndex: e3, rect: t2, blob: n4, imageType: this.config.imageType || "image/png", scale: this.config.scale || 1, withAnnotations: this.config.withAnnotations || false });
          }, wn);
        }
        enableMarqueeCapture(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          null == (t2 = this.interactionManagerCapability) || t2.forDocument(n3).activate("marqueeCapture");
        }
        disableMarqueeCapture(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          null == (t2 = this.interactionManagerCapability) || t2.forDocument(n3).activateDefaultMode();
        }
        toggleMarqueeCapture(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId(), o3 = null == (t2 = this.interactionManagerCapability) ? void 0 : t2.forDocument(n3);
          "marqueeCapture" === (null == o3 ? void 0 : o3.getActiveMode()) ? o3.activateDefaultMode() : null == o3 || o3.activate("marqueeCapture");
        }
        isMarqueeCaptureActive(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          return "marqueeCapture" === (null == (t2 = this.interactionManagerCapability) ? void 0 : t2.forDocument(n3).getActiveMode());
        }
        onStoreUpdated(e3, t2) {
          for (const n3 in t2.documents) {
            const o3 = e3.documents[n3], i3 = t2.documents[n3];
            o3 && i3 && o3.isMarqueeCaptureActive !== i3.isMarqueeCaptureActive && this.state$.emit({ documentId: n3, state: i3 });
          }
        }
        async destroy() {
          this.captureArea$.clear(), this.state$.clear(), super.destroy();
        }
      };
      zu.id = "capture";
      Eu = zu;
      _u = { manifest: ku, create: (e3, t2) => new Eu(Su, e3, t2), reducer: (e3 = Tu, t2) => {
        switch (t2.type) {
          case Du: {
            const { documentId: n3, state: o3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: o3 }, activeDocumentId: e3.activeDocumentId ?? n3 };
          }
          case Mu: {
            const n3 = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3, activeDocumentId: e3.activeDocumentId === n3 ? null : e3.activeDocumentId };
          }
          case "CAPTURE/SET_ACTIVE_DOCUMENT":
            return { ...e3, activeDocumentId: t2.payload };
          case Pu: {
            const { documentId: n3, isActive: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, isMarqueeCaptureActive: o3 } } } : e3;
          }
          default:
            return e3;
        }
      }, initialState: Tu };
      Ru = ({ documentId: e3, pageIndex: t2, scale: n3, className: o3, stroke: i3 = "rgba(33,150,243,0.8)", fill: r2 = "rgba(33,150,243,0.15)" }) => {
        const { provides: a3 } = po(Eu.id), s4 = fo(e3), [l4, c4] = ke(null), d4 = Te(() => void 0 !== n3 ? n3 : (null == s4 ? void 0 : s4.scale) ?? 1, [n3, null == s4 ? void 0 : s4.scale]);
        return Me(() => {
          if (a3) return a3.registerMarqueeOnPage({ documentId: e3, pageIndex: t2, scale: d4, callback: { onPreview: c4 } });
        }, [a3, e3, t2, d4]), l4 ? Ue("div", { style: { position: "absolute", pointerEvents: "none", left: l4.origin.x * d4, top: l4.origin.y * d4, width: l4.size.width * d4, height: l4.size.height * d4, border: `1px solid ${i3}`, background: r2, boxSizing: "border-box" }, className: o3 }) : null;
      };
      Nu = "history";
      Ou = { id: Nu, name: "History Plugin", version: "1.0.0", provides: ["history"], requires: [], optional: [], defaultConfig: {} };
      Lu = "HISTORY/INIT_STATE";
      $u = "HISTORY/CLEANUP_STATE";
      Fu = "HISTORY/SET_DOCUMENT_STATE";
      ju = class extends Yn {
        constructor(e3, t2) {
          super(e3, t2), this.documentHistories = /* @__PURE__ */ new Map(), this.historyChange$ = ro();
        }
        async initialize(e3) {
          this.logger.info("HistoryPlugin", "Initialize", "History plugin initialized");
        }
        onDocumentLoadingStarted(e3) {
          this.dispatch(/* @__PURE__ */ ((e4) => ({ type: Lu, payload: { documentId: e4 } }))(e3)), this.documentHistories.set(e3, { topicHistories: /* @__PURE__ */ new Map(), globalTimeline: [], globalIndex: -1 }), this.logger.debug("HistoryPlugin", "DocumentOpened", `Initialized history state for document: ${e3}`);
        }
        onDocumentClosed(e3) {
          this.dispatch(/* @__PURE__ */ ((e4) => ({ type: $u, payload: { documentId: e4 } }))(e3)), this.documentHistories.delete(e3), this.logger.debug("HistoryPlugin", "DocumentClosed", `Cleaned up history state for document: ${e3}`);
        }
        getDocumentHistoryData(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.documentHistories.get(t2);
          if (!n3) throw new Error(`History data not found for document: ${t2}`);
          return n3;
        }
        getDocumentHistoryState(e3) {
          const t2 = this.documentHistories.get(e3);
          if (!t2) throw new Error(`History data not found for document: ${e3}`);
          const n3 = {};
          return Array.from(t2.topicHistories.entries()).forEach(([e4, t3]) => {
            n3[e4] = { canUndo: t3.currentIndex > -1, canRedo: t3.currentIndex < t3.commands.length - 1 };
          }), { global: { canUndo: t2.globalIndex > -1, canRedo: t2.globalIndex < t2.globalTimeline.length - 1 }, topics: n3 };
        }
        emitHistoryChange(e3, t2) {
          const n3 = this.getDocumentHistoryState(e3);
          this.dispatch(/* @__PURE__ */ ((e4, t3) => ({ type: Fu, payload: { documentId: e4, state: t3 } }))(e3, n3)), this.historyChange$.emit({ documentId: e3, topic: t2, state: n3 });
        }
        register(e3, t2, n3) {
          const o3 = this.getDocumentHistoryData(n3);
          o3.topicHistories.has(t2) || o3.topicHistories.set(t2, { commands: [], currentIndex: -1 });
          const i3 = o3.topicHistories.get(t2);
          i3.commands.splice(i3.currentIndex + 1), i3.commands.push(e3), i3.currentIndex++;
          const r2 = { command: e3, topic: t2 };
          o3.globalTimeline.splice(o3.globalIndex + 1), o3.globalTimeline.push(r2), o3.globalIndex++, e3.execute(), this.emitHistoryChange(n3, t2);
        }
        undo(e3, t2) {
          const n3 = this.getDocumentHistoryData(t2);
          let o3;
          if (e3) {
            const t3 = n3.topicHistories.get(e3);
            t3 && t3.currentIndex > -1 && (t3.commands[t3.currentIndex].undo(), t3.currentIndex--, o3 = e3);
          } else if (n3.globalIndex > -1) {
            const e4 = n3.globalTimeline[n3.globalIndex];
            e4.command.undo(), n3.topicHistories.get(e4.topic).currentIndex--, n3.globalIndex--, o3 = e4.topic;
          }
          o3 && this.emitHistoryChange(t2, o3);
        }
        redo(e3, t2) {
          const n3 = this.getDocumentHistoryData(t2);
          let o3;
          if (e3) {
            const t3 = n3.topicHistories.get(e3);
            t3 && t3.currentIndex < t3.commands.length - 1 && (t3.currentIndex++, t3.commands[t3.currentIndex].execute(), o3 = e3);
          } else if (n3.globalIndex < n3.globalTimeline.length - 1) {
            n3.globalIndex++;
            const e4 = n3.globalTimeline[n3.globalIndex];
            e4.command.execute(), n3.topicHistories.get(e4.topic).currentIndex++, o3 = e4.topic;
          }
          o3 && this.emitHistoryChange(t2, o3);
        }
        canUndo(e3, t2) {
          const n3 = this.getDocumentHistoryData(t2);
          if (e3) {
            const t3 = n3.topicHistories.get(e3);
            return !!t3 && t3.currentIndex > -1;
          }
          return n3.globalIndex > -1;
        }
        canRedo(e3, t2) {
          const n3 = this.getDocumentHistoryData(t2);
          if (e3) {
            const t3 = n3.topicHistories.get(e3);
            return !!t3 && t3.currentIndex < t3.commands.length - 1;
          }
          return n3.globalIndex < n3.globalTimeline.length - 1;
        }
        createHistoryScope(e3) {
          return { register: (t2, n3) => this.register(t2, n3, e3), undo: (t2) => this.undo(t2, e3), redo: (t2) => this.redo(t2, e3), canUndo: (t2) => this.canUndo(t2, e3), canRedo: (t2) => this.canRedo(t2, e3), getHistoryState: () => this.getDocumentHistoryState(e3), onHistoryChange: (t2) => this.historyChange$.on((n3) => {
            n3.documentId === e3 && t2(n3.topic);
          }) };
        }
        buildCapability() {
          return { register: (e3, t2) => {
            const n3 = this.getActiveDocumentId();
            this.register(e3, t2, n3);
          }, undo: (e3) => {
            const t2 = this.getActiveDocumentId();
            this.undo(e3, t2);
          }, redo: (e3) => {
            const t2 = this.getActiveDocumentId();
            this.redo(e3, t2);
          }, canUndo: (e3) => {
            const t2 = this.getActiveDocumentId();
            return this.canUndo(e3, t2);
          }, canRedo: (e3) => {
            const t2 = this.getActiveDocumentId();
            return this.canRedo(e3, t2);
          }, getHistoryState: () => {
            const e3 = this.getActiveDocumentId();
            return this.getDocumentHistoryState(e3);
          }, forDocument: (e3) => this.createHistoryScope(e3), onHistoryChange: this.historyChange$.on };
        }
        async destroy() {
          this.historyChange$.clear(), this.documentHistories.clear(), super.destroy();
        }
      };
      ju.id = "history";
      Hu = ju;
      Uu = { global: { canUndo: false, canRedo: false }, topics: {} };
      Wu = { documents: {}, activeDocumentId: null };
      Bu = { manifest: Ou, create: (e3) => new Hu(Nu, e3), reducer: (e3 = Wu, t2) => {
        switch (t2.type) {
          case Lu: {
            const { documentId: n3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: { ...Uu } } };
          }
          case $u: {
            const { documentId: n3 } = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3, activeDocumentId: e3.activeDocumentId === n3 ? null : e3.activeDocumentId };
          }
          case Fu: {
            const { documentId: n3, state: o3 } = t2.payload;
            return e3.documents[n3] ? { ...e3, documents: { ...e3.documents, [n3]: o3 } } : e3;
          }
          case "HISTORY/SET_ACTIVE_DOCUMENT":
            return { ...e3, activeDocumentId: t2.payload };
          default:
            return e3;
        }
      }, initialState: Wu };
      qu = ((e3) => (e3.MarqueeRedact = "marqueeRedact", e3.RedactSelection = "redactSelection", e3))(qu || {});
      Gu = "REDACTION/INIT_STATE";
      Vu = "REDACTION/CLEANUP_STATE";
      Zu = "START_REDACTION";
      Ku = "END_REDACTION";
      Yu = "ADD_PENDING";
      Xu = "REMOVE_PENDING";
      Qu = "CLEAR_PENDING";
      Ju = "SELECT_PENDING";
      eh = "DESELECT_PENDING";
      th = (e3, t2) => ({ type: Yu, payload: { documentId: e3, items: t2 } });
      nh = (e3, t2, n3) => ({ type: Xu, payload: { documentId: e3, page: t2, id: n3 } });
      oh = (e3) => ({ type: Qu, payload: e3 });
      ih = (e3, t2) => ({ type: Zu, payload: { documentId: e3, mode: t2 } });
      rh = (e3) => Object.values(e3).reduce((e4, t2) => e4 + t2.length, 0);
      ah = { isRedacting: false, activeType: null, pending: {}, pendingCount: 0, selected: null };
      sh = { documents: {}, activeDocumentId: null };
      lh = class extends Yn {
        constructor(e3, t2, n3) {
          var o3, i3, r2;
          super(e3, t2), this.redactionSelection$ = /* @__PURE__ */ new Map(), this.pending$ = ao(), this.selected$ = ao(), this.state$ = ao(), this.events$ = ao(), this.documentUnsubscribers = /* @__PURE__ */ new Map(), this.config = n3, this.selectionCapability = null == (o3 = this.registry.getPlugin("selection")) ? void 0 : o3.provides(), this.interactionManagerCapability = null == (i3 = this.registry.getPlugin("interaction-manager")) ? void 0 : i3.provides(), this.interactionManagerCapability && (this.interactionManagerCapability.registerMode({ id: qu.MarqueeRedact, scope: "page", exclusive: true, cursor: "crosshair" }), this.interactionManagerCapability.registerMode({ id: qu.RedactSelection, scope: "page", exclusive: false })), null == (r2 = this.interactionManagerCapability) || r2.onModeChange((e4) => {
            const t3 = e4.documentId;
            if (e4.activeMode === qu.RedactSelection) this.dispatch(ih(t3, qu.RedactSelection));
            else if (e4.activeMode === qu.MarqueeRedact) this.dispatch(ih(t3, qu.MarqueeRedact));
            else {
              const e5 = this.getDocumentState(t3);
              (null == e5 ? void 0 : e5.isRedacting) && this.dispatch(/* @__PURE__ */ ((e6) => ({ type: Ku, payload: e6 }))(t3));
            }
          });
        }
        onDocumentLoadingStarted(e3) {
          this.dispatch(/* @__PURE__ */ (function(e4, t3) {
            return { type: Gu, payload: { documentId: e4, state: t3 } };
          })(e3, { ...ah })), this.redactionSelection$.set(e3, ao());
          const t2 = [];
          if (this.selectionCapability) {
            const n3 = this.selectionCapability.forDocument(e3), o3 = n3.onSelectionChange(() => {
              const t3 = this.getDocumentState(e3);
              if (!(null == t3 ? void 0 : t3.isRedacting)) return;
              const o4 = n3.getFormattedSelection(), i4 = this.redactionSelection$.get(e3);
              null == i4 || i4.emit(o4);
            }), i3 = n3.onEndSelection(() => {
              const t3 = this.getDocumentState(e3);
              if (!(null == t3 ? void 0 : t3.isRedacting)) return;
              const o4 = n3.getFormattedSelection().map((e4) => ({ id: yn(), kind: "text", page: e4.pageIndex, rect: e4.rect, rects: e4.segmentRects }));
              this.dispatch(th(e3, o4));
              const i4 = this.redactionSelection$.get(e3);
              null == i4 || i4.emit([]), n3.clear(), this.emitPendingChange(e3), o4.length && this.selectPending(o4[o4.length - 1].page, o4[o4.length - 1].id, e3);
            });
            t2.push(o3, i3);
          }
          this.documentUnsubscribers.set(e3, t2), this.logger.debug("RedactionPlugin", "DocumentOpened", `Initialized redaction state for document: ${e3}`);
        }
        onDocumentLoaded(e3) {
          var t2;
          null == (t2 = this.selectionCapability) || t2.enableForMode(qu.RedactSelection, e3);
        }
        onDocumentClosed(e3) {
          this.dispatch(/* @__PURE__ */ (function(e4) {
            return { type: Vu, payload: e4 };
          })(e3));
          const t2 = this.redactionSelection$.get(e3);
          null == t2 || t2.clear(), this.redactionSelection$.delete(e3);
          const n3 = this.documentUnsubscribers.get(e3);
          n3 && (n3.forEach((e4) => e4()), this.documentUnsubscribers.delete(e3)), this.logger.debug("RedactionPlugin", "DocumentClosed", `Cleaned up redaction state for document: ${e3}`);
        }
        async initialize(e3) {
          this.logger.info("RedactionPlugin", "Initialize", "Redaction plugin initialized");
        }
        buildCapability() {
          return { queueCurrentSelectionAsPending: () => this.queueCurrentSelectionAsPending(), enableMarqueeRedact: () => this.enableMarqueeRedact(), toggleMarqueeRedact: () => this.toggleMarqueeRedact(), isMarqueeRedactActive: () => this.isMarqueeRedactActive(), enableRedactSelection: () => this.enableRedactSelection(), toggleRedactSelection: () => this.toggleRedactSelection(), isRedactSelectionActive: () => this.isRedactSelectionActive(), addPending: (e3) => this.addPendingItems(e3), removePending: (e3, t2) => this.removePendingItem(e3, t2), clearPending: () => this.clearPendingItems(), commitAllPending: () => this.commitAllPending(), commitPending: (e3, t2) => this.commitPendingOne(e3, t2), endRedaction: () => this.endRedactionMode(), startRedaction: () => this.startRedactionMode(), selectPending: (e3, t2) => this.selectPending(e3, t2), getSelectedPending: () => this.getSelectedPending(), deselectPending: () => this.deselectPending(), getState: () => this.getDocumentStateOrThrow(), forDocument: (e3) => this.createRedactionScope(e3), onPendingChange: this.pending$.on, onSelectedChange: this.selected$.on, onRedactionEvent: this.events$.on, onStateChange: this.state$.on };
        }
        createRedactionScope(e3) {
          return { queueCurrentSelectionAsPending: () => this.queueCurrentSelectionAsPending(e3), enableMarqueeRedact: () => this.enableMarqueeRedact(e3), toggleMarqueeRedact: () => this.toggleMarqueeRedact(e3), isMarqueeRedactActive: () => this.isMarqueeRedactActive(e3), enableRedactSelection: () => this.enableRedactSelection(e3), toggleRedactSelection: () => this.toggleRedactSelection(e3), isRedactSelectionActive: () => this.isRedactSelectionActive(e3), addPending: (t2) => this.addPendingItems(t2, e3), removePending: (t2, n3) => this.removePendingItem(t2, n3, e3), clearPending: () => this.clearPendingItems(e3), commitAllPending: () => this.commitAllPending(e3), commitPending: (t2, n3) => this.commitPendingOne(t2, n3, e3), endRedaction: () => this.endRedactionMode(e3), startRedaction: () => this.startRedactionMode(e3), selectPending: (t2, n3) => this.selectPending(t2, n3, e3), getSelectedPending: () => this.getSelectedPending(e3), deselectPending: () => this.deselectPending(e3), getState: () => this.getDocumentStateOrThrow(e3), onPendingChange: (t2) => this.pending$.on((n3) => {
            n3.documentId === e3 && t2(n3.pending);
          }), onSelectedChange: (t2) => this.selected$.on((n3) => {
            n3.documentId === e3 && t2(n3.selected);
          }), onRedactionEvent: (t2) => this.events$.on((n3) => {
            n3.documentId === e3 && t2(n3);
          }), onStateChange: (t2) => this.state$.on((n3) => {
            n3.documentId === e3 && t2(n3.state);
          }) };
        }
        getDocumentState(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          return this.state.documents[t2] ?? null;
        }
        getDocumentStateOrThrow(e3) {
          const t2 = this.getDocumentState(e3);
          if (!t2) throw new Error(`Redaction state not found for document: ${e3 ?? "active"}`);
          return t2;
        }
        addPendingItems(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId();
          this.dispatch(th(n3, e3)), this.emitPendingChange(n3), this.events$.emit({ type: "add", documentId: n3, items: e3 });
        }
        removePendingItem(e3, t2, n3) {
          const o3 = n3 ?? this.getActiveDocumentId();
          this.dispatch(nh(o3, e3, t2)), this.emitPendingChange(o3), this.events$.emit({ type: "remove", documentId: o3, page: e3, id: t2 });
        }
        clearPendingItems(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          this.dispatch(oh(t2)), this.emitPendingChange(t2), this.events$.emit({ type: "clear", documentId: t2 });
        }
        selectPending(e3, t2, n3) {
          var o3;
          const i3 = n3 ?? this.getActiveDocumentId();
          this.dispatch(/* @__PURE__ */ ((e4, t3, n4) => ({ type: Ju, payload: { documentId: e4, page: t3, id: n4 } }))(i3, e3, t2)), null == (o3 = this.selectionCapability) || o3.forDocument(i3).clear(), this.emitSelectedChange(i3);
        }
        getSelectedPending(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          return (null == (t2 = this.getDocumentState(n3)) ? void 0 : t2.selected) ?? null;
        }
        deselectPending(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          this.dispatch(/* @__PURE__ */ ((e4) => ({ type: eh, payload: e4 }))(t2)), this.emitSelectedChange(t2);
        }
        enableRedactSelection(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          null == (t2 = this.interactionManagerCapability) || t2.forDocument(n3).activate(qu.RedactSelection);
        }
        toggleRedactSelection(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId(), o3 = null == (t2 = this.interactionManagerCapability) ? void 0 : t2.forDocument(n3);
          (null == o3 ? void 0 : o3.getActiveMode()) === qu.RedactSelection ? o3.activateDefaultMode() : null == o3 || o3.activate(qu.RedactSelection);
        }
        isRedactSelectionActive(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          return (null == (t2 = this.interactionManagerCapability) ? void 0 : t2.forDocument(n3).getActiveMode()) === qu.RedactSelection;
        }
        enableMarqueeRedact(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          null == (t2 = this.interactionManagerCapability) || t2.forDocument(n3).activate(qu.MarqueeRedact);
        }
        toggleMarqueeRedact(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId(), o3 = null == (t2 = this.interactionManagerCapability) ? void 0 : t2.forDocument(n3);
          (null == o3 ? void 0 : o3.getActiveMode()) === qu.MarqueeRedact ? o3.activateDefaultMode() : null == o3 || o3.activate(qu.MarqueeRedact);
        }
        isMarqueeRedactActive(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          return (null == (t2 = this.interactionManagerCapability) ? void 0 : t2.forDocument(n3).getActiveMode()) === qu.MarqueeRedact;
        }
        startRedactionMode(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          null == (t2 = this.interactionManagerCapability) || t2.forDocument(n3).activate(qu.RedactSelection);
        }
        endRedactionMode(e3) {
          var t2;
          const n3 = e3 ?? this.getActiveDocumentId();
          null == (t2 = this.interactionManagerCapability) || t2.forDocument(n3).activateDefaultMode();
        }
        onRedactionSelectionChange(e3, t2) {
          const n3 = this.redactionSelection$.get(e3);
          return (null == n3 ? void 0 : n3.on(t2)) ?? (() => {
          });
        }
        registerMarqueeOnPage(e3) {
          if (!this.interactionManagerCapability) return this.logger.warn("RedactionPlugin", "MissingDependency", "Interaction manager plugin not loaded, marquee redaction disabled"), () => {
          };
          const t2 = this.coreState.core.documents[e3.documentId];
          if (!(null == t2 ? void 0 : t2.document)) return this.logger.warn("RedactionPlugin", "DocumentNotFound", "Document not found"), () => {
          };
          const n3 = t2.document.pages[e3.pageIndex];
          if (!n3) return this.logger.warn("RedactionPlugin", "PageNotFound", `Page ${e3.pageIndex} not found`), () => {
          };
          const o3 = (function(e4) {
            const { pageSize: t3, scale: n4, minDragPx: o4 = 5, onPreview: i4, onCommit: r3 } = e4;
            let a3 = null, s4 = null;
            return { onPointerDown: (e5, t4) => {
              var n5;
              a3 = e5, s4 = { origin: { x: e5.x, y: e5.y }, size: { width: 0, height: 0 } }, null == i4 || i4(s4), null == (n5 = t4.setPointerCapture) || n5.call(t4);
            }, onPointerMove: (e5) => {
              if (!a3) return;
              const n5 = eo(e5.x, 0, t3.width), o5 = eo(e5.y, 0, t3.height);
              s4 = { origin: { x: Math.min(a3.x, n5), y: Math.min(a3.y, o5) }, size: { width: Math.abs(n5 - a3.x), height: Math.abs(o5 - a3.y) } }, null == i4 || i4(s4);
            }, onPointerUp: (e5, t4) => {
              var l4;
              s4 && Math.max(s4.size.width, s4.size.height) * n4 > o4 && (null == r3 || r3(s4)), a3 = null, s4 = null, null == i4 || i4(null), null == (l4 = t4.releasePointerCapture) || l4.call(t4);
            }, onPointerCancel: (e5, t4) => {
              var n5;
              a3 = null, s4 = null, null == i4 || i4(null), null == (n5 = t4.releasePointerCapture) || n5.call(t4);
            } };
          })({ pageSize: n3.size, scale: e3.scale, onPreview: e3.callback.onPreview, onCommit: (t3) => {
            var n4, o4;
            const i4 = { id: yn(), kind: "area", page: e3.pageIndex, rect: t3 };
            this.dispatch(th(e3.documentId, [i4])), this.emitPendingChange(e3.documentId), null == (o4 = (n4 = e3.callback).onCommit) || o4.call(n4, t3), this.enableRedactSelection(e3.documentId), this.selectPending(e3.pageIndex, i4.id, e3.documentId);
          } }), i3 = this.interactionManagerCapability.registerAlways({ handlers: { onPointerDown: (t3, n4) => {
            n4.target === n4.currentTarget && this.deselectPending(e3.documentId);
          } }, scope: { type: "page", documentId: e3.documentId, pageIndex: e3.pageIndex } }), r2 = this.interactionManagerCapability.registerHandlers({ documentId: e3.documentId, modeId: qu.MarqueeRedact, handlers: o3, pageIndex: e3.pageIndex });
          return () => {
            i3(), r2();
          };
        }
        queueCurrentSelectionAsPending(e3) {
          const t2 = e3 ?? this.getActiveDocumentId();
          if (!this.selectionCapability) return Ut.reject({ code: Ht.NotFound, message: "[RedactionPlugin] selection plugin required" });
          const n3 = this.coreState.core.documents[t2];
          if (!(null == n3 ? void 0 : n3.document)) return Ut.reject({ code: Ht.NotFound, message: "Document not found" });
          const o3 = this.selectionCapability.forDocument(t2), i3 = o3.getFormattedSelection();
          if (!i3.length) return Ut.resolve(true);
          const r2 = yn(), a3 = i3.map((e4) => ({ id: r2, kind: "text", page: e4.pageIndex, rect: e4.rect, rects: e4.segmentRects }));
          this.enableRedactSelection(t2), this.dispatch(th(t2, a3)), this.emitPendingChange(t2);
          const s4 = a3[a3.length - 1];
          this.selectPending(s4.page, s4.id, t2);
          const l4 = this.redactionSelection$.get(t2);
          return null == l4 || l4.emit([]), o3.clear(), Ut.resolve(true);
        }
        commitPendingOne(e3, t2, n3) {
          const o3 = n3 ?? this.getActiveDocumentId(), i3 = this.coreState.core.documents[o3];
          if (!(null == i3 ? void 0 : i3.document)) return Ut.reject({ code: Ht.NotFound, message: "Document not found" });
          const r2 = this.getDocumentState(o3);
          if (!r2) return Ut.reject({ code: Ht.NotFound, message: "Document state not found" });
          const a3 = (r2.pending[e3] ?? []).find((e4) => e4.id === t2);
          if (!a3) return Ut.resolve(true);
          const s4 = "text" === a3.kind ? a3.rects : [a3.rect], l4 = i3.document.pages[e3];
          if (!l4) return Ut.reject({ code: Ht.NotFound, message: "Page not found" });
          const c4 = new gt();
          return this.engine.redactTextInRects(i3.document, l4, s4, { drawBlackBoxes: this.config.drawBlackBoxes }).wait(() => {
            this.dispatch(nh(o3, e3, t2)), this.emitPendingChange(o3), this.dispatchCoreAction(Un(o3, [e3])), this.events$.emit({ type: "commit", documentId: o3, success: true }), c4.resolve(true);
          }, (e4) => {
            this.events$.emit({ type: "commit", documentId: o3, success: false, error: e4.reason }), c4.reject({ code: Ht.Unknown, message: "Failed to commit redactions" });
          }), c4;
        }
        commitAllPending(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.coreState.core.documents[t2];
          if (!(null == n3 ? void 0 : n3.document)) return Ut.reject({ code: Ht.NotFound, message: "Document not found" });
          const o3 = this.getDocumentState(t2);
          if (!o3) return Ut.reject({ code: Ht.NotFound, message: "Document state not found" });
          const i3 = /* @__PURE__ */ new Map();
          for (const [e4, t3] of Object.entries(o3.pending)) {
            const n4 = Number(e4), o4 = i3.get(n4) ?? [];
            for (const e5 of t3) "text" === e5.kind ? o4.push(...e5.rects) : o4.push(e5.rect);
            i3.set(n4, o4);
          }
          const r2 = Array.from(i3.entries()).filter(([e4, t3]) => t3.length > 0).map(([e4]) => e4), a3 = [];
          for (const [e4, t3] of i3) {
            const o4 = n3.document.pages[e4];
            o4 && (t3.length && a3.push(this.engine.redactTextInRects(n3.document, o4, t3, { drawBlackBoxes: this.config.drawBlackBoxes })));
          }
          const s4 = new gt();
          return gt.all(a3).wait(() => {
            this.dispatch(oh(t2)), this.dispatchCoreAction(Un(t2, r2)), this.emitPendingChange(t2), this.events$.emit({ type: "commit", documentId: t2, success: true }), s4.resolve(true);
          }, (e4) => {
            this.events$.emit({ type: "commit", documentId: t2, success: false, error: e4.reason }), s4.reject({ code: Ht.Unknown, message: "Failed to commit redactions" });
          }), s4;
        }
        emitPendingChange(e3) {
          const t2 = this.getDocumentState(e3);
          t2 && this.pending$.emit({ documentId: e3, pending: t2.pending });
        }
        emitSelectedChange(e3) {
          const t2 = this.getDocumentState(e3);
          t2 && this.selected$.emit({ documentId: e3, selected: t2.selected });
        }
        emitStateChange(e3) {
          const t2 = this.getDocumentState(e3);
          t2 && this.state$.emit({ documentId: e3, state: t2 });
        }
        onStoreUpdated(e3, t2) {
          for (const e4 in t2.documents) {
            t2.documents[e4] && (this.emitPendingChange(e4), this.emitSelectedChange(e4), this.emitStateChange(e4));
          }
        }
        async destroy() {
          this.pending$.clear(), this.selected$.clear(), this.state$.clear(), this.events$.clear(), this.redactionSelection$.forEach((e3) => e3.clear()), this.redactionSelection$.clear(), this.documentUnsubscribers.forEach((e3) => {
            e3.forEach((e4) => e4());
          }), this.documentUnsubscribers.clear(), await super.destroy();
        }
      };
      lh.id = "redaction";
      ch = lh;
      dh = "redaction";
      uh = { manifest: { id: dh, name: "Redaction Plugin", version: "1.0.0", provides: ["redaction"], requires: [], optional: ["interaction-manager", "selection"], defaultConfig: { drawBlackBoxes: true } }, create: (e3, t2) => new ch(dh, e3, t2), reducer: (e3 = sh, t2) => {
        switch (t2.type) {
          case Gu: {
            const { documentId: n3, state: o3 } = t2.payload;
            return { ...e3, documents: { ...e3.documents, [n3]: o3 }, activeDocumentId: e3.activeDocumentId ?? n3 };
          }
          case Vu: {
            const n3 = t2.payload, { [n3]: o3, ...i3 } = e3.documents;
            return { ...e3, documents: i3, activeDocumentId: e3.activeDocumentId === n3 ? null : e3.activeDocumentId };
          }
          case "REDACTION/SET_ACTIVE_DOCUMENT":
            return { ...e3, activeDocumentId: t2.payload };
          case Yu: {
            const { documentId: n3, items: o3 } = t2.payload, i3 = e3.documents[n3];
            if (!i3) return e3;
            const r2 = { ...i3.pending };
            for (const e4 of o3) r2[e4.page] = (r2[e4.page] ?? []).concat(e4);
            return { ...e3, documents: { ...e3.documents, [n3]: { ...i3, pending: r2, pendingCount: rh(r2) } } };
          }
          case Xu: {
            const { documentId: n3, page: o3, id: i3 } = t2.payload, r2 = e3.documents[n3];
            if (!r2) return e3;
            const a3 = (r2.pending[o3] ?? []).filter((e4) => e4.id !== i3), s4 = { ...r2.pending, [o3]: a3 }, l4 = r2.selected && !(r2.selected.page === o3 && r2.selected.id === i3);
            return { ...e3, documents: { ...e3.documents, [n3]: { ...r2, pending: s4, pendingCount: rh(s4), selected: l4 ? r2.selected : null } } };
          }
          case Qu: {
            const n3 = t2.payload, o3 = e3.documents[n3];
            return o3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...o3, pending: {}, pendingCount: 0, selected: null } } } : e3;
          }
          case Ju: {
            const { documentId: n3, page: o3, id: i3 } = t2.payload, r2 = e3.documents[n3];
            return r2 ? { ...e3, documents: { ...e3.documents, [n3]: { ...r2, selected: { page: o3, id: i3 } } } } : e3;
          }
          case eh: {
            const n3 = t2.payload, o3 = e3.documents[n3];
            return o3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...o3, selected: null } } } : e3;
          }
          case Zu: {
            const { documentId: n3, mode: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, isRedacting: true, activeType: o3 } } } : e3;
          }
          case Ku: {
            const n3 = t2.payload, o3 = e3.documents[n3];
            return o3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...o3, pending: {}, pendingCount: 0, selected: null, isRedacting: false, activeType: null } } } : e3;
          }
          case "SET_ACTIVE_TYPE": {
            const { documentId: n3, mode: o3 } = t2.payload, i3 = e3.documents[n3];
            return i3 ? { ...e3, documents: { ...e3.documents, [n3]: { ...i3, activeType: o3 } } } : e3;
          }
          default:
            return e3;
        }
      }, initialState: sh };
      hh = () => go(ch.id);
      mh = ({ documentId: e3, pageIndex: t2, scale: n3, className: o3, stroke: i3 = "red", fill: r2 = "transparent" }) => {
        const { plugin: a3 } = hh(), s4 = fo(e3), [l4, c4] = ke(null), d4 = Te(() => void 0 !== n3 ? n3 : (null == s4 ? void 0 : s4.scale) ?? 1, [n3, null == s4 ? void 0 : s4.scale]);
        return Me(() => {
          if (a3 && e3) return a3.registerMarqueeOnPage({ documentId: e3, pageIndex: t2, scale: d4, callback: { onPreview: c4 } });
        }, [a3, e3, t2, d4]), l4 ? Ue("div", { style: { position: "absolute", pointerEvents: "none", left: l4.origin.x * d4, top: l4.origin.y * d4, width: l4.size.width * d4, height: l4.size.height * d4, border: `1px solid ${i3}`, background: r2, boxSizing: "border-box" }, className: o3 }) : null;
      };
      fh = ({ documentId: e3, pageIndex: t2, scale: n3, rotation: o3, selectionMenu: i3 }) => {
        const r2 = fo(e3), a3 = Te(() => void 0 !== n3 ? n3 : (null == r2 ? void 0 : r2.scale) ?? 1, [n3, null == r2 ? void 0 : r2.scale]);
        return Ue(U2, { children: [Ue(vh, { documentId: e3, pageIndex: t2, scale: a3, rotation: Te(() => void 0 !== o3 ? o3 : (null == r2 ? void 0 : r2.rotation) ?? We.Degree0, [o3, null == r2 ? void 0 : r2.rotation]), selectionMenu: i3 }), Ue(mh, { documentId: e3, pageIndex: t2, scale: a3 }), Ue(ph, { documentId: e3, pageIndex: t2, scale: a3 })] });
      };
      yh = class extends Yn {
        constructor(e3, t2) {
          super(e3, t2);
        }
        async initialize(e3) {
        }
        buildCapability() {
          return { getAttachments: () => this.getAttachments(), downloadAttachment: (e3) => this.downloadAttachment(e3), forDocument: (e3) => this.createAttachmentScope(e3) };
        }
        createAttachmentScope(e3) {
          return { getAttachments: () => this.getAttachments(e3), downloadAttachment: (t2) => this.downloadAttachment(t2, e3) };
        }
        downloadAttachment(e3, t2) {
          const n3 = t2 ?? this.getActiveDocumentId(), o3 = this.coreState.core.documents[n3];
          return (null == o3 ? void 0 : o3.document) ? this.engine.readAttachmentContent(o3.document, e3) : Ut.reject({ code: Ht.NotFound, message: `Document ${n3} not found` });
        }
        getAttachments(e3) {
          const t2 = e3 ?? this.getActiveDocumentId(), n3 = this.coreState.core.documents[t2];
          return (null == n3 ? void 0 : n3.document) ? this.engine.getAttachments(n3.document) : Ut.reject({ code: Ht.NotFound, message: `Document ${t2} not found` });
        }
      };
      yh.id = "attachment";
      bh = yh;
      wh = "attachment";
      xh = { manifest: { id: wh, name: "Attachment Plugin", version: "1.0.0", provides: ["attachment"], requires: [], optional: [], defaultConfig: {} }, create: (e3) => new bh(wh, e3), reducer: () => {
      }, initialState: {} };
      Ch = (e3 = /* @__PURE__ */ new Map(), t2 = null, n3) => ({ nextPart: e3, validators: t2, classGroupId: n3 });
      Ih = "-";
      Sh = [];
      kh = (e3) => {
        const t2 = Ph(e3), { conflictingClassGroups: n3, conflictingClassGroupModifiers: o3 } = e3;
        return { getClassGroupId: (e4) => {
          if (e4.startsWith("[") && e4.endsWith("]")) return Mh(e4);
          const n4 = e4.split(Ih), o4 = "" === n4[0] && n4.length > 1 ? 1 : 0;
          return Dh(n4, o4, t2);
        }, getConflictingClassGroupIds: (e4, t3) => {
          if (t3) {
            const t4 = o3[e4], i3 = n3[e4];
            return t4 ? i3 ? ((e5, t5) => {
              const n4 = new Array(e5.length + t5.length);
              for (let t6 = 0; t6 < e5.length; t6++) n4[t6] = e5[t6];
              for (let o4 = 0; o4 < t5.length; o4++) n4[e5.length + o4] = t5[o4];
              return n4;
            })(i3, t4) : t4 : i3 || Sh;
          }
          return n3[e4] || Sh;
        } };
      };
      Dh = (e3, t2, n3) => {
        if (0 === e3.length - t2) return n3.classGroupId;
        const o3 = e3[t2], i3 = n3.nextPart.get(o3);
        if (i3) {
          const n4 = Dh(e3, t2 + 1, i3);
          if (n4) return n4;
        }
        const r2 = n3.validators;
        if (null === r2) return;
        const a3 = 0 === t2 ? e3.join(Ih) : e3.slice(t2).join(Ih), s4 = r2.length;
        for (let e4 = 0; e4 < s4; e4++) {
          const t3 = r2[e4];
          if (t3.validator(a3)) return t3.classGroupId;
        }
      };
      Mh = (e3) => -1 === e3.slice(1, -1).indexOf(":") ? void 0 : (() => {
        const t2 = e3.slice(1, -1), n3 = t2.indexOf(":"), o3 = t2.slice(0, n3);
        return o3 ? "arbitrary.." + o3 : void 0;
      })();
      Ph = (e3) => {
        const { theme: t2, classGroups: n3 } = e3;
        return Ah(n3, t2);
      };
      Ah = (e3, t2) => {
        const n3 = Ch();
        for (const o3 in e3) {
          const i3 = e3[o3];
          Th(i3, n3, o3, t2);
        }
        return n3;
      };
      Th = (e3, t2, n3, o3) => {
        const i3 = e3.length;
        for (let r2 = 0; r2 < i3; r2++) {
          const i4 = e3[r2];
          zh(i4, t2, n3, o3);
        }
      };
      zh = (e3, t2, n3, o3) => {
        "string" != typeof e3 ? "function" != typeof e3 ? Rh(e3, t2, n3, o3) : _h(e3, t2, n3, o3) : Eh(e3, t2, n3);
      };
      Eh = (e3, t2, n3) => {
        ("" === e3 ? t2 : Nh(t2, e3)).classGroupId = n3;
      };
      _h = (e3, t2, n3, o3) => {
        Oh(e3) ? Th(e3(o3), t2, n3, o3) : (null === t2.validators && (t2.validators = []), t2.validators.push(/* @__PURE__ */ ((e4, t3) => ({ classGroupId: e4, validator: t3 }))(n3, e3)));
      };
      Rh = (e3, t2, n3, o3) => {
        const i3 = Object.entries(e3), r2 = i3.length;
        for (let e4 = 0; e4 < r2; e4++) {
          const [r3, a3] = i3[e4];
          Th(a3, Nh(t2, r3), n3, o3);
        }
      };
      Nh = (e3, t2) => {
        let n3 = e3;
        const o3 = t2.split(Ih), i3 = o3.length;
        for (let e4 = 0; e4 < i3; e4++) {
          const t3 = o3[e4];
          let i4 = n3.nextPart.get(t3);
          i4 || (i4 = Ch(), n3.nextPart.set(t3, i4)), n3 = i4;
        }
        return n3;
      };
      Oh = (e3) => "isThemeGetter" in e3 && true === e3.isThemeGetter;
      Lh = (e3) => {
        if (e3 < 1) return { get: () => {
        }, set: () => {
        } };
        let t2 = 0, n3 = /* @__PURE__ */ Object.create(null), o3 = /* @__PURE__ */ Object.create(null);
        const i3 = (i4, r2) => {
          n3[i4] = r2, t2++, t2 > e3 && (t2 = 0, o3 = n3, n3 = /* @__PURE__ */ Object.create(null));
        };
        return { get(e4) {
          let t3 = n3[e4];
          return void 0 !== t3 ? t3 : void 0 !== (t3 = o3[e4]) ? (i3(e4, t3), t3) : void 0;
        }, set(e4, t3) {
          e4 in n3 ? n3[e4] = t3 : i3(e4, t3);
        } };
      };
      $h = [];
      Fh = (e3, t2, n3, o3, i3) => ({ modifiers: e3, hasImportantModifier: t2, baseClassName: n3, maybePostfixModifierPosition: o3, isExternal: i3 });
      jh = (e3) => {
        const { prefix: t2, experimentalParseClassName: n3 } = e3;
        let o3 = (e4) => {
          const t3 = [];
          let n4, o4 = 0, i3 = 0, r2 = 0;
          const a3 = e4.length;
          for (let s5 = 0; s5 < a3; s5++) {
            const a4 = e4[s5];
            if (0 === o4 && 0 === i3) {
              if (":" === a4) {
                t3.push(e4.slice(r2, s5)), r2 = s5 + 1;
                continue;
              }
              if ("/" === a4) {
                n4 = s5;
                continue;
              }
            }
            "[" === a4 ? o4++ : "]" === a4 ? o4-- : "(" === a4 ? i3++ : ")" === a4 && i3--;
          }
          const s4 = 0 === t3.length ? e4 : e4.slice(r2);
          let l4 = s4, c4 = false;
          s4.endsWith("!") ? (l4 = s4.slice(0, -1), c4 = true) : s4.startsWith("!") && (l4 = s4.slice(1), c4 = true);
          return Fh(t3, c4, l4, n4 && n4 > r2 ? n4 - r2 : void 0);
        };
        if (t2) {
          const e4 = t2 + ":", n4 = o3;
          o3 = (t3) => t3.startsWith(e4) ? n4(t3.slice(e4.length)) : Fh($h, false, t3, void 0, true);
        }
        if (n3) {
          const e4 = o3;
          o3 = (t3) => n3({ className: t3, parseClassName: e4 });
        }
        return o3;
      };
      Hh = (e3) => {
        const t2 = /* @__PURE__ */ new Map();
        return e3.orderSensitiveModifiers.forEach((e4, n3) => {
          t2.set(e4, 1e6 + n3);
        }), (e4) => {
          const n3 = [];
          let o3 = [];
          for (let i3 = 0; i3 < e4.length; i3++) {
            const r2 = e4[i3], a3 = "[" === r2[0], s4 = t2.has(r2);
            a3 || s4 ? (o3.length > 0 && (o3.sort(), n3.push(...o3), o3 = []), n3.push(r2)) : o3.push(r2);
          }
          return o3.length > 0 && (o3.sort(), n3.push(...o3)), n3;
        };
      };
      Uh = /\s+/;
      Wh = (e3) => {
        if ("string" == typeof e3) return e3;
        let t2, n3 = "";
        for (let o3 = 0; o3 < e3.length; o3++) e3[o3] && (t2 = Wh(e3[o3])) && (n3 && (n3 += " "), n3 += t2);
        return n3;
      };
      Bh = (e3, ...t2) => {
        let n3, o3, i3, r2;
        const a3 = (e4) => {
          const t3 = o3(e4);
          if (t3) return t3;
          const r3 = ((e5, t4) => {
            const { parseClassName: n4, getClassGroupId: o4, getConflictingClassGroupIds: i4, sortModifiers: r4 } = t4, a4 = [], s4 = e5.trim().split(Uh);
            let l4 = "";
            for (let e6 = s4.length - 1; e6 >= 0; e6 -= 1) {
              const t5 = s4[e6], { isExternal: c4, modifiers: d4, hasImportantModifier: u4, baseClassName: h3, maybePostfixModifierPosition: m3 } = n4(t5);
              if (c4) {
                l4 = t5 + (l4.length > 0 ? " " + l4 : l4);
                continue;
              }
              let g3 = !!m3, p4 = o4(g3 ? h3.substring(0, m3) : h3);
              if (!p4) {
                if (!g3) {
                  l4 = t5 + (l4.length > 0 ? " " + l4 : l4);
                  continue;
                }
                if (p4 = o4(h3), !p4) {
                  l4 = t5 + (l4.length > 0 ? " " + l4 : l4);
                  continue;
                }
                g3 = false;
              }
              const v2 = 0 === d4.length ? "" : 1 === d4.length ? d4[0] : r4(d4).join(":"), f2 = u4 ? v2 + "!" : v2, y2 = f2 + p4;
              if (a4.indexOf(y2) > -1) continue;
              a4.push(y2);
              const b2 = i4(p4, g3);
              for (let e7 = 0; e7 < b2.length; ++e7) {
                const t6 = b2[e7];
                a4.push(f2 + t6);
              }
              l4 = t5 + (l4.length > 0 ? " " + l4 : l4);
            }
            return l4;
          })(e4, n3);
          return i3(e4, r3), r3;
        };
        return r2 = (s4) => {
          const l4 = t2.reduce((e4, t3) => t3(e4), e3());
          return n3 = ((e4) => ({ cache: Lh(e4.cacheSize), parseClassName: jh(e4), sortModifiers: Hh(e4), ...kh(e4) }))(l4), o3 = n3.cache.get, i3 = n3.cache.set, r2 = a3, a3(s4);
        }, (...e4) => r2(((...e5) => {
          let t3, n4, o4 = 0, i4 = "";
          for (; o4 < e5.length; ) (t3 = e5[o4++]) && (n4 = Wh(t3)) && (i4 && (i4 += " "), i4 += n4);
          return i4;
        })(...e4));
      };
      qh = [];
      Gh = (e3) => {
        const t2 = (t3) => t3[e3] || qh;
        return t2.isThemeGetter = true, t2;
      };
      Vh = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
      Zh = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
      Kh = /^\d+\/\d+$/;
      Yh = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
      Xh = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
      Qh = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
      Jh = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
      em = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
      tm = (e3) => Kh.test(e3);
      nm = (e3) => !!e3 && !Number.isNaN(Number(e3));
      om = (e3) => !!e3 && Number.isInteger(Number(e3));
      im = (e3) => e3.endsWith("%") && nm(e3.slice(0, -1));
      rm = (e3) => Yh.test(e3);
      am = () => true;
      sm = (e3) => Xh.test(e3) && !Qh.test(e3);
      lm = () => false;
      cm = (e3) => Jh.test(e3);
      dm = (e3) => em.test(e3);
      um = (e3) => !mm(e3) && !bm(e3);
      hm = (e3) => Dm(e3, Tm, lm);
      mm = (e3) => Vh.test(e3);
      gm = (e3) => Dm(e3, zm, sm);
      pm = (e3) => Dm(e3, Em, nm);
      vm = (e3) => Dm(e3, Pm, lm);
      fm = (e3) => Dm(e3, Am, dm);
      ym = (e3) => Dm(e3, Rm, cm);
      bm = (e3) => Zh.test(e3);
      wm = (e3) => Mm(e3, zm);
      xm = (e3) => Mm(e3, _m);
      Cm = (e3) => Mm(e3, Pm);
      Im = (e3) => Mm(e3, Tm);
      Sm = (e3) => Mm(e3, Am);
      km = (e3) => Mm(e3, Rm, true);
      Dm = (e3, t2, n3) => {
        const o3 = Vh.exec(e3);
        return !!o3 && (o3[1] ? t2(o3[1]) : n3(o3[2]));
      };
      Mm = (e3, t2, n3 = false) => {
        const o3 = Zh.exec(e3);
        return !!o3 && (o3[1] ? t2(o3[1]) : n3);
      };
      Pm = (e3) => "position" === e3 || "percentage" === e3;
      Am = (e3) => "image" === e3 || "url" === e3;
      Tm = (e3) => "length" === e3 || "size" === e3 || "bg-size" === e3;
      zm = (e3) => "length" === e3;
      Em = (e3) => "number" === e3;
      _m = (e3) => "family-name" === e3;
      Rm = (e3) => "shadow" === e3;
      Nm = Bh(() => {
        const e3 = Gh("color"), t2 = Gh("font"), n3 = Gh("text"), o3 = Gh("font-weight"), i3 = Gh("tracking"), r2 = Gh("leading"), a3 = Gh("breakpoint"), s4 = Gh("container"), l4 = Gh("spacing"), c4 = Gh("radius"), d4 = Gh("shadow"), u4 = Gh("inset-shadow"), h3 = Gh("text-shadow"), m3 = Gh("drop-shadow"), g3 = Gh("blur"), p4 = Gh("perspective"), v2 = Gh("aspect"), f2 = Gh("ease"), y2 = Gh("animate"), b2 = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom", bm, mm], w2 = () => [bm, mm, l4], x2 = () => [tm, "full", "auto", ...w2()], C2 = () => [om, "none", "subgrid", bm, mm], I2 = () => ["auto", { span: ["full", om, bm, mm] }, om, bm, mm], S2 = () => [om, "auto", bm, mm], k2 = () => ["auto", "min", "max", "fr", bm, mm], D2 = () => ["auto", ...w2()], M2 = () => [tm, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...w2()], P2 = () => [e3, bm, mm], A2 = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom", Cm, vm, { position: [bm, mm] }], T2 = () => ["auto", "cover", "contain", Im, hm, { size: [bm, mm] }], z3 = () => [im, wm, gm], E2 = () => ["", "none", "full", c4, bm, mm], _2 = () => ["", nm, wm, gm], R2 = () => [nm, im, Cm, vm], N3 = () => ["", "none", g3, bm, mm], O2 = () => ["none", nm, bm, mm], L3 = () => ["none", nm, bm, mm], $3 = () => [nm, bm, mm], F2 = () => [tm, "full", ...w2()];
        return { cacheSize: 500, theme: { animate: ["spin", "ping", "pulse", "bounce"], aspect: ["video"], blur: [rm], breakpoint: [rm], color: [am], container: [rm], "drop-shadow": [rm], ease: ["in", "out", "in-out"], font: [um], "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"], "inset-shadow": [rm], leading: ["none", "tight", "snug", "normal", "relaxed", "loose"], perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"], radius: [rm], shadow: [rm], spacing: ["px", nm], text: [rm], "text-shadow": [rm], tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"] }, classGroups: { aspect: [{ aspect: ["auto", "square", tm, mm, bm, v2] }], container: ["container"], columns: [{ columns: [nm, mm, bm, s4] }], "break-after": [{ "break-after": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"] }], "break-before": [{ "break-before": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"] }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], sr: ["sr-only", "not-sr-only"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: b2() }], overflow: [{ overflow: ["auto", "hidden", "clip", "visible", "scroll"] }], "overflow-x": [{ "overflow-x": ["auto", "hidden", "clip", "visible", "scroll"] }], "overflow-y": [{ "overflow-y": ["auto", "hidden", "clip", "visible", "scroll"] }], overscroll: [{ overscroll: ["auto", "contain", "none"] }], "overscroll-x": [{ "overscroll-x": ["auto", "contain", "none"] }], "overscroll-y": [{ "overscroll-y": ["auto", "contain", "none"] }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: x2() }], "inset-x": [{ "inset-x": x2() }], "inset-y": [{ "inset-y": x2() }], start: [{ start: x2() }], end: [{ end: x2() }], top: [{ top: x2() }], right: [{ right: x2() }], bottom: [{ bottom: x2() }], left: [{ left: x2() }], visibility: ["visible", "invisible", "collapse"], z: [{ z: [om, "auto", bm, mm] }], basis: [{ basis: [tm, "full", "auto", s4, ...w2()] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["nowrap", "wrap", "wrap-reverse"] }], flex: [{ flex: [nm, tm, "auto", "initial", "none", mm] }], grow: [{ grow: ["", nm, bm, mm] }], shrink: [{ shrink: ["", nm, bm, mm] }], order: [{ order: [om, "first", "last", "none", bm, mm] }], "grid-cols": [{ "grid-cols": C2() }], "col-start-end": [{ col: I2() }], "col-start": [{ "col-start": S2() }], "col-end": [{ "col-end": S2() }], "grid-rows": [{ "grid-rows": C2() }], "row-start-end": [{ row: I2() }], "row-start": [{ "row-start": S2() }], "row-end": [{ "row-end": S2() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": k2() }], "auto-rows": [{ "auto-rows": k2() }], gap: [{ gap: w2() }], "gap-x": [{ "gap-x": w2() }], "gap-y": [{ "gap-y": w2() }], "justify-content": [{ justify: ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe", "normal"] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch", "center-safe", "end-safe", "normal"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch", "center-safe", "end-safe"] }], "align-content": [{ content: ["normal", "start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"] }], "align-items": [{ items: ["start", "end", "center", "stretch", "center-safe", "end-safe", { baseline: ["", "last"] }] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "center-safe", "end-safe", { baseline: ["", "last"] }] }], "place-content": [{ "place-content": ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"] }], "place-items": [{ "place-items": ["start", "end", "center", "stretch", "center-safe", "end-safe", "baseline"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch", "center-safe", "end-safe"] }], p: [{ p: w2() }], px: [{ px: w2() }], py: [{ py: w2() }], ps: [{ ps: w2() }], pe: [{ pe: w2() }], pt: [{ pt: w2() }], pr: [{ pr: w2() }], pb: [{ pb: w2() }], pl: [{ pl: w2() }], m: [{ m: D2() }], mx: [{ mx: D2() }], my: [{ my: D2() }], ms: [{ ms: D2() }], me: [{ me: D2() }], mt: [{ mt: D2() }], mr: [{ mr: D2() }], mb: [{ mb: D2() }], ml: [{ ml: D2() }], "space-x": [{ "space-x": w2() }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": w2() }], "space-y-reverse": ["space-y-reverse"], size: [{ size: M2() }], w: [{ w: [s4, "screen", ...M2()] }], "min-w": [{ "min-w": [s4, "screen", "none", ...M2()] }], "max-w": [{ "max-w": [s4, "screen", "none", "prose", { screen: [a3] }, ...M2()] }], h: [{ h: ["screen", "lh", ...M2()] }], "min-h": [{ "min-h": ["screen", "lh", "none", ...M2()] }], "max-h": [{ "max-h": ["screen", "lh", ...M2()] }], "font-size": [{ text: ["base", n3, wm, gm] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: [o3, bm, pm] }], "font-stretch": [{ "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", im, mm] }], "font-family": [{ font: [xm, mm, t2] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: [i3, bm, mm] }], "line-clamp": [{ "line-clamp": [nm, "none", bm, pm] }], leading: [{ leading: [r2, ...w2()] }], "list-image": [{ "list-image": ["none", bm, mm] }], "list-style-position": [{ list: ["inside", "outside"] }], "list-style-type": [{ list: ["disc", "decimal", "none", bm, mm] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "placeholder-color": [{ placeholder: P2() }], "text-color": [{ text: P2() }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: ["solid", "dashed", "dotted", "double", "wavy"] }], "text-decoration-thickness": [{ decoration: [nm, "from-font", "auto", bm, gm] }], "text-decoration-color": [{ decoration: P2() }], "underline-offset": [{ "underline-offset": [nm, "auto", bm, mm] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: w2() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", bm, mm] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], wrap: [{ wrap: ["break-word", "anywhere", "normal"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", bm, mm] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: A2() }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "space", "round"] }] }], "bg-size": [{ bg: T2() }], "bg-image": [{ bg: ["none", { linear: [{ to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, om, bm, mm], radial: ["", bm, mm], conic: [om, bm, mm] }, Sm, fm] }], "bg-color": [{ bg: P2() }], "gradient-from-pos": [{ from: z3() }], "gradient-via-pos": [{ via: z3() }], "gradient-to-pos": [{ to: z3() }], "gradient-from": [{ from: P2() }], "gradient-via": [{ via: P2() }], "gradient-to": [{ to: P2() }], rounded: [{ rounded: E2() }], "rounded-s": [{ "rounded-s": E2() }], "rounded-e": [{ "rounded-e": E2() }], "rounded-t": [{ "rounded-t": E2() }], "rounded-r": [{ "rounded-r": E2() }], "rounded-b": [{ "rounded-b": E2() }], "rounded-l": [{ "rounded-l": E2() }], "rounded-ss": [{ "rounded-ss": E2() }], "rounded-se": [{ "rounded-se": E2() }], "rounded-ee": [{ "rounded-ee": E2() }], "rounded-es": [{ "rounded-es": E2() }], "rounded-tl": [{ "rounded-tl": E2() }], "rounded-tr": [{ "rounded-tr": E2() }], "rounded-br": [{ "rounded-br": E2() }], "rounded-bl": [{ "rounded-bl": E2() }], "border-w": [{ border: _2() }], "border-w-x": [{ "border-x": _2() }], "border-w-y": [{ "border-y": _2() }], "border-w-s": [{ "border-s": _2() }], "border-w-e": [{ "border-e": _2() }], "border-w-t": [{ "border-t": _2() }], "border-w-r": [{ "border-r": _2() }], "border-w-b": [{ "border-b": _2() }], "border-w-l": [{ "border-l": _2() }], "divide-x": [{ "divide-x": _2() }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": _2() }], "divide-y-reverse": ["divide-y-reverse"], "border-style": [{ border: ["solid", "dashed", "dotted", "double", "hidden", "none"] }], "divide-style": [{ divide: ["solid", "dashed", "dotted", "double", "hidden", "none"] }], "border-color": [{ border: P2() }], "border-color-x": [{ "border-x": P2() }], "border-color-y": [{ "border-y": P2() }], "border-color-s": [{ "border-s": P2() }], "border-color-e": [{ "border-e": P2() }], "border-color-t": [{ "border-t": P2() }], "border-color-r": [{ "border-r": P2() }], "border-color-b": [{ "border-b": P2() }], "border-color-l": [{ "border-l": P2() }], "divide-color": [{ divide: P2() }], "outline-style": [{ outline: ["solid", "dashed", "dotted", "double", "none", "hidden"] }], "outline-offset": [{ "outline-offset": [nm, bm, mm] }], "outline-w": [{ outline: ["", nm, wm, gm] }], "outline-color": [{ outline: P2() }], shadow: [{ shadow: ["", "none", d4, km, ym] }], "shadow-color": [{ shadow: P2() }], "inset-shadow": [{ "inset-shadow": ["none", u4, km, ym] }], "inset-shadow-color": [{ "inset-shadow": P2() }], "ring-w": [{ ring: _2() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: P2() }], "ring-offset-w": [{ "ring-offset": [nm, gm] }], "ring-offset-color": [{ "ring-offset": P2() }], "inset-ring-w": [{ "inset-ring": _2() }], "inset-ring-color": [{ "inset-ring": P2() }], "text-shadow": [{ "text-shadow": ["none", h3, km, ym] }], "text-shadow-color": [{ "text-shadow": P2() }], opacity: [{ opacity: [nm, bm, mm] }], "mix-blend": [{ "mix-blend": ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-darker", "plus-lighter"] }], "bg-blend": [{ "bg-blend": ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"] }], "mask-clip": [{ "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"] }, "mask-no-clip"], "mask-composite": [{ mask: ["add", "subtract", "intersect", "exclude"] }], "mask-image-linear-pos": [{ "mask-linear": [nm] }], "mask-image-linear-from-pos": [{ "mask-linear-from": R2() }], "mask-image-linear-to-pos": [{ "mask-linear-to": R2() }], "mask-image-linear-from-color": [{ "mask-linear-from": P2() }], "mask-image-linear-to-color": [{ "mask-linear-to": P2() }], "mask-image-t-from-pos": [{ "mask-t-from": R2() }], "mask-image-t-to-pos": [{ "mask-t-to": R2() }], "mask-image-t-from-color": [{ "mask-t-from": P2() }], "mask-image-t-to-color": [{ "mask-t-to": P2() }], "mask-image-r-from-pos": [{ "mask-r-from": R2() }], "mask-image-r-to-pos": [{ "mask-r-to": R2() }], "mask-image-r-from-color": [{ "mask-r-from": P2() }], "mask-image-r-to-color": [{ "mask-r-to": P2() }], "mask-image-b-from-pos": [{ "mask-b-from": R2() }], "mask-image-b-to-pos": [{ "mask-b-to": R2() }], "mask-image-b-from-color": [{ "mask-b-from": P2() }], "mask-image-b-to-color": [{ "mask-b-to": P2() }], "mask-image-l-from-pos": [{ "mask-l-from": R2() }], "mask-image-l-to-pos": [{ "mask-l-to": R2() }], "mask-image-l-from-color": [{ "mask-l-from": P2() }], "mask-image-l-to-color": [{ "mask-l-to": P2() }], "mask-image-x-from-pos": [{ "mask-x-from": R2() }], "mask-image-x-to-pos": [{ "mask-x-to": R2() }], "mask-image-x-from-color": [{ "mask-x-from": P2() }], "mask-image-x-to-color": [{ "mask-x-to": P2() }], "mask-image-y-from-pos": [{ "mask-y-from": R2() }], "mask-image-y-to-pos": [{ "mask-y-to": R2() }], "mask-image-y-from-color": [{ "mask-y-from": P2() }], "mask-image-y-to-color": [{ "mask-y-to": P2() }], "mask-image-radial": [{ "mask-radial": [bm, mm] }], "mask-image-radial-from-pos": [{ "mask-radial-from": R2() }], "mask-image-radial-to-pos": [{ "mask-radial-to": R2() }], "mask-image-radial-from-color": [{ "mask-radial-from": P2() }], "mask-image-radial-to-color": [{ "mask-radial-to": P2() }], "mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }], "mask-image-radial-size": [{ "mask-radial": [{ closest: ["side", "corner"], farthest: ["side", "corner"] }] }], "mask-image-radial-pos": [{ "mask-radial-at": ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"] }], "mask-image-conic-pos": [{ "mask-conic": [nm] }], "mask-image-conic-from-pos": [{ "mask-conic-from": R2() }], "mask-image-conic-to-pos": [{ "mask-conic-to": R2() }], "mask-image-conic-from-color": [{ "mask-conic-from": P2() }], "mask-image-conic-to-color": [{ "mask-conic-to": P2() }], "mask-mode": [{ mask: ["alpha", "luminance", "match"] }], "mask-origin": [{ "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"] }], "mask-position": [{ mask: A2() }], "mask-repeat": [{ mask: ["no-repeat", { repeat: ["", "x", "y", "space", "round"] }] }], "mask-size": [{ mask: T2() }], "mask-type": [{ "mask-type": ["alpha", "luminance"] }], "mask-image": [{ mask: ["none", bm, mm] }], filter: [{ filter: ["", "none", bm, mm] }], blur: [{ blur: N3() }], brightness: [{ brightness: [nm, bm, mm] }], contrast: [{ contrast: [nm, bm, mm] }], "drop-shadow": [{ "drop-shadow": ["", "none", m3, km, ym] }], "drop-shadow-color": [{ "drop-shadow": P2() }], grayscale: [{ grayscale: ["", nm, bm, mm] }], "hue-rotate": [{ "hue-rotate": [nm, bm, mm] }], invert: [{ invert: ["", nm, bm, mm] }], saturate: [{ saturate: [nm, bm, mm] }], sepia: [{ sepia: ["", nm, bm, mm] }], "backdrop-filter": [{ "backdrop-filter": ["", "none", bm, mm] }], "backdrop-blur": [{ "backdrop-blur": N3() }], "backdrop-brightness": [{ "backdrop-brightness": [nm, bm, mm] }], "backdrop-contrast": [{ "backdrop-contrast": [nm, bm, mm] }], "backdrop-grayscale": [{ "backdrop-grayscale": ["", nm, bm, mm] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [nm, bm, mm] }], "backdrop-invert": [{ "backdrop-invert": ["", nm, bm, mm] }], "backdrop-opacity": [{ "backdrop-opacity": [nm, bm, mm] }], "backdrop-saturate": [{ "backdrop-saturate": [nm, bm, mm] }], "backdrop-sepia": [{ "backdrop-sepia": ["", nm, bm, mm] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": w2() }], "border-spacing-x": [{ "border-spacing-x": w2() }], "border-spacing-y": [{ "border-spacing-y": w2() }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", bm, mm] }], "transition-behavior": [{ transition: ["normal", "discrete"] }], duration: [{ duration: [nm, "initial", bm, mm] }], ease: [{ ease: ["linear", "initial", f2, bm, mm] }], delay: [{ delay: [nm, bm, mm] }], animate: [{ animate: ["none", y2, bm, mm] }], backface: [{ backface: ["hidden", "visible"] }], perspective: [{ perspective: [p4, bm, mm] }], "perspective-origin": [{ "perspective-origin": b2() }], rotate: [{ rotate: O2() }], "rotate-x": [{ "rotate-x": O2() }], "rotate-y": [{ "rotate-y": O2() }], "rotate-z": [{ "rotate-z": O2() }], scale: [{ scale: L3() }], "scale-x": [{ "scale-x": L3() }], "scale-y": [{ "scale-y": L3() }], "scale-z": [{ "scale-z": L3() }], "scale-3d": ["scale-3d"], skew: [{ skew: $3() }], "skew-x": [{ "skew-x": $3() }], "skew-y": [{ "skew-y": $3() }], transform: [{ transform: [bm, mm, "", "none", "gpu", "cpu"] }], "transform-origin": [{ origin: b2() }], "transform-style": [{ transform: ["3d", "flat"] }], translate: [{ translate: F2() }], "translate-x": [{ "translate-x": F2() }], "translate-y": [{ "translate-y": F2() }], "translate-z": [{ "translate-z": F2() }], "translate-none": ["translate-none"], accent: [{ accent: P2() }], appearance: [{ appearance: ["none", "auto"] }], "caret-color": [{ caret: P2() }], "color-scheme": [{ scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", bm, mm] }], "field-sizing": [{ "field-sizing": ["fixed", "content"] }], "pointer-events": [{ "pointer-events": ["auto", "none"] }], resize: [{ resize: ["none", "", "y", "x"] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": w2() }], "scroll-mx": [{ "scroll-mx": w2() }], "scroll-my": [{ "scroll-my": w2() }], "scroll-ms": [{ "scroll-ms": w2() }], "scroll-me": [{ "scroll-me": w2() }], "scroll-mt": [{ "scroll-mt": w2() }], "scroll-mr": [{ "scroll-mr": w2() }], "scroll-mb": [{ "scroll-mb": w2() }], "scroll-ml": [{ "scroll-ml": w2() }], "scroll-p": [{ "scroll-p": w2() }], "scroll-px": [{ "scroll-px": w2() }], "scroll-py": [{ "scroll-py": w2() }], "scroll-ps": [{ "scroll-ps": w2() }], "scroll-pe": [{ "scroll-pe": w2() }], "scroll-pt": [{ "scroll-pt": w2() }], "scroll-pr": [{ "scroll-pr": w2() }], "scroll-pb": [{ "scroll-pb": w2() }], "scroll-pl": [{ "scroll-pl": w2() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", bm, mm] }], fill: [{ fill: ["none", ...P2()] }], "stroke-w": [{ stroke: [nm, wm, gm, pm] }], stroke: [{ stroke: ["none", ...P2()] }], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], translate: ["translate-x", "translate-y", "translate-none"], "translate-none": ["translate", "translate-x", "translate-y", "translate-z"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] }, orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"] };
      });
      Om = ["children", "onClick", "active", "disabled", "className", "anchorRef"];
      $m = function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M9 6l6 6l-6 6" }));
      };
      Fm = function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M15 6l-6 6l6 6" }));
      };
      jm = function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M6 9l6 6l6 -6" }));
      };
      Hm = function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" }), j2("path", { d: "M21 21l-6 -6" }));
      };
      Um = function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M18 6l-12 12" }), j2("path", { d: "M6 6l12 12" }));
      };
      Wm = { download: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2" }), j2("path", { d: "M7 11l5 5l5 -5" }), j2("path", { d: "M12 4l0 12" }));
      }, menu: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4 8l16 0" }), j2("path", { d: "M4 16l16 0" }));
      }, fullscreen: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2" }), j2("path", { d: "M4 16v2a2 2 0 0 0 2 2h2" }), j2("path", { d: "M16 4h2a2 2 0 0 1 2 2v2" }), j2("path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2" }));
      }, fullscreenExit: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4 8v-2c0 -.551 .223 -1.05 .584 -1.412" }), j2("path", { d: "M4 16v2a2 2 0 0 0 2 2h2" }), j2("path", { d: "M16 4h2a2 2 0 0 1 2 2v2" }), j2("path", { d: "M16 20h2c.545 0 1.04 -.218 1.4 -.572" }), j2("path", { d: "M3 3l18 18" }));
      }, save: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M6 4h10l4 4v10a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2" }), j2("path", { d: "M12 14m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }), j2("path", { d: "M14 4l0 4l-6 0l0 -4" }));
      }, print: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M17 17h2a2 2 0 0 0 2 -2v-4a2 2 0 0 0 -2 -2h-14a2 2 0 0 0 -2 2v4a2 2 0 0 0 2 2h2" }), j2("path", { d: "M17 9v-4a2 2 0 0 0 -2 -2h-6a2 2 0 0 0 -2 2v4" }), j2("path", { d: "M7 13m0 2a2 2 0 0 1 2 -2h6a2 2 0 0 1 2 2v4a2 2 0 0 1 -2 2h-6a2 2 0 0 1 -2 -2z" }));
      }, settings: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z" }), j2("path", { d: "M9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0" }));
      }, viewSettings: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M12 14m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }), j2("path", { d: "M12 10.5v1.5" }), j2("path", { d: "M12 16v1.5" }), j2("path", { d: "M15.031 12.25l-1.299 .75" }), j2("path", { d: "M10.268 15l-1.3 .75" }), j2("path", { d: "M15 15.803l-1.285 -.773" }), j2("path", { d: "M10.285 12.97l-1.285 -.773" }), j2("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }), j2("path", { d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z" }));
      }, rotateClockwise: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4.05 11a8 8 0 1 1 .5 4m-.5 5v-5h5" }));
      }, rotateCounterClockwise: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M19.95 11a8 8 0 1 0 -.5 4m.5 5v-5h-5" }));
      }, singlePage: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M5 3m0 1a1 1 0 0 1 1 -1h12a1 1 0 0 1 1 1v16a1 1 0 0 1 -1 1h-12a1 1 0 0 1 -1 -1z" }));
      }, doublePage: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M3 3m0 1a1 1 0 0 1 1 -1h16a1 1 0 0 1 1 1v16a1 1 0 0 1 -1 1h-16a1 1 0 0 1 -1 -1zm9 -1v18" }));
      }, zoomIn: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" }), j2("path", { d: "M9 12h6" }), j2("path", { d: "M12 9v6" }));
      }, zoomOut: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }), j2("path", { d: "M9 12l6 0" }));
      }, fitToWidth: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4 12v-6a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v6" }), j2("path", { d: "M10 18h-7" }), j2("path", { d: "M21 18h-7" }), j2("path", { d: "M6 15l-3 3l3 3" }), j2("path", { d: "M18 15l3 3l-3 3" }));
      }, fitToPage: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M12 20h-6a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h6" }), j2("path", { d: "M18 14v7" }), j2("path", { d: "M18 3v7" }), j2("path", { d: "M15 18l3 3l3 -3" }), j2("path", { d: "M15 6l3 -3l3 3" }));
      }, chevronRight: $m, chevronLeft: Fm, chevronDown: jm, search: Hm, comment: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M12 11v.01" }), j2("path", { d: "M8 11v.01" }), j2("path", { d: "M16 11v.01" }), j2("path", { d: "M18 4a3 3 0 0 1 3 3v8a3 3 0 0 1 -3 3h-5l-5 3v-3h-2a3 3 0 0 1 -3 -3v-8a3 3 0 0 1 3 -3z" }));
      }, sidebar: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4 18v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z" }), j2("path", { d: "M14 18v-12a2 2 0 0 0 -2 -2h-6a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h6a2 2 0 0 0 2 -2z" }));
      }, dots: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M5 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" }), j2("path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" }), j2("path", { d: "M19 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" }));
      }, vertical: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M8 7l4 -4l4 4" }), j2("path", { d: "M8 17l4 4l4 -4" }), j2("path", { d: "M12 3l0 18" }));
      }, horizontal: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M7 8l-4 4l4 4" }), j2("path", { d: "M17 8l4 4l-4 4" }), j2("path", { d: "M3 12l18 0" }));
      }, book: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }), j2("path", { d: "M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }), j2("path", { d: "M3 6l0 13" }), j2("path", { d: "M12 6l0 13" }), j2("path", { d: "M21 6l0 13" }));
      }, book2: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M19 4v16h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12z" }), j2("path", { d: "M19 16h-12a2 2 0 0 0 -2 2" }), j2("path", { d: "M9 8h6" }));
      }, squares: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M8 10a2 2 0 0 1 2 -2h9a2 2 0 0 1 2 2v9a2 2 0 0 1 -2 2h-9a2 2 0 0 1 -2 -2z" }), j2("path", { d: "M16 8v-3a2 2 0 0 0 -2 -2h-9a2 2 0 0 0 -2 2v9a2 2 0 0 0 2 2h3" }));
      }, listTree: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M9 6h11" }), j2("path", { d: "M12 12h8" }), j2("path", { d: "M15 18h5" }), j2("path", { d: "M5 6v.01" }), j2("path", { d: "M8 12v.01" }), j2("path", { d: "M11 18v.01" }));
      }, paperclip: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M15 7l-6.5 6.5a1.5 1.5 0 0 0 3 3l6.5 -6.5a3 3 0 0 0 -6 -6l-6.5 6.5a4.5 4.5 0 0 0 9 9l6.5 -6.5" }));
      }, copy: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" }), j2("path", { d: "M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" }));
      }, underline: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor, a3 = void 0 === r2 ? "currentColor" : r2;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4 20h16", stroke: a3 }), j2("path", { d: "M8 16v-8a4 4 0 1 1 8 0v8", stroke: "currentColor" }), j2("path", { d: "M8 10h8", stroke: "currentColor" }));
      }, squiggly: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor, a3 = void 0 === r2 ? "currentColor" : r2;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M8 16v-8a4 4 0 1 1 8 0v8", stroke: "currentColor" }), j2("path", { d: "M8 10h8", stroke: "currentColor" }), j2("path", { d: "M4 20c1.5 -1.5 3.5 -1.5 5 0s3.5 1.5 5 0 3.5 -1.5 5 0", stroke: a3 }));
      }, strikethrough: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor, a3 = void 0 === r2 ? "currentColor" : r2;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M8 16v-8a4 4 0 1 1 8 0v8", stroke: "currentColor" }), j2("path", { d: "M4 10h16", stroke: a3 }));
      }, highlight: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor, a3 = void 0 === r2 ? "currentColor" : r2;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("rect", { x: "2", y: "6", width: "20", height: "16", rx: "2", fill: a3, stroke: "none" }), j2("path", { d: "M8 16v-8a4 4 0 1 1 8 0v8", stroke: "currentColor" }), j2("path", { d: "M8 10h8", stroke: "currentColor" }));
      }, palette: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M12 21a9 9 0 0 1 0 -18c4.97 0 9 3.582 9 8c0 1.06 -.474 2.078 -1.318 2.828c-.844 .75 -1.989 1.172 -3.182 1.172h-2.5a2 2 0 0 0 -1 3.75a1.3 1.3 0 0 1 -1 2.25" }), j2("path", { d: "M8.5 10.5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" }), j2("path", { d: "M12.5 7.5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" }), j2("path", { d: "M16.5 10.5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" }));
      }, x: Um, fileImport: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }), j2("path", { d: "M5 13v-8a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2h-5.5m-9.5 -2h7m-3 -3l3 3l-3 3" }));
      }, hand: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M8 13v-7.5a1.5 1.5 0 0 1 3 0v6.5" }), j2("path", { d: "M11 5.5v-2a1.5 1.5 0 1 1 3 0v8.5" }), j2("path", { d: "M14 5.5a1.5 1.5 0 0 1 3 0v6.5" }), j2("path", { d: "M17 7.5a1.5 1.5 0 0 1 3 0v8.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47" }));
      }, zoomInArea: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M15 13v4" }), j2("path", { d: "M13 15h4" }), j2("path", { d: "M15 15m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0" }), j2("path", { d: "M22 22l-3 -3" }), j2("path", { d: "M6 18h-1a2 2 0 0 1 -2 -2v-1" }), j2("path", { d: "M3 11v-1" }), j2("path", { d: "M3 6v-1a2 2 0 0 1 2 -2h1" }), j2("path", { d: "M10 3h1" }), j2("path", { d: "M15 3h1a2 2 0 0 1 2 2v1" }));
      }, screenshot: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M7 19a2 2 0 0 1 -2 -2" }), j2("path", { d: "M5 13v-2" }), j2("path", { d: "M5 7a2 2 0 0 1 2 -2" }), j2("path", { d: "M11 5h2" }), j2("path", { d: "M17 5a2 2 0 0 1 2 2" }), j2("path", { d: "M19 11v2" }), j2("path", { d: "M19 17v4" }), j2("path", { d: "M21 19h-4" }), j2("path", { d: "M13 19h-2" }));
      }, arrowBackUp: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M9 14l-4 -4l4 -4" }), j2("path", { d: "M5 10h11a4 4 0 1 1 0 8h-1" }));
      }, arrowForwardUp: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M15 14l4 -4l-4 -4" }), j2("path", { d: "M19 10h-11a4 4 0 1 0 0 8h1" }));
      }, trash: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4 7l16 0" }), j2("path", { d: "M10 11l0 6" }), j2("path", { d: "M14 11l0 6" }), j2("path", { d: "M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12" }), j2("path", { d: "M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3" }));
      }, deviceFloppy: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M6 4h10l4 4v10a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2" }), j2("path", { d: "M12 14m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }), j2("path", { d: "M14 4l0 4l-6 0l0 -4" }));
      }, pencilMarker: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor, a3 = void 0 === r2 ? "currentColor" : r2;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", "stroke-linejoin": "round", "stroke-linecap": "round", "stroke-width": i3, class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { d: "m9.109 16.275 8.856-8.097c.812-.743.87-2.014.127-2.826s-2.014-.869-2.826-.127L6.41 13.322l-.127 2.826zM13.79 6.575l2.7 2.952", stroke: "currentColor" }), j2("path", { stroke: a3, d: "M19.375 20.125c.569.063-4.05-.562-6.412-.437s-4.759 1.229-6.857 1.625c-1.764.687-3.404-.938-1.981-2.5" }));
      }, circle: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor, a3 = void 0 === r2 ? "currentColor" : r2, s4 = e3.secondaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: void 0 === s4 ? "none" : s4, stroke: a3, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }));
      }, square: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor, a3 = void 0 === r2 ? "currentColor" : r2, s4 = e3.secondaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: void 0 === s4 ? "none" : s4, stroke: a3, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M3 3m0 2a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" }));
      }, line: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2.2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M20 4l-16 16" }));
      }, lineArrow: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2.2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M20 4l-16 16" }), j2("path", { d: "M16 3h5v5" }));
      }, polygon: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor, a3 = void 0 === r2 ? "currentColor" : r2, s4 = e3.secondaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: void 0 === s4 ? "none" : s4, stroke: a3, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M13.163 2.168l8.021 5.828c.694 .504 .984 1.397 .719 2.212l-3.064 9.43a1.978 1.978 0 0 1 -1.881 1.367h-9.916a1.978 1.978 0 0 1 -1.881 -1.367l-3.064 -9.43a1.978 1.978 0 0 1 .719 -2.212l8.021 -5.828a1.978 1.978 0 0 1 2.326 0z" }));
      }, zigzag: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { d: "M12 2.4L21.36 11.76L2.64 12.24L12 21.6" }));
      }, text: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M6.5 15.5m-3.5 0a3.5 3.5 0 1 0 7 0a3.5 3.5 0 1 0 -7 0" }), j2("path", { d: "M14 19v-10.5a3.5 3.5 0 0 1 7 0v10.5" }), j2("path", { d: "M14 13h7" }), j2("path", { d: "M10 12v7" }));
      }, italic: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M11 5l6 0" }), j2("path", { d: "M7 19l6 0" }), j2("path", { d: "M14 5l-4 14" }));
      }, bold: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M7 5h6a3.5 3.5 0 0 1 0 7h-6z" }), j2("path", { d: "M13 12h1a3.5 3.5 0 0 1 0 7h-7v-7" }));
      }, alignLeft: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4 6l16 0" }), j2("path", { d: "M4 12l10 0" }), j2("path", { d: "M4 18l14 0" }));
      }, alignCenter: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4 6l16 0" }), j2("path", { d: "M8 12l8 0" }), j2("path", { d: "M6 18l12 0" }));
      }, alignRight: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M4 6l16 0" }), j2("path", { d: "M10 12l10 0" }), j2("path", { d: "M6 18l14 0" }));
      }, alignTop: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M3 19v-14a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" }), j2("path", { d: "M11 13h2" }), j2("path", { d: "M9 10h6" }), j2("path", { d: "M10 7h4" }));
      }, alignMiddle: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M3 19v-14a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" }), j2("path", { d: "M11 15h2" }), j2("path", { d: "M9 12h6" }), j2("path", { d: "M10 9h4" }));
      }, alignBottom: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M3 19v-14a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" }), j2("path", { d: "M11 17h2" }), j2("path", { d: "M9 14h6" }), j2("path", { d: "M10 11h4" }));
      }, photo: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M15 8h.01" }), j2("path", { d: "M3 6a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v12a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3v-12z" }), j2("path", { d: "M3 16l5 -5c.928 -.893 2.072 -.893 3 0l5 5" }), j2("path", { d: "M14 14l1 -1c.928 -.893 2.072 -.893 3 0l3 3" }));
      }, pointer: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M7.904 17.563a1.2 1.2 0 0 0 2.228 .308l2.09 -3.093l4.907 4.907a1.067 1.067 0 0 0 1.509 0l1.047 -1.047a1.067 1.067 0 0 0 0 -1.509l-4.907 -4.907l3.113 -2.09a1.2 1.2 0 0 0 -.309 -2.228l-13.582 -3.904l3.904 13.563z" }));
      }, redact: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M7 4h10" }), j2("path", { d: "M12 4v8" }), j2("defs", null, j2("clipPath", { id: "stripeClip" }, j2("rect", { x: "2", y: "12", width: "20", height: "10", rx: "2" }))), j2("rect", { x: "2", y: "12", width: "20", height: "10", rx: "2", fill: "none" }), j2("g", { "clip-path": "url(#stripeClip)" }, j2("path", { d: "M-7 24l12 -12" }), j2("path", { d: "M-3 24l12 -12" }), j2("path", { d: "M1 24l12 -12" }), j2("path", { d: "M5 24l12 -12" }), j2("path", { d: "M9 24l12 -12" }), j2("path", { d: "M13 24l12 -12" }), j2("path", { d: "M17 24l12 -12" }), j2("path", { d: "M21 24l12 -12" }), j2("path", { d: "M25 24l12 -12" })));
      }, redactArea: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M6 20h-1a2 2 0 0 1 -2 -2v-1" }), j2("path", { d: "M3 13v-3" }), j2("path", { d: "M3 6v-1a2 2 0 0 1 2 -2h1" }), j2("path", { d: "M10 3h3" }), j2("path", { d: "M17 3h1a2 2 0 0 1 2 2v1" }), j2("defs", null, j2("clipPath", { id: "redactClip" }, j2("rect", { x: "10", y: "10", width: "12", height: "12", rx: "2" }))), j2("rect", { x: "10", y: "10", width: "12", height: "12", rx: "2", fill: "none" }), j2("g", { "clip-path": "url(#redactClip)" }, j2("path", { d: "M-2 24l14 -14" }), j2("path", { d: "M2 24l14 -14" }), j2("path", { d: "M6 24l14 -14" }), j2("path", { d: "M10 24l15 -15" }), j2("path", { d: "M14 24l15 -15" }), j2("path", { d: "M18 24l15 -15" })));
      }, check: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor;
        return j2("svg", { width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: void 0 === r2 ? "currentColor" : r2, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: e3.className, role: "img", "aria-label": e3.title }, j2("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), j2("path", { d: "M5 12l5 5l10 -10" }));
      }, file: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor, a3 = void 0 === r2 ? "currentColor" : r2, s4 = e3.className, l4 = e3.title;
        return j2("svg", { xmlns: "http://www.w3.org/2000/svg", width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: a3, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: s4, "aria-hidden": !l4, role: l4 ? "img" : "presentation" }, l4 && j2("title", null, l4), j2("path", { d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" }), j2("polyline", { points: "14 2 14 8 20 8" }));
      }, plus: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.strokeWidth, i3 = void 0 === o3 ? 2 : o3, r2 = e3.primaryColor, a3 = void 0 === r2 ? "currentColor" : r2, s4 = e3.className, l4 = e3.title;
        return j2("svg", { xmlns: "http://www.w3.org/2000/svg", width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: a3, "stroke-width": i3, "stroke-linecap": "round", "stroke-linejoin": "round", class: s4, "aria-hidden": !l4, role: l4 ? "img" : "presentation" }, l4 && j2("title", null, l4), j2("line", { x1: "12", y1: "5", x2: "12", y2: "19" }), j2("line", { x1: "5", y1: "12", x2: "19", y2: "12" }));
      }, lock: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.className;
        return j2("svg", { xmlns: "http://www.w3.org/2000/svg", width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: void 0 === o3 ? "" : o3, style: e3.style }, j2("rect", { x: "3", y: "11", width: "18", height: "11", rx: "2", ry: "2" }), j2("path", { d: "M7 11V7a5 5 0 0 1 10 0v4" }));
      }, alertTriangle: function(e3) {
        var t2 = e3.size, n3 = void 0 === t2 ? 24 : t2, o3 = e3.className;
        return j2("svg", { xmlns: "http://www.w3.org/2000/svg", width: n3, height: n3, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: void 0 === o3 ? "" : o3, style: e3.style }, j2("path", { d: "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z" }), j2("line", { x1: "12", y1: "9", x2: "12", y2: "13" }), j2("line", { x1: "12", y1: "17", x2: "12.01", y2: "17" }));
      } };
      Bm = /* @__PURE__ */ new Map();
      qm = /^[MmZzLlHhVvCcSsQqTtAa0-9\s,.\-eE]+$/;
      Xm = ["id", "children", "onClick", "active", "disabled", "className", "tooltip", "elementRef"];
      Jm = Math.min;
      eg = Math.max;
      tg = Math.round;
      ng = Math.floor;
      og = (e3) => ({ x: e3, y: e3 });
      ig = { left: "right", right: "left", bottom: "top", top: "bottom" };
      rg = { start: "end", end: "start" };
      hg = /* @__PURE__ */ new Set(["top", "bottom"]);
      vg = ["left", "right"];
      fg = ["right", "left"];
      yg = ["top", "bottom"];
      bg = ["bottom", "top"];
      Dg = /* @__PURE__ */ new Set(["left", "top"]);
      Ng = /* @__PURE__ */ new Set(["inline", "contents"]);
      Lg = /* @__PURE__ */ new Set(["table", "td", "th"]);
      Fg = [":popover-open", ":modal"];
      Hg = ["transform", "translate", "scale", "rotate", "perspective"];
      Ug = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
      Wg = ["paint", "layout", "strict", "content"];
      Gg = /* @__PURE__ */ new Set(["html", "body", "#document"]);
      op = og(0);
      lp = /* @__PURE__ */ new Set(["absolute", "fixed"]);
      pp = { convertOffsetParentRelativeRectToViewportRelativeRect: function(e3) {
        let { elements: t2, rect: n3, offsetParent: o3, strategy: i3 } = e3;
        const r2 = "fixed" === i3, a3 = Tg(o3), s4 = !!t2 && jg(t2.floating);
        if (o3 === a3 || s4 && r2) return n3;
        let l4 = { scrollLeft: 0, scrollTop: 0 }, c4 = og(1);
        const d4 = og(0), u4 = _g(o3);
        if ((u4 || !u4 && !r2) && (("body" !== Pg(o3) || Og(a3)) && (l4 = Kg(o3)), _g(o3))) {
          const e4 = rp(o3);
          c4 = np(o3), d4.x = e4.x + o3.clientLeft, d4.y = e4.y + o3.clientTop;
        }
        const h3 = !a3 || u4 || r2 ? og(0) : sp(a3, l4);
        return { width: n3.width * c4.x, height: n3.height * c4.y, x: n3.x * c4.x - l4.scrollLeft * c4.x + d4.x + h3.x, y: n3.y * c4.y - l4.scrollTop * c4.y + d4.y + h3.y };
      }, getDocumentElement: Tg, getClippingRect: function(e3) {
        let { element: t2, boundary: n3, rootBoundary: o3, strategy: i3 } = e3;
        const r2 = [..."clippingAncestors" === n3 ? jg(t2) ? [] : (function(e4, t3) {
          const n4 = t3.get(e4);
          if (n4) return n4;
          let o4 = Qg(e4, [], false).filter((e5) => Eg(e5) && "body" !== Pg(e5)), i4 = null;
          const r3 = "fixed" === Zg(e4).position;
          let a4 = r3 ? Yg(e4) : e4;
          for (; Eg(a4) && !Vg(a4); ) {
            const t4 = Zg(a4), n5 = Bg(a4);
            n5 || "fixed" !== t4.position || (i4 = null), (r3 ? !n5 && !i4 : !n5 && "static" === t4.position && i4 && lp.has(i4.position) || Og(a4) && !n5 && dp(e4, a4)) ? o4 = o4.filter((e5) => e5 !== a4) : i4 = t4, a4 = Yg(a4);
          }
          return t3.set(e4, o4), o4;
        })(t2, this._c) : [].concat(n3), o3], a3 = r2[0], s4 = r2.reduce((e4, n4) => {
          const o4 = cp(t2, n4, i3);
          return e4.top = eg(o4.top, e4.top), e4.right = Jm(o4.right, e4.right), e4.bottom = Jm(o4.bottom, e4.bottom), e4.left = eg(o4.left, e4.left), e4;
        }, cp(t2, a3, i3));
        return { width: s4.right - s4.left, height: s4.bottom - s4.top, x: s4.left, y: s4.top };
      }, getOffsetParent: gp, getElementRects: async function(e3) {
        const t2 = this.getOffsetParent || gp, n3 = this.getDimensions, o3 = await n3(e3.floating);
        return { reference: up(e3.reference, await t2(e3.floating), e3.strategy), floating: { x: 0, y: 0, width: o3.width, height: o3.height } };
      }, getClientRects: function(e3) {
        return Array.from(e3.getClientRects());
      }, getDimensions: function(e3) {
        const { width: t2, height: n3 } = ep(e3);
        return { width: t2, height: n3 };
      }, getScale: np, isElement: Eg, isRTL: function(e3) {
        return "rtl" === Zg(e3).direction;
      } };
      yp = function(e3) {
        return void 0 === e3 && (e3 = 0), { name: "offset", options: e3, async fn(t2) {
          var n3, o3;
          const { x: i3, y: r2, placement: a3, middlewareData: s4 } = t2, l4 = await (async function(e4, t3) {
            const { placement: n4, platform: o4, elements: i4 } = e4, r3 = await (null == o4.isRTL ? void 0 : o4.isRTL(i4.floating)), a4 = lg(n4), s5 = cg(n4), l5 = "y" === mg(n4), c4 = Dg.has(a4) ? -1 : 1, d4 = r3 && l5 ? -1 : 1, u4 = sg(t3, e4);
            let { mainAxis: h3, crossAxis: m3, alignmentAxis: g3 } = "number" == typeof u4 ? { mainAxis: u4, crossAxis: 0, alignmentAxis: null } : { mainAxis: u4.mainAxis || 0, crossAxis: u4.crossAxis || 0, alignmentAxis: u4.alignmentAxis };
            return s5 && "number" == typeof g3 && (m3 = "end" === s5 ? -1 * g3 : g3), l5 ? { x: m3 * d4, y: h3 * c4 } : { x: h3 * c4, y: m3 * d4 };
          })(t2, e3);
          return a3 === (null == (n3 = s4.offset) ? void 0 : n3.placement) && null != (o3 = s4.arrow) && o3.alignmentOffset ? {} : { x: i3 + l4.x, y: r2 + l4.y, data: { ...l4, placement: a3 } };
        } };
      };
      bp = function(e3) {
        return void 0 === e3 && (e3 = {}), { name: "shift", options: e3, async fn(t2) {
          const { x: n3, y: o3, placement: i3 } = t2, { mainAxis: r2 = true, crossAxis: a3 = false, limiter: s4 = { fn: (e4) => {
            let { x: t3, y: n4 } = e4;
            return { x: t3, y: n4 };
          } }, ...l4 } = sg(e3, t2), c4 = { x: n3, y: o3 }, d4 = await kg(t2, l4), u4 = mg(lg(i3)), h3 = dg(u4);
          let m3 = c4[h3], g3 = c4[u4];
          if (r2) {
            const e4 = "y" === h3 ? "bottom" : "right";
            m3 = ag(m3 + d4["y" === h3 ? "top" : "left"], m3, m3 - d4[e4]);
          }
          if (a3) {
            const e4 = "y" === u4 ? "bottom" : "right";
            g3 = ag(g3 + d4["y" === u4 ? "top" : "left"], g3, g3 - d4[e4]);
          }
          const p4 = s4.fn({ ...t2, [h3]: m3, [u4]: g3 });
          return { ...p4, data: { x: p4.x - n3, y: p4.y - o3, enabled: { [h3]: r2, [u4]: a3 } } };
        } };
      };
      wp = function(e3) {
        return void 0 === e3 && (e3 = {}), { name: "flip", options: e3, async fn(t2) {
          var n3, o3;
          const { placement: i3, middlewareData: r2, rects: a3, initialPlacement: s4, platform: l4, elements: c4 } = t2, { mainAxis: d4 = true, crossAxis: u4 = true, fallbackPlacements: h3, fallbackStrategy: m3 = "bestFit", fallbackAxisSideDirection: g3 = "none", flipAlignment: p4 = true, ...v2 } = sg(e3, t2);
          if (null != (n3 = r2.arrow) && n3.alignmentOffset) return {};
          const f2 = lg(i3), y2 = mg(s4), b2 = lg(s4) === s4, w2 = await (null == l4.isRTL ? void 0 : l4.isRTL(c4.floating)), x2 = h3 || (b2 || !p4 ? [xg(s4)] : (function(e4) {
            const t3 = xg(e4);
            return [pg(e4), t3, pg(t3)];
          })(s4)), C2 = "none" !== g3;
          !h3 && C2 && x2.push(...wg(s4, p4, g3, w2));
          const I2 = [s4, ...x2], S2 = await kg(t2, v2), k2 = [];
          let D2 = (null == (o3 = r2.flip) ? void 0 : o3.overflows) || [];
          if (d4 && k2.push(S2[f2]), u4) {
            const e4 = (function(e5, t3, n4) {
              void 0 === n4 && (n4 = false);
              const o4 = cg(e5), i4 = gg(e5), r3 = ug(i4);
              let a4 = "x" === i4 ? o4 === (n4 ? "end" : "start") ? "right" : "left" : "start" === o4 ? "bottom" : "top";
              return t3.reference[r3] > t3.floating[r3] && (a4 = xg(a4)), [a4, xg(a4)];
            })(i3, a3, w2);
            k2.push(S2[e4[0]], S2[e4[1]]);
          }
          if (D2 = [...D2, { placement: i3, overflows: k2 }], !k2.every((e4) => e4 <= 0)) {
            var M2, P2;
            const e4 = ((null == (M2 = r2.flip) ? void 0 : M2.index) || 0) + 1, t3 = I2[e4];
            if (t3) {
              if (!("alignment" === u4 && y2 !== mg(t3)) || D2.every((e5) => mg(e5.placement) !== y2 || e5.overflows[0] > 0)) return { data: { index: e4, overflows: D2 }, reset: { placement: t3 } };
            }
            let n4 = null == (P2 = D2.filter((e5) => e5.overflows[0] <= 0).sort((e5, t4) => e5.overflows[1] - t4.overflows[1])[0]) ? void 0 : P2.placement;
            if (!n4) switch (m3) {
              case "bestFit": {
                var A2;
                const e5 = null == (A2 = D2.filter((e6) => {
                  if (C2) {
                    const t4 = mg(e6.placement);
                    return t4 === y2 || "y" === t4;
                  }
                  return true;
                }).map((e6) => [e6.placement, e6.overflows.filter((e7) => e7 > 0).reduce((e7, t4) => e7 + t4, 0)]).sort((e6, t4) => e6[1] - t4[1])[0]) ? void 0 : A2[0];
                e5 && (n4 = e5);
                break;
              }
              case "initialPlacement":
                n4 = s4;
            }
            if (i3 !== n4) return { reset: { placement: n4 } };
          }
          return {};
        } };
      };
      xp = (e3) => ({ name: "arrow", options: e3, async fn(t2) {
        const { x: n3, y: o3, placement: i3, rects: r2, platform: a3, elements: s4, middlewareData: l4 } = t2, { element: c4, padding: d4 = 0 } = sg(e3, t2) || {};
        if (null == c4) return {};
        const u4 = Cg(d4), h3 = { x: n3, y: o3 }, m3 = gg(i3), g3 = ug(m3), p4 = await a3.getDimensions(c4), v2 = "y" === m3, f2 = v2 ? "top" : "left", y2 = v2 ? "bottom" : "right", b2 = v2 ? "clientHeight" : "clientWidth", w2 = r2.reference[g3] + r2.reference[m3] - h3[m3] - r2.floating[g3], x2 = h3[m3] - r2.reference[m3], C2 = await (null == a3.getOffsetParent ? void 0 : a3.getOffsetParent(c4));
        let I2 = C2 ? C2[b2] : 0;
        I2 && await (null == a3.isElement ? void 0 : a3.isElement(C2)) || (I2 = s4.floating[b2] || r2.floating[g3]);
        const S2 = w2 / 2 - x2 / 2, k2 = I2 / 2 - p4[g3] / 2 - 1, D2 = Jm(u4[f2], k2), M2 = Jm(u4[y2], k2), P2 = D2, A2 = I2 - p4[g3] - M2, T2 = I2 / 2 - p4[g3] / 2 + S2, z3 = ag(P2, T2, A2), E2 = !l4.arrow && null != cg(i3) && T2 !== z3 && r2.reference[g3] / 2 - (T2 < P2 ? D2 : M2) - p4[g3] / 2 < 0, _2 = E2 ? T2 < P2 ? T2 - P2 : T2 - A2 : 0;
        return { [m3]: h3[m3] + _2, data: { [m3]: z3, centerOffset: T2 - z3 - _2, ...E2 && { alignmentOffset: _2 } }, reset: E2 };
      } });
      Cp = (e3, t2, n3) => {
        const o3 = /* @__PURE__ */ new Map(), i3 = { platform: pp, ...n3 }, r2 = { ...i3.platform, _c: o3 };
        return (async (e4, t3, n4) => {
          const { placement: o4 = "bottom", strategy: i4 = "absolute", middleware: r3 = [], platform: a3 } = n4, s4 = r3.filter(Boolean), l4 = await (null == a3.isRTL ? void 0 : a3.isRTL(t3));
          let c4 = await a3.getElementRects({ reference: e4, floating: t3, strategy: i4 }), { x: d4, y: u4 } = Sg(c4, o4, l4), h3 = o4, m3 = {}, g3 = 0;
          for (let n5 = 0; n5 < s4.length; n5++) {
            const { name: r4, fn: p4 } = s4[n5], { x: v2, y: f2, data: y2, reset: b2 } = await p4({ x: d4, y: u4, initialPlacement: o4, placement: h3, strategy: i4, middlewareData: m3, rects: c4, platform: a3, elements: { reference: e4, floating: t3 } });
            d4 = null != v2 ? v2 : d4, u4 = null != f2 ? f2 : u4, m3 = { ...m3, [r4]: { ...m3[r4], ...y2 } }, b2 && g3 <= 50 && (g3++, "object" == typeof b2 && (b2.placement && (h3 = b2.placement), b2.rects && (c4 = true === b2.rects ? await a3.getElementRects({ reference: e4, floating: t3, strategy: i4 }) : b2.rects), { x: d4, y: u4 } = Sg(c4, h3, l4)), n5 = -1);
          }
          return { x: d4, y: u4, placement: h3, strategy: i4, middlewareData: m3 };
        })(e3, t2, { ...i3, platform: r2 });
      };
      Ip = (function() {
        function e3() {
          return i2(this, e3), o2(this, e3, arguments);
        }
        return c3(e3, W2), r(e3, [{ key: "render", value: function() {
          return this.props.children;
        } }]);
      })();
      (Lp.prototype = new W2()).isPureReactComponent = true, Lp.prototype.shouldComponentUpdate = function(e3, t2) {
        return Op(this.props, e3) || Op(this.state, t2);
      };
      $p = I.__b;
      I.__b = function(e3) {
        e3.type && e3.type.__f && e3.ref && (e3.props.ref = e3.ref, e3.ref = null), $p && $p(e3);
      };
      Fp = I.__e;
      I.__e = function(e3, t2, n3, o3) {
        if (e3.then) {
          for (var i3, r2 = t2; r2 = r2.__; ) if ((i3 = r2.__c) && i3.__c) return null == t2.__e && (t2.__e = n3.__e, t2.__k = n3.__k), i3.__c(e3, t2);
        }
        Fp(e3, t2, n3, o3);
      };
      jp = I.unmount;
      I.unmount = function(e3) {
        var t2 = e3.__c;
        t2 && t2.__R && t2.__R(), t2 && 32 & e3.__u && (e3.type = null), jp && jp(e3);
      }, (Wp.prototype = new W2()).__c = function(e3, t2) {
        var n3 = t2.__c, o3 = this;
        null == o3.o && (o3.o = []), o3.o.push(n3);
        var i3 = Bp(o3.__v), r2 = false, a3 = function() {
          r2 || (r2 = true, n3.__R = null, i3 ? i3(s4) : s4());
        };
        n3.__R = a3;
        var s4 = function() {
          if (!--o3.__u) {
            if (o3.state.__a) {
              var e4 = o3.state.__a;
              o3.__v.__k[0] = Up(e4, e4.__c.__P, e4.__c.__O);
            }
            var t3;
            for (o3.setState({ __a: o3.__b = null }); t3 = o3.o.pop(); ) t3.forceUpdate();
          }
        };
        o3.__u++ || 32 & t2.__u || o3.setState({ __a: o3.__b = o3.__v.__k[0] }), e3.then(a3, a3);
      }, Wp.prototype.componentWillUnmount = function() {
        this.o = [];
      }, Wp.prototype.render = function(e3, t2) {
        if (this.__b) {
          if (this.__v.__k) {
            var n3 = document.createElement("div"), o3 = this.__v.__k[0].__c;
            this.__v.__k[0] = Hp(this.__b, n3, o3.__O = o3.__P);
          }
          this.__b = null;
        }
        var i3 = t2.__a && j2(U2, null, e3.fallback);
        return i3 && (i3.__u &= -33), [j2(U2, null, t2.__a ? null : e3.children), i3];
      };
      Gp = function(e3, t2, n3) {
        if (++n3[1] === n3[0] && e3.l.delete(t2), e3.props.revealOrder && ("t" !== e3.props.revealOrder[0] || !e3.l.size)) for (n3 = e3.i; n3; ) {
          for (; n3.length > 3; ) n3.pop()();
          if (n3[1] < n3[0]) break;
          e3.i = n3 = n3[2];
        }
      };
      (qp.prototype = new W2()).__a = function(e3) {
        var t2 = this, n3 = Bp(t2.__v), o3 = t2.l.get(e3);
        return o3[0]++, function(i3) {
          var r2 = function() {
            t2.props.revealOrder ? (o3.push(i3), Gp(t2, e3, o3)) : i3();
          };
          n3 ? n3(r2) : r2();
        };
      }, qp.prototype.render = function(e3) {
        this.i = null, this.l = /* @__PURE__ */ new Map();
        var t2 = Y2(e3.children);
        e3.revealOrder && "b" === e3.revealOrder[0] && t2.reverse();
        for (var n3 = t2.length; n3--; ) this.l.set(t2[n3], this.i = [1, 0, this.i]);
        return e3.children;
      }, qp.prototype.componentDidUpdate = qp.prototype.componentDidMount = function() {
        var e3 = this;
        this.l.forEach(function(t2, n3) {
          Gp(e3, n3, t2);
        });
      };
      Yp = "undefined" != typeof Symbol && Symbol.for && /* @__PURE__ */ Symbol.for("react.element") || 60103;
      Xp = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
      Qp = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;
      Jp = /[A-Z0-9]/g;
      ev = "undefined" != typeof document;
      tv = function(e3) {
        return ("undefined" != typeof Symbol && "symbol" == typeof /* @__PURE__ */ Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(e3);
      };
      W2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(e3) {
        Object.defineProperty(W2.prototype, e3, { configurable: true, get: function() {
          return this["UNSAFE_" + e3];
        }, set: function(t2) {
          Object.defineProperty(this, e3, { configurable: true, writable: true, value: t2 });
        } });
      });
      nv = I.event;
      I.event = function(e3) {
        return nv && (e3 = nv(e3)), e3.persist = ov, e3.isPropagationStopped = iv, e3.isDefaultPrevented = rv, e3.nativeEvent = e3;
      };
      av = { enumerable: false, configurable: true, get: function() {
        return this.class;
      } };
      sv = I.vnode;
      I.vnode = function(e3) {
        "string" == typeof e3.type && (function(e4) {
          var t2 = e4.props, n3 = e4.type, o3 = {}, i3 = -1 === n3.indexOf("-");
          for (var r2 in t2) {
            var a3 = t2[r2];
            if (!("value" === r2 && "defaultValue" in t2 && null == a3 || ev && "children" === r2 && "noscript" === n3 || "class" === r2 || "className" === r2)) {
              var s4 = r2.toLowerCase();
              "defaultValue" === r2 && "value" in t2 && null == t2.value ? r2 = "value" : "download" === r2 && true === a3 ? a3 = "" : "translate" === s4 && "no" === a3 ? a3 = false : "o" === s4[0] && "n" === s4[1] ? "ondoubleclick" === s4 ? r2 = "ondblclick" : "onchange" !== s4 || "input" !== n3 && "textarea" !== n3 || tv(t2.type) ? "onfocus" === s4 ? r2 = "onfocusin" : "onblur" === s4 ? r2 = "onfocusout" : Qp.test(r2) && (r2 = s4) : s4 = r2 = "oninput" : i3 && Xp.test(r2) ? r2 = r2.replace(Jp, "-$&").toLowerCase() : null === a3 && (a3 = void 0), "oninput" === s4 && o3[r2 = s4] && (r2 = "oninputCapture"), o3[r2] = a3;
            }
          }
          "select" == n3 && o3.multiple && Array.isArray(o3.value) && (o3.value = Y2(t2.children).forEach(function(e5) {
            e5.props.selected = -1 != o3.value.indexOf(e5.props.value);
          })), "select" == n3 && null != o3.defaultValue && (o3.value = Y2(t2.children).forEach(function(e5) {
            e5.props.selected = o3.multiple ? -1 != o3.defaultValue.indexOf(e5.props.value) : o3.defaultValue == e5.props.value;
          })), t2.class && !t2.className ? (o3.class = t2.class, Object.defineProperty(o3, "className", av)) : (t2.className && !t2.class || t2.class && t2.className) && (o3.class = o3.className = t2.className), e4.props = o3;
        })(e3), e3.$$typeof = Yp, sv && sv(e3);
      };
      lv = I.__r;
      I.__r = function(e3) {
        lv && lv(e3), e3.__c;
      };
      cv = I.diffed;
      I.diffed = function(e3) {
        cv && cv(e3);
        var t2 = e3.props, n3 = e3.__e;
        null != n3 && "textarea" === e3.type && "value" in t2 && t2.value !== n3.value && (n3.value = null == t2.value ? "" : t2.value);
      };
      Iv = function(e3) {
        var t2 = e3.label, n3 = e3.checked, o3 = e3.onChange;
        return j2("label", { className: "text-fg-secondary inline-flex cursor-pointer select-none items-center gap-2 text-xs font-medium" }, j2("input", { type: "checkbox", checked: n3, onChange: function(e4) {
          return o3(e4.target.checked);
        }, className: "border-border-default bg-bg-input checked:border-accent checked:bg-accent peer h-4 w-4 shrink-0 appearance-none rounded-[3px] border transition-all" }), j2("svg", { viewBox: "0 0 24 24", className: "/* fine-tune centering */ text-fg-on-accent pointer-events-none absolute h-3.5 w-3.5 translate-x-[1px] translate-y-[1px] opacity-0 peer-checked:opacity-100", fill: "none", stroke: "currentColor", strokeWidth: 3, strokeLinecap: "round", strokeLinejoin: "round" }, j2("polyline", { points: "20 6 9 17 4 12" })), t2);
      };
      Sv = function(e3) {
        var t2 = e3.hit, n3 = e3.onClick, o3 = e3.active, i3 = Ae(null);
        return Me(function() {
          o3 && i3.current && i3.current.scrollIntoView({ behavior: "smooth", block: "nearest" });
        }, [o3]), j2("button", { ref: i3, onClick: n3, className: "w-full rounded border p-2 text-left text-sm transition-colors ".concat(o3 ? "border-accent bg-accent-light text-fg-primary" : "border-border-subtle bg-bg-surface text-fg-secondary hover:bg-interactive-hover") }, j2("span", null, t2.context.truncatedLeft && "\u2026 ", t2.context.before, j2("span", { className: "text-accent font-bold" }, t2.context.match), t2.context.after, t2.context.truncatedRight && " \u2026"));
      };
      Tv = function() {
        var e3 = (function(e4) {
          const { provides: t3 } = yd(), [n4, o4] = ke(pd);
          return Me(() => {
            if (t3) return t3.forDocument(e4).onStateChange((e5) => {
              o4(e5);
            });
          }, [t3]), { provides: (null == t3 ? void 0 : t3.forDocument(e4)) ?? null, state: n4 };
        })().provides, t2 = f(ke({ show: false, mode: null, isAnimating: false }), 2), n3 = t2[0], o3 = t2[1];
        Me(function() {
          if (e3) return e3.onModeChange(function(e4) {
            var t3 = e4.activeMode;
            if ("marqueeZoom" === t3 || "marqueeCapture" === t3) {
              o3({ show: true, mode: t3, isAnimating: true });
              var n4 = setTimeout(function() {
                o3(function(e5) {
                  return h2(h2({}, e5), {}, { show: false });
                });
              }, 3e3);
              return function() {
                return clearTimeout(n4);
              };
            }
            o3({ show: false, mode: null, isAnimating: false });
          });
        }, [e3]);
        if (!n3.show && !n3.isAnimating) return null;
        var i3 = "marqueeZoom" === n3.mode ? "Drag to select area to zoom" : "Drag to select area to capture", r2 = "marqueeZoom" === n3.mode ? "rgba(33,150,243,0.8)" : "rgba(76,175,80,0.8)";
        return j2("div", { className: "hint-overlay ".concat(n3.show ? "hint-show" : "hint-hide"), onAnimationEnd: function() {
          n3.show || o3(function(e4) {
            return h2(h2({}, e4), {}, { isAnimating: false, mode: null });
          });
        }, style: { position: "absolute", top: 0, left: 0, right: 0, bottom: 0, pointerEvents: "none", zIndex: 1e3, display: "flex", alignItems: "center", justifyContent: "center", flexDirection: "column", gap: "20px" } }, j2("div", { className: "hint-text", style: { background: "rgba(0, 0, 0, 0.8)", color: "white", padding: "12px 20px", borderRadius: "8px", fontSize: "14px", fontWeight: "500", textAlign: "center", maxWidth: "250px" } }, i3), j2("div", { className: "drag-demo", style: { position: "relative", width: "150px", height: "100px" } }, j2("div", { style: { position: "absolute", top: "20px", left: "20px", width: "110px", height: "60px", border: "2px dashed ".concat(r2), borderRadius: "4px", opacity: 0.6 } }), j2("div", { className: "animated-rect", style: { position: "absolute", top: "20px", left: "20px", border: "2px solid ".concat(r2), backgroundColor: "".concat(r2.replace("0.8", "0.15")), borderRadius: "4px" } }), j2("div", { className: "cursor-demo", style: { position: "absolute", width: "20px", height: "20px" } }, j2("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, j2("path", { d: "M3.5 2.5L16.5 10L10 11.5L7.5 16.5L3.5 2.5Z", fill: "rgba(0,0,0,0.3)", transform: "translate(1,1)" }), j2("path", { d: "M3 2L16 10L10 11.5L7.5 16L3 2Z", fill: "white", stroke: "black", strokeWidth: "1" }), j2("path", { d: "M4 3.5L13.5 9.5L9.5 10.5L7.5 14L4 3.5Z", fill: "rgba(255,255,255,0.8)" })))), j2("style", { jsx: true }, "\n        .hint-overlay {\n          animation-duration: 0.3s;\n          animation-fill-mode: both;\n        }\n\n        .hint-show {\n          animation-name: hintFadeIn;\n        }\n\n        .hint-hide {\n          animation-name: hintFadeOut;\n        }\n\n        @keyframes hintFadeIn {\n          from {\n            opacity: 0;\n            transform: translateY(10px);\n          }\n          to {\n            opacity: 1;\n            transform: translateY(0);\n          }\n        }\n\n        @keyframes hintFadeOut {\n          from {\n            opacity: 1;\n            transform: translateY(0);\n          }\n          to {\n            opacity: 0;\n            transform: translateY(-10px);\n          }\n        }\n\n        .animated-rect {\n          animation: rectGrow 2s ease-in-out infinite;\n        }\n\n        @keyframes rectGrow {\n          0% {\n            width: 0;\n            height: 0;\n          }\n          50% {\n            width: 110px;\n            height: 60px;\n          }\n          100% {\n            width: 110px;\n            height: 60px;\n            opacity: 0.7;\n          }\n        }\n\n        .cursor-demo {\n          animation: cursorMove 2s ease-in-out infinite;\n        }\n\n        @keyframes cursorMove {\n          0% {\n            top: 20px;\n            left: 20px;\n          }\n          50% {\n            top: 50px;\n            left: 80px;\n          }\n          100% {\n            top: 80px;\n            left: 130px;\n          }\n        }\n\n        .hint-text {\n          animation: textPulse 0.6s ease-in-out;\n        }\n\n        @keyframes textPulse {\n          0% {\n            transform: scale(0.9);\n          }\n          50% {\n            transform: scale(1.05);\n          }\n          100% {\n            transform: scale(1);\n          }\n        }\n      "));
      };
      zv = function(e3) {
        var t2 = e3.placeholder, n3 = e3.onSubmit, o3 = e3.inputRef, i3 = e3.isFocused, r2 = f(ke(""), 2), a3 = r2[0], s4 = r2[1];
        return j2("form", { className: "border-border-subtle mt-4 flex items-end space-x-2 border-t pt-4", onClick: function(e4) {
          return e4.stopPropagation();
        }, onSubmit: function(e4) {
          null == e4 || e4.preventDefault(), a3.trim() && (n3(a3), s4(""));
        } }, j2("input", { ref: o3, type: "text", placeholder: t2, value: a3, onInput: function(e4) {
          return s4(e4.currentTarget.value);
        }, className: "bg-bg-input text-fg-primary placeholder-fg-muted w-full rounded-lg border px-3 py-1 text-base transition-colors focus:border-transparent focus:outline-none focus:ring-2 ".concat(i3 ? "border-accent focus:ring-accent" : "border-border-default focus:ring-accent") }), j2("button", { type: "submit", disabled: !a3.trim(), className: "bg-accent text-fg-on-accent hover:bg-accent-hover disabled:bg-interactive-disabled rounded-lg p-2 transition-colors disabled:cursor-not-allowed" }, j2("svg", { className: "h-5 w-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" }, j2("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 19l9 2-9-18-9 18 9-2zm0 0v-8" }))));
      };
      Ev = ["bg-red-500", "bg-blue-500", "bg-green-500", "bg-yellow-500", "bg-purple-500", "bg-pink-500", "bg-indigo-500", "bg-teal-500"];
      _v = function(e3) {
        if (!e3) return Ev[0];
        var t2 = e3.length > 0 ? e3.charCodeAt(0) % Ev.length : 0;
        return Ev[t2];
      };
      Rv = function(e3) {
        var t2 = e3.name, n3 = e3.className, o3 = void 0 === n3 ? "" : n3;
        return j2("div", { className: "flex h-8 w-8 items-center justify-center rounded-full text-sm font-medium text-white ".concat(_v(t2), " ").concat(o3) }, (function(e4) {
          return e4 ? e4.split(" ").map(function(e5) {
            return e5[0];
          }).join("").toUpperCase().slice(0, 2) : "G";
        })(t2));
      };
      Nv = function(e3) {
        var t2, n3, o3 = e3.onEdit, i3 = e3.onDelete, r2 = e3.onClose, a3 = e3.documentId, s4 = Ae(null), l4 = ma(a3).translate;
        Me(function() {
          var e4 = function(e5) {
            t2.current && !t2.current.contains(e5.target) && n3();
          };
          return document.addEventListener("click", e4), function() {
            document.removeEventListener("click", e4);
          };
        }, [t2 = s4, n3 = r2]);
        return j2("div", { ref: s4, className: "bg-bg-elevated ring-border-default absolute right-0 top-6 z-10 w-32 rounded-md shadow-lg ring-1" }, j2("div", { className: "py-1" }, j2("button", { onClick: function(e4) {
          e4.preventDefault(), e4.stopPropagation(), o3(), r2();
        }, className: "text-fg-secondary hover:bg-interactive-hover block w-full px-4 py-2 text-left text-sm" }, l4("comments.edit")), j2("button", { onClick: function(e4) {
          e4.preventDefault(), e4.stopPropagation(), i3(), r2();
        }, className: "text-state-error hover:bg-interactive-hover block w-full px-4 py-2 text-left text-sm" }, l4("comments.delete"))));
      };
      Ov = function(e3) {
        var t2 = e3.initialText, n3 = e3.onSave, o3 = e3.onCancel, i3 = e3.autoFocus, r2 = void 0 !== i3 && i3, a3 = e3.documentId, s4 = f(ke(t2), 2), l4 = s4[0], c4 = s4[1], d4 = Ae(null), u4 = ma(a3).translate;
        Me(function() {
          r2 && d4.current && (d4.current.focus(), d4.current.setSelectionRange(l4.length, l4.length));
        }, [r2, l4.length]);
        return j2("div", { className: "flex-1 space-y-2" }, j2("textarea", { ref: d4, value: l4, onInput: function(e4) {
          return c4(e4.currentTarget.value);
        }, className: "border-border-default bg-bg-input text-fg-primary focus:border-accent focus:ring-accent w-full rounded-md border px-3 py-2 text-base focus:outline-none focus:ring-1", rows: 3 }), j2("div", { className: "flex flex-wrap gap-2" }, j2("button", { onClick: function(e4) {
          e4.stopPropagation(), n3(l4);
        }, className: "bg-accent text-fg-on-accent hover:bg-accent-hover whitespace-nowrap rounded-md px-3 py-1 text-sm" }, u4("comments.save")), j2("button", { onClick: function(e4) {
          e4.stopPropagation(), o3();
        }, className: "bg-interactive-hover text-fg-secondary hover:bg-border-default whitespace-nowrap rounded-md px-3 py-1 text-sm" }, u4("comments.cancel"))));
      };
      Lv = function(e3) {
        if (!e3) return "(no date)";
        try {
          return (e3 instanceof Date ? e3 : new Date(e3)).toLocaleDateString("en-US", { month: "short", day: "numeric", hour: "numeric", minute: "2-digit" });
        } catch (t2) {
          return "string" == typeof e3 ? e3 : "(no date)";
        }
      };
      $v = function(e3) {
        var t2 = e3.annotation, n3 = e3.onSave, o3 = e3.onDelete, i3 = e3.isReply, r2 = void 0 !== i3 && i3, a3 = e3.documentId, s4 = f(ke(false), 2), l4 = s4[0], c4 = s4[1], d4 = f(ke(false), 2), u4 = d4[0], h3 = d4[1], m3 = t2.author || "Guest";
        return u4 ? j2("div", { className: "flex w-full items-start space-x-3", onClick: function(e4) {
          return e4.stopPropagation();
        } }, r2 && j2(Rv, { name: m3, className: "h-8 w-8" }), j2(Ov, { initialText: t2.contents || "", onSave: function(e4) {
          n3(e4), h3(false);
        }, onCancel: function() {
          h3(false);
        }, autoFocus: true, documentId: a3 })) : j2("div", { className: "flex items-start space-x-3" }, r2 && j2(Rv, { name: m3, className: "h-8 w-8" }), j2("div", { className: "min-w-0 flex-1" }, r2 && j2("div", { className: "flex items-center justify-between" }, j2("div", { className: "leading-none" }, j2("h5", { className: "text-fg-primary text-sm font-medium" }, m3), j2("span", { className: "text-fg-muted text-xs" }, Lv(t2.modified || t2.created))), j2("div", { className: "relative" }, j2("button", { onClick: function(e4) {
          e4.stopPropagation(), c4(true);
        }, className: "text-fg-muted hover:bg-interactive-hover rounded-md p-1" }, j2("svg", { className: "h-4 w-4", fill: "currentColor", viewBox: "0 0 20 20" }, j2("path", { d: "M6 10a2 2 0 11-4 0 2 2 0 014 0zM12 10a2 2 0 11-4 0 2 2 0 014 0zM16 12a2 2 0 100-4 2 2 0 000 4z" }))), l4 && j2(Nv, { onEdit: function() {
          return h3(true);
        }, onDelete: o3, onClose: function() {
          return c4(false);
        }, documentId: a3 }))), j2("p", { className: "text-fg-primary mt-2 text-sm" }, t2.contents)));
      };
      Fv = (s3(s3(s3(s3(s3(s3(s3(s3(s3(s3(Av = {}, Dt.HIGHLIGHT, { label: "Highlight", icon: "highlight", iconProps: function(e3) {
        return { primaryColor: e3.color || "#ffff00" };
      } }), Dt.CIRCLE, { label: "Circle", icon: "circle", iconProps: function(e3) {
        return { primaryColor: e3.strokeColor || "#000000", secondaryColor: e3.color };
      } }), Dt.SQUARE, { label: "Square", icon: "square", iconProps: function(e3) {
        return { primaryColor: e3.strokeColor || "#000000", secondaryColor: e3.color };
      } }), Dt.LINE, { label: "Line", icon: "line", iconProps: function(e3) {
        return { primaryColor: e3.strokeColor || "#000000" };
      } }), Dt.UNDERLINE, { label: "Underline", icon: "underline", iconProps: function(e3) {
        return { primaryColor: e3.color || "#000000" };
      } }), Dt.SQUIGGLY, { label: "Squiggly", icon: "squiggly", iconProps: function(e3) {
        return { primaryColor: e3.color || "#000000" };
      } }), Dt.STRIKEOUT, { label: "Strikethrough", icon: "strikethrough", iconProps: function(e3) {
        return { primaryColor: e3.color || "#000000" };
      } }), Dt.INK, { label: "Ink", icon: "pencilMarker", iconProps: function(e3) {
        return { primaryColor: e3.color || "#000000" };
      } }), Dt.FREETEXT, { label: "Text", icon: "text", iconProps: function(e3) {
        return { primaryColor: e3.fontColor || "#000000" };
      } }), Dt.POLYGON, { label: "Polygon", icon: "polygon", iconProps: function(e3) {
        return { primaryColor: e3.strokeColor || "#000000", secondaryColor: e3.color };
      } }), s3(s3(Av, Dt.POLYLINE, { label: "Polyline", icon: "zigzag", iconProps: function(e3) {
        return { primaryColor: e3.strokeColor || "#000000" };
      } }), Dt.STAMP, { label: "Stamp", icon: "deviceFloppy", iconProps: function() {
        return { primaryColor: "#dc2626" };
      } }));
      jv = function(e3) {
        var t2 = e3.text, n3 = e3.maxWords, o3 = void 0 === n3 ? 16 : n3, i3 = e3.className, r2 = void 0 === i3 ? "" : i3, a3 = e3.documentId, s4 = f(ke(false), 2), l4 = s4[0], c4 = s4[1], d4 = ma(a3).translate, u4 = t2.split(" ");
        return u4.length > o3 ? j2("div", { className: r2 }, l4 ? t2 : u4.slice(0, o3).join(" ") + "...", " ", j2("button", { onClick: function(e4) {
          e4.stopPropagation(), c4(!l4);
        }, className: "text-accent hover:text-accent-hover text-sm font-medium focus:outline-none" }, d4(l4 ? "comments.showLess" : "comments.showMore"))) : j2("div", { className: r2 }, t2);
      };
      Hv = function(e3) {
        var t2 = e3.annotation, n3 = e3.config, o3 = e3.className, i3 = void 0 === o3 ? "" : o3, r2 = n3.iconProps(t2.object);
        return j2("div", { className: "bg-bg-surface-alt flex items-center justify-center rounded-full ".concat(i3), title: n3.label }, j2(Ym, h2({ icon: n3.icon }, r2)));
      };
      Uv = function(e3) {
        var t2, n3 = e3.entry, o3 = e3.isSelected, i3 = e3.onSelect, r2 = e3.onUpdate, a3 = e3.onDelete, s4 = e3.onReply, l4 = e3.documentId, c4 = n3.annotation, d4 = n3.replies, u4 = f(ke(false), 2), h3 = u4[0], m3 = u4[1], g3 = f(ke(false), 2), p4 = g3[0], v2 = g3[1], y2 = ma(l4).translate, b2 = (function(e4) {
          return uc(e4) ? Fv[e4.object.type] : null;
        })(c4), w2 = !!c4.object.contents, x2 = d4.length > 0, C2 = !w2 && !x2, I2 = Ae(null), S2 = c4.object.author || "Guest";
        if (Me(function() {
          var e4;
          o3 && (null === (e4 = I2.current) || void 0 === e4 || e4.focus({ preventScroll: true }));
        }, [o3, n3]), !b2) return null;
        return j2("div", { onClick: i3, className: "bg-bg-surface cursor-pointer rounded-lg border shadow-sm transition-all hover:shadow-md ".concat(o3 ? "border-accent ring-interactive-focus-ring ring-2" : "border-border-subtle") }, j2("div", { className: "p-4" }, j2("div", { className: "flex items-start space-x-3" }, j2(Hv, { annotation: c4, config: b2, className: "h-8 w-8" }), j2("div", { className: "min-w-0 flex-1" }, j2("div", { className: "flex items-center justify-between" }, j2("div", { className: "leading-none" }, j2("h4", { className: "text-fg-primary text-sm font-medium" }, S2), j2("span", { className: "text-fg-disabled text-xs" }, Lv(c4.object.modified || c4.object.created))), j2("div", { className: "relative" }, j2("button", { onClick: function(e4) {
          e4.stopPropagation(), m3(true);
        }, className: "text-fg-disabled hover:bg-interactive-hover hover:text-fg-secondary rounded-md p-1" }, j2("svg", { className: "h-4 w-4", fill: "currentColor", viewBox: "0 0 20 20" }, j2("path", { d: "M6 10a2 2 0 11-4 0 2 2 0 014 0zM12 10a2 2 0 11-4 0 2 2 0 014 0zM16 12a2 2 0 100-4 2 2 0 000 4z" }))), h3 && j2(Nv, { onEdit: function() {
          return v2(true);
        }, onDelete: function() {
          return a3(c4);
        }, onClose: function() {
          return m3(false);
        }, documentId: l4 }))), (null === (t2 = c4.object.custom) || void 0 === t2 ? void 0 : t2.text) && j2(jv, { text: c4.object.custom.text, maxWords: 14, className: "text-fg-muted mt-2 text-sm", documentId: l4 }), j2("div", { className: "mt-2" }, p4 ? j2(Ov, { initialText: c4.object.contents || "", onSave: function(e4) {
          r2(c4.object.id, e4), v2(false);
        }, onCancel: function() {
          v2(false);
        }, autoFocus: true, documentId: l4 }) : w2 ? j2("p", { className: "text-fg-primary text-sm" }, c4.object.contents) : null))), x2 && j2("div", { className: "border-border-subtle mt-4 space-y-4 border-t pt-4" }, d4.map(function(e4) {
          return j2($v, { key: e4.object.id, annotation: e4.object, onSave: function(t3) {
            return r2(e4.object.id, t3);
          }, onDelete: function() {
            return a3(e4);
          }, isReply: true, documentId: l4 });
        })), !p4 && j2(zv, { inputRef: I2, isFocused: o3, placeholder: y2(C2 ? "comments.addComment" : "comments.addReply"), onSubmit: function(e4) {
          C2 ? r2(c4.object.id, e4) : s4(c4.object.id, e4);
        } })));
      };
      Wv = function(e3) {
        var t2 = e3.documentId, n3 = ma(t2).translate;
        return j2("div", { class: "text-fg-muted flex flex-col items-center gap-2 p-4" }, j2(Ym, { icon: "comment", className: "h-18 w-18 text-fg-muted" }), j2("div", { className: "text-fg-muted max-w-[150px] text-center text-sm" }, n3("comments.emptyState")));
      };
      Bv = function(e3) {
        var t2 = e3.documentId, n3 = Md().provides, o3 = Pd(t2).state, i3 = ni().provides, r2 = ma(t2).translate, s4 = Ae({}), l4 = Ae(null), c4 = o3.selectedUid ? mc(o3, o3.selectedUid) : null, d4 = ((e4) => {
          const t3 = {};
          for (const n5 of Object.values(e4.pages)) for (const o4 of n5) {
            const n6 = e4.byUid[o4];
            if (n6 && dc(n6)) {
              const e5 = n6.object.inReplyToId;
              e5 && (t3[e5] || (t3[e5] = [])).push(n6);
            }
          }
          const n4 = {};
          for (const [o4, i4] of Object.entries(e4.pages)) {
            const r3 = Number(o4), a3 = [];
            for (const n5 of i4) {
              const o5 = e4.byUid[n5];
              o5 && uc(o5) && a3.push({ page: r3, annotation: o5, replies: t3[o5.object.id] ?? [] });
            }
            a3.length > 0 && (n4[r3] = a3);
          }
          return n4;
        })(o3);
        Me(function() {
          if (c4 && l4.current) {
            var e4 = s4.current[c4.object.id];
            if (e4 && l4.current) {
              var t3 = l4.current, n4 = t3.getBoundingClientRect(), o4 = e4.getBoundingClientRect(), i4 = o4.top - n4.top + t3.scrollTop - t3.clientHeight / 2 + o4.height / 2;
              t3.scrollTo({ top: i4, behavior: "smooth" });
            }
          }
        }, [c4]);
        var u4 = function(e4, t3) {
          var o4 = p4(e4);
          o4 && (null == n3 || n3.updateAnnotation(o4.object.pageIndex, e4, { contents: t3, modified: /* @__PURE__ */ new Date() }));
        }, h3 = function(e4) {
          null == n3 || n3.deleteAnnotation(e4.object.pageIndex, e4.object.id);
        }, m3 = function(e4, t3) {
          var o4 = p4(e4);
          o4 && (null == n3 || n3.createAnnotation(o4.object.pageIndex, { id: yn(), rect: { origin: { x: o4.object.rect.origin.x, y: o4.object.rect.origin.y }, size: { width: 24, height: 24 } }, pageIndex: o4.object.pageIndex, created: /* @__PURE__ */ new Date(), modified: /* @__PURE__ */ new Date(), type: Dt.TEXT, contents: t3, inReplyToId: o4.object.id, flags: ["noRotate", "noZoom", "print"], icon: Pt.Comment }));
        }, g3 = Object.keys(d4).map(Number).sort(function(e4, t3) {
          return e4 - t3;
        }), p4 = function(e4) {
          var t3, n4 = a2(g3);
          try {
            for (n4.s(); !(t3 = n4.n()).done; ) {
              var o4, i4 = t3.value, r3 = a2(d4[i4]);
              try {
                for (r3.s(); !(o4 = r3.n()).done; ) {
                  var s5 = o4.value;
                  if (s5.annotation.object.id === e4) return s5.annotation;
                  var l5 = s5.replies.find(function(t4) {
                    return t4.object.id === e4;
                  });
                  if (l5) return l5;
                }
              } catch (e5) {
                r3.e(e5);
              } finally {
                r3.f();
              }
            }
          } catch (e5) {
            n4.e(e5);
          } finally {
            n4.f();
          }
        };
        return 0 === g3.length ? j2(Wv, { documentId: t2 }) : j2("div", { ref: l4, className: "h-full overflow-y-auto" }, j2("div", { className: "space-y-6 p-3" }, g3.map(function(e4) {
          return j2("div", { key: e4, className: "space-y-3" }, j2("div", { className: "bg-bg-surface sticky top-0 z-10 px-1" }, j2("div", { className: "border-border-subtle border-b py-2" }, j2("h3", { className: "text-md text-fg-primary font-semibold" }, r2("comments.page", { params: { page: e4 + 1 } })), j2("p", { className: "text-fg-muted text-sm" }, 1 === d4[e4].length ? r2("comments.commentCount", { params: { count: 1 } }) : r2("comments.commentCountPlural", { params: { count: d4[e4].length } })))), j2("div", { className: "space-y-3 px-1" }, d4[e4].map(function(e5) {
            return j2("div", { key: e5.annotation.object.id, ref: function(t3) {
              t3 && (s4.current[e5.annotation.object.id] = t3);
            } }, j2(Uv, { entry: e5, isSelected: (null == c4 ? void 0 : c4.object.id) === e5.annotation.object.id, onSelect: function() {
              return t3 = e5.annotation, null == n3 || n3.selectAnnotation(t3.object.pageIndex, t3.object.id), void (null == i3 || i3.scrollToPage({ pageNumber: t3.object.pageIndex + 1, pageCoordinates: { x: t3.object.rect.origin.x, y: t3.object.rect.origin.y }, alignX: 50, alignY: 25, behavior: "smooth" }));
              var t3;
            }, onUpdate: u4, onDelete: h3, onReply: m3, documentId: t2 }));
          })));
        })));
      };
      Vv = ["position"];
      Zv = function() {
        var e3 = f(ke(false), 2), t2 = e3[0], n3 = e3[1], o3 = Ae(null), i3 = Ae(null);
        return Me(function() {
          if (t2) {
            var e4 = function(e5) {
              o3.current && !o3.current.contains(e5.target) && n3(false);
            };
            return document.addEventListener("click", e4), function() {
              return document.removeEventListener("click", e4);
            };
          }
        }, [t2]), Me(function() {
          t2 && i3.current && i3.current.scrollIntoView({ block: "center", inline: "start" });
        }, [t2]), { open: t2, setOpen: n3, rootRef: o3, selectedItemRef: i3 };
      };
      Kv = function(e3) {
        var t2 = e3.value, n3 = e3.onChange, o3 = e3.options, i3 = e3.getOptionKey, r2 = e3.renderValue, a3 = e3.renderOption, s4 = e3.triggerClass, l4 = void 0 === s4 ? "px-3 py-2" : s4, c4 = Zv(), d4 = c4.open, u4 = c4.setOpen, h3 = c4.rootRef, m3 = c4.selectedItemRef;
        return j2("div", { ref: h3, class: "relative inline-block w-full" }, j2("button", { type: "button", class: "border-border-default bg-bg-input flex w-full items-center justify-between gap-2 rounded border ".concat(l4), onClick: function() {
          return u4(function(e4) {
            return !e4;
          });
        } }, r2(t2), j2("svg", { class: "text-fg-secondary h-4 w-4", viewBox: "0 0 20 20", fill: "currentColor" }, j2("path", { fillRule: "evenodd", d: "M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z", clipRule: "evenodd" }))), d4 && j2("div", { class: "border-border-default bg-bg-elevated absolute z-10 mt-1 max-h-60 w-full overflow-y-auto rounded border p-1 shadow-lg" }, o3.map(function(e4) {
          var o4 = i3(e4) === i3(t2);
          return j2("button", { ref: o4 ? m3 : null, key: i3(e4), class: "hover:bg-interactive-hover block w-full rounded text-left ".concat(o4 ? "bg-interactive-hover" : ""), onClick: function() {
            n3(e4), u4(false);
          } }, a3(e4, o4));
        })));
      };
      Yv = function(e3) {
        var t2 = e3.children, n3 = e3.className;
        return j2("label", { class: "text-fg-primary mb-2 block text-sm font-medium ".concat(void 0 === n3 ? "" : n3) }, t2);
      };
      Xv = function(e3) {
        var t2 = e3.children, n3 = e3.className;
        return j2("span", { class: "text-fg-muted text-xs ".concat(void 0 === n3 ? "" : n3) }, t2);
      };
      Qv = function(e3) {
        var t2 = e3.children, n3 = e3.className;
        return j2("section", { class: "mb-6 ".concat(void 0 === n3 ? "" : n3) }, t2);
      };
      Jv = function(e3) {
        var t2 = e3.value, n3 = e3.min, o3 = void 0 === n3 ? 0 : n3, i3 = e3.max, r2 = void 0 === i3 ? 1 : i3, a3 = e3.step, s4 = void 0 === a3 ? 0.1 : a3, l4 = e3.onChange;
        return j2("input", { type: "range", class: "range-sm bg-border-subtle mb-2 h-1 w-full cursor-pointer appearance-none rounded-lg", value: t2, min: o3, max: r2, step: s4, onInput: function(e4) {
          return l4(parseFloat(e4.target.value));
        } });
      };
      ef = function(e3) {
        var t2 = e3.color, n3 = e3.active, o3 = e3.onSelect, i3 = (function(e4) {
          return "transparent" === e4 || /^rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*0\s*\)$/i.test(e4) || /^#([0-9a-f]{8})$/i.test(e4) && "00" === e4.slice(-2).toLowerCase() || /^#([0-9a-f]{4})$/i.test(e4) && "0" === e4.slice(-1).toLowerCase();
        })(t2) ? { backgroundColor: "#fff", backgroundImage: "linear-gradient(45deg, transparent 40%, red 40%, red 60%, transparent 60%)", backgroundSize: "100% 100%" } : { backgroundColor: t2 };
        return j2("button", { title: t2, class: "border-border-strong h-5 w-5 rounded-full border ".concat(n3 ? "outline-accent outline outline-2 outline-offset-2" : ""), style: i3, onClick: function() {
          return o3(t2);
        } });
      };
      tf = [{ id: Et.SOLID }, { id: Et.DASHED, dash: [6, 2] }, { id: Et.DASHED, dash: [8, 4] }, { id: Et.DASHED, dash: [3, 3] }, { id: Et.DASHED, dash: [1, 2] }, { id: Et.DASHED, dash: [4, 2, 1, 2] }, { id: Et.DASHED, dash: [8, 4, 1, 4] }];
      nf = function(e3) {
        return j2("svg", { width: "80", height: "8", viewBox: "0 0 80 8" }, j2("line", { x1: "0", y1: "4", x2: "80", y2: "4", style: { strokeDasharray: null == e3 ? void 0 : e3.join(" "), stroke: "currentColor", strokeWidth: "2" } }));
      };
      of = function(e3) {
        return j2(Kv, h2(h2({}, e3), {}, { options: tf, getOptionKey: function(e4) {
          var t2;
          return e4.id + ((null === (t2 = e4.dash) || void 0 === t2 ? void 0 : t2.join("-")) || "");
        }, renderValue: function(e4) {
          return nf(e4.dash);
        }, renderOption: function(e4) {
          return j2("div", { class: "px-1 py-2" }, nf(e4.dash));
        } }));
      };
      rf = [At.None, At.Square, At.Circle, At.Diamond, At.OpenArrow, At.ClosedArrow, At.ROpenArrow, At.RClosedArrow, At.Butt, At.Slash];
      af = function(e3) {
        var t2, n3 = e3.ending, o3 = e3.position, i3 = s3(s3(s3(s3(s3(s3(s3(s3(s3({}, At.Square, j2("path", { d: "M68 -4 L76 -4 L76 4 L68 4 Z" })), At.Circle, j2("circle", { cx: "72", cy: "0", r: "4" })), At.Diamond, j2("path", { d: "M72 -5 L77 0 L72 5 L67 0 Z" })), At.OpenArrow, j2("path", { d: "M67 -5 L77 0 L67 5", fill: "none" })), At.ClosedArrow, j2("path", { d: "M67 -5 L77 0 L67 5 Z" })), At.ROpenArrow, j2("path", { d: "M77 -5 L67 0 L77 5", fill: "none" })), At.RClosedArrow, j2("path", { d: "M77 -5 L67 0 L77 5 Z" })), At.Butt, j2("path", { d: "M72 -5 L72 5", fill: "none" })), At.Slash, j2("path", { d: "M67 -5 L77 5", fill: "none" })), r2 = s3(s3(s3(s3(s3(s3(s3(s3(s3({}, At.Square, 68), At.Circle, 68), At.Diamond, 67), At.OpenArrow, 76), At.ClosedArrow, 67), At.ROpenArrow, 67), At.RClosedArrow, 67), At.Butt, 72), At.Slash, 72), a3 = i3[n3];
        return j2("svg", { width: "80", height: "20", viewBox: "0 0 80 20", class: "text-fg-primary" }, j2("g", { transform: "start" === o3 ? "rotate(180 40 10)" : "" }, j2("line", { x1: "4", y1: "10", x2: null !== (t2 = r2[n3]) && void 0 !== t2 ? t2 : 77, y2: "10", stroke: "currentColor", "stroke-width": "1.5" }), a3 && j2("g", { transform: "translate(0, 10)", fill: "currentColor", stroke: "currentColor", "stroke-width": "1.5" }, a3)));
      };
      sf = function(e3) {
        var t2 = e3.position, n3 = m2(e3, Vv);
        return j2(Kv, h2(h2({}, n3), {}, { options: rf, getOptionKey: function(e4) {
          return e4;
        }, triggerClass: "px-3 py-1", renderValue: function(e4) {
          return j2(af, { ending: e4, position: t2 });
        }, renderOption: function(e4) {
          return j2("div", { class: "px-1 py-1" }, j2(af, { ending: e4, position: t2 }));
        } }));
      };
      lf = function(e3) {
        return j2(Kv, h2(h2({}, e3), {}, { options: cn, getOptionKey: function(e4) {
          return e4;
        }, triggerClass: "px-2 py-1 text-sm", renderValue: function(e4) {
          return j2("span", null, dn(e4));
        }, renderOption: function(e4) {
          return j2("div", { class: "px-2 py-1" }, dn(e4));
        } }));
      };
      cf = function(e3) {
        var t2 = e3.value, n3 = e3.onChange, o3 = e3.options, i3 = void 0 === o3 ? [8, 9, 10, 11, 12, 14, 16, 18, 24, 36, 48, 72] : o3, r2 = Zv(), a3 = r2.open, s4 = r2.setOpen, l4 = r2.rootRef, c4 = r2.selectedItemRef;
        return j2("div", { ref: l4, class: "relative w-full" }, j2("input", { type: "number", min: "1", class: "border-border-default bg-bg-input w-full rounded border px-2 py-1 pr-7 text-sm", value: t2, onInput: function(e4) {
          var t3 = parseInt(e4.target.value, 10);
          Number.isFinite(t3) && t3 > 0 && n3(t3);
        }, onClick: function() {
          return s4(true);
        } }), j2("button", { type: "button", class: "absolute inset-y-0 right-1 flex items-center", onClick: function() {
          return s4(function(e4) {
            return !e4;
          });
        }, tabIndex: -1 }, j2("svg", { class: "text-fg-secondary h-4 w-4", viewBox: "0 0 20 20", fill: "currentColor" }, j2("path", { "fill-rule": "evenodd", d: "M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z", "clip-rule": "evenodd" }))), a3 && j2("div", { class: "border-border-default bg-bg-elevated absolute z-10 mt-1 max-h-48 w-full overflow-y-auto rounded border shadow-lg" }, i3.map(function(e4) {
          var o4 = e4 === t2;
          return j2("button", { ref: o4 ? c4 : null, key: e4, class: "hover:bg-interactive-hover block w-full px-2 py-1 text-left text-sm ".concat(o4 ? "bg-interactive-hover" : ""), onClick: function() {
            n3(e4), s4(false);
          } }, e4);
        })));
      };
      df = (s3(s3(s3(s3(s3(s3(s3(s3(s3(s3(Gv = {}, It.Normal, "blendMode.normal"), It.Multiply, "blendMode.multiply"), It.Screen, "blendMode.screen"), It.Overlay, "blendMode.overlay"), It.Darken, "blendMode.darken"), It.Lighten, "blendMode.lighten"), It.ColorDodge, "blendMode.colorDodge"), It.ColorBurn, "blendMode.colorBurn"), It.HardLight, "blendMode.hardLight"), It.SoftLight, "blendMode.softLight"), s3(s3(s3(s3(s3(s3(Gv, It.Difference, "blendMode.difference"), It.Exclusion, "blendMode.exclusion"), It.Hue, "blendMode.hue"), It.Saturation, "blendMode.saturation"), It.Color, "blendMode.color"), It.Luminosity, "blendMode.luminosity"));
      uf = function(e3) {
        var t2, n3, o3, i3, r2 = e3.documentId, a3 = e3.selected, s4 = e3.activeTool, l4 = e3.colorPresets, c4 = Md().provides, d4 = ma(r2).translate;
        if (!c4) return null;
        var u4 = null == a3 ? void 0 : a3.object, h3 = null == s4 ? void 0 : s4.defaults, m3 = !!u4, g3 = m3 ? u4.color : null !== (t2 = null == h3 ? void 0 : h3.color) && void 0 !== t2 ? t2 : "#FFFF00", p4 = m3 ? u4.opacity : null !== (n3 = null == h3 ? void 0 : h3.opacity) && void 0 !== n3 ? n3 : 1, v2 = m3 ? null !== (o3 = u4.blendMode) && void 0 !== o3 ? o3 : It.Normal : null !== (i3 = null == h3 ? void 0 : h3.blendMode) && void 0 !== i3 ? i3 : It.Normal, y2 = f(ke(g3), 2), b2 = y2[0], w2 = y2[1], x2 = f(ke(p4), 2), C2 = x2[0], I2 = x2[1], S2 = f(ke(v2), 2), k2 = S2[0], D2 = S2[1];
        Me(function() {
          return w2(g3);
        }, [g3]), Me(function() {
          return I2(p4);
        }, [p4]), Me(function() {
          return D2(v2);
        }, [v2]);
        var M2 = Cv(C2, 300);
        Me(function() {
          return A2({ opacity: M2 });
        }, [M2]);
        var P2 = function(e4) {
          w2(e4), A2({ color: e4 });
        };
        function A2(e4) {
          c4 && (m3 ? c4.updateAnnotation(u4.pageIndex, u4.id, e4) : s4 && c4.setToolDefaults(s4.id, e4));
        }
        return j2(U2, null, j2(Qv, null, j2(Yv, { className: "mb-3" }, d4("annotation.color")), j2("div", { class: "grid grid-cols-6 gap-x-1 gap-y-4" }, l4.map(function(e4) {
          return j2(ef, { key: e4, color: e4, active: e4 === b2, onSelect: P2 });
        }))), j2(Qv, null, j2(Yv, null, d4("annotation.opacity")), j2(Jv, { value: C2, min: 0.1, max: 1, step: 0.05, onChange: I2 }), j2(Xv, null, Math.round(100 * C2), "%")), j2(Qv, null, j2(Yv, null, d4("annotation.blendMode")), j2("select", { class: "border-border-default bg-bg-input text-fg-primary w-full rounded border px-2 py-1 text-sm", value: k2, onChange: function(e4) {
          return t3 = parseInt(e4.target.value, 10), D2(n4 = t3), void A2({ blendMode: n4 });
          var t3, n4;
        } }, gn.map(function(e4) {
          return j2("option", { key: e4, value: e4 }, d4(df[e4]));
        }))));
      };
      hf = function(e3) {
        var t2, n3, o3, i3, r2, a3 = e3.documentId, s4 = e3.selected, l4 = e3.activeTool, c4 = e3.colorPresets, d4 = Md().provides, u4 = ma(a3).translate;
        if (!d4) return null;
        var h3 = null == s4 ? void 0 : s4.object, m3 = null == l4 ? void 0 : l4.defaults, g3 = !!h3, p4 = g3 ? h3.color : null !== (t2 = null == m3 ? void 0 : m3.color) && void 0 !== t2 ? t2 : "#000000", v2 = g3 ? h3.strokeColor : null !== (n3 = null == m3 ? void 0 : m3.strokeColor) && void 0 !== n3 ? n3 : "#000000", y2 = g3 ? h3.opacity : null !== (o3 = null == m3 ? void 0 : m3.opacity) && void 0 !== o3 ? o3 : 1, b2 = g3 ? h3.strokeWidth : null !== (i3 = null == m3 ? void 0 : m3.strokeWidth) && void 0 !== i3 ? i3 : 2, w2 = g3 ? { id: h3.strokeStyle, dash: h3.strokeDashArray } : { id: null !== (r2 = null == m3 ? void 0 : m3.strokeStyle) && void 0 !== r2 ? r2 : Et.SOLID, dash: null == m3 ? void 0 : m3.strokeDashArray }, x2 = f(ke(p4), 2), C2 = x2[0], I2 = x2[1], S2 = f(ke(v2), 2), k2 = S2[0], D2 = S2[1], M2 = f(ke(y2), 2), P2 = M2[0], A2 = M2[1], T2 = f(ke(b2), 2), z3 = T2[0], E2 = T2[1], _2 = f(ke(w2), 2), R2 = _2[0], N3 = _2[1];
        Me(function() {
          return I2(p4);
        }, [p4]), Me(function() {
          return D2(v2);
        }, [v2]), Me(function() {
          return A2(y2);
        }, [y2]), Me(function() {
          return E2(b2);
        }, [b2]), Me(function() {
          return N3(w2);
        }, [w2]);
        var O2 = Cv(P2, 300), L3 = Cv(z3, 300);
        Me(function() {
          return H3({ opacity: O2 });
        }, [O2]), Me(function() {
          return H3({ strokeWidth: L3 });
        }, [L3]);
        var $3 = function(e4) {
          I2(e4), H3({ color: e4 });
        }, F2 = function(e4) {
          D2(e4), H3({ strokeColor: e4 });
        };
        function H3(e4) {
          d4 && (g3 ? d4.updateAnnotation(h3.pageIndex, h3.id, e4) : l4 && d4.setToolDefaults(l4.id, e4));
        }
        return j2(U2, null, j2(Qv, null, j2(Yv, { className: "mb-3" }, u4("annotation.fillColor")), j2("div", { class: "grid grid-cols-6 gap-x-1 gap-y-4" }, c4.map(function(e4) {
          return j2(ef, { key: e4, color: e4, active: e4 === C2, onSelect: $3 });
        }), j2(ef, { color: "transparent", active: "transparent" === C2, onSelect: $3 }))), j2(Qv, null, j2(Yv, null, u4("annotation.opacity")), j2(Jv, { value: P2, min: 0.1, max: 1, step: 0.05, onChange: A2 }), j2(Xv, null, Math.round(100 * P2), "%")), j2(Qv, null, j2(Yv, { className: "mb-3" }, u4("annotation.strokeColor")), j2("div", { class: "grid grid-cols-6 gap-x-1 gap-y-4" }, c4.map(function(e4) {
          return j2(ef, { key: e4, color: e4, active: e4 === k2, onSelect: F2 });
        }))), j2(Qv, null, j2(Yv, { className: "mb-3" }, u4("annotation.borderStyle")), j2(of, { value: R2, onChange: function(e4) {
          N3(e4), H3({ strokeStyle: e4.id, strokeDashArray: e4.dash });
        } })), j2(Qv, null, j2(Yv, null, u4("annotation.strokeWidth")), j2(Jv, { value: z3, min: 1, max: 30, step: 1, onChange: E2 }), j2(Xv, null, z3, "px")));
      };
      mf = function(e3) {
        var t2, n3, o3, i3, r2, a3, s4, l4 = e3.documentId, c4 = e3.selected, d4 = e3.activeTool, u4 = e3.colorPresets, h3 = Md().provides, m3 = ma(l4).translate;
        if (!h3) return null;
        var g3 = null == c4 ? void 0 : c4.object, p4 = null == d4 ? void 0 : d4.defaults, v2 = !!g3, y2 = v2 ? g3.color : null !== (t2 = null == p4 ? void 0 : p4.color) && void 0 !== t2 ? t2 : "#000000", b2 = v2 ? g3.strokeColor : null !== (n3 = null == p4 ? void 0 : p4.strokeColor) && void 0 !== n3 ? n3 : "#000000", w2 = v2 ? g3.opacity : null !== (o3 = null == p4 ? void 0 : p4.opacity) && void 0 !== o3 ? o3 : 1, x2 = v2 ? g3.strokeWidth : null !== (i3 = null == p4 ? void 0 : p4.strokeWidth) && void 0 !== i3 ? i3 : 2, C2 = v2 ? null !== (r2 = g3.lineEndings) && void 0 !== r2 ? r2 : { start: At.None, end: At.None } : null !== (a3 = null == p4 ? void 0 : p4.lineEndings) && void 0 !== a3 ? a3 : { start: At.None, end: At.None }, I2 = v2 ? { id: g3.strokeStyle, dash: g3.strokeDashArray } : { id: null !== (s4 = null == p4 ? void 0 : p4.strokeStyle) && void 0 !== s4 ? s4 : Et.SOLID, dash: null == p4 ? void 0 : p4.strokeDashArray }, S2 = f(ke(y2), 2), k2 = S2[0], D2 = S2[1], M2 = f(ke(b2), 2), P2 = M2[0], A2 = M2[1], T2 = f(ke(w2), 2), z3 = T2[0], E2 = T2[1], _2 = f(ke(x2), 2), R2 = _2[0], N3 = _2[1], O2 = f(ke(I2), 2), L3 = O2[0], $3 = O2[1], F2 = f(ke(C2.start), 2), H3 = F2[0], W3 = F2[1], B3 = f(ke(C2.end), 2), q3 = B3[0], G2 = B3[1];
        Me(function() {
          return D2(y2);
        }, [y2]), Me(function() {
          return A2(b2);
        }, [b2]), Me(function() {
          return E2(w2);
        }, [w2]), Me(function() {
          return N3(x2);
        }, [x2]), Me(function() {
          return $3(I2);
        }, [I2]), Me(function() {
          return W3(C2.start);
        }, [C2.start]), Me(function() {
          return G2(C2.end);
        }, [C2.end]);
        var V3 = Cv(z3, 300), Z3 = Cv(R2, 300);
        Me(function() {
          return X3({ opacity: V3 });
        }, [V3]), Me(function() {
          return X3({ strokeWidth: Z3 });
        }, [Z3]);
        var K3 = function(e4) {
          D2(e4), X3({ color: e4 });
        }, Y3 = function(e4) {
          A2(e4), X3({ strokeColor: e4 });
        };
        function X3(e4) {
          h3 && (v2 ? h3.updateAnnotation(g3.pageIndex, g3.id, e4) : d4 && h3.setToolDefaults(d4.id, e4));
        }
        return j2(U2, null, j2(Qv, null, j2(Yv, { className: "mb-3" }, m3("annotation.strokeColor")), j2("div", { class: "grid grid-cols-6 gap-x-1 gap-y-4" }, u4.map(function(e4) {
          return j2(ef, { key: e4, color: e4, active: e4 === P2, onSelect: Y3 });
        }), j2(ef, { color: "transparent", active: "transparent" === P2, onSelect: Y3 }))), j2(Qv, null, j2(Yv, null, m3("annotation.opacity")), j2(Jv, { value: z3, min: 0.1, max: 1, step: 0.05, onChange: E2 }), j2(Xv, null, Math.round(100 * z3), "%")), j2(Qv, null, j2(Yv, { className: "mb-3" }, m3("annotation.borderStyle")), j2(of, { value: L3, onChange: function(e4) {
          $3(e4), X3({ strokeStyle: e4.id, strokeDashArray: e4.dash });
        } })), j2(Qv, null, j2(Yv, null, m3("annotation.strokeWidth")), j2(Jv, { value: R2, min: 1, max: 10, step: 1, onChange: N3 }), j2(Xv, null, R2)), j2(Qv, null, j2("div", { class: "grid grid-cols-2 gap-4" }, j2("div", null, j2(Yv, { className: "mb-3" }, m3("annotation.lineStart")), j2(sf, { value: H3, onChange: function(e4) {
          W3(e4), X3({ lineEndings: { start: e4, end: q3 } });
        }, position: "start" })), j2("div", null, j2(Yv, { className: "mb-3" }, m3("annotation.lineEnd")), j2(sf, { value: q3, onChange: function(e4) {
          G2(e4), X3({ lineEndings: { start: H3, end: e4 } });
        }, position: "end" })))), j2(Qv, null, j2(Yv, { className: "mb-3" }, m3("annotation.fillColor")), j2("div", { class: "grid grid-cols-6 gap-x-1 gap-y-4" }, u4.map(function(e4) {
          return j2(ef, { key: e4, color: e4, active: e4 === k2, onSelect: K3 });
        }), j2(ef, { color: "transparent", active: "transparent" === k2, onSelect: K3 }))));
      };
      vf = (s3(s3(s3(s3(s3(s3(s3(s3(s3(s3(pf = {}, Dt.INK, { component: function(e3) {
        var t2, n3, o3, i3, r2, a3, s4 = e3.documentId, l4 = e3.selected, c4 = e3.activeTool, d4 = e3.colorPresets, u4 = Md().provides, h3 = ma(s4).translate;
        if (!u4) return null;
        var m3 = null == l4 ? void 0 : l4.object, g3 = null == c4 ? void 0 : c4.defaults, p4 = null !== (t2 = null !== (n3 = null == m3 ? void 0 : m3.color) && void 0 !== n3 ? n3 : null == g3 ? void 0 : g3.color) && void 0 !== t2 ? t2 : "#000000", v2 = null !== (o3 = null !== (i3 = null == m3 ? void 0 : m3.opacity) && void 0 !== i3 ? i3 : null == g3 ? void 0 : g3.opacity) && void 0 !== o3 ? o3 : 1, y2 = null !== (r2 = null !== (a3 = null == m3 ? void 0 : m3.strokeWidth) && void 0 !== a3 ? a3 : null == g3 ? void 0 : g3.strokeWidth) && void 0 !== r2 ? r2 : 2, b2 = f(ke(p4), 2), w2 = b2[0], x2 = b2[1], C2 = f(ke(v2), 2), I2 = C2[0], S2 = C2[1], k2 = f(ke(y2), 2), D2 = k2[0], M2 = k2[1];
        Me(function() {
          return x2(p4);
        }, [p4]), Me(function() {
          return S2(v2);
        }, [v2]), Me(function() {
          return M2(y2);
        }, [y2]);
        var P2 = Cv(I2, 300), A2 = Cv(D2, 300);
        Me(function() {
          return z3({ opacity: P2 });
        }, [P2]), Me(function() {
          return z3({ strokeWidth: A2 });
        }, [A2]);
        var T2 = function(e4) {
          x2(e4), z3({ color: e4 });
        };
        function z3(e4) {
          u4 && (m3 ? u4.updateAnnotation(m3.pageIndex, m3.id, e4) : c4 && u4.setToolDefaults(c4.id, e4));
        }
        return j2(U2, null, j2(Qv, null, j2(Yv, { className: "mb-3" }, h3("annotation.color")), j2("div", { class: "grid grid-cols-6 gap-x-1 gap-y-4" }, d4.map(function(e4) {
          return j2(ef, { key: e4, color: e4, active: e4 === w2, onSelect: T2 });
        }))), j2(Qv, null, j2(Yv, null, h3("annotation.opacity")), j2(Jv, { value: I2, min: 0.1, max: 1, step: 0.05, onChange: S2 }), j2(Xv, null, Math.round(100 * I2), "%")), j2(Qv, null, j2(Yv, null, h3("annotation.strokeWidth")), j2(Jv, { value: D2, min: 1, max: 30, step: 1, onChange: M2 }), j2(Xv, null, D2, "px")));
      }, titleKey: "annotation.ink" }), Dt.POLYGON, { component: function(e3) {
        var t2, n3, o3, i3, r2, a3 = e3.documentId, s4 = e3.selected, l4 = e3.activeTool, c4 = e3.colorPresets, d4 = Md().provides, u4 = ma(a3).translate;
        if (!d4) return null;
        var h3 = null == s4 ? void 0 : s4.object, m3 = null == l4 ? void 0 : l4.defaults, g3 = !!h3, p4 = g3 ? h3.color : null !== (t2 = null == m3 ? void 0 : m3.color) && void 0 !== t2 ? t2 : "#000000", v2 = g3 ? h3.strokeColor : null !== (n3 = null == m3 ? void 0 : m3.strokeColor) && void 0 !== n3 ? n3 : "#000000", y2 = g3 ? h3.opacity : null !== (o3 = null == m3 ? void 0 : m3.opacity) && void 0 !== o3 ? o3 : 1, b2 = g3 ? h3.strokeWidth : null !== (i3 = null == m3 ? void 0 : m3.strokeWidth) && void 0 !== i3 ? i3 : 2, w2 = g3 ? { id: h3.strokeStyle, dash: h3.strokeDashArray } : { id: null !== (r2 = null == m3 ? void 0 : m3.strokeStyle) && void 0 !== r2 ? r2 : Et.SOLID, dash: null == m3 ? void 0 : m3.strokeDashArray }, x2 = f(ke(p4), 2), C2 = x2[0], I2 = x2[1], S2 = f(ke(v2), 2), k2 = S2[0], D2 = S2[1], M2 = f(ke(y2), 2), P2 = M2[0], A2 = M2[1], T2 = f(ke(b2), 2), z3 = T2[0], E2 = T2[1], _2 = f(ke(w2), 2), R2 = _2[0], N3 = _2[1];
        Me(function() {
          return I2(p4);
        }, [p4]), Me(function() {
          return D2(v2);
        }, [v2]), Me(function() {
          return A2(y2);
        }, [y2]), Me(function() {
          return E2(b2);
        }, [b2]), Me(function() {
          return N3(w2);
        }, [w2]);
        var O2 = Cv(P2, 300), L3 = Cv(z3, 300);
        Me(function() {
          return H3({ opacity: O2 });
        }, [O2]), Me(function() {
          return H3({ strokeWidth: L3 });
        }, [L3]);
        var $3 = function(e4) {
          I2(e4), H3({ color: e4 });
        }, F2 = function(e4) {
          D2(e4), H3({ strokeColor: e4 });
        };
        function H3(e4) {
          d4 && (g3 ? d4.updateAnnotation(h3.pageIndex, h3.id, e4) : l4 && d4.setToolDefaults(l4.id, e4));
        }
        return j2(U2, null, j2(Qv, null, j2(Yv, { className: "mb-3" }, u4("annotation.strokeColor")), j2("div", { class: "grid grid-cols-6 gap-x-1 gap-y-4" }, c4.map(function(e4) {
          return j2(ef, { key: e4, color: e4, active: e4 === k2, onSelect: F2 });
        }), j2(ef, { color: "transparent", active: "transparent" === k2, onSelect: F2 }))), j2(Qv, null, j2(Yv, null, u4("annotation.opacity")), j2(Jv, { value: P2, min: 0.1, max: 1, step: 0.05, onChange: A2 }), j2(Xv, null, Math.round(100 * P2), "%")), j2(Qv, null, j2(Yv, { className: "mb-3" }, u4("annotation.borderStyle")), j2(of, { value: R2, onChange: function(e4) {
          N3(e4), H3({ strokeStyle: e4.id, strokeDashArray: e4.dash });
        } })), j2(Qv, null, j2(Yv, null, u4("annotation.strokeWidth")), j2(Jv, { value: z3, min: 1, max: 10, step: 1, onChange: E2 }), j2(Xv, null, z3)), j2(Qv, null, j2(Yv, { className: "mb-3" }, u4("annotation.fillColor")), j2("div", { class: "grid grid-cols-6 gap-x-1 gap-y-4" }, c4.map(function(e4) {
          return j2(ef, { key: e4, color: e4, active: e4 === C2, onSelect: $3 });
        }), j2(ef, { color: "transparent", active: "transparent" === C2, onSelect: $3 }))));
      }, titleKey: "annotation.polygon" }), Dt.SQUARE, { component: hf, titleKey: "annotation.square" }), Dt.CIRCLE, { component: hf, titleKey: "annotation.circle" }), Dt.LINE, { component: mf, titleKey: function(e3) {
        var t2;
        return "lineArrow" === (null === (t2 = e3.activeTool) || void 0 === t2 ? void 0 : t2.id) ? "annotation.arrow" : "annotation.line";
      } }), Dt.POLYLINE, { component: mf, titleKey: "annotation.polyline" }), Dt.HIGHLIGHT, { component: uf, titleKey: "annotation.highlight" }), Dt.UNDERLINE, { component: uf, titleKey: "annotation.underline" }), Dt.STRIKEOUT, { component: uf, titleKey: "annotation.strikeout" }), Dt.SQUIGGLY, { component: uf, titleKey: "annotation.squiggly" }), s3(s3(pf, Dt.FREETEXT, { component: function(e3) {
        var t2, n3, o3, i3, r2, a3, s4, l4 = e3.documentId, c4 = e3.selected, d4 = e3.activeTool, u4 = e3.colorPresets, h3 = Md().provides, m3 = ma(l4).translate;
        if (!h3) return null;
        var g3 = null == c4 ? void 0 : c4.object, p4 = null == d4 ? void 0 : d4.defaults, v2 = !!g3, y2 = v2 ? g3.fontFamily : null !== (t2 = null == p4 ? void 0 : p4.fontFamily) && void 0 !== t2 ? t2 : wt.Helvetica, b2 = rn(y2).family, w2 = an(y2), x2 = sn(y2), C2 = v2 ? g3.fontColor : null !== (n3 = null == p4 ? void 0 : p4.fontColor) && void 0 !== n3 ? n3 : "#000000", I2 = v2 ? g3.opacity : null !== (o3 = null == p4 ? void 0 : p4.opacity) && void 0 !== o3 ? o3 : 1, S2 = v2 ? g3.backgroundColor : null !== (i3 = null == p4 ? void 0 : p4.backgroundColor) && void 0 !== i3 ? i3 : "#000000", k2 = v2 ? g3.fontSize : null !== (r2 = null == p4 ? void 0 : p4.fontSize) && void 0 !== r2 ? r2 : 12, D2 = v2 ? g3.textAlign : null !== (a3 = null == p4 ? void 0 : p4.textAlign) && void 0 !== a3 ? a3 : xt.Left, M2 = v2 ? g3.verticalAlign : null !== (s4 = null == p4 ? void 0 : p4.verticalAlign) && void 0 !== s4 ? s4 : Ct.Top, P2 = f(ke(b2), 2), A2 = P2[0], T2 = P2[1], z3 = f(ke(k2), 2), E2 = z3[0], _2 = z3[1], R2 = f(ke(w2), 2), N3 = R2[0], O2 = R2[1], L3 = f(ke(x2), 2), $3 = L3[0], F2 = L3[1], H3 = f(ke(D2), 2), W3 = H3[0], B3 = H3[1], q3 = f(ke(M2), 2), G2 = q3[0], V3 = q3[1], Z3 = f(ke(C2), 2), K3 = Z3[0], Y3 = Z3[1], X3 = f(ke(I2), 2), Q3 = X3[0], J3 = X3[1], ee3 = f(ke(S2), 2), te3 = ee3[0], ne3 = ee3[1];
        function oe3(e4) {
          h3 && (v2 ? h3.updateAnnotation(g3.pageIndex, g3.id, e4) : d4 && h3.setToolDefaults(d4.id, e4));
        }
        Me(function() {
          T2(b2), O2(w2), F2(x2);
        }, [b2, w2, x2]), Me(function() {
          return Y3(C2);
        }, [C2]), Me(function() {
          return J3(I2);
        }, [I2]), Me(function() {
          return ne3(S2);
        }, [S2]), Me(function() {
          return _2(k2);
        }, [k2]), Me(function() {
          return B3(D2);
        }, [D2]), Me(function() {
          return V3(M2);
        }, [M2]);
        var ie3 = Cv(Q3, 300), re3 = Cv(te3, 300);
        Me(function() {
          return oe3({ opacity: ie3 });
        }, [ie3]), Me(function() {
          return oe3({ backgroundColor: re3 });
        }, [re3]);
        var ae3 = function(e4) {
          Y3(e4), oe3({ fontColor: e4 });
        }, se2 = function(e4) {
          ne3(e4), oe3({ backgroundColor: e4 });
        }, le2 = function(e4, t3, n4) {
          oe3({ fontFamily: ln(e4, { bold: t3, italic: n4 }) });
        }, ce2 = function(e4) {
          B3(e4), oe3({ textAlign: e4 });
        }, de2 = function(e4) {
          V3(e4), oe3({ verticalAlign: e4 });
        };
        return j2(U2, null, j2(Qv, null, j2(Yv, null, m3("annotation.font")), j2("div", { class: "mb-3 flex gap-2" }, j2(lf, { value: A2, onChange: function(e4) {
          var t3 = an(ln(e4, { bold: true, italic: false })), n4 = sn(ln(e4, { bold: false, italic: true })), o4 = !!t3 && N3, i4 = !!n4 && $3;
          T2(e4), O2(o4), F2(i4), le2(e4, o4, i4);
        } }), j2("div", { class: "w-36" }, j2(cf, { value: E2, onChange: function(e4) {
          !Number.isFinite(e4) || e4 <= 0 || (_2(e4), oe3({ fontSize: e4 }));
        } }))), j2("div", { class: "flex gap-2" }, j2(gf, { title: "Bold", active: N3, disabled: !an(ln(A2, { bold: true, italic: false })), onClick: function() {
          if (an(ln(A2, { bold: true, italic: false }))) {
            var e4 = !N3;
            O2(e4), le2(A2, e4, $3);
          }
        }, className: "font-bold" }, j2(Ym, { icon: "bold", size: 18 })), j2(gf, { title: "Italic", active: $3, disabled: !sn(ln(A2, { bold: false, italic: true })), onClick: function() {
          if (sn(ln(A2, { bold: false, italic: true }))) {
            var e4 = !$3;
            F2(e4), le2(A2, N3, e4);
          }
        }, className: "italic" }, j2(Ym, { icon: "italic", size: 18 })))), j2(Qv, null, j2(Yv, null, m3("annotation.textAlign")), j2("div", { class: "flex gap-2" }, j2(gf, { title: "Align left", active: W3 === xt.Left, onClick: function() {
          return ce2(xt.Left);
        } }, j2(Ym, { icon: "alignLeft", size: 18 })), j2(gf, { title: "Align center", active: W3 === xt.Center, onClick: function() {
          return ce2(xt.Center);
        } }, j2(Ym, { icon: "alignCenter", size: 18 })), j2(gf, { title: "Align right", active: W3 === xt.Right, onClick: function() {
          return ce2(xt.Right);
        } }, j2(Ym, { icon: "alignRight", size: 18 })))), j2(Qv, null, j2(Yv, null, m3("annotation.verticalAlign")), j2("div", { class: "flex gap-2" }, j2(gf, { title: "Align top", active: G2 === Ct.Top, onClick: function() {
          return de2(Ct.Top);
        } }, j2(Ym, { icon: "alignTop", size: 18 })), j2(gf, { title: "Align middle", active: G2 === Ct.Middle, onClick: function() {
          return de2(Ct.Middle);
        } }, j2(Ym, { icon: "alignMiddle", size: 18 })), j2(gf, { title: "Align bottom", active: G2 === Ct.Bottom, onClick: function() {
          return de2(Ct.Bottom);
        } }, j2(Ym, { icon: "alignBottom", size: 18 })))), j2(Qv, null, j2(Yv, { className: "mb-3" }, m3("annotation.fontColor")), j2("div", { class: "grid grid-cols-6 gap-x-1 gap-y-4" }, u4.map(function(e4) {
          return j2(ef, { key: e4, color: e4, active: e4 === K3, onSelect: ae3 });
        }))), j2(Qv, null, j2(Yv, { className: "mb-3" }, m3("annotation.backgroundColor")), j2("div", { class: "grid grid-cols-6 gap-x-1 gap-y-4" }, u4.map(function(e4) {
          return j2(ef, { key: e4, color: e4, active: e4 === te3, onSelect: se2 });
        }), j2(ef, { color: "transparent", active: "transparent" === te3, onSelect: se2 }))), j2(Qv, null, j2(Yv, null, m3("annotation.opacity")), j2(Jv, { value: Q3, min: 0.1, max: 1, step: 0.05, onChange: J3 }), j2(Xv, null, Math.round(100 * Q3), "%")));
      }, titleKey: "annotation.freeText" }), Dt.STAMP, { component: function(e3) {
        var t2 = e3.documentId;
        return j2("div", { className: "text-fg-muted text-sm" }, (0, ma(t2).translate)("annotation.noStylesStamp"));
      }, titleKey: "annotation.stamp" }));
      ff = function(e3) {
        var t2 = e3.documentId, n3 = ma(t2).translate;
        return j2("div", { class: "text-fg-muted flex flex-col items-center gap-2 p-4" }, j2(Ym, { icon: "palette", className: "h-18 w-18 text-fg-muted" }), j2("div", { className: "text-fg-muted max-w-[150px] text-center text-sm" }, n3("annotation.selectAnnotation")));
      };
      kf = { colors: { background: { app: "#f3f4f6", surface: "#ffffff", surfaceAlt: "#f1f3f5", elevated: "#ffffff", overlay: "rgba(0, 0, 0, 0.5)", input: "#ffffff" }, foreground: { primary: "#111827", secondary: "#374151", muted: "#6b7280", disabled: "#9ca3af", onAccent: "#ffffff" }, border: { default: "#d1d5db", subtle: "#e5e7eb", strong: "#9ca3af" }, accent: { primary: "#3b82f6", primaryHover: "#2563eb", primaryActive: "#1d4ed8", primaryLight: "#eff6ff", primaryForeground: "#ffffff" }, interactive: { hover: "#f3f4f6", active: "#e5e7eb", selected: "#eff6ff", focus: "#3b82f6", focusRing: "#bfdbfe" }, state: { error: "#ef4444", errorLight: "#fef2f2", warning: "#f59e0b", warningLight: "#fffbeb", success: "#22c55e", successLight: "#f0fdf4", info: "#3b82f6", infoLight: "#eff6ff" }, tooltip: { background: "#111827", foreground: "#ffffff" }, scrollbar: { track: "#f3f4f6", thumb: "#d1d5db", thumbHover: "#9ca3af" } } };
      Df = { colors: { background: { app: "#111827", surface: "#1f2937", surfaceAlt: "#374151", elevated: "#1f2937", overlay: "rgba(0, 0, 0, 0.7)", input: "#374151" }, foreground: { primary: "#f9fafb", secondary: "#e5e7eb", muted: "#9ca3af", disabled: "#6b7280", onAccent: "#111827" }, border: { default: "#4b5563", subtle: "#374151", strong: "#6b7280" }, accent: { primary: "#60a5fa", primaryHover: "#3b82f6", primaryActive: "#2563eb", primaryLight: "#1e3a5f", primaryForeground: "#111827" }, interactive: { hover: "#374151", active: "#4b5563", selected: "#1e3a5f", focus: "#60a5fa", focusRing: "#1e40af" }, state: { error: "#f87171", errorLight: "#7f1d1d", warning: "#fbbf24", warningLight: "#78350f", success: "#4ade80", successLight: "#14532d", info: "#60a5fa", infoLight: "#1e3a5f" }, tooltip: { background: "#f9fafb", foreground: "#111827" }, scrollbar: { track: "#1f2937", thumb: "#4b5563", thumbHover: "#6b7280" } } };
      Of = { documentManager: {}, commands: { commands: { "zoom:in": { id: "zoom:in", labelKey: "zoom.in", icon: "zoomIn", shortcuts: ["Ctrl+=", "Meta+=", "Ctrl+NumpadAdd", "Meta+NumpadAdd"], categories: ["zoom", "zoom-in"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).zoomIn();
      } }, "zoom:out": { id: "zoom:out", labelKey: "zoom.out", icon: "zoomOut", shortcuts: ["Ctrl+-", "Meta+-", "Ctrl+NumpadSubtract", "Meta+NumpadSubtract"], categories: ["zoom", "zoom-out"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).zoomOut();
      } }, "zoom:fit-page": { id: "zoom:fit-page", labelKey: "zoom.fitPage", icon: "fitToPage", shortcuts: ["Ctrl+0", "Meta+0"], categories: ["zoom", "zoom-fit-page"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).requestZoom(ga.FitPage);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return (null === (t2 = n3.plugins.zoom) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.zoomLevel) === ga.FitPage;
      } }, "zoom:fit-width": { id: "zoom:fit-width", labelKey: "zoom.fitWidth", icon: "fitToWidth", shortcuts: ["Ctrl+1", "Meta+1"], categories: ["zoom", "zoom-fit-width"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).requestZoom(ga.FitWidth);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return (null === (t2 = n3.plugins.zoom) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.zoomLevel) === ga.FitWidth;
      } }, "zoom:marquee": { id: "zoom:marquee", labelKey: "zoom.marquee", icon: "zoomInArea", shortcuts: ["Ctrl+M", "Meta+M"], categories: ["zoom", "zoom-marquee"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).toggleMarqueeZoom();
      }, active: function(e3) {
        var t2, n3, o3 = e3.state, i3 = e3.documentId;
        return null !== (t2 = null === (n3 = o3.plugins.zoom) || void 0 === n3 || null === (n3 = n3.documents[i3]) || void 0 === n3 ? void 0 : n3.isMarqueeZoomActive) && void 0 !== t2 && t2;
      } }, "zoom:25": { id: "zoom:25", label: "25%", categories: ["zoom", "zoom-level", "zoom-level-25"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).requestZoom(0.25);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return 0.25 === (null === (t2 = n3.plugins.zoom) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.zoomLevel);
      } }, "zoom:50": { id: "zoom:50", label: "50%", categories: ["zoom", "zoom-level", "zoom-level-50"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).requestZoom(0.5);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return 0.5 === (null === (t2 = n3.plugins.zoom) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.zoomLevel);
      } }, "zoom:100": { id: "zoom:100", label: "100%", categories: ["zoom", "zoom-level", "zoom-level-100"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).requestZoom(1);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return 1 === (null === (t2 = n3.plugins.zoom) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.zoomLevel);
      } }, "zoom:125": { id: "zoom:125", label: "125%", categories: ["zoom", "zoom-level", "zoom-level-125"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).requestZoom(1.25);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return 1.25 === (null === (t2 = n3.plugins.zoom) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.zoomLevel);
      } }, "zoom:150": { id: "zoom:150", label: "150%", categories: ["zoom", "zoom-level", "zoom-level-150"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).requestZoom(1.5);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return 1.5 === (null === (t2 = n3.plugins.zoom) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.zoomLevel);
      } }, "zoom:200": { id: "zoom:200", label: "200%", categories: ["zoom", "zoom-level", "zoom-level-200"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).requestZoom(2);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return 2 === (null === (t2 = n3.plugins.zoom) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.zoomLevel);
      } }, "zoom:400": { id: "zoom:400", label: "400%", categories: ["zoom", "zoom-level", "zoom-level-400"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).requestZoom(4);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return 4 === (null === (t2 = n3.plugins.zoom) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.zoomLevel);
      } }, "zoom:800": { id: "zoom:800", label: "800%", categories: ["zoom", "zoom-level", "zoom-level-800"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).requestZoom(8);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return 8 === (null === (t2 = n3.plugins.zoom) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.zoomLevel);
      } }, "zoom:1600": { id: "zoom:1600", label: "1600%", categories: ["zoom", "zoom-level", "zoom-level-1600"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("zoom")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).requestZoom(16);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return 16 === (null === (t2 = n3.plugins.zoom) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.zoomLevel);
      } }, "zoom:toggle-menu": { id: "zoom:toggle-menu", labelKey: "zoom.menu", icon: "chevronDown", iconProps: { className: "h-3.5 w-3.5" }, categories: ["zoom", "zoom-menu"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("ui")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).toggleMenu("zoom-menu", "zoom:toggle-menu", "zoom-menu-button");
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins.ui) || void 0 === t2 ? void 0 : t2.documents[o3];
        return void 0 !== (null == i3 ? void 0 : i3.openMenus["zoom-menu"]);
      } }, "zoom:toggle-menu-mobile": { id: "zoom:toggle-menu-mobile", labelKey: "zoom.menu", icon: "zoomIn", categories: ["zoom", "zoom-menu"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("ui")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).toggleMenu("zoom-menu", "zoom:toggle-menu-mobile", "zoom-menu-button");
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins.ui) || void 0 === t2 ? void 0 : t2.documents[o3];
        return void 0 !== (null == i3 ? void 0 : i3.openMenus["zoom-menu"]);
      } }, "pan:toggle": { id: "pan:toggle", labelKey: "pan.toggle", icon: "hand", shortcuts: ["h"], categories: ["tools", "pan"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("pan")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).togglePan();
      }, active: function(e3) {
        var t2, n3, o3 = e3.state, i3 = e3.documentId;
        return null !== (t2 = null === (n3 = o3.plugins.pan) || void 0 === n3 || null === (n3 = n3.documents[i3]) || void 0 === n3 ? void 0 : n3.isPanMode) && void 0 !== t2 && t2;
      } }, "pointer:toggle": { id: "pointer:toggle", labelKey: "pointer.toggle", icon: "pointer", shortcuts: ["p"], categories: ["tools", "pointer"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("interaction-manager")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).activate("pointerMode");
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return "pointerMode" === (null === (t2 = n3.plugins["interaction-manager"]) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.activeMode);
      } }, "left-action-menu:overflow-menu": { id: "left-action-menu:overflow-menu", labelKey: "menu.moreOptions", icon: "dots", categories: ["ui", "ui-menu"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("ui")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.toggleMenu("left-action-menu", "left-action-menu:overflow-menu", "overflow-left-action-menu-button", o3);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins.ui) || void 0 === t2 ? void 0 : t2.documents[o3];
        return void 0 !== (null == i3 ? void 0 : i3.openMenus["left-action-menu"]);
      } }, "capture:screenshot": { id: "capture:screenshot", labelKey: "capture.screenshot", icon: "screenshot", shortcuts: ["Ctrl+Shift+S", "Meta+Shift+S"], categories: ["tools", "capture", "capture-screenshot"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("capture")) || void 0 === t2 ? void 0 : t2.provides();
        if (i3) {
          var r2 = i3.forDocument(o3);
          r2.isMarqueeCaptureActive() ? r2.disableMarqueeCapture() : r2.enableMarqueeCapture();
        }
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return "marqueeCapture" === (null === (t2 = n3.plugins["interaction-manager"].documents[o3]) || void 0 === t2 ? void 0 : t2.activeMode);
      } }, "document:menu": { id: "document:menu", labelKey: "document.menu", icon: "menu", categories: ["document", "document-menu"], action: function(e3) {
        var t2 = e3.registry, n3 = e3.documentId, o3 = t2.getPlugin(fi);
        if (o3 && o3.provides) {
          var i3 = o3.provides();
          if (i3) i3.forDocument(n3).toggleMenu("document-menu", "document:menu", "document-menu-button");
        }
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins.ui) || void 0 === t2 ? void 0 : t2.documents[o3];
        return void 0 !== (null == i3 ? void 0 : i3.openMenus["document-menu"]);
      } }, "document:open": { id: "document:open", labelKey: "document.open", icon: "fileImport", shortcuts: ["Ctrl+O", "Meta+O"], categories: ["document", "document-open"], action: function(e3) {
        var t2, n3 = null === (t2 = e3.registry.getPlugin("document-manager")) || void 0 === t2 ? void 0 : t2.provides();
        null == n3 || n3.openFileDialog();
      } }, "document:close": { id: "document:close", labelKey: "document.close", icon: "x", shortcuts: ["Ctrl+W", "Meta+W"], categories: ["document", "document-close"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("document-manager")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.closeDocument(o3);
      } }, "document:print": { id: "document:print", labelKey: "document.print", icon: "print", shortcuts: ["Ctrl+P", "Meta+P"], categories: ["document", "document-print"], action: function(e3) {
        var t2 = e3.registry, n3 = e3.documentId, o3 = t2.getPlugin(fi);
        if (o3 && o3.provides) {
          var i3 = o3.provides();
          if (i3) i3.forDocument(n3).openModal("print-modal");
        }
      } }, "document:export": { id: "document:export", labelKey: "document.export", icon: "download", categories: ["document", "document-export"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("export")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).download();
      } }, "document:fullscreen": { id: "document:fullscreen", labelKey: "document.fullscreen", icon: function(e3) {
        var t2;
        return null !== (t2 = e3.state.plugins.fullscreen) && void 0 !== t2 && t2.isFullscreen ? "fullscreenExit" : "fullscreen";
      }, shortcuts: ["F11"], categories: ["document", "document-fullscreen"], action: function(e3) {
        var t2, n3 = null === (t2 = e3.registry.getPlugin("fullscreen")) || void 0 === t2 ? void 0 : t2.provides();
        n3 && (n3.isFullscreen() ? n3.exitFullscreen() : n3.enableFullscreen());
      }, active: function(e3) {
        var t2, n3;
        return null !== (t2 = null === (n3 = e3.state.plugins.fullscreen) || void 0 === n3 ? void 0 : n3.isFullscreen) && void 0 !== t2 && t2;
      } }, "panel:toggle-sidebar": { id: "panel:toggle-sidebar", labelKey: "panel.sidebar", icon: "sidebar", categories: ["panel", "panel-sidebar"], action: function(e3) {
        var t2 = e3.registry, n3 = e3.documentId, o3 = t2.getPlugin(fi);
        if (o3 && o3.provides) {
          var i3 = o3.provides();
          if (i3) i3.forDocument(n3).toggleSidebar("left", "main", "sidebar-panel");
        }
      }, active: function(e3) {
        var t2 = e3.state, n3 = e3.documentId;
        return xr(t2.plugins, n3, "left", "main", "sidebar-panel");
      } }, "panel:toggle-search": { id: "panel:toggle-search", labelKey: "panel.search", icon: "search", shortcuts: ["Ctrl+F", "Meta+F"], categories: ["panel", "panel-search"], action: function(e3) {
        var t2 = e3.registry, n3 = e3.documentId, o3 = t2.getPlugin(fi);
        if (o3 && o3.provides) {
          var i3 = o3.provides();
          if (i3) i3.forDocument(n3).toggleSidebar("right", "main", "search-panel");
        }
      }, active: function(e3) {
        var t2 = e3.state, n3 = e3.documentId;
        return xr(t2.plugins, n3, "right", "main", "search-panel");
      } }, "panel:toggle-comment": { id: "panel:toggle-comment", labelKey: "panel.comment", icon: "comment", categories: ["panel", "panel-comment"], action: function(e3) {
        var t2 = e3.registry, n3 = e3.documentId, o3 = t2.getPlugin(fi);
        if (o3 && o3.provides) {
          var i3 = o3.provides();
          if (i3) i3.forDocument(n3).toggleSidebar("right", "main", "comment-panel");
        }
      }, active: function(e3) {
        var t2 = e3.state, n3 = e3.documentId;
        return xr(t2.plugins, n3, "right", "main", "comment-panel");
      } }, "panel:toggle-annotation-style": { id: "panel:toggle-annotation-style", labelKey: "panel.annotationStyle", icon: "palette", categories: ["panel", "panel-annotation-style"], action: function(e3) {
        var t2 = e3.registry, n3 = e3.documentId, o3 = t2.getPlugin(fi);
        if (o3 && o3.provides) {
          var i3 = o3.provides();
          if (i3) i3.forDocument(n3).toggleSidebar("left", "main", "annotation-panel");
        }
      }, active: function(e3) {
        var t2 = e3.state, n3 = e3.documentId;
        return xr(t2.plugins, n3, "left", "main", "annotation-panel");
      } }, "page:settings": { id: "page:settings", labelKey: "page.settings", icon: "viewSettings", categories: ["page", "page-settings"], action: function(e3) {
        var t2 = e3.registry, n3 = e3.documentId, o3 = t2.getPlugin(fi);
        if (o3 && o3.provides) {
          var i3 = o3.provides();
          if (i3) i3.forDocument(n3).toggleMenu("page-settings-menu", "page:settings", "page-settings-button");
        }
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins.ui) || void 0 === t2 ? void 0 : t2.documents[o3];
        return void 0 !== (null == i3 ? void 0 : i3.openMenus["page-settings-menu"]);
      } }, "spread:none": { id: "spread:none", labelKey: "page.single", icon: "singlePage", categories: ["page", "spread", "spread-none"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("spread")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).setSpreadMode(ri.None);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return (null === (t2 = n3.plugins.spread) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.spreadMode) === ri.None;
      } }, "spread:odd": { id: "spread:odd", labelKey: "page.twoOdd", icon: "doublePage", categories: ["page", "spread", "spread-odd"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("spread")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).setSpreadMode(ri.Odd);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return (null === (t2 = n3.plugins.spread) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.spreadMode) === ri.Odd;
      } }, "spread:even": { id: "spread:even", labelKey: "page.twoEven", icon: "book2", categories: ["page", "spread", "spread-even"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("spread")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).setSpreadMode(ri.Even);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return (null === (t2 = n3.plugins.spread) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.spreadMode) === ri.Even;
      } }, "rotate:clockwise": { id: "rotate:clockwise", labelKey: "rotate.clockwise", icon: "rotateClockwise", shortcuts: ["Ctrl+]", "Meta+]"], categories: ["page", "rotate", "rotate-clockwise"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("rotate")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).rotateForward();
      } }, "rotate:counter-clockwise": { id: "rotate:counter-clockwise", labelKey: "rotate.counterClockwise", icon: "rotateCounterClockwise", shortcuts: ["Ctrl+[", "Meta+["], categories: ["page", "rotate", "rotate-counter-clockwise"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("rotate")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).rotateBackward();
      } }, "scroll:vertical": { id: "scroll:vertical", labelKey: "page.vertical", icon: "vertical", categories: ["page", "scroll", "scroll-vertical"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("scroll")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).setScrollStrategy(Uo.Vertical);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return (null === (t2 = n3.plugins.scroll) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.strategy) === Uo.Vertical;
      } }, "scroll:horizontal": { id: "scroll:horizontal", labelKey: "page.horizontal", icon: "horizontal", categories: ["page", "scroll", "scroll-horizontal"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("scroll")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).setScrollStrategy(Uo.Horizontal);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return (null === (t2 = n3.plugins.scroll) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.strategy) === Uo.Horizontal;
      } }, "scroll:next-page": { id: "scroll:next-page", labelKey: "page.next", icon: "chevronRight", categories: ["page", "navigation", "navigation-next"], shortcuts: ["Ctrl+]", "Meta+]", "ArrowRight"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("scroll")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).scrollToNextPage();
      }, disabled: function(e3) {
        var t2, n3, o3 = e3.state, i3 = e3.documentId;
        return (null === (t2 = o3.plugins.scroll) || void 0 === t2 || null === (t2 = t2.documents[i3]) || void 0 === t2 ? void 0 : t2.currentPage) >= (null === (n3 = o3.plugins.scroll) || void 0 === n3 || null === (n3 = n3.documents[i3]) || void 0 === n3 ? void 0 : n3.totalPages);
      } }, "scroll:previous-page": { id: "scroll:previous-page", labelKey: "page.previous", icon: "chevronLeft", categories: ["page", "navigation", "navigation-previous"], shortcuts: ["Ctrl+[", "Meta+[", "ArrowLeft"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("scroll")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).scrollToPreviousPage();
      }, disabled: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return (null === (t2 = n3.plugins.scroll) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.currentPage) <= 1;
      } }, "mode:view": { id: "mode:view", labelKey: "mode.view", categories: ["mode", "mode-view"], action: function(e3) {
        var t2, n3, o3 = e3.registry, i3 = e3.documentId, r2 = null === (t2 = o3.getPlugin("ui")) || void 0 === t2 ? void 0 : t2.provides(), a3 = null === (n3 = o3.getPlugin("interaction-manager")) || void 0 === n3 ? void 0 : n3.provides();
        if (r2 && a3) {
          var s4 = a3.forDocument(i3);
          s4 && (s4.activate("pointerMode"), r2.forDocument(i3).closeToolbarSlot("top", "secondary"));
        }
      }, active: function(e3) {
        var t2 = e3.state, n3 = e3.documentId;
        return !wr(t2.plugins, n3, "top", "secondary");
      } }, "mode:annotate": { id: "mode:annotate", labelKey: "mode.annotate", categories: ["mode", "mode-annotate", "annotation"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("ui")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.setActiveToolbar("top", "secondary", "annotation-toolbar", o3);
      }, active: function(e3) {
        var t2 = e3.state, n3 = e3.documentId;
        return wr(t2.plugins, n3, "top", "secondary", "annotation-toolbar");
      } }, "mode:shapes": { id: "mode:shapes", labelKey: "mode.shapes", categories: ["mode", "mode-shapes", "annotation"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("ui")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.setActiveToolbar("top", "secondary", "shapes-toolbar", o3);
      }, active: function(e3) {
        var t2 = e3.state, n3 = e3.documentId;
        return wr(t2.plugins, n3, "top", "secondary", "shapes-toolbar");
      } }, "mode:redact": { id: "mode:redact", labelKey: "mode.redact", categories: ["mode", "mode-redact", "redaction"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("ui")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.setActiveToolbar("top", "secondary", "redaction-toolbar", o3);
      }, active: function(e3) {
        var t2 = e3.state, n3 = e3.documentId;
        return wr(t2.plugins, n3, "top", "secondary", "redaction-toolbar");
      } }, "tabs:overflow-menu": { id: "tabs:overflow-menu", labelKey: "tabs.overflowMenu", icon: "dots", categories: ["ui", "ui-menu"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("ui")) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.toggleMenu("mode-tabs-overflow-menu", "tabs:overflow-menu", "overflow-tabs-button", o3);
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId;
        return void 0 !== (null === (t2 = n3.plugins.ui) || void 0 === t2 || null === (t2 = t2.documents[o3]) || void 0 === t2 ? void 0 : t2.openMenus["mode-tabs-overflow-menu"]);
      } }, "annotation:add-highlight": { id: "annotation:add-highlight", labelKey: "annotation.highlight", icon: "highlight", iconProps: function(e3) {
        var t2;
        return { primaryColor: null === (t2 = pc(e3.state.plugins.annotation, "highlight")) || void 0 === t2 ? void 0 : t2.color };
      }, categories: ["annotation", "annotation-markup", "annotation-highlight"], action: function(e3) {
        var t2, n3, o3, i3 = e3.registry, r2 = e3.documentId, s4 = null === (t2 = i3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), l4 = null === (n3 = i3.getPlugin(ps)) || void 0 === n3 ? void 0 : n3.provides(), c4 = null === (o3 = i3.getPlugin("ui")) || void 0 === o3 ? void 0 : o3.provides();
        if (l4 && s4 && c4) {
          var d4 = null == s4 ? void 0 : s4.forDocument(r2), u4 = null == l4 ? void 0 : l4.forDocument(r2);
          if (d4 && u4) {
            var h3 = s4.getTool("highlight");
            if (h3 && qc(h3)) {
              var m3 = h3.defaults, g3 = u4.getFormattedSelection(), p4 = u4.getSelectedText();
              if (g3.length > 0) {
                var v2, f2 = a2(g3);
                try {
                  var y2 = function() {
                    var e4 = v2.value;
                    p4.wait(function(t3) {
                      var n4 = yn();
                      d4.createAnnotation(e4.pageIndex, { id: n4, created: /* @__PURE__ */ new Date(), flags: ["print"], type: Dt.HIGHLIGHT, blendMode: It.Multiply, color: m3.color, opacity: m3.opacity, pageIndex: e4.pageIndex, rect: e4.rect, segmentRects: e4.segmentRects, custom: { text: t3.join("\n") } }), d4.selectAnnotation(e4.pageIndex, n4);
                    }, wn);
                  };
                  for (f2.s(); !(v2 = f2.n()).done; ) y2();
                } catch (e4) {
                  f2.e(e4);
                } finally {
                  f2.f();
                }
                u4.clear(), d4.setActiveTool("highlight"), c4.setActiveToolbar("top", "secondary", "annotation-toolbar", r2);
              } else {
                var b2;
                "highlight" === (null === (b2 = d4.getActiveTool()) || void 0 === b2 ? void 0 : b2.id) ? d4.setActiveTool(null) : d4.setActiveTool("highlight");
              }
            }
          }
        }
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "highlight" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-underline": { id: "annotation:add-underline", labelKey: "annotation.underline", icon: "underline", iconProps: function(e3) {
        var t2;
        return { primaryColor: null === (t2 = pc(e3.state.plugins.annotation, "underline")) || void 0 === t2 ? void 0 : t2.color };
      }, categories: ["annotation", "annotation-markup", "annotation-underline"], action: function(e3) {
        var t2, n3, o3, i3 = e3.registry, r2 = e3.documentId, s4 = null === (t2 = i3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), l4 = null === (n3 = i3.getPlugin(ps)) || void 0 === n3 ? void 0 : n3.provides(), c4 = null === (o3 = i3.getPlugin("ui")) || void 0 === o3 ? void 0 : o3.provides();
        if (l4 && s4 && c4) {
          var d4 = null == s4 ? void 0 : s4.forDocument(r2), u4 = null == l4 ? void 0 : l4.forDocument(r2);
          if (d4 && u4) {
            var h3 = s4.getTool("underline");
            if (h3 && Vc(h3)) {
              var m3 = h3.defaults, g3 = u4.getFormattedSelection(), p4 = u4.getSelectedText();
              if (g3.length > 0) {
                var v2, f2 = a2(g3);
                try {
                  var y2 = function() {
                    var e4 = v2.value;
                    p4.wait(function(t3) {
                      var n4 = yn();
                      d4.createAnnotation(e4.pageIndex, { id: n4, created: /* @__PURE__ */ new Date(), flags: ["print"], type: Dt.UNDERLINE, color: m3.color, opacity: m3.opacity, pageIndex: e4.pageIndex, rect: e4.rect, segmentRects: e4.segmentRects, custom: { text: t3.join("\n") } }), d4.selectAnnotation(e4.pageIndex, n4);
                    }, wn);
                  };
                  for (f2.s(); !(v2 = f2.n()).done; ) y2();
                } catch (e4) {
                  f2.e(e4);
                } finally {
                  f2.f();
                }
                u4.clear(), d4.setActiveTool("underline"), c4.setActiveToolbar("top", "secondary", "annotation-toolbar", r2);
              } else {
                var b2;
                "underline" === (null === (b2 = d4.getActiveTool()) || void 0 === b2 ? void 0 : b2.id) ? d4.setActiveTool(null) : d4.setActiveTool("underline");
              }
            }
          }
        }
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "underline" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-strikeout": { id: "annotation:add-strikeout", labelKey: "annotation.strikeout", icon: "strikethrough", iconProps: function(e3) {
        var t2;
        return { primaryColor: null === (t2 = pc(e3.state.plugins.annotation, "strikeout")) || void 0 === t2 ? void 0 : t2.color };
      }, categories: ["annotation", "annotation-markup", "annotation-strikeout"], action: function(e3) {
        var t2, n3, o3, i3 = e3.registry, r2 = e3.documentId, s4 = null === (t2 = i3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), l4 = null === (n3 = i3.getPlugin(ps)) || void 0 === n3 ? void 0 : n3.provides(), c4 = null === (o3 = i3.getPlugin("ui")) || void 0 === o3 ? void 0 : o3.provides();
        if (l4 && s4 && c4) {
          var d4 = null == s4 ? void 0 : s4.forDocument(r2), u4 = null == l4 ? void 0 : l4.forDocument(r2);
          if (d4 && u4) {
            var h3 = s4.getTool("strikeout");
            if (h3 && Zc(h3)) {
              var m3 = h3.defaults, g3 = u4.getFormattedSelection(), p4 = u4.getSelectedText();
              if (g3.length > 0) {
                var v2, f2 = a2(g3);
                try {
                  var y2 = function() {
                    var e4 = v2.value;
                    p4.wait(function(t3) {
                      var n4 = yn();
                      d4.createAnnotation(e4.pageIndex, { id: n4, created: /* @__PURE__ */ new Date(), flags: ["print"], type: Dt.STRIKEOUT, color: m3.color, opacity: m3.opacity, pageIndex: e4.pageIndex, rect: e4.rect, segmentRects: e4.segmentRects, custom: { text: t3.join("\n") } }), d4.selectAnnotation(e4.pageIndex, n4);
                    }, wn);
                  };
                  for (f2.s(); !(v2 = f2.n()).done; ) y2();
                } catch (e4) {
                  f2.e(e4);
                } finally {
                  f2.f();
                }
                u4.clear(), d4.setActiveTool("strikeout"), c4.setActiveToolbar("top", "secondary", "annotation-toolbar", r2);
              } else {
                var b2;
                "strikeout" === (null === (b2 = d4.getActiveTool()) || void 0 === b2 ? void 0 : b2.id) ? d4.setActiveTool(null) : d4.setActiveTool("strikeout");
              }
            }
          }
        }
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "strikeout" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-squiggly": { id: "annotation:add-squiggly", labelKey: "annotation.squiggly", icon: "squiggly", iconProps: function(e3) {
        var t2;
        return { primaryColor: null === (t2 = pc(e3.state.plugins.annotation, "squiggly")) || void 0 === t2 ? void 0 : t2.color };
      }, categories: ["annotation", "annotation-markup", "annotation-squiggly"], action: function(e3) {
        var t2, n3, o3, i3 = e3.registry, r2 = e3.documentId, s4 = null === (t2 = i3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), l4 = null === (n3 = i3.getPlugin(ps)) || void 0 === n3 ? void 0 : n3.provides(), c4 = null === (o3 = i3.getPlugin("ui")) || void 0 === o3 ? void 0 : o3.provides();
        if (l4 && s4 && c4) {
          var d4 = null == s4 ? void 0 : s4.forDocument(r2), u4 = null == l4 ? void 0 : l4.forDocument(r2);
          if (d4 && u4) {
            var h3 = s4.getTool("squiggly");
            if (h3 && Gc(h3)) {
              var m3 = h3.defaults, g3 = u4.getFormattedSelection(), p4 = u4.getSelectedText();
              if (g3.length > 0) {
                var v2, f2 = a2(g3);
                try {
                  var y2 = function() {
                    var e4 = v2.value;
                    p4.wait(function(t3) {
                      var n4 = yn();
                      d4.createAnnotation(e4.pageIndex, { id: n4, created: /* @__PURE__ */ new Date(), flags: ["print"], type: Dt.SQUIGGLY, color: m3.color, opacity: m3.opacity, pageIndex: e4.pageIndex, rect: e4.rect, segmentRects: e4.segmentRects, custom: { text: t3.join("\n") } }), d4.selectAnnotation(e4.pageIndex, n4);
                    }, wn);
                  };
                  for (f2.s(); !(v2 = f2.n()).done; ) y2();
                } catch (e4) {
                  f2.e(e4);
                } finally {
                  f2.f();
                }
                u4.clear(), d4.setActiveTool("squiggly"), c4.setActiveToolbar("top", "secondary", "annotation-toolbar", r2);
              } else {
                var b2;
                "squiggly" === (null === (b2 = d4.getActiveTool()) || void 0 === b2 ? void 0 : b2.id) ? d4.setActiveTool(null) : d4.setActiveTool("squiggly");
              }
            }
          }
        }
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "squiggly" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-ink": { id: "annotation:add-ink", labelKey: "annotation.ink", icon: "pencilMarker", iconProps: function(e3) {
        var t2;
        return { primaryColor: null === (t2 = pc(e3.state.plugins.annotation, "ink")) || void 0 === t2 ? void 0 : t2.color };
      }, categories: ["annotation", "annotation-ink"], action: function(e3) {
        var t2, n3, o3 = e3.registry, i3 = e3.documentId, r2 = null === (t2 = o3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), a3 = null == r2 ? void 0 : r2.forDocument(i3);
        a3 && ("ink" === (null === (n3 = a3.getActiveTool()) || void 0 === n3 ? void 0 : n3.id) ? a3.setActiveTool(null) : a3.setActiveTool("ink"));
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "ink" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-text": { id: "annotation:add-text", labelKey: "annotation.text", icon: "text", iconProps: function(e3) {
        var t2;
        return { primaryColor: null === (t2 = pc(e3.state.plugins.annotation, "freeText")) || void 0 === t2 ? void 0 : t2.fontColor };
      }, categories: ["annotation", "annotation-text"], action: function(e3) {
        var t2, n3, o3 = e3.registry, i3 = e3.documentId, r2 = null === (t2 = o3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), a3 = null == r2 ? void 0 : r2.forDocument(i3);
        a3 && ("freeText" === (null === (n3 = a3.getActiveTool()) || void 0 === n3 ? void 0 : n3.id) ? a3.setActiveTool(null) : a3.setActiveTool("freeText"));
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "freeText" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-stamp": { id: "annotation:add-stamp", labelKey: "annotation.stamp", icon: "photo", categories: ["annotation", "annotation-stamp"], action: function(e3) {
        var t2, n3, o3 = e3.registry, i3 = e3.documentId, r2 = null === (t2 = o3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), a3 = null == r2 ? void 0 : r2.forDocument(i3);
        a3 && ("stamp" === (null === (n3 = a3.getActiveTool()) || void 0 === n3 ? void 0 : n3.id) ? a3.setActiveTool(null) : a3.setActiveTool("stamp"));
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "stamp" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-rectangle": { id: "annotation:add-rectangle", labelKey: "annotation.rectangle", icon: "square", iconProps: function(e3) {
        var t2, n3, o3 = e3.state;
        return { primaryColor: null === (t2 = pc(o3.plugins.annotation, "square")) || void 0 === t2 ? void 0 : t2.strokeColor, secondaryColor: null === (n3 = pc(o3.plugins.annotation, "square")) || void 0 === n3 ? void 0 : n3.color };
      }, categories: ["annotation", "annotation-shape", "annotation-rectangle"], action: function(e3) {
        var t2, n3, o3 = e3.registry, i3 = e3.documentId, r2 = null === (t2 = o3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), a3 = null == r2 ? void 0 : r2.forDocument(i3);
        a3 && ("square" === (null === (n3 = a3.getActiveTool()) || void 0 === n3 ? void 0 : n3.id) ? a3.setActiveTool(null) : a3.setActiveTool("square"));
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "square" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-circle": { id: "annotation:add-circle", labelKey: "annotation.circle", icon: "circle", iconProps: function(e3) {
        var t2, n3, o3 = e3.state;
        return { primaryColor: null === (t2 = pc(o3.plugins.annotation, "circle")) || void 0 === t2 ? void 0 : t2.strokeColor, secondaryColor: null === (n3 = pc(o3.plugins.annotation, "circle")) || void 0 === n3 ? void 0 : n3.color };
      }, categories: ["annotation", "annotation-shape", "annotation-circle"], action: function(e3) {
        var t2, n3, o3 = e3.registry, i3 = e3.documentId, r2 = null === (t2 = o3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), a3 = null == r2 ? void 0 : r2.forDocument(i3);
        a3 && ("circle" === (null === (n3 = a3.getActiveTool()) || void 0 === n3 ? void 0 : n3.id) ? a3.setActiveTool(null) : a3.setActiveTool("circle"));
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "circle" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-line": { id: "annotation:add-line", labelKey: "annotation.line", icon: "line", iconProps: function(e3) {
        var t2;
        return { primaryColor: null === (t2 = pc(e3.state.plugins.annotation, "line")) || void 0 === t2 ? void 0 : t2.strokeColor };
      }, categories: ["annotation", "annotation-shape", "annotation-line"], action: function(e3) {
        var t2, n3, o3 = e3.registry, i3 = e3.documentId, r2 = null === (t2 = o3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), a3 = null == r2 ? void 0 : r2.forDocument(i3);
        a3 && ("line" === (null === (n3 = a3.getActiveTool()) || void 0 === n3 ? void 0 : n3.id) ? a3.setActiveTool(null) : a3.setActiveTool("line"));
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "line" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-arrow": { id: "annotation:add-arrow", labelKey: "annotation.arrow", icon: "lineArrow", iconProps: function(e3) {
        var t2;
        return { primaryColor: null === (t2 = pc(e3.state.plugins.annotation, "line")) || void 0 === t2 ? void 0 : t2.strokeColor };
      }, categories: ["annotation", "annotation-shape", "annotation-arrow"], action: function(e3) {
        var t2, n3, o3 = e3.registry, i3 = e3.documentId, r2 = null === (t2 = o3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), a3 = null == r2 ? void 0 : r2.forDocument(i3);
        a3 && ("lineArrow" === (null === (n3 = a3.getActiveTool()) || void 0 === n3 ? void 0 : n3.id) ? a3.setActiveTool(null) : a3.setActiveTool("lineArrow"));
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "lineArrow" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-polygon": { id: "annotation:add-polygon", labelKey: "annotation.polygon", icon: "polygon", iconProps: function(e3) {
        var t2, n3, o3 = e3.state;
        return { primaryColor: null === (t2 = pc(o3.plugins.annotation, "polygon")) || void 0 === t2 ? void 0 : t2.strokeColor, secondaryColor: null === (n3 = pc(o3.plugins.annotation, "polygon")) || void 0 === n3 ? void 0 : n3.color };
      }, categories: ["annotation", "annotation-shape", "annotation-polygon"], action: function(e3) {
        var t2, n3, o3 = e3.registry, i3 = e3.documentId, r2 = null === (t2 = o3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), a3 = null == r2 ? void 0 : r2.forDocument(i3);
        a3 && ("polygon" === (null === (n3 = a3.getActiveTool()) || void 0 === n3 ? void 0 : n3.id) ? a3.setActiveTool(null) : a3.setActiveTool("polygon"));
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "polygon" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:add-polyline": { id: "annotation:add-polyline", labelKey: "annotation.polyline", icon: "zigzag", iconProps: function(e3) {
        var t2;
        return { primaryColor: null === (t2 = pc(e3.state.plugins.annotation, "polyline")) || void 0 === t2 ? void 0 : t2.strokeColor };
      }, categories: ["annotation", "annotation-shape", "annotation-polyline"], action: function(e3) {
        var t2, n3, o3 = e3.registry, i3 = e3.documentId, r2 = null === (t2 = o3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), a3 = null == r2 ? void 0 : r2.forDocument(i3);
        a3 && ("polyline" === (null === (n3 = a3.getActiveTool()) || void 0 === n3 ? void 0 : n3.id) ? a3.setActiveTool(null) : a3.setActiveTool("polyline"));
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Tl]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return "polyline" === (null == i3 ? void 0 : i3.activeToolId);
      } }, "annotation:delete-selected": { id: "annotation:delete-selected", labelKey: "annotation.deleteSelected", icon: "trash", categories: ["annotation", "annotation-delete"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin(Tl)) || void 0 === t2 ? void 0 : t2.provides(), r2 = null == i3 ? void 0 : i3.forDocument(o3);
        if (r2) {
          var a3 = r2.getSelectedAnnotation();
          a3 && r2.deleteAnnotation(a3.object.pageIndex, a3.object.id);
        }
      } }, "annotation:overflow-tools": { id: "annotation:overflow-tools", labelKey: "annotation.moreTools", icon: "dots", categories: ["annotation", "annotation-overflow"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("ui")) || void 0 === t2 ? void 0 : t2.provides();
        if (i3) {
          var r2 = i3.forDocument(o3);
          r2 && r2.toggleMenu("annotation-tools-menu", "annotation:overflow-tools", "overflow-annotation-tools");
        }
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins.ui) || void 0 === t2 ? void 0 : t2.documents[o3];
        return void 0 !== (null == i3 ? void 0 : i3.openMenus["annotation-tools-menu"]);
      } }, "annotation:overflow-shapes": { id: "annotation:overflow-shapes", labelKey: "annotation.moreTools", icon: "dots", categories: ["annotation", "annotation-shape", "annotation-overflow"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("ui")) || void 0 === t2 ? void 0 : t2.provides();
        if (i3) {
          var r2 = i3.forDocument(o3);
          r2 && r2.toggleMenu("shapes-tools-menu", "annotation:overflow-shapes", "overflow-shapes-tools");
        }
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins.ui) || void 0 === t2 ? void 0 : t2.documents[o3];
        return void 0 !== (null == i3 ? void 0 : i3.openMenus["shapes-tools-menu"]);
      } }, "redaction:redact-area": { id: "redaction:redact-area", labelKey: "redaction.area", icon: "redactArea", categories: ["redaction", "redaction-area"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("redaction")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).toggleMarqueeRedact();
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[dh]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return (null == i3 ? void 0 : i3.activeType) === qu.MarqueeRedact;
      } }, "redaction:redact-text": { id: "redaction:redact-text", labelKey: "redaction.text", icon: "redact", categories: ["redaction", "redaction-text"], action: function(e3) {
        var t2, n3, o3, i3, r2 = e3.registry, a3 = e3.documentId, s4 = null === (t2 = r2.getPlugin("redaction")) || void 0 === t2 ? void 0 : t2.provides(), l4 = null === (n3 = r2.getPlugin(ps)) || void 0 === n3 ? void 0 : n3.provides(), c4 = null === (o3 = r2.getPlugin("ui")) || void 0 === o3 ? void 0 : o3.provides();
        if (s4 && l4 && c4) {
          var d4 = s4.forDocument(a3), u4 = null == l4 ? void 0 : l4.forDocument(a3);
          (null !== (i3 = null == u4 ? void 0 : u4.getFormattedSelection()) && void 0 !== i3 ? i3 : []).length > 0 ? (d4.queueCurrentSelectionAsPending(), c4.setActiveToolbar("top", "secondary", "redaction-toolbar", a3)) : d4.toggleRedactSelection();
        }
      }, active: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[dh]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return (null == i3 ? void 0 : i3.activeType) === qu.RedactSelection;
      } }, "redaction:apply-all": { id: "redaction:apply-all", labelKey: "redaction.applyAll", icon: "check", categories: ["redaction", "redaction-apply"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("redaction")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).commitAllPending();
      }, disabled: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[dh]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return 0 === (null == i3 ? void 0 : i3.pendingCount);
      } }, "redaction:clear-all": { id: "redaction:clear-all", labelKey: "redaction.clearAll", icon: "x", categories: ["redaction", "redaction-clear"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("redaction")) || void 0 === t2 ? void 0 : t2.provides();
        null == i3 || i3.forDocument(o3).clearPending();
      }, disabled: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[dh]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return 0 === (null == i3 ? void 0 : i3.pendingCount);
      } }, "redaction:delete-selected": { id: "redaction:delete-selected", labelKey: "redaction.deleteSelected", icon: "trash", categories: ["redaction", "redaction-delete"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("redaction")) || void 0 === t2 ? void 0 : t2.provides(), r2 = null == i3 ? void 0 : i3.forDocument(o3).getSelectedPending();
        r2 && (null == i3 || i3.forDocument(o3).removePending(r2.page, r2.id));
      } }, "redaction:commit-selected": { id: "redaction:commit-selected", labelKey: "redaction.commitSelected", icon: "check", categories: ["redaction", "redaction-commit"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin("redaction")) || void 0 === t2 ? void 0 : t2.provides(), r2 = null == i3 ? void 0 : i3.forDocument(o3).getSelectedPending();
        r2 && (null == i3 || i3.forDocument(o3).commitPending(r2.page, r2.id));
      } }, "selection:copy-to-clipboard": { id: "selection:copy-to-clipboard", labelKey: "selection.copyToClipboard", icon: "copy", shortcuts: ["Ctrl+C", "Meta+C"], categories: ["selection", "selection-copy-to-clipboard"], action: function(e3) {
        var t2 = e3.registry, n3 = e3.documentId, o3 = t2.getPlugin("selection"), i3 = null == o3 ? void 0 : o3.provides().forDocument(n3);
        null == i3 || i3.copyToClipboard();
      } }, "selection:copy": { id: "selection:copy", labelKey: "selection.copy", icon: "copy", categories: ["selection", "selection-copy"], action: function(e3) {
        var t2 = e3.registry, n3 = e3.documentId, o3 = t2.getPlugin("selection"), i3 = null == o3 ? void 0 : o3.provides().forDocument(n3);
        null == i3 || i3.copyToClipboard(), null == i3 || i3.clear();
      } }, "history:undo": { id: "history:undo", labelKey: "history.undo", icon: "arrowBackUp", shortcuts: ["Ctrl+Z", "Meta+Z"], categories: ["history", "history-undo"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin(Nu)) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).undo();
      }, disabled: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Nu]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return !(null != i3 && i3.global.canUndo);
      } }, "history:redo": { id: "history:redo", labelKey: "history.redo", icon: "arrowForwardUp", shortcuts: ["Ctrl+Y", "Meta+Shift+Z"], categories: ["history", "history-redo"], action: function(e3) {
        var t2, n3 = e3.registry, o3 = e3.documentId, i3 = null === (t2 = n3.getPlugin(Nu)) || void 0 === t2 ? void 0 : t2.provides();
        i3 && i3.forDocument(o3).redo();
      }, disabled: function(e3) {
        var t2, n3 = e3.state, o3 = e3.documentId, i3 = null === (t2 = n3.plugins[Nu]) || void 0 === t2 ? void 0 : t2.documents[o3];
        return !(null != i3 && i3.global.canRedo);
      } } } }, i18n: { defaultLocale: "en", locales: [{ code: "en", name: "English", translations: { search: { placeholder: "Search", caseSensitive: "Case sensitive", wholeWord: "Whole word", resultsFound: "{count} results found", page: "Page {page}" }, zoom: { in: "Zoom In", out: "Zoom Out", fitWidth: "Fit to Width", fitPage: "Fit to Page", marquee: "Marquee Zoom", menu: "Zoom Menu", level: "Zoom Level ({level}%)" }, pan: { toggle: "Toggle Pan Mode" }, pointer: { toggle: "Toggle Pointer Mode" }, capture: { screenshot: "Screenshot" }, document: { menu: "Document Menu", open: "Open", close: "Close", print: "Print", export: "Export", fullscreen: "Fullscreen", loading: "Loading document..." }, emptyState: { title: "No Documents Open", description: "Open a PDF document to get started.", descriptionMulti: "You can view multiple documents using tabs.", openButton: "Open Document", supportedFormats: "Supported format: PDF" }, passwordPrompt: { title: "Password Required", required: "This document is password protected. Please enter the password to open it.", incorrect: "The password you entered was incorrect. Please try again.", incorrectWarning: "Incorrect password. Please check and try again.", label: "Password", placeholder: "Enter document password", open: "Open", opening: "Opening...", cancel: "Cancel", close: "Close" }, documentError: { title: "Error loading document", unknown: "An unknown error occurred", errorCode: "Error Code: {code}", close: "Close Document" }, panel: { sidebar: "Sidebar", search: "Search", comment: "Comment", thumbnails: "Thumbnails", outline: "Outline", annotationStyle: "Annotation Style" }, menu: { viewControls: "View Controls", zoomControls: "Zoom Controls", moreOptions: "More Options" }, outline: { title: "Outline", loading: "Loading outline...", noOutline: "No outline available", noBookmarks: "This document doesn't contain bookmarks" }, page: { settings: "Page Settings", single: "Single Page", twoOdd: "Two Page (Odd)", twoEven: "Two Page (Even)", vertical: "Vertical", horizontal: "Horizontal", spreadMode: "Spread Mode", scrollLayout: "Scroll Layout", rotation: "Page Rotation", next: "Next Page", previous: "Previous Page" }, rotate: { clockwise: "Rotate Clockwise", counterClockwise: "Rotate Counter-Clockwise" }, selection: { copy: "Copy Selection" }, mode: { view: "View", annotate: "Annotate", shapes: "Shapes", redact: "Redact" }, annotation: { text: "Text", highlight: "Highlight", strikeout: "Strikethrough", underline: "Underline", squiggly: "Squiggly", rectangle: "Rectangle", circle: "Circle", line: "Line", arrow: "Arrow", polygon: "Polygon", polyline: "Polyline", ink: "Ink", stamp: "Stamp", freeText: "Free Text", square: "Square", styles: "{type} Styles", defaults: "{type} Defaults", color: "Color", opacity: "Opacity", blendMode: "Blend mode", strokeWidth: "Stroke width", strokeColor: "Stroke color", borderStyle: "Border style", fillColor: "Fill color", fontSize: "Font size", fontFamily: "Font", textAlign: "Text alignment", verticalAlign: "Vertical alignment", lineEnding: "Line ending", lineStart: "Line start", lineEnd: "Line end", font: "Font", fontColor: "Font color", backgroundColor: "Background color", noStyles: "There are no styles for this annotation.", noStylesStamp: "There are no styles for stamps.", selectAnnotation: "Select an annotation to see styles", deleteSelected: "Delete selected annotation", moreTools: "More Tools" }, redaction: { area: "Redact Area", text: "Redact Text", applyAll: "Apply All", clearAll: "Clear All" }, history: { undo: "Undo", redo: "Redo" }, comments: { page: "Page {page}", commentCount: "{count} comment", commentCountPlural: "{count} comments", addComment: "Add comment...", addReply: "Add reply...", save: "Save", cancel: "Cancel", edit: "Edit", delete: "Delete", showMore: "more", showLess: "less", emptyState: "Add annotations to be able to comment on them." }, blendMode: { normal: "Normal", multiply: "Multiply", screen: "Screen", overlay: "Overlay", darken: "Darken", lighten: "Lighten", colorDodge: "Color Dodge", colorBurn: "Color Burn", hardLight: "Hard Light", softLight: "Soft Light", difference: "Difference", exclusion: "Exclusion", hue: "Hue", saturation: "Saturation", color: "Color", luminosity: "Luminosity" } } }, { code: "nl", name: "Nederlands", translations: { search: { placeholder: "Zoeken", caseSensitive: "Hoofdlettergevoelig", wholeWord: "Heel woord", resultsFound: "{count} resultaten gevonden", page: "Pagina {page}" }, zoom: { in: "Inzoomen", out: "Uitzoomen", fitWidth: "Aanbreedte aanpassen", fitPage: "Aan pagina aanpassen", marquee: "Lijstzoom", menu: "Zoommenu", level: "Zoomniveau ({level}%)" }, pan: { toggle: "Pan-modus wisselen" }, pointer: { toggle: "Aanwijzermodus wisselen" }, capture: { screenshot: "Schermafbeelding" }, document: { menu: "Documentmenu", open: "Openen", close: "Sluiten", print: "Afdrukken", export: "Exporteren", fullscreen: "Volledig scherm", loading: "Document laden..." }, emptyState: { title: "Geen documenten geopend", description: "Open een PDF-document om te beginnen.", descriptionMulti: "U kunt meerdere documenten bekijken met tabs.", openButton: "Document openen", supportedFormats: "Ondersteund formaat: PDF" }, passwordPrompt: { title: "Wachtwoord vereist", required: "Dit document is beveiligd met een wachtwoord. Voer het wachtwoord in om te openen.", incorrect: "Het ingevoerde wachtwoord was onjuist. Probeer het opnieuw.", incorrectWarning: "Onjuist wachtwoord. Controleer en probeer opnieuw.", label: "Wachtwoord", placeholder: "Voer documentwachtwoord in", open: "Openen", opening: "Openen...", cancel: "Annuleren", close: "Sluiten" }, documentError: { title: "Fout bij laden van document", unknown: "Er is een onbekende fout opgetreden", errorCode: "Foutcode: {code}", close: "Document sluiten" }, panel: { sidebar: "Zijbalk", search: "Zoeken", comment: "Opmerking", thumbnails: "Miniaturen", outline: "Overzicht", annotationStyle: "Annotatiestijl" }, menu: { viewControls: "Weergave-instellingen", zoomControls: "Zoom-instellingen", moreOptions: "Meer opties" }, outline: { title: "Overzicht", loading: "Overzicht laden...", noOutline: "Geen overzicht beschikbaar", noBookmarks: "Dit document bevat geen bladwijzers" }, page: { settings: "Pagina-instellingen", single: "Enkele pagina", twoOdd: "Twee pagina's (Oneven)", twoEven: "Twee pagina's (Even)", vertical: "Verticaal", horizontal: "Horizontaal", spreadMode: "Spreidingsmodus", scrollLayout: "Scrollindeling", rotation: "Paginarotatie", next: "Volgende pagina", previous: "Vorige pagina" }, rotate: { clockwise: "Met de klok mee draaien", counterClockwise: "Tegen de klok in draaien" }, selection: { copy: "Selectie kopi\xEBren" }, mode: { view: "Weergave", annotate: "Annoteren", shapes: "Vormen", redact: "Redigeren" }, annotation: { text: "Tekst", highlight: "Markeren", strikeout: "Doorhalen", underline: "Onderstrepen", squiggly: "Golflijn", rectangle: "Rechthoek", circle: "Cirkel", line: "Lijn", arrow: "Pijl", polygon: "Veelhoek", polyline: "Polylijn", ink: "Inkt", stamp: "Stempel", freeText: "Vrije tekst", square: "Vierkant", styles: "{type} stijlen", defaults: "{type} standaardwaarden", color: "Kleur", opacity: "Dekking", blendMode: "Overvloeimodus", strokeWidth: "Lijndikte", strokeColor: "Lijnkleur", borderStyle: "Randstijl", fillColor: "Vulkleur", fontSize: "Lettergrootte", fontFamily: "Lettertype", textAlign: "Tekstuitlijning", verticalAlign: "Verticale uitlijning", lineEnding: "Lijneinde", lineStart: "Lijnbegin", lineEnd: "Lijneinde", font: "Lettertype", fontColor: "Tekstkleur", backgroundColor: "Achtergrondkleur", noStyles: "Er zijn geen stijlen voor deze annotatie.", noStylesStamp: "Er zijn geen stijlen voor stempels.", selectAnnotation: "Selecteer een annotatie om stijlen te zien", deleteSelected: "Geselecteerde annotatie verwijderen", moreTools: "Meer gereedschappen" }, redaction: { area: "Gebied redigeren", text: "Tekst redigeren", applyAll: "Alles toepassen", clearAll: "Alles wissen" }, history: { undo: "Ongedaan maken", redo: "Opnieuw doen" }, comments: { page: "Pagina {page}", commentCount: "{count} opmerking", commentCountPlural: "{count} opmerkingen", addComment: "Opmerking toevoegen...", addReply: "Antwoord toevoegen...", save: "Opslaan", cancel: "Annuleren", edit: "Bewerken", delete: "Verwijderen", showMore: "meer", showLess: "minder", emptyState: "Voeg annotaties toe om erop te kunnen reageren." }, blendMode: { normal: "Normaal", multiply: "Vermenigvuldigen", screen: "Bleken", overlay: "Bedekken", darken: "Donkerder", lighten: "Lichter", colorDodge: "Kleur tegenhouden", colorBurn: "Kleur doordrukken", hardLight: "Hard licht", softLight: "Zacht licht", difference: "Verschil", exclusion: "Uitsluiting", hue: "Kleurtoon", saturation: "Verzadiging", color: "Kleur", luminosity: "Helderheid" } } }, { code: "de", name: "Deutsch", translations: { search: { placeholder: "Suchen", caseSensitive: "Gro\xDF-/Kleinschreibung", wholeWord: "Ganzes Wort", resultsFound: "{count} Ergebnisse gefunden", page: "Seite {page}" }, zoom: { in: "Vergr\xF6\xDFern", out: "Verkleinern", fitWidth: "An Breite anpassen", fitPage: "An Seite anpassen", marquee: "Laufrahmen-Zoom", menu: "Zoom-Men\xFC", level: "Zoomstufe ({level}%)" }, pan: { toggle: "Verschieben-Modus umschalten" }, pointer: { toggle: "Zeiger-Modus umschalten" }, capture: { screenshot: "Screenshot" }, document: { menu: "Dokument-Men\xFC", open: "\xD6ffnen", close: "Schlie\xDFen", print: "Drucken", export: "Exportieren", fullscreen: "Vollbild", loading: "Dokument wird geladen..." }, emptyState: { title: "Keine Dokumente ge\xF6ffnet", description: "\xD6ffnen Sie ein PDF-Dokument, um zu beginnen.", descriptionMulti: "Sie k\xF6nnen mehrere Dokumente mit Tabs anzeigen.", openButton: "Dokument \xF6ffnen", supportedFormats: "Unterst\xFCtztes Format: PDF" }, passwordPrompt: { title: "Passwort erforderlich", required: "Dieses Dokument ist passwortgesch\xFCtzt. Bitte geben Sie das Passwort ein.", incorrect: "Das eingegebene Passwort war falsch. Bitte versuchen Sie es erneut.", incorrectWarning: "Falsches Passwort. Bitte \xFCberpr\xFCfen und erneut versuchen.", label: "Passwort", placeholder: "Dokumentpasswort eingeben", open: "\xD6ffnen", opening: "\xD6ffnen...", cancel: "Abbrechen", close: "Schlie\xDFen" }, documentError: { title: "Fehler beim Laden des Dokuments", unknown: "Ein unbekannter Fehler ist aufgetreten", errorCode: "Fehlercode: {code}", close: "Dokument schlie\xDFen" }, panel: { sidebar: "Seitenleiste", search: "Suchen", comment: "Kommentar", thumbnails: "Miniaturansichten", outline: "Gliederung", annotationStyle: "Anmerkungsstil" }, menu: { viewControls: "Ansichtseinstellungen", zoomControls: "Zoom-Einstellungen", moreOptions: "Weitere Optionen" }, outline: { title: "Gliederung", loading: "Gliederung wird geladen...", noOutline: "Keine Gliederung verf\xFCgbar", noBookmarks: "Dieses Dokument enth\xE4lt keine Lesezeichen" }, page: { settings: "Seiteneinstellungen", single: "Einzelseite", twoOdd: "Zwei Seiten (Ungerade)", twoEven: "Zwei Seiten (Gerade)", vertical: "Vertikal", horizontal: "Horizontal", spreadMode: "Doppelseiten-Modus", scrollLayout: "Scroll-Layout", rotation: "Seitendrehung", next: "N\xE4chste Seite", previous: "Vorherige Seite" }, rotate: { clockwise: "Im Uhrzeigersinn drehen", counterClockwise: "Gegen den Uhrzeigersinn drehen" }, selection: { copy: "Auswahl kopieren" }, mode: { view: "Ansicht", annotate: "Annotieren", shapes: "Formen", redact: "Schw\xE4rzen" }, annotation: { text: "Text", highlight: "Markieren", strikeout: "Durchstreichen", underline: "Unterstreichen", squiggly: "Wellenlinie", rectangle: "Rechteck", circle: "Kreis", line: "Linie", arrow: "Pfeil", polygon: "Polygon", polyline: "Polylinie", ink: "Freihand", stamp: "Stempel", freeText: "Freitext", square: "Quadrat", styles: "{type}-Stile", defaults: "{type}-Standardwerte", color: "Farbe", opacity: "Deckkraft", blendMode: "Mischmodus", strokeWidth: "Strichst\xE4rke", strokeColor: "Strichfarbe", borderStyle: "Rahmenstil", fillColor: "F\xFCllfarbe", fontSize: "Schriftgr\xF6\xDFe", fontFamily: "Schriftart", textAlign: "Textausrichtung", verticalAlign: "Vertikale Ausrichtung", lineEnding: "Linienende", lineStart: "Linienanfang", lineEnd: "Linienende", font: "Schriftart", fontColor: "Schriftfarbe", backgroundColor: "Hintergrundfarbe", noStyles: "F\xFCr diese Anmerkung gibt es keine Stile.", noStylesStamp: "F\xFCr Stempel gibt es keine Stile.", selectAnnotation: "W\xE4hlen Sie eine Anmerkung aus, um Stile anzuzeigen", deleteSelected: "Ausgew\xE4hlte Anmerkung l\xF6schen", moreTools: "Weitere Werkzeuge" }, redaction: { area: "Bereich schw\xE4rzen", text: "Text schw\xE4rzen", applyAll: "Alle anwenden", clearAll: "Alle l\xF6schen" }, history: { undo: "R\xFCckg\xE4ngig", redo: "Wiederholen" }, comments: { page: "Seite {page}", commentCount: "{count} Kommentar", commentCountPlural: "{count} Kommentare", addComment: "Kommentar hinzuf\xFCgen...", addReply: "Antwort hinzuf\xFCgen...", save: "Speichern", cancel: "Abbrechen", edit: "Bearbeiten", delete: "L\xF6schen", showMore: "mehr", showLess: "weniger", emptyState: "F\xFCgen Sie Anmerkungen hinzu, um sie kommentieren zu k\xF6nnen." }, blendMode: { normal: "Normal", multiply: "Multiplizieren", screen: "Negativ multiplizieren", overlay: "Ineinanderkopieren", darken: "Abdunkeln", lighten: "Aufhellen", colorDodge: "Farbig abwedeln", colorBurn: "Farbig nachbelichten", hardLight: "Hartes Licht", softLight: "Weiches Licht", difference: "Differenz", exclusion: "Ausschluss", hue: "Farbton", saturation: "S\xE4ttigung", color: "Farbe", luminosity: "Luminanz" } } }, { code: "fr", name: "Fran\xE7ais", translations: { search: { placeholder: "Rechercher", caseSensitive: "Respecter la casse", wholeWord: "Mot entier", resultsFound: "{count} r\xE9sultats trouv\xE9s", page: "Page {page}" }, zoom: { in: "Zoom avant", out: "Zoom arri\xE8re", fitWidth: "Ajuster \xE0 la largeur", fitPage: "Ajuster \xE0 la page", marquee: "Zoom de s\xE9lection", menu: "Menu Zoom", level: "Niveau de zoom ({level}%)" }, pan: { toggle: "Basculer le mode d\xE9placement" }, pointer: { toggle: "Basculer le mode pointeur" }, capture: { screenshot: "Capture d'\xE9cran" }, document: { menu: "Menu Document", open: "Ouvrir", close: "Fermer", print: "Imprimer", export: "Exporter", fullscreen: "Plein \xE9cran", loading: "Chargement du document..." }, emptyState: { title: "Aucun document ouvert", description: "Ouvrez un document PDF pour commencer.", descriptionMulti: "Vous pouvez afficher plusieurs documents avec des onglets.", openButton: "Ouvrir un document", supportedFormats: "Format pris en charge : PDF" }, passwordPrompt: { title: "Mot de passe requis", required: "Ce document est prot\xE9g\xE9 par mot de passe. Veuillez entrer le mot de passe.", incorrect: "Le mot de passe saisi est incorrect. Veuillez r\xE9essayer.", incorrectWarning: "Mot de passe incorrect. Veuillez v\xE9rifier et r\xE9essayer.", label: "Mot de passe", placeholder: "Entrer le mot de passe du document", open: "Ouvrir", opening: "Ouverture...", cancel: "Annuler", close: "Fermer" }, documentError: { title: "Erreur lors du chargement du document", unknown: "Une erreur inconnue est survenue", errorCode: "Code erreur : {code}", close: "Fermer le document" }, panel: { sidebar: "Barre lat\xE9rale", search: "Rechercher", comment: "Commentaire", thumbnails: "Miniatures", outline: "Plan", annotationStyle: "Style d'annotation" }, menu: { viewControls: "Contr\xF4les d'affichage", zoomControls: "Contr\xF4les de zoom", moreOptions: "Plus d'options" }, outline: { title: "Plan", loading: "Chargement du plan...", noOutline: "Aucun plan disponible", noBookmarks: "Ce document ne contient pas de signets" }, page: { settings: "Param\xE8tres de page", single: "Page unique", twoOdd: "Deux pages (Impair)", twoEven: "Deux pages (Pair)", vertical: "Vertical", horizontal: "Horizontal", spreadMode: "Mode double page", scrollLayout: "Disposition de d\xE9filement", rotation: "Rotation de page", next: "Page suivante", previous: "Page pr\xE9c\xE9dente" }, rotate: { clockwise: "Tourner dans le sens horaire", counterClockwise: "Tourner dans le sens antihoraire" }, selection: { copy: "Copier la s\xE9lection" }, mode: { view: "Affichage", annotate: "Annoter", shapes: "Formes", redact: "Caviarder" }, annotation: { text: "Texte", highlight: "Surligner", strikeout: "Barrer", underline: "Souligner", squiggly: "Ondul\xE9", rectangle: "Rectangle", circle: "Cercle", line: "Ligne", arrow: "Fl\xE8che", polygon: "Polygone", polyline: "Polyligne", ink: "Encre", stamp: "Tampon", freeText: "Texte libre", square: "Carr\xE9", styles: "Styles de {type}", defaults: "Valeurs par d\xE9faut de {type}", color: "Couleur", opacity: "Opacit\xE9", blendMode: "Mode de fusion", strokeWidth: "\xC9paisseur du trait", strokeColor: "Couleur du trait", borderStyle: "Style de bordure", fillColor: "Couleur de remplissage", fontSize: "Taille de police", fontFamily: "Police", textAlign: "Alignement du texte", verticalAlign: "Alignement vertical", lineEnding: "Fin de ligne", lineStart: "D\xE9but de ligne", lineEnd: "Fin de ligne", font: "Police", fontColor: "Couleur du texte", backgroundColor: "Couleur de fond", noStyles: "Il n'y a pas de styles pour cette annotation.", noStylesStamp: "Il n'y a pas de styles pour les tampons.", selectAnnotation: "S\xE9lectionnez une annotation pour voir les styles", deleteSelected: "Supprimer l'annotation s\xE9lectionn\xE9e", moreTools: "Plus d'outils" }, redaction: { area: "Caviarder la zone", text: "Caviarder le texte", applyAll: "Tout appliquer", clearAll: "Tout effacer" }, history: { undo: "Annuler", redo: "Refaire" }, comments: { page: "Page {page}", commentCount: "{count} commentaire", commentCountPlural: "{count} commentaires", addComment: "Ajouter un commentaire...", addReply: "Ajouter une r\xE9ponse...", save: "Enregistrer", cancel: "Annuler", edit: "Modifier", delete: "Supprimer", showMore: "plus", showLess: "moins", emptyState: "Ajoutez des annotations pour pouvoir les commenter." }, blendMode: { normal: "Normal", multiply: "Produit", screen: "Superposition", overlay: "Incrustation", darken: "Obscurcir", lighten: "\xC9claircir", colorDodge: "Densit\xE9 couleur -", colorBurn: "Densit\xE9 couleur +", hardLight: "Lumi\xE8re crue", softLight: "Lumi\xE8re tamis\xE9e", difference: "Diff\xE9rence", exclusion: "Exclusion", hue: "Teinte", saturation: "Saturation", color: "Couleur", luminosity: "Luminosit\xE9" } } }, { code: "es", name: "Espa\xF1ol", translations: { search: { placeholder: "Buscar", caseSensitive: "Distinguir may\xFAsculas", wholeWord: "Palabra completa", resultsFound: "{count} resultados encontrados", page: "P\xE1gina {page}" }, zoom: { in: "Acercar", out: "Alejar", fitWidth: "Ajustar al ancho", fitPage: "Ajustar a la p\xE1gina", marquee: "Zoom de selecci\xF3n", menu: "Men\xFA de zoom", level: "Nivel de zoom ({level}%)" }, pan: { toggle: "Alternar modo desplazamiento" }, pointer: { toggle: "Alternar modo puntero" }, capture: { screenshot: "Captura de pantalla" }, document: { menu: "Men\xFA del documento", open: "Abrir", close: "Cerrar", print: "Imprimir", export: "Exportar", fullscreen: "Pantalla completa", loading: "Cargando documento..." }, emptyState: { title: "No hay documentos abiertos", description: "Abra un documento PDF para comenzar.", descriptionMulti: "Puede ver varios documentos usando pesta\xF1as.", openButton: "Abrir documento", supportedFormats: "Formato compatible: PDF" }, passwordPrompt: { title: "Contrase\xF1a requerida", required: "Este documento est\xE1 protegido con contrase\xF1a. Por favor, ingrese la contrase\xF1a para abrirlo.", incorrect: "La contrase\xF1a ingresada es incorrecta. Por favor, int\xE9ntelo de nuevo.", incorrectWarning: "Contrase\xF1a incorrecta. Por favor, verifique e int\xE9ntelo de nuevo.", label: "Contrase\xF1a", placeholder: "Ingrese la contrase\xF1a del documento", open: "Abrir", opening: "Abriendo...", cancel: "Cancelar", close: "Cerrar" }, documentError: { title: "Error al cargar el documento", unknown: "Ha ocurrido un error desconocido", errorCode: "C\xF3digo de error: {code}", close: "Cerrar documento" }, panel: { sidebar: "Barra lateral", search: "Buscar", comment: "Comentario", thumbnails: "Miniaturas", outline: "Esquema", annotationStyle: "Estilo de anotaci\xF3n" }, menu: { viewControls: "Controles de vista", zoomControls: "Controles de zoom", moreOptions: "M\xE1s opciones" }, outline: { title: "Esquema", loading: "Cargando esquema...", noOutline: "No hay esquema disponible", noBookmarks: "Este documento no contiene marcadores" }, page: { settings: "Configuraci\xF3n de p\xE1gina", single: "P\xE1gina \xFAnica", twoOdd: "Dos p\xE1ginas (Impar)", twoEven: "Dos p\xE1ginas (Par)", vertical: "Vertical", horizontal: "Horizontal", spreadMode: "Modo de doble p\xE1gina", scrollLayout: "Dise\xF1o de desplazamiento", rotation: "Rotaci\xF3n de p\xE1gina", next: "P\xE1gina siguiente", previous: "P\xE1gina anterior" }, rotate: { clockwise: "Rotar en sentido horario", counterClockwise: "Rotar en sentido antihorario" }, selection: { copy: "Copiar selecci\xF3n" }, mode: { view: "Ver", annotate: "Anotar", shapes: "Formas", redact: "Redactar" }, annotation: { text: "Texto", highlight: "Resaltar", strikeout: "Tachar", underline: "Subrayar", squiggly: "Ondulado", rectangle: "Rect\xE1ngulo", circle: "C\xEDrculo", line: "L\xEDnea", arrow: "Flecha", polygon: "Pol\xEDgono", polyline: "Polil\xEDnea", ink: "Tinta", stamp: "Sello", freeText: "Texto libre", square: "Cuadrado", styles: "Estilos de {type}", defaults: "Valores predeterminados de {type}", color: "Color", opacity: "Opacidad", blendMode: "Modo de fusi\xF3n", strokeWidth: "Grosor del trazo", strokeColor: "Color del trazo", borderStyle: "Estilo del borde", fillColor: "Color de relleno", fontSize: "Tama\xF1o de fuente", fontFamily: "Fuente", textAlign: "Alineaci\xF3n del texto", verticalAlign: "Alineaci\xF3n vertical", lineEnding: "Final de l\xEDnea", lineStart: "Inicio de l\xEDnea", lineEnd: "Final de l\xEDnea", font: "Fuente", fontColor: "Color de fuente", backgroundColor: "Color de fondo", noStyles: "No hay estilos para esta anotaci\xF3n.", noStylesStamp: "No hay estilos para los sellos.", selectAnnotation: "Seleccione una anotaci\xF3n para ver los estilos", deleteSelected: "Eliminar anotaci\xF3n seleccionada", moreTools: "M\xE1s herramientas" }, redaction: { area: "Redactar \xE1rea", text: "Redactar texto", applyAll: "Aplicar todo", clearAll: "Borrar todo" }, history: { undo: "Deshacer", redo: "Rehacer" }, comments: { page: "P\xE1gina {page}", commentCount: "{count} comentario", commentCountPlural: "{count} comentarios", addComment: "A\xF1adir comentario...", addReply: "A\xF1adir respuesta...", save: "Guardar", cancel: "Cancelar", edit: "Editar", delete: "Eliminar", showMore: "m\xE1s", showLess: "menos", emptyState: "A\xF1ada anotaciones para poder comentarlas." }, blendMode: { normal: "Normal", multiply: "Multiplicar", screen: "Trama", overlay: "Superponer", darken: "Oscurecer", lighten: "Aclarar", colorDodge: "Sobreexponer color", colorBurn: "Subexponer color", hardLight: "Luz fuerte", softLight: "Luz suave", difference: "Diferencia", exclusion: "Exclusi\xF3n", hue: "Tono", saturation: "Saturaci\xF3n", color: "Color", luminosity: "Luminosidad" } } }], paramResolvers: { "zoom.level": function(e3) {
        var t2, n3, o3 = e3.state, i3 = e3.documentId, r2 = i3 && null !== (t2 = null === (n3 = o3.plugins[va]) || void 0 === n3 || null === (n3 = n3.documents[i3]) || void 0 === n3 ? void 0 : n3.currentZoomLevel) && void 0 !== t2 ? t2 : 1;
        return { level: Math.round(100 * r2) };
      } } }, ui: { schema: { id: "pdf-viewer-ui", version: "1.0.0", toolbars: { "main-toolbar": { id: "main-toolbar", position: { placement: "top", slot: "main", order: 0 }, permanent: true, responsive: { localeOverrides: { groups: [{ id: "germanic-languages", locales: ["de", "nl"], breakpoints: { md: { replaceShow: ["view-mode", "annotate-mode", "zoom-toolbar", "pan-button", "pointer-button", "divider-3", "overflow-tabs-button"] } } }] }, breakpoints: { xxxs: { maxWidth: 400, hide: ["annotate-mode", "view-mode", "shapes-mode", "redact-mode", "zoom-toolbar", "pan-button", "pointer-button", "divider-3", "page-settings-button", "zoom-menu-button", "divider-2", "overflow-tabs-button"], show: ["mode-select-button"] }, xxs: { minWidth: 400, show: ["page-settings-button", "zoom-menu-button", "divider-2"], hide: ["overflow-left-action-menu-button"] }, xs: { minWidth: 500, maxWidth: 640, show: ["pan-button", "pointer-button", "divider-3"] }, sm: { minWidth: 640, maxWidth: 768, hide: ["shapes-mode", "redact-mode", "zoom-toolbar", "mode-select-button"], show: ["view-mode", "annotate-mode", "overflow-tabs-button", "pan-button", "pointer-button", "divider-3"] }, md: { minWidth: 768, show: ["view-mode", "annotate-mode", "shapes-mode", "zoom-toolbar", "pan-button", "pointer-button", "divider-3", "overflow-tabs-button"], hide: ["zoom-menu-button", "mode-select-button"] }, lg: { minWidth: 1024, show: ["shapes-mode", "redact-mode"], hide: ["overflow-tabs-button"] } } }, items: [{ type: "group", id: "left-group", alignment: "start", gap: 2, items: [{ type: "command-button", id: "document-menu-button", commandId: "document:menu", variant: "icon", categories: ["document", "document-menu"] }, { type: "divider", id: "divider-1", orientation: "vertical" }, { type: "command-button", id: "sidebar-button", commandId: "panel:toggle-sidebar", variant: "icon", categories: ["panel", "panel-sidebar"] }, { type: "command-button", id: "overflow-left-action-menu-button", commandId: "left-action-menu:overflow-menu", variant: "icon", categories: ["ui", "ui-menu"] }, { type: "command-button", id: "page-settings-button", commandId: "page:settings", variant: "icon", categories: ["page", "page-settings"] }] }, { type: "divider", id: "divider-2", orientation: "vertical" }, { type: "group", id: "center-group", alignment: "center", gap: 2, items: [{ type: "command-button", id: "zoom-menu-button", commandId: "zoom:toggle-menu-mobile", variant: "icon", categories: ["zoom", "zoom-menu"] }, { type: "custom", id: "zoom-toolbar", componentId: "zoom-toolbar", categories: ["zoom"] }, { type: "divider", id: "divider-3", orientation: "vertical", visibilityDependsOn: { itemIds: ["zoom-toolbar", "zoom-menu-button"] } }, { type: "command-button", id: "pan-button", commandId: "pan:toggle", variant: "icon", categories: ["tools", "pan"] }, { type: "command-button", id: "pointer-button", commandId: "pointer:toggle", variant: "icon", categories: ["tools", "pointer"] }] }, { type: "spacer", id: "spacer-1", flex: true }, { type: "custom", id: "mode-select-button", componentId: "mode-select-button", categories: ["mode"], visibilityDependsOn: { menuId: "mode-tabs-overflow-menu" } }, { type: "tab-group", id: "mode-tabs", tabs: [{ id: "view-mode", commandId: "mode:view", variant: "text", categories: ["mode", "mode-view"], visibilityDependsOn: { itemIds: ["annotate-mode", "shapes-mode", "redact-mode"] } }, { id: "annotate-mode", commandId: "mode:annotate", variant: "text", categories: ["mode", "mode-annotate", "annotation"] }, { id: "shapes-mode", commandId: "mode:shapes", variant: "text", categories: ["mode", "mode-shapes", "annotation"] }, { id: "redact-mode", commandId: "mode:redact", variant: "text", categories: ["mode", "mode-redact", "redaction"] }, { id: "overflow-tabs-button", commandId: "tabs:overflow-menu", variant: "icon", categories: ["ui", "ui-menu"], visibilityDependsOn: { menuId: "mode-tabs-overflow-menu" } }] }, { type: "spacer", id: "spacer-2", flex: true }, { type: "group", id: "right-group", alignment: "end", gap: 2, items: [{ type: "command-button", id: "search-button", commandId: "panel:toggle-search", variant: "icon", categories: ["panel", "panel-search"] }, { type: "command-button", id: "comment-button", commandId: "panel:toggle-comment", variant: "icon", categories: ["panel", "panel-comment"] }] }] }, "annotation-toolbar": { id: "annotation-toolbar", position: { placement: "top", slot: "secondary", order: 0 }, responsive: { breakpoints: { sm: { maxWidth: 640, hide: ["add-text", "add-stamp"], show: ["overflow-annotation-tools"] }, md: { minWidth: 640, hide: ["overflow-annotation-tools"], show: ["add-text", "add-stamp"] } } }, permanent: false, categories: ["annotation"], items: [{ type: "spacer", id: "spacer-3", flex: true }, { type: "group", id: "annotation-tools", alignment: "start", gap: 2, items: [{ type: "command-button", id: "add-highlight", commandId: "annotation:add-highlight", variant: "icon", categories: ["annotation", "annotation-markup", "annotation-highlight"] }, { type: "command-button", id: "add-strikeout", commandId: "annotation:add-strikeout", variant: "icon", categories: ["annotation", "annotation-markup", "annotation-strikeout"] }, { type: "command-button", id: "add-underline", commandId: "annotation:add-underline", variant: "icon", categories: ["annotation", "annotation-markup", "annotation-underline"] }, { type: "command-button", id: "add-ink", commandId: "annotation:add-ink", variant: "icon", categories: ["annotation", "annotation-ink"] }, { type: "command-button", id: "add-text", commandId: "annotation:add-text", variant: "icon", categories: ["annotation", "annotation-text"] }, { type: "command-button", id: "add-stamp", commandId: "annotation:add-stamp", variant: "icon", categories: ["annotation", "annotation-stamp"] }, { type: "command-button", id: "overflow-annotation-tools", commandId: "annotation:overflow-tools", variant: "icon", categories: ["annotation", "annotation-overflow"] }, { type: "divider", id: "annotation-tools-divider-1", orientation: "vertical" }, { type: "command-button", id: "toggle-annotation-style", commandId: "panel:toggle-annotation-style", variant: "icon", categories: ["panel", "panel-annotation-style"] }, { type: "divider", id: "annotation-tools-divider-2", orientation: "vertical", visibilityDependsOn: { itemIds: ["toggle-annotation-style"] } }, { type: "command-button", id: "undo-button", commandId: "history:undo", variant: "icon", categories: ["history", "history-undo"] }, { type: "command-button", id: "redo-button", commandId: "history:redo", variant: "icon", categories: ["history", "history-redo"] }] }, { type: "spacer", id: "spacer-4", flex: true }] }, "shapes-toolbar": { id: "shapes-toolbar", position: { placement: "top", slot: "secondary", order: 0 }, responsive: { breakpoints: { sm: { maxWidth: 640, hide: ["add-polygon", "add-polyline"], show: ["overflow-shapes-tools"] }, md: { minWidth: 640, hide: ["overflow-shapes-tools"], show: ["add-polygon", "add-polyline"] } } }, permanent: false, categories: ["annotation", "annotation-shape"], items: [{ type: "spacer", id: "spacer-5", flex: true }, { type: "group", id: "shapes-tools", alignment: "start", gap: 2, items: [{ type: "command-button", id: "add-rectangle", commandId: "annotation:add-rectangle", variant: "icon", categories: ["annotation", "annotation-shape", "annotation-rectangle"] }, { type: "command-button", id: "add-circle", commandId: "annotation:add-circle", variant: "icon", categories: ["annotation", "annotation-shape", "annotation-circle"] }, { type: "command-button", id: "add-line", commandId: "annotation:add-line", variant: "icon", categories: ["annotation", "annotation-shape", "annotation-line"] }, { type: "command-button", id: "add-arrow", commandId: "annotation:add-arrow", variant: "icon", categories: ["annotation", "annotation-shape", "annotation-arrow"] }, { type: "command-button", id: "add-polygon", commandId: "annotation:add-polygon", variant: "icon", categories: ["annotation", "annotation-shape", "annotation-polygon"] }, { type: "command-button", id: "add-polyline", commandId: "annotation:add-polyline", variant: "icon", categories: ["annotation", "annotation-shape", "annotation-polyline"] }, { type: "command-button", id: "overflow-shapes-tools", commandId: "annotation:overflow-shapes", variant: "icon", categories: ["annotation", "annotation-shape", "annotation-overflow"] }, { type: "divider", id: "shapes-tools-divider-1", orientation: "vertical" }, { type: "command-button", id: "toggle-annotation-style", commandId: "panel:toggle-annotation-style", variant: "icon", categories: ["panel", "panel-annotation-style"] }, { type: "divider", id: "shapes-tools-divider-2", orientation: "vertical", visibilityDependsOn: { itemIds: ["toggle-annotation-style"] } }, { type: "command-button", id: "undo-button", commandId: "history:undo", variant: "icon", categories: ["history", "history-undo"] }, { type: "command-button", id: "redo-button", commandId: "history:redo", variant: "icon", categories: ["history", "history-redo"] }] }, { type: "spacer", id: "spacer-6", flex: true }] }, "redaction-toolbar": { id: "redaction-toolbar", position: { placement: "top", slot: "secondary", order: 0 }, permanent: false, categories: ["redaction"], items: [{ type: "spacer", id: "spacer-7", flex: true }, { type: "group", id: "redaction-tools", alignment: "start", gap: 2, items: [{ type: "command-button", id: "redact-text", commandId: "redaction:redact-text", variant: "icon", categories: ["redaction", "redaction-text"] }, { type: "command-button", id: "redact-area", commandId: "redaction:redact-area", variant: "icon", categories: ["redaction", "redaction-area"] }, { type: "divider", id: "divider-5", orientation: "vertical" }, { type: "command-button", id: "apply-redactions", commandId: "redaction:apply-all", variant: "icon", categories: ["redaction", "redaction-apply"] }, { type: "command-button", id: "clear-redactions", commandId: "redaction:clear-all", variant: "icon", categories: ["redaction", "redaction-clear"] }] }, { type: "spacer", id: "spacer-8", flex: true }] } }, menus: { "left-action-menu": { id: "left-action-menu", categories: ["ui"], items: [{ type: "submenu", id: "page-settings-submenu", labelKey: "menu.viewControls", label: "View Controls", icon: "viewSettings", menuId: "page-settings-menu", categories: ["page"] }, { type: "submenu", id: "zoom-submenu", labelKey: "menu.zoomControls", label: "Zoom Controls", icon: "zoomIn", menuId: "zoom-menu", categories: ["zoom"] }, { type: "divider", id: "divider-15" }, { type: "command", id: "pan-button-menu", commandId: "pan:toggle", categories: ["tools", "pan"] }, { type: "command", id: "pointer-button-menu", commandId: "pointer:toggle", categories: ["tools", "pointer"] }] }, "mode-tabs-overflow-menu": { id: "mode-tabs-overflow-menu", items: [{ type: "command", id: "mode:view", commandId: "mode:view", categories: ["mode", "mode-view"] }, { type: "command", id: "mode:annotate", commandId: "mode:annotate", categories: ["mode", "mode-annotate", "annotation"] }, { type: "command", id: "mode:shapes", commandId: "mode:shapes", categories: ["mode", "mode-shapes", "annotation"] }, { type: "command", id: "mode:redact", commandId: "mode:redact", categories: ["mode", "mode-redact", "redaction"] }], responsive: { breakpoints: { xs: { maxWidth: 640, show: ["mode:view", "mode:annotate", "mode:shapes", "mode:redact"] }, sm: { minWidth: 640, maxWidth: 768, hide: ["mode:view", "mode:annotate"] }, md: { minWidth: 768, hide: ["mode:view", "mode:annotate", "mode:shapes"] } }, localeOverrides: { groups: [{ id: "germanic-languages", locales: ["de", "nl"], breakpoints: { md: { replaceHide: ["mode:view", "mode:annotate"] } } }] } } }, "zoom-levels-menu": { id: "zoom-levels-menu", categories: ["zoom", "zoom-level"], items: [{ type: "command", id: "zoom-levels-menu:25", commandId: "zoom:25", categories: ["zoom", "zoom-level", "zoom-level-25"] }, { type: "command", id: "zoom-levels-menu:50", commandId: "zoom:50", categories: ["zoom", "zoom-level", "zoom-level-50"] }, { type: "command", id: "zoom-levels-menu:100", commandId: "zoom:100", categories: ["zoom", "zoom-level", "zoom-level-100"] }, { type: "command", id: "zoom-levels-menu:125", commandId: "zoom:125", categories: ["zoom", "zoom-level", "zoom-level-125"] }, { type: "command", id: "zoom-levels-menu:150", commandId: "zoom:150", categories: ["zoom", "zoom-level", "zoom-level-150"] }, { type: "command", id: "zoom-levels-menu:200", commandId: "zoom:200", categories: ["zoom", "zoom-level", "zoom-level-200"] }, { type: "command", id: "zoom-levels-menu:400", commandId: "zoom:400", categories: ["zoom", "zoom-level", "zoom-level-400"] }, { type: "command", id: "zoom-levels-menu:800", commandId: "zoom:800", categories: ["zoom", "zoom-level", "zoom-level-800"] }, { type: "command", id: "zoom-levels-menu:1600", commandId: "zoom:1600", categories: ["zoom", "zoom-level", "zoom-level-1600"] }] }, "zoom-menu": { id: "zoom-menu", categories: ["zoom"], items: [{ type: "command", id: "zoom-menu:25", commandId: "zoom:25", categories: ["zoom", "zoom-level", "zoom-level-25"] }, { type: "command", id: "zoom-menu:50", commandId: "zoom:50", categories: ["zoom", "zoom-level", "zoom-level-50"] }, { type: "command", id: "zoom-menu:100", commandId: "zoom:100", categories: ["zoom", "zoom-level", "zoom-level-100"] }, { type: "command", id: "zoom-menu:125", commandId: "zoom:125", categories: ["zoom", "zoom-level", "zoom-level-125"] }, { type: "command", id: "zoom-menu:150", commandId: "zoom:150", categories: ["zoom", "zoom-level", "zoom-level-150"] }, { type: "command", id: "zoom-menu:200", commandId: "zoom:200", categories: ["zoom", "zoom-level", "zoom-level-200"] }, { type: "command", id: "zoom-menu:400", commandId: "zoom:400", categories: ["zoom", "zoom-level", "zoom-level-400"] }, { type: "command", id: "zoom-menu:800", commandId: "zoom:800", categories: ["zoom", "zoom-level", "zoom-level-800"] }, { type: "command", id: "zoom-menu:1600", commandId: "zoom:1600", categories: ["zoom", "zoom-level", "zoom-level-1600"] }, { type: "submenu", id: "zoom-levels-submenu", labelKey: "zoom.level", label: "Zoom Levels", menuId: "zoom-levels-menu", categories: ["zoom", "zoom-level"] }, { type: "divider", id: "divider-zoom-in-out" }, { type: "command", id: "zoom-menu:in", commandId: "zoom:in", categories: ["zoom", "zoom-in"] }, { type: "command", id: "zoom-menu:out", commandId: "zoom:out", categories: ["zoom", "zoom-out"] }, { type: "divider", id: "divider-8" }, { type: "command", id: "zoom:fit-page", commandId: "zoom:fit-page", categories: ["zoom", "zoom-fit-page"] }, { type: "command", id: "zoom:fit-width", commandId: "zoom:fit-width", categories: ["zoom", "zoom-fit-width"] }, { type: "divider", id: "divider-9" }, { type: "command", id: "zoom:marquee", commandId: "zoom:marquee", categories: ["zoom", "zoom-marquee"] }], responsive: { breakpoints: { xs: { maxWidth: 640, show: ["zoom-levels-submenu", "divider-zoom-in-out"], hide: ["zoom-menu:25", "zoom-menu:50", "zoom-menu:100", "zoom-menu:125", "zoom-menu:150", "zoom-menu:200", "zoom-menu:400", "zoom-menu:800", "zoom-menu:1600"] }, md: { minWidth: 768, show: ["zoom-menu:25", "zoom-menu:50", "zoom-menu:100", "zoom-menu:125", "zoom-menu:150", "zoom-menu:200", "zoom-menu:400", "zoom-menu:800", "zoom-menu:1600"], hide: ["zoom-levels-submenu", "divider-zoom-in-out", "zoom-menu:in", "zoom-menu:out"] } } } }, "document-menu": { id: "document-menu", categories: ["document"], items: [{ type: "command", id: "document:open", commandId: "document:open", categories: ["document", "document-open"] }, { type: "command", id: "document:close", commandId: "document:close", categories: ["document", "document-close"] }, { type: "divider", id: "divider-10" }, { type: "command", id: "document:print", commandId: "document:print", categories: ["document", "document-print"] }, { type: "command", id: "document:export", commandId: "document:export", categories: ["document", "document-export"] }, { type: "divider", id: "divider-11", visibilityDependsOn: { itemIds: ["document:export", "document:print"] } }, { type: "command", id: "document:fullscreen", commandId: "document:fullscreen", categories: ["document", "document-fullscreen"] }] }, "annotation-tools-menu": { id: "annotation-tools-menu", categories: ["annotation"], items: [{ type: "command", id: "annotation:add-text", commandId: "annotation:add-text", categories: ["annotation", "annotation-text"] }, { type: "command", id: "annotation:add-stamp", commandId: "annotation:add-stamp", categories: ["annotation", "annotation-stamp"] }] }, "shapes-tools-menu": { id: "shapes-tools-menu", categories: ["annotation", "annotation-shape"], items: [{ type: "command", id: "annotation:add-polygon", commandId: "annotation:add-polygon", categories: ["annotation", "annotation-shape", "annotation-polygon"] }, { type: "command", id: "annotation:add-polyline", commandId: "annotation:add-polyline", categories: ["annotation", "annotation-shape", "annotation-polyline"] }] }, "page-settings-menu": { id: "page-settings-menu", categories: ["page"], items: [{ type: "section", id: "spread-mode-section", labelKey: "page.spreadMode", label: "Spread Mode", categories: ["page", "spread"], items: [{ type: "command", id: "spread:none", commandId: "spread:none", categories: ["page", "spread", "spread-none"] }, { type: "command", id: "spread:odd", commandId: "spread:odd", categories: ["page", "spread", "spread-odd"] }, { type: "command", id: "spread:even", commandId: "spread:even", categories: ["page", "spread", "spread-even"] }] }, { type: "divider", id: "divider-13" }, { type: "section", id: "scroll-layout-section", labelKey: "page.scrollLayout", label: "Scroll Layout", categories: ["page", "scroll"], items: [{ type: "command", id: "scroll:vertical", commandId: "scroll:vertical", categories: ["page", "scroll", "scroll-vertical"] }, { type: "command", id: "scroll:horizontal", commandId: "scroll:horizontal", categories: ["page", "scroll", "scroll-horizontal"] }] }, { type: "divider", id: "divider-14" }, { type: "section", id: "page-rotation-section", labelKey: "page.rotation", label: "Page Rotation", categories: ["page", "rotate"], items: [{ type: "command", id: "rotate:clockwise", commandId: "rotate:clockwise", categories: ["page", "rotate", "rotate-clockwise"] }, { type: "command", id: "rotate:counter-clockwise", commandId: "rotate:counter-clockwise", categories: ["page", "rotate", "rotate-counter-clockwise"] }] }, { type: "divider", id: "divider-15" }, { type: "command", id: "document:fullscreen", commandId: "document:fullscreen", categories: ["document", "document-fullscreen"] }] } }, sidebars: { "sidebar-panel": { id: "sidebar-panel", position: { placement: "left", slot: "main", order: 0 }, content: { type: "tabs", tabs: [{ id: "thumbnails", labelKey: "panel.thumbnails", label: "Thumbnails", icon: "squares", componentId: "thumbnails-sidebar" }, { id: "outline", labelKey: "panel.outline", label: "Outline", icon: "listTree", componentId: "outline-sidebar" }] }, width: "250px", collapsible: true, defaultOpen: false }, "annotation-panel": { id: "annotation-panel", position: { placement: "left", slot: "main", order: 0 }, content: { type: "component", componentId: "annotation-sidebar" }, width: "250px", collapsible: true, defaultOpen: false }, "search-panel": { id: "search-panel", position: { placement: "right", slot: "main", order: 0 }, content: { type: "component", componentId: "search-sidebar" }, width: "250px", collapsible: true, defaultOpen: false }, "comment-panel": { id: "comment-panel", position: { placement: "right", slot: "main", order: 0 }, content: { type: "component", componentId: "comment-sidebar" }, width: "250px", collapsible: true, defaultOpen: false } }, modals: { "print-modal": { id: "print-modal", content: { type: "component", componentId: "print-modal" }, maxWidth: "28rem", closeOnClickOutside: true, closeOnEscape: true } }, overlays: { "page-controls": { id: "page-controls", position: { anchor: "bottom-center", offset: { bottom: "1.5rem" } }, content: { type: "component", componentId: "page-controls" }, defaultEnabled: true } }, selectionMenus: { annotation: { id: "annotation", categories: ["annotation"], items: [{ type: "command-button", id: "delete-annotation", commandId: "annotation:delete-selected", variant: "icon", categories: ["annotation", "annotation-delete"] }, { type: "command-button", id: "toggle-annotation-style", commandId: "panel:toggle-annotation-style", variant: "icon", categories: ["panel", "panel-annotation-style"] }, { type: "command-button", id: "comment-button", commandId: "panel:toggle-comment", variant: "icon", categories: ["panel", "panel-comment"] }] }, redaction: { id: "redaction", categories: ["redaction"], items: [{ type: "command-button", id: "delete-redaction", commandId: "redaction:delete-selected", variant: "icon", categories: ["redaction", "redaction-delete"] }, { type: "command-button", id: "commit-redaction", commandId: "redaction:commit-selected", variant: "icon", categories: ["redaction", "redaction-commit"] }] }, selection: { id: "selection", visibilityDependsOn: { itemIds: ["copy-selection", "add-highlight", "add-strikeout", "add-underline", "add-squiggly", "redact-text"] }, items: [{ type: "command-button", id: "copy-selection", commandId: "selection:copy", variant: "icon", categories: ["selection", "selection-copy"] }, { type: "command-button", id: "add-highlight", commandId: "annotation:add-highlight", variant: "icon", categories: ["annotation", "annotation-markup", "annotation-highlight"] }, { type: "command-button", id: "add-strikeout", commandId: "annotation:add-strikeout", variant: "icon", categories: ["annotation", "annotation-markup", "annotation-strikeout"] }, { type: "command-button", id: "add-underline", commandId: "annotation:add-underline", variant: "icon", categories: ["annotation", "annotation-markup", "annotation-underline"] }, { type: "command-button", id: "add-squiggly", commandId: "annotation:add-squiggly", variant: "icon", categories: ["annotation", "annotation-markup", "annotation-squiggly"] }, { type: "command-button", id: "redact-text", commandId: "redaction:redact-text", variant: "icon", categories: ["redaction", "redaction-text"] }] } } } }, viewport: { viewportGap: 10 }, scroll: { defaultStrategy: Uo.Vertical }, zoom: { defaultZoomLevel: ga.FitPage }, spread: { defaultSpreadMode: ri.None }, rotation: { defaultRotation: We.Degree0 }, pan: {}, render: { defaultImageType: "image/png" }, tiling: { tileSize: 768, overlapPx: 2.5, extraRings: 0 }, thumbnails: { width: 150, gap: 10, buffer: 3, labelHeight: 30 }, annotations: {}, search: {}, selection: {}, bookmarks: {}, attachments: {}, capture: { scale: 2, imageType: "image/png" }, redaction: { drawBlackBoxes: true }, print: {}, export: { defaultFileName: "document.pdf" }, fullscreen: {}, history: {}, interactionManager: {} };
      $f = new dt([new st(), new ct()]);
      jf = "undefined" != typeof HTMLElement ? HTMLElement : r(function e2() {
        i2(this, e2);
      });
      Hf = (function() {
        function e3() {
          var t2;
          return i2(this, e3), s3(t2 = o2(this, e3), "_resolveRegistry", null), s3(t2, "themeStyleEl", null), s3(t2, "systemPreferenceCleanup", null), s3(t2, "handleRegistryReady", function(e4) {
            t2._resolveRegistry && (t2._resolveRegistry(e4), t2._resolveRegistry = null);
          }), t2.root = t2.attachShadow({ mode: "open" }), t2._registryPromise = new Promise(function(e4) {
            t2._resolveRegistry = e4;
          }), t2;
        }
        return c3(e3, jf), r(e3, [{ key: "connectedCallback", value: function() {
          this._config || (this._config = { src: this.getAttribute("src") || "/demo.pdf", worker: "false" !== this.getAttribute("worker"), theme: this.parseThemeAttribute() }), this.setupTheme(), this.renderViewer();
        } }, { key: "disconnectedCallback", value: function() {
          var e4;
          null === (e4 = this.systemPreferenceCleanup) || void 0 === e4 || e4.call(this), this.systemPreferenceCleanup = null;
        } }, { key: "parseThemeAttribute", value: function() {
          var e4 = this.getAttribute("theme");
          if (e4) return ["light", "dark", "system"].includes(e4) ? { preference: e4 } : void 0;
        } }, { key: "config", get: function() {
          return this._config;
        }, set: function(e4) {
          this._config = e4, e4.icons && Zm(e4.icons), this.isConnected && (this.setupTheme(), this.renderViewer());
        } }, { key: "registry", get: function() {
          return this._registryPromise;
        } }, { key: "themePreference", get: function() {
          var e4;
          return (null === (e4 = this._config) || void 0 === e4 || null === (e4 = e4.theme) || void 0 === e4 ? void 0 : e4.preference) || "system";
        } }, { key: "activeColorScheme", get: function() {
          return Af(this.themePreference);
        } }, { key: "activeTheme", get: function() {
          return this.resolveActiveTheme();
        } }, { key: "resolveActiveTheme", value: function() {
          var e4, t2, n3, o3 = null === (e4 = this._config) || void 0 === e4 ? void 0 : e4.theme, i3 = Af((null == o3 ? void 0 : o3.preference) || "system"), r2 = "dark" === i3 ? Df : kf, a3 = null == o3 ? void 0 : o3[i3];
          return n3 = r2, (t2 = a3) ? Pf(n3, t2) : n3;
        } }, { key: "setupTheme", value: function() {
          var e4, t2, n3 = this;
          null === (e4 = this.systemPreferenceCleanup) || void 0 === e4 || e4.call(this), this.systemPreferenceCleanup = null, "system" === ((null === (t2 = this._config) || void 0 === t2 || null === (t2 = t2.theme) || void 0 === t2 ? void 0 : t2.preference) || "system") && (this.systemPreferenceCleanup = (function(e5) {
            if ("undefined" == typeof window) return function() {
            };
            var t3 = window.matchMedia("(prefers-color-scheme: dark)"), n4 = function(t4) {
              return e5(t4.matches ? "dark" : "light");
            };
            return t3.addEventListener("change", n4), function() {
              return t3.removeEventListener("change", n4);
            };
          })(function(e5) {
            n3.injectTheme(), n3.dispatchEvent(new CustomEvent("themechange", { detail: { preference: "system", colorScheme: e5, theme: n3.activeTheme }, bubbles: true }));
          })), this.injectTheme();
        } }, { key: "injectTheme", value: function() {
          var e4 = zf(this.resolveActiveTheme()), t2 = this.root.querySelector("style[data-embedpdf-theme]");
          t2 || ((t2 = document.createElement("style")).setAttribute("data-embedpdf-theme", ""), this.root.appendChild(t2)), this.themeStyleEl = t2, this.themeStyleEl.textContent = e4, this.setAttribute("data-color-scheme", this.activeColorScheme);
        } }, { key: "setTheme", value: function(e4) {
          this._config && (this._config.theme = "string" == typeof e4 ? h2(h2({}, this._config.theme), {}, { preference: e4 }) : h2(h2({}, this._config.theme), e4), this.setupTheme(), this.dispatchEvent(new CustomEvent("themechange", { detail: { preference: this.themePreference, colorScheme: this.activeColorScheme, theme: this.activeTheme }, bubbles: true })));
        } }, { key: "registerIcon", value: function(e4, t2) {
          Vm(e4, t2);
        } }, { key: "registerIcons", value: function(e4) {
          Zm(e4);
        } }, { key: "renderViewer", value: function() {
          this._config && (ce(j2(Ff, { config: this._config, onRegistryReady: this.handleRegistryReady }), this.root), this.injectTheme());
        } }]);
      })();
      Uf = ["type", "target"];
      Wf = "2.1.1";
      "undefined" == typeof customElements || customElements.get("embedpdf-container") || customElements.define("embedpdf-container", Hf);
      Bf = { version: Wf, init: function(e3) {
        if ("container" === e3.type) return (function(e4) {
          e4.type, e4.target;
          var t2 = m2(e4, Uf), n3 = document.createElement("embedpdf-container");
          return n3.config = t2, e4.target.appendChild(n3), n3;
        })(e3);
      } };
    }
  });

  // node_modules/@embedpdf/snippet/dist/embedpdf.js
  init_embedpdf_Ob4AJbqq();

  // entry.js
  window.EmbedPDF = Bf;
})();
/*! Bundled license information:

@embedpdf/snippet/dist/embedpdf-Ob4AJbqq.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)
*/
